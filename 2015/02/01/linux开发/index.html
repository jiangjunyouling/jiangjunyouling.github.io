<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="思 见" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="主要介绍了linux下的编程包括Makefile，进程编程等">
<meta property="og:type" content="article">
<meta property="og:title" content="linux开发">
<meta property="og:url" content="http://yoursite.com/2015/02/01/linux开发/index.html">
<meta property="og:site_name" content="思 见">
<meta property="og:description" content="主要介绍了linux下的编程包括Makefile，进程编程等">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-02-15T08:01:26.382Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="linux开发">
<meta name="twitter:description" content="主要介绍了linux下的编程包括Makefile，进程编程等">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2015/02/01/linux开发/"/>





  <title> linux开发 | 思 见 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">思 见</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/02/01/linux开发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/curiosity.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思 见">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                linux开发
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-02-01T16:44:27+08:00">
                2015-02-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>主要介绍了linux下的编程包括Makefile，进程编程等<br><a id="more"></a></p>
<h1 id="MakeFile"><a href="#MakeFile" class="headerlink" title="MakeFile"></a>MakeFile</h1><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>格式： 目标:源<br>test: main.o add.o<br>  gcc -o test main.o add.o</p>
<p>main.o: main.c add.h<br>  gcc -c main.c</p>
<p>add.o: add.c<br>  gcc -c add.c</p>
<p>clean:<br>  rm *.o<br>  rm test</p>
<h2 id="Makefile变量"><a href="#Makefile变量" class="headerlink" title="Makefile变量"></a>Makefile变量</h2><h3 id="变量"><a href="#变量" class="headerlink" title="$(变量)"></a>$(变量)</h3><p> OBJS = foo.o bar.o<br> CC = gcc<br> CFLAGS = -Wall -O -g</p>
<p> $(CC) $(OBJS) -o myprog</p>
<h3 id="与"><a href="#与" class="headerlink" title="$@ 与 $^"></a>$@ 与 $^</h3><p>test: main.o add.o<br>  gcc -o test main.o add.o<br>  gcc -o test $@ $^</p>
<h2 id="wildcard通配符"><a href="#wildcard通配符" class="headerlink" title="wildcard通配符"></a>wildcard通配符</h2><p>SRCS = $(wildcard *.c)<br>OBJS = $(SRCS:.c=.o)</p>
<p>test: $(OBJS)<br>  gcc -o $@ $^</p>
<p> gcc -MM main.c ;;自动扫描依赖文件.depend</p>
<h2 id="Autotools工具"><a href="#Autotools工具" class="headerlink" title="Autotools工具"></a>Autotools工具</h2><p> – linux上的软件开发一般都用autotools来制作Makefile。</p>
<p>– 开源软件configure生成Makefile<br>– Makefile.am<br>– ./configure  ;; 下载的<br>– bin_PROGRAMS = hello<br>– hello_SOURCES-hello.c<br>– configure.in</p>
<h1 id="进程开发"><a href="#进程开发" class="headerlink" title="进程开发"></a>进程开发</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="进程运行状态"><a href="#进程运行状态" class="headerlink" title="进程运行状态"></a>进程运行状态</h3><p> 就绪、执行、暂停、睡眠（深度、浅度）、僵死。</p>
<h3 id="linux进程描述符：task-struct"><a href="#linux进程描述符：task-struct" class="headerlink" title="linux进程描述符：task_struct"></a>linux进程描述符：task_struct</h3><p> 包括：thread_info 线程信息；<br>      mm_struct 内存信息；<br>      tty_struct 关联的控制台；<br>      fs_struct 当前的目录；<br>      files_struct 文件描述符；<br>      signal_struct 信号</p>
<p> –  通过esp(栈寄存器) &amp; 0xfffe0000可得到当前 thread_info，然后 current_thread_info()-&gt;task 可得到task_struct。</p>
<h2 id="pid"><a href="#pid" class="headerlink" title="pid"></a>pid</h2><p> – task_struct 双向链表<br> – 树表示父子进程关系<br> – PID哈希表：快速得到通过PID获取到task_struct<br> – 查看系统最大的PID： cat /proc/sys/kernel/pid_max</p>
<p> – 遍历所有进程 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> for_each_process(p) \</span></span><br><span class="line"><span class="keyword">for</span>(p=&amp;init_task; (p=list_entry((p)-&gt;tasks.next, \</span><br><span class="line">struct task_struct, tasks) \</span><br><span class="line">)!= &amp;init_task;)</span><br></pre></td></tr></table></figure>
<h2 id="创建-fork-vfork-clone"><a href="#创建-fork-vfork-clone" class="headerlink" title="创建 fork/vfork/clone"></a>创建 fork/vfork/clone</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h3><p>   父进程返回子进程的PID，子进程返回0.<br>   重新申请一份内存，赋值资源：mm(内存)/fs（当前目录）/files/signal(信号)/tty(控制台)<br>   代码段只读、数据段读写。子进程在起始被fork时，原数据段被映射为只读的，子（父）进程在进行写操作时，会触发中断，重新分配数据段，再次执行原语句data = 20；对应代码training/process/fork/fork_child.c，写时拷贝技术,copy&amp;&amp;write,需要硬件支持mmu系统。</p>
<h3 id="vfork-，在没有mmu系统中"><a href="#vfork-，在没有mmu系统中" class="headerlink" title="vfork()，在没有mmu系统中"></a>vfork()，在没有mmu系统中</h3><p>   五类资源，vfork()时，不申请mm内存，mm直接指向父进程的mm，在内存方面完全共享。不支持内存分裂。vfork()的子进程与父进程共享内存 vfork.c</p>
<h3 id="clone-线程，轻量级线程"><a href="#clone-线程，轻量级线程" class="headerlink" title="clone(), 线程，轻量级线程"></a>clone(), 线程，轻量级线程</h3><p>   五类资源都是指向而不重申请，内核全部使用dofork()，而参数不同。</p>
<h3 id="起点：进程0"><a href="#起点：进程0" class="headerlink" title="起点：进程0"></a>起点：进程0</h3><p> – init pid = 1；<br> – 进程0优先级最低，全局变量，通过exec()创建init进程，完成后，变为 while(1) WFI;空闲等中断状态。<br> – 在实现最后的进入低功耗态时，存在着不同的实现方式：可能所有的进程都查看一下是否是最后一个进程，若是则进入低功耗。优先级。</p>
<p> – 可以在proc/下的status中查看父进程</p>
<h2 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h2><p> – 停止进程的所有线程<br>    exit_group() 调用 –》 do_group_exit()</p>
<p> – 父进程通过wait()函数来清理子进程，子进程的task_struct才被删除，之前处于僵尸态</p>
<h3 id="子进程死而父进程不清理-ps-aux"><a href="#子进程死而父进程不清理-ps-aux" class="headerlink" title="子进程死而父进程不清理 ps aux"></a>子进程死而父进程不清理 ps aux</h3><p> – 子进程会成为僵尸态，除非父进程被干掉</p>
<h3 id="子进程不死而父进程死掉"><a href="#子进程不死而父进程死掉" class="headerlink" title="子进程不死而父进程死掉"></a>子进程不死而父进程死掉</h3><p> – 父进程被干掉后，子进程变为孤儿进程，托孤过程，变为init的子进程。<br> – 为什么不会代替前一级？</p>
<h2 id="线程的类型"><a href="#线程的类型" class="headerlink" title="线程的类型"></a>线程的类型</h2><p> – I/O消耗型：伴随用户体验，I/O消耗型对CPU很敏感<br> – CPU消耗型<br> – ARM大核配小核，八核上，弱核跑I/O消耗型，big LITTLE</p>
<h2 id="调度目标"><a href="#调度目标" class="headerlink" title="调度目标"></a>调度目标</h2><p> – 快速响应：靠抢占实现<br> – 高吞吐率<br>    蜘蛛侠法则，最优的最少 spider norm</p>
<h3 id="调度策略-与-优先级"><a href="#调度策略-与-优先级" class="headerlink" title="调度策略 与 优先级"></a>调度策略 与 优先级</h3><p> – RT: （0 - 99）SCHED_FIFO（同等优先级也不轮转）、 SCHED_RR（同等优先级轮转）<br> – Normal: （100 - 139）SCHED_OTHER，劳动人民的善良性，nice值(-20 - +19)，nice值越高，优先级越低。<br> – 动态的抢占依然发生</p>
<h3 id="动态优先级"><a href="#动态优先级" class="headerlink" title="动态优先级"></a>动态优先级</h3><p> – 动态优先级，task_struc.static_prio反映进程创建时的优先级，nice值<br> – 干活变低，睡眠变高优先级，effective_prio()返回一个进程的动态优先级，根据task——struct的sleep_avg对nice进行+-5的调整</p>
<p> – vruntime = delta * NICE_0_LOAD / se.weight<br> – 睡眠型且优先级高【100-139】</p>
<h3 id="linux-RT与Normal之间的策略"><a href="#linux-RT与Normal之间的策略" class="headerlink" title="linux RT与Normal之间的策略"></a>linux RT与Normal之间的策略</h3><p> – 在RT与Normal中，以1s为周期，95%的时间若都跑RT，内核会切断RT，然后给5%的时间给Normal</p>
<h3 id="相关系统调用"><a href="#相关系统调用" class="headerlink" title="相关系统调用"></a>相关系统调用</h3><p> – nice(), sets a process’s nice value<br> – sched_setscheduler(), set s process’s scheduling policy<br> – sched_getscheduler(), get a process’s scheduling policy<br> – sched_setparam(), set a process’s real-time policy<br> – sched_getparam(), get a process’s real-time policy<br> – sched_rr_get_interval() get a process’s timeslice value</p>
<h3 id="墨菲定律"><a href="#墨菲定律" class="headerlink" title="墨菲定律"></a>墨菲定律</h3><p> – 软件工程会将小概率事件变为必然事件</p>
<h2 id="多核负载均衡"><a href="#多核负载均衡" class="headerlink" title="多核负载均衡"></a>多核负载均衡</h2><p> – thread_life.cpp<br> – time ./a.out ;real,user,sys</p>
<h3 id="RT任务的负载均衡CFS"><a href="#RT任务的负载均衡CFS" class="headerlink" title="RT任务的负载均衡CFS"></a>RT任务的负载均衡CFS</h3><p> – RTC 线程，通过一定的策略来进行负载的均衡，常见的为CFS<br> – 以劳动为快乐<br> – BFS调度算法，核比较少时，算法更优；核比较多时，CFS更优，适合分布式。</p>
<h2 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h2><p> – 只在内核空间来运行，软实时的linux可以通过配置或者运行一个子内核的方式来达到硬实时。</p>
<h1 id="多进程开发"><a href="#多进程开发" class="headerlink" title="多进程开发"></a>多进程开发</h1><h2 id="进程类型"><a href="#进程类型" class="headerlink" title="进程类型"></a>进程类型</h2><p> – 交互进程，有shell控制和运行，可在前台、后台运行<br> – 批处理进程，该进程不属于某个终端，它被提交到某个队列中以便顺序执行【交互与终端有关】<br> – 守护进行， 该进程只有在需要时才被唤醒在后台执行。一般在linux启动时开始执行【驱动】</p>
<h2 id="linux下进程的模式"><a href="#linux下进程的模式" class="headerlink" title="linux下进程的模式"></a>linux下进程的模式</h2><p> – 进程的执行模式划分为用户模式与内核模式。用户进程通过系统调用来调用内核进程。</p>
<h2 id="linux系统调用的实现"><a href="#linux系统调用的实现" class="headerlink" title="linux系统调用的实现"></a>linux系统调用的实现</h2><h3 id="系统调用表"><a href="#系统调用表" class="headerlink" title="系统调用表"></a>系统调用表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(sys_call_table)</span><br><span class="line">.<span class="keyword">long</span> sys_restart_syscall</span><br><span class="line">.<span class="keyword">long</span> sys_exit</span><br><span class="line">.<span class="keyword">long</span> sys_fork</span><br><span class="line">.<span class="keyword">long</span> sys_read</span><br><span class="line">.<span class="keyword">long</span> sys_write</span><br><span class="line">.<span class="keyword">long</span> sys_open    <span class="comment">/* 5 */</span></span><br></pre></td></tr></table></figure>
<h3 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h3><p> 软中断， x86调用 init $0x80指令，从用户空间切换到内核空间（128号异常处理程序，system_call()），系统调用号放入eax，system_call()将系统调用号与NR_syscalls对比，合理调用sys_xxx()，系统调用的返回值也放入eax。</p>
<h2 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h2><h3 id="fork-1"><a href="#fork-1" class="headerlink" title="fork"></a>fork</h3><p> – 根据返回值，判断为父进程（子进程PID）还是子进程（0），子进程通过exit()发送结束信号给父进程，父进程调用wait()函数来清理子进程</p>
<h3 id="写时拷贝"><a href="#写时拷贝" class="headerlink" title="写时拷贝"></a>写时拷贝</h3><p> – 即虽然fork时，子进程申请了内存，父进程与子进程的实际物理内存是在写入操作时，才实际分配的，并且，谁写入的晚，谁使用原来的内存。</p>
<h3 id="exec-函数族"><a href="#exec-函数族" class="headerlink" title="exec 函数族"></a>exec 函数族</h3><p> – exec函数族提供了在一个进程中启动另一个进程的方法。它可以根据指定的文件名或目录名，找到对应可执行文件，，并用它来取代原调用程序的数据段、代码段 和 堆栈段， 在执行完后，元调用进程的内容除了进程号外，其他全部被新的进程替换了。</p>
<p> – 可执行文件可以是二进程文件，可以是可执行脚本<br> – 如果一个进程想执行另一个程序，可以先掉用fork新建一个进程，然后调用任意exec。这样可以看作通过执行应用程序而产生了一个新进程一样。</p>
<h3 id="exit-和-exit"><a href="#exit-和-exit" class="headerlink" title="exit 和 _exit"></a>exit 和 _exit</h3><p> void exit(int status)<br> –  status是整型的参数，可以利用这个参数传递进程结束时的状态，一般来说，0表示没有意外的正常结束，其他便是出现问题<br> – 在实际编程时，可以用wait系统调用接收子进程的返回值，从而针对不同情况进行处理。<br> – _exit()函数的作用：直接使进程停止，清除其内存空间，并销毁在内核中的各种数据结构；<br> – exit()函数在滴哦用exit系统调用 之前，做了一些包装，要检查文件的打开情况，把文件缓存区中的内容写回文件等。</p>
<h3 id="wait-和-waitpid"><a href="#wait-和-waitpid" class="headerlink" title="wait 和 waitpid"></a>wait 和 waitpid</h3><p>  – waith函数使父进程阻塞，知道收到子进程结束信号。<br>  – waitpid，有若干选项，wait只是调用waitpid的阻塞形式，它可以提供非阻塞的wait功能。<br>  – waitpid(pid_t pid, int *status, int options);在opitons处包括阻塞（0），非阻塞WNOHANG(子进程无信号则返回值为0)， WUNTRACED(若支持作业控制，则由pid指定的子进程已暂停， 且其状态自暂停以来还为报告够，则返回其状态)。</p>
<h2 id="linux守护进程"><a href="#linux守护进程" class="headerlink" title="linux守护进程"></a>linux守护进程</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p> – Daemon进程，是linux中的后台服务进程。它通常独立与控制终端，并且周期性的执行某种任务或等待处理某些发生的事情。<br> – 守护进程一般在系统引导装入时启动，在系统关闭时终止。大多数服务都是守护进程实现的。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p> – 每个从终端开始的进程都依赖与此终端，终端关闭时，相应的进程都会关闭，而守护进程能够突破这种线程，它从执行开始运转，知道整个系统退出才会关闭。</p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p> – 查看常用的系统守护进程 ps -axj</p>
<h3 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h3><p> – 1、创建子进程、父进程退出。 【孤儿进程升级为init子进程】<br>       pid = fork();<br>       if(pid &gt; 0) exit(0);</p>
<p> – 2、在子进程中创建新会话<br>      进程组是一个或多个进程的集合。进程组有进程组ID来唯一标志PGID。每个进程组都有一个组长进程，组长进程的进程号等于进程组ID。<br>      会话期，会话期是一个或多个进程组的集合，通常一个会话开始与用户登录，终止与用户退出，在此期间该用户运行的所有进程都属于这个会话组。<br>      – setsid函数<br>      用于创建一个新的会话，并且任该会话组的组长，让进程摆脱原会话、进程组、终端的控制</p>
<p> – 3、改变当前目录为根目录。 fs<br>    使用fork创建的子进程继承了父进程的当前目录，由于在进程运行过程中，当前目录所在的文件系统是不能卸载的，这会对以后使用的会话造成诸多的麻烦。所以改变当前目录为/目录。chdir(“/“)</p>
<p> – 4、改变文件权限掩码。 files<br>    使用父进程的文件权限掩码会给子进程使用文件带来诸多的麻烦，因此把文件权限掩码设置为0，可以大大增加该守护进程的灵活性。 umask(0)</p>
<p> – 5、关闭文件描述符。  files<br>    从父进程那继承的已经打开的文件，这些文件子进程keying从来不会读写，不仅消耗了资源，而且导致所在的文件系统无法卸载。由于重写设置了会话，因此从终端输入的字符不可能达到守护进程，守护进程用常规的（printf）输出的字符也不可能在终端上显示出来。所以文件描述符为0，1，2的三个文件 （输入、输出错标志错误三个文件）已经失去了存在的价值，也应该被关闭。<br>    for(i=0; i&lt;MAXFILE; i++) close(i);</p>
<h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="单计算机内通信-From-AT-amp-T贝尔实验室"><a href="#单计算机内通信-From-AT-amp-T贝尔实验室" class="headerlink" title="单计算机内通信  From AT&amp;T贝尔实验室"></a>单计算机内通信  From AT&amp;T贝尔实验室</h3><ul>
<li><p>管道（pipe）及有名管道（named pipe）<br>Pile在父子进程间通信，named pipe可以在无关系进程间的通信</p>
</li>
<li><p>信号（signal）<br>软件模拟中断</p>
</li>
<li><p>消息队列<br>消息链表，解决前两种信号量有限的缺点，有写权限的进程可以写，有读权限的进程可以读。</p>
</li>
<li><p>共享内存<br>最有用的进程间通信方式，多个进程可以访问同一块内存，不同进程可以即时看到共享内存的修改，依靠互斥锁或信号量来同步。</p>
</li>
<li><p>信号量<br>主要作为不同进程、线程间的同步手段。</p>
</li>
</ul>
<h3 id="socket-From-BSD伯克利"><a href="#socket-From-BSD伯克利" class="headerlink" title="socket  From BSD伯克利"></a>socket  From BSD伯克利</h3><p> 可以用于不同机器间的进程通信。</p>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p> – 只用于父子进程间<br> – 固定的读写端<br> – 可以看作为一种特殊的文件，可用read、write等函数。</p>
<h3 id="创建与关闭"><a href="#创建与关闭" class="headerlink" title="创建与关闭"></a>创建与关闭</h3><p> – 管道基于文件描述符的通信方式，当一个管道创建时，它创建2个文件描述符，fds[0] fds[1]<br>其中 fds[0]固定用于读、 fds[1]固定用于写。构成一个半双工的通道<br> – int pipe(int fd[2]),成功返回0，失败返回-1</p>
<h2 id="FIFO命名管道"><a href="#FIFO命名管道" class="headerlink" title="FIFO命名管道"></a>FIFO命名管道</h2><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul>
<li>有命名管道可以在不相关的两个进程实现彼此通信，该通道在文件系统中可见，通过路径名来进程通信。</li>
<li>FIFO， 先进先出原则</li>
</ul>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul>
<li>int mkfifo(const char *filename, mode_t mode); filename要创建的管道,mode包括读管道、写管道、读写管道；从功能上为非阻塞、创建。</li>
</ul>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><ul>
<li>消息队列比FIFO多随机查询，消息在内核中，由消息ID来标识</li>
</ul>
<h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><ul>
<li>操作包括创建或打开消息队列、添加消息、读取消息、控制消息队列。</li>
<li>创建消息队列 – msgget，受系统消息队列数量的限制</li>
<li>添加消息 – msgsend</li>
<li>读取消息 – msgrcv，与FIFO不同，可以指定取走某条消息</li>
<li>控制消息 – msgctl ，可以完成多项功能。</li>
</ul>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><h3 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h3><ul>
<li>最为高效的进程间通信方式，进程间可以直接读写，不需要数据的拷贝，大大提高效率。</li>
<li>内核中留出一个内存区，可以由访问的进程将其映射到自己的私有地址空间。</li>
<li>多个进程间访问，需要同步机制。 互斥锁与信号量。</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li><p>创建共享内存shmget<br>int shmget(key_t key, int size, int shmflg);;<br>key:IPC_PRIVATE; size:大小 shmflg:Usr/Grp/Oth 的读写执行<br>成功：返回共享内存段标志符</p>
</li>
<li><p>映射共享内存shmat<br>char <em>shmat(int shmid, const void</em> shmaddr, int shmflg);<br>shmid:要映射的共享内存标志符<br>shmaddr:将共享内存映射到指定位置，若为0则表示把该共享内存映射到调用进程的地址空间<br>shmflg:SHM_RDONLY:共享内存只读。默认0：共享内存读写<br>成功：被映射的段地址</p>
</li>
<li><p>现在就可以使用共享内存了，也就是用不带缓存的I/O读写命令对其进行操作</p>
</li>
<li><p>撤销映射的操作shmdt<br>int shmdt(const void *shmaddr)；<br>shmaddr:被映射的共享内存段地址</p>
</li>
</ul>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>二值信号量：值为0或1，与互斥锁类似。</li>
<li>计数信号量：值在0-n之间，用来统计资源，其值代表可用资源数</li>
<li>等待操作时等待信号量的值变为大于0，然后将其减1；而挂出操作则相反，将信号量—+1，会唤醒等待资源的任何进程或线程</li>
</ul>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ul>
<li><p>int semget(key_t key, int nsems, int oflag);<br>key: ftok的返回值或IPC_PRIVATE<br>nsems:信号量的值<br>oflag:一般为IPC_CREAT|IPC_EXCL|0600 自己拥有读写操作</p>
</li>
<li><p>int semop(int semid, struct sembuf *opsptr, size_t nops);<br>nops为结构体中元素的个数<br>opsptr指向结构体:<br>struct sembuf{<br>short sem_num; // 指定的某个信号量<br>short sem_op;  // 信号量操作 1: semval+1–释放资源； -1:semval-1 –获取资源<br>short sem_flg; // 0, IPC_NOWAIT,SEM_UNDO<br> }</p>
</li>
<li><p>int semctl(int semid, int semnum, int cmd, ……);<br>semnum:要修改的信号量ID？<br>cmd: SETVAL GETVAL  设置或获取semval的值</p>
<pre><code>IPC_RMID：在系统中删除semid标识的sem
</code></pre></li>
</ul>
<h2 id="信号-软中断"><a href="#信号-软中断" class="headerlink" title="信号(软中断)"></a>信号(软中断)</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><ul>
<li>信号是软件层次上对中断机制的一种模拟，是一种异步通信方式</li>
<li><p>信号可以直接进行用户空间进程和内核进程之间的交互，内核进程可以利用它来通知用户用间进程发生哪些系统事件。它可以在任何使用发给某一进程，而无需知道该进程的状态。若用户进程未处于执行态，该信号会由内核保存起来，知道该进程处于执行状态再传递给它。如果一个信号被进程设置为阻塞，则该信号的传递被延迟，知道其阻塞被取消才传递给进程。</p>
</li>
<li><p>用户进程对信号的相应方式<br>忽略信号，即对信号不做任何处理，两个信号不能忽略 SIGKILL与SIGSTOP<br>捕捉信号，定义信号处理函数，当信号发生时，执行相应的处理函数<br>缺省操作，linux对每种信号都定义了缺省操作。</p>
</li>
</ul>
<h3 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h3><ul>
<li><p>kill()<br>kill函数可以发生信号给进程或进程组，它不仅可以中止进程，也可以发生其他信号<br>int kill(pid_t pid, int sig);<br>pid:正数表示要发送信号的进程号； 0:信号发送给所有和pid进程在同一进程组的进程; -1:所有进程（除进程号最大的进程外）？？<br>sig：信号</p>
</li>
<li><p>raise()<br>raise()函数允许进程向自身发送信号<br>int raise(int sig);<br>sig:信号</p>
</li>
<li><p>alarm()<br>闹钟信号，定时器，时间一到就发送SIGALARM信号。一个进程中只能有一个闹钟信号，新值代替旧值。<br>unsigned int alarm(unsigned int seconds)；<br>seconds:秒数<br>返回成功：如果此前已经调用过alarm()则返回上一个闹钟时间的剩余值，否则返回0</p>
</li>
<li><p>pause()<br>将调用进程挂起，直到捕捉到信号为止。<br>int pause(void);</p>
</li>
</ul>
<h3 id="信号的处理"><a href="#信号的处理" class="headerlink" title="信号的处理"></a>信号的处理</h3><ul>
<li>一个进程可以决定在该进程中需要对哪些信号进行什么样的处理</li>
<li>两种方式：signal()函数，使用信号集函数组<br>signal()，用于前32种非实时信号的处理，不支持信号传递信息，简单易用<br>void (<em> signal(int signum, void( </em>handler)(int)))(int)<br>signum:指定信号<br>handler: SIG_IGN,SIG_DFL,自定义的信号处理函数指针。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 1、管道、消息队列、共享内存，用于传递数据<br> 2、信号，用于同步动作，像是回调函数<br> 3、信号量、互斥锁，用于对资源的保护</p>
<h1 id="多线程开发"><a href="#多线程开发" class="headerlink" title="多线程开发"></a>多线程开发</h1><h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><p> – lpthread 库 –&gt; clone()</p>
<h2 id="信号量-–-生产者消费者问题"><a href="#信号量-–-生产者消费者问题" class="headerlink" title="信号量 – 生产者消费者问题"></a>信号量 – 生产者消费者问题</h2><p> – sem_wait()阻塞; sem_post()唤醒阻塞<br> – 生产者–消费者问题，用信号量来解决<br> – a++ ：ldr inc str； 共同访问时，会出现两次a++结果为1的情况<br> – 关于临界区：</p>
<h2 id="互斥锁-–-互斥"><a href="#互斥锁-–-互斥" class="headerlink" title="互斥锁 – 互斥"></a>互斥锁 – 互斥</h2><p> – pthread_mutex_t mutex;<br> – pthread_mutex_init(&amp;mutex, NULL);</p>
<p> – pthread_mutex_lock(&amp;mutex);<br> – pthread_mutex_unlock(&amp;mutex);</p>
<h3 id="关于注释"><a href="#关于注释" class="headerlink" title="关于注释"></a>关于注释</h3><p> – 自注释<br> – 表达现实语义的根据，或结果</p>
<p> – 2B:对本身代码语音的解说； 正常:对现实语义的根据，函数要干嘛； 或结果； 文艺:抒情与原因</p>
<h3 id="关于锁"><a href="#关于锁" class="headerlink" title="关于锁"></a>关于锁</h3><p> – 同一把锁<br> – 语义整体 ：原子，全部发生或全部不发生；<br> – 密度最小</p>
<h3 id="早死早超生"><a href="#早死早超生" class="headerlink" title="早死早超生"></a>早死早超生</h3><p> – 小写字母转大写字母； 使用断言来做输入检查，而不是用返回</p>
<h3 id="关于自愈"><a href="#关于自愈" class="headerlink" title="关于自愈"></a>关于自愈</h3><p> – 主辅</p>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p> – 用全局变量来做线程同步时不正确的。</p>
<h2 id="条件变量-–-同步"><a href="#条件变量-–-同步" class="headerlink" title="条件变量 – 同步"></a>条件变量 – 同步</h2><p> – case失效：命中失效<br> – 命名：架构相关</p>
<p> – 编译乱序<br> – 执行乱序<br>      == == ==<br>         == == ==<br>            == == ==<br>   命中失效，会往下执行，导致执行上的乱序。</p>
<h3 id="带着对计算机本身的理解去编写。"><a href="#带着对计算机本身的理解去编写。" class="headerlink" title="带着对计算机本身的理解去编写。"></a>带着对计算机本身的理解去编写。</h3><p> – pthread_cond_wait()，先解锁，再sleep等待唤醒，再拿锁。<br> – pthread_cond_signal()：点到点唤醒<br> – pthread_cond_cast()：全部唤醒<br>    电源管理线程唤醒其他线程。</p>
<h2 id="线程级全局变量"><a href="#线程级全局变量" class="headerlink" title="线程级全局变量"></a>线程级全局变量</h2><p> – 逻辑上是不能访问，但直到地址后，也可以访问，以进程为单位。</p>
<h2 id="优先级反转"><a href="#优先级反转" class="headerlink" title="优先级反转"></a>优先级反转</h2><p> – 低的优先级拿到锁，高的优先级来拿锁造成等待，而中的优先级而抢了低优先级，而造成高优先级等待更长时间。火星上发生了什么。</p>
<p> – 优先级继承，提高低优先级的优先级到高的程度。 pi.c</p>
<h2 id="可重入与线程安全"><a href="#可重入与线程安全" class="headerlink" title="可重入与线程安全"></a>可重入与线程安全</h2><p> – 可重入 – 线程安全、信号处理函数中调用的异步安全。<br> – 信号与线程问题，变为线程与线程问题：异步信号的同步化<br> – 只使用临时变量，内部来维护外部变量，才可以满世界调用。</p>
<h3 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h3><h3 id="异步信号同步化"><a href="#异步信号同步化" class="headerlink" title="异步信号同步化"></a>异步信号同步化</h3><h2 id="线程栈与栈溢出"><a href="#线程栈与栈溢出" class="headerlink" title="线程栈与栈溢出"></a>线程栈与栈溢出</h2><p>  – 线程栈私有而共享<br>  – gcc stack_overflow.c -lpthread</p>
<h1 id="多线程编程模型"><a href="#多线程编程模型" class="headerlink" title="多线程编程模型"></a>多线程编程模型</h1><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><p> – 单核情况下完成I/O与CPU并发</p>
<ul>
<li>H.GOMMA原则</li>
<li>I/O原则<br>– I/O操作单独线程处理</li>
<li>大量运算原则<br>– 数据处理方面放在单独线程</li>
<li><p>优先级原则<br>– 不同优先级放在不同线程</p>
</li>
<li><p>功能耦合原则<br>– 过程，有相同的行为</p>
</li>
<li>周期性原则<br>– 周期性，心跳线程</li>
<li>偶然耦合原则<br>– 比如时间点相同</li>
</ul>
<h2 id="流水线模型"><a href="#流水线模型" class="headerlink" title="流水线模型"></a>流水线模型</h2><p> – 读取 –&gt; 解码 –&gt; 处理 –&gt; 渲染<br> 每个流程都独自一个线程，来完成。<br> – 去IOE运行</p>
<h2 id="工作组模型"><a href="#工作组模型" class="headerlink" title="工作组模型"></a>工作组模型</h2><p> – 适合多核分布下工作</p>
<h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><p> – seguer</p>
<h2 id="amdahl’s-law"><a href="#amdahl’s-law" class="headerlink" title="amdahl’s law"></a>amdahl’s law</h2><p> – 性能很大程度上是软件</p>
<h2 id="c10K，-c10M"><a href="#c10K，-c10M" class="headerlink" title="c10K， c10M"></a>c10K， c10M</h2><h2 id="线程池技术"><a href="#线程池技术" class="headerlink" title="线程池技术"></a>线程池技术</h2><p> – 将线程的创建与销毁，变为线程的唤醒与睡眠<br> – man 3 sleep<br> – g++ thread_pool.c thread_pool_test.c</p>
<h2 id="系统I-O与服务器模型"><a href="#系统I-O与服务器模型" class="headerlink" title="系统I/O与服务器模型"></a>系统I/O与服务器模型</h2><h1 id="linux网络编程"><a href="#linux网络编程" class="headerlink" title="linux网络编程"></a>linux网络编程</h1><h2 id="linux性能剖析手段"><a href="#linux性能剖析手段" class="headerlink" title="linux性能剖析手段"></a>linux性能剖析手段</h2><p> – oprofile，分析效率<br> – gprof ,每个函数占用的时间</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/02/01/linux工具与文件/" rel="next" title="linux工具与文件">
                <i class="fa fa-chevron-left"></i> linux工具与文件
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/02/01/linux调试/" rel="prev" title="linux调试">
                linux调试 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/curiosity.jpg"
               alt="sun" />
          <p class="site-author-name" itemprop="name">sun</p>
           
              <p class="site-description motion-element" itemprop="description">有一片天空，能留下鸟的痕迹</p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">63</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">34</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#MakeFile"><span class="nav-number">1.</span> <span class="nav-text">MakeFile</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本结构"><span class="nav-number">1.1.</span> <span class="nav-text">基本结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Makefile变量"><span class="nav-number">1.2.</span> <span class="nav-text">Makefile变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#变量"><span class="nav-number">1.2.1.</span> <span class="nav-text">$(变量)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#与"><span class="nav-number">1.2.2.</span> <span class="nav-text">$@ 与 $^</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wildcard通配符"><span class="nav-number">1.3.</span> <span class="nav-text">wildcard通配符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Autotools工具"><span class="nav-number">1.4.</span> <span class="nav-text">Autotools工具</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#进程开发"><span class="nav-number">2.</span> <span class="nav-text">进程开发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基础"><span class="nav-number">2.1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程运行状态"><span class="nav-number">2.1.1.</span> <span class="nav-text">进程运行状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linux进程描述符：task-struct"><span class="nav-number">2.1.2.</span> <span class="nav-text">linux进程描述符：task_struct</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pid"><span class="nav-number">2.2.</span> <span class="nav-text">pid</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建-fork-vfork-clone"><span class="nav-number">2.3.</span> <span class="nav-text">创建 fork/vfork/clone</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fork"><span class="nav-number">2.3.1.</span> <span class="nav-text">fork()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vfork-，在没有mmu系统中"><span class="nav-number">2.3.2.</span> <span class="nav-text">vfork()，在没有mmu系统中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#clone-线程，轻量级线程"><span class="nav-number">2.3.3.</span> <span class="nav-text">clone(), 线程，轻量级线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#起点：进程0"><span class="nav-number">2.3.4.</span> <span class="nav-text">起点：进程0</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#终止"><span class="nav-number">2.4.</span> <span class="nav-text">终止</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#子进程死而父进程不清理-ps-aux"><span class="nav-number">2.4.1.</span> <span class="nav-text">子进程死而父进程不清理 ps aux</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#子进程不死而父进程死掉"><span class="nav-number">2.4.2.</span> <span class="nav-text">子进程不死而父进程死掉</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程的类型"><span class="nav-number">2.5.</span> <span class="nav-text">线程的类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调度目标"><span class="nav-number">2.6.</span> <span class="nav-text">调度目标</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#调度策略-与-优先级"><span class="nav-number">2.6.1.</span> <span class="nav-text">调度策略 与 优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态优先级"><span class="nav-number">2.6.2.</span> <span class="nav-text">动态优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linux-RT与Normal之间的策略"><span class="nav-number">2.6.3.</span> <span class="nav-text">linux RT与Normal之间的策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#相关系统调用"><span class="nav-number">2.6.4.</span> <span class="nav-text">相关系统调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#墨菲定律"><span class="nav-number">2.6.5.</span> <span class="nav-text">墨菲定律</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多核负载均衡"><span class="nav-number">2.7.</span> <span class="nav-text">多核负载均衡</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RT任务的负载均衡CFS"><span class="nav-number">2.7.1.</span> <span class="nav-text">RT任务的负载均衡CFS</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内核线程"><span class="nav-number">2.8.</span> <span class="nav-text">内核线程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#多进程开发"><span class="nav-number">3.</span> <span class="nav-text">多进程开发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#进程类型"><span class="nav-number">3.1.</span> <span class="nav-text">进程类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux下进程的模式"><span class="nav-number">3.2.</span> <span class="nav-text">linux下进程的模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux系统调用的实现"><span class="nav-number">3.3.</span> <span class="nav-text">linux系统调用的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#系统调用表"><span class="nav-number">3.3.1.</span> <span class="nav-text">系统调用表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现机制"><span class="nav-number">3.3.2.</span> <span class="nav-text">实现机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程创建"><span class="nav-number">3.4.</span> <span class="nav-text">进程创建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fork-1"><span class="nav-number">3.4.1.</span> <span class="nav-text">fork</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#写时拷贝"><span class="nav-number">3.4.2.</span> <span class="nav-text">写时拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exec-函数族"><span class="nav-number">3.4.3.</span> <span class="nav-text">exec 函数族</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exit-和-exit"><span class="nav-number">3.4.4.</span> <span class="nav-text">exit 和 _exit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wait-和-waitpid"><span class="nav-number">3.4.5.</span> <span class="nav-text">wait 和 waitpid</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux守护进程"><span class="nav-number">3.5.</span> <span class="nav-text">linux守护进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#作用"><span class="nav-number">3.5.1.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特点"><span class="nav-number">3.5.2.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#命令"><span class="nav-number">3.5.3.</span> <span class="nav-text">命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编写"><span class="nav-number">3.5.4.</span> <span class="nav-text">编写</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#进程间通信"><span class="nav-number">4.</span> <span class="nav-text">进程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">4.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单计算机内通信-From-AT-amp-T贝尔实验室"><span class="nav-number">4.1.1.</span> <span class="nav-text">单计算机内通信  From AT&amp;T贝尔实验室</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#socket-From-BSD伯克利"><span class="nav-number">4.1.2.</span> <span class="nav-text">socket  From BSD伯克利</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#管道"><span class="nav-number">4.2.</span> <span class="nav-text">管道</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#特点-1"><span class="nav-number">4.2.1.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建与关闭"><span class="nav-number">4.2.2.</span> <span class="nav-text">创建与关闭</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FIFO命名管道"><span class="nav-number">4.3.</span> <span class="nav-text">FIFO命名管道</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#特点-2"><span class="nav-number">4.3.1.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建"><span class="nav-number">4.3.2.</span> <span class="nav-text">创建</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消息队列"><span class="nav-number">4.4.</span> <span class="nav-text">消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#特点-3"><span class="nav-number">4.4.1.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建-1"><span class="nav-number">4.4.2.</span> <span class="nav-text">创建</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#共享内存"><span class="nav-number">4.5.</span> <span class="nav-text">共享内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#特点-4"><span class="nav-number">4.5.1.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现"><span class="nav-number">4.5.2.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#信号量"><span class="nav-number">4.6.</span> <span class="nav-text">信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简介"><span class="nav-number">4.6.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作"><span class="nav-number">4.6.2.</span> <span class="nav-text">操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#信号-软中断"><span class="nav-number">4.7.</span> <span class="nav-text">信号(软中断)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简介-1"><span class="nav-number">4.7.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作-1"><span class="nav-number">4.7.2.</span> <span class="nav-text">操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号的处理"><span class="nav-number">4.7.3.</span> <span class="nav-text">信号的处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">4.8.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#多线程开发"><span class="nav-number">5.</span> <span class="nav-text">多线程开发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#线程创建"><span class="nav-number">5.1.</span> <span class="nav-text">线程创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#信号量-–-生产者消费者问题"><span class="nav-number">5.2.</span> <span class="nav-text">信号量 – 生产者消费者问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#互斥锁-–-互斥"><span class="nav-number">5.3.</span> <span class="nav-text">互斥锁 – 互斥</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关于注释"><span class="nav-number">5.3.1.</span> <span class="nav-text">关于注释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于锁"><span class="nav-number">5.3.2.</span> <span class="nav-text">关于锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#早死早超生"><span class="nav-number">5.3.3.</span> <span class="nav-text">早死早超生</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于自愈"><span class="nav-number">5.3.4.</span> <span class="nav-text">关于自愈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条件变量"><span class="nav-number">5.3.5.</span> <span class="nav-text">条件变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#条件变量-–-同步"><span class="nav-number">5.4.</span> <span class="nav-text">条件变量 – 同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#带着对计算机本身的理解去编写。"><span class="nav-number">5.4.1.</span> <span class="nav-text">带着对计算机本身的理解去编写。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程级全局变量"><span class="nav-number">5.5.</span> <span class="nav-text">线程级全局变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#优先级反转"><span class="nav-number">5.6.</span> <span class="nav-text">优先级反转</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可重入与线程安全"><span class="nav-number">5.7.</span> <span class="nav-text">可重入与线程安全</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程不安全"><span class="nav-number">5.7.1.</span> <span class="nav-text">线程不安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异步信号同步化"><span class="nav-number">5.7.2.</span> <span class="nav-text">异步信号同步化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程栈与栈溢出"><span class="nav-number">5.8.</span> <span class="nav-text">线程栈与栈溢出</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#多线程编程模型"><span class="nav-number">6.</span> <span class="nav-text">多线程编程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#原则"><span class="nav-number">6.1.</span> <span class="nav-text">原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#流水线模型"><span class="nav-number">6.2.</span> <span class="nav-text">流水线模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#工作组模型"><span class="nav-number">6.3.</span> <span class="nav-text">工作组模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UML图"><span class="nav-number">6.4.</span> <span class="nav-text">UML图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#amdahl’s-law"><span class="nav-number">6.5.</span> <span class="nav-text">amdahl’s law</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c10K，-c10M"><span class="nav-number">6.6.</span> <span class="nav-text">c10K， c10M</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池技术"><span class="nav-number">6.7.</span> <span class="nav-text">线程池技术</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#系统I-O与服务器模型"><span class="nav-number">6.8.</span> <span class="nav-text">系统I/O与服务器模型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#linux网络编程"><span class="nav-number">7.</span> <span class="nav-text">linux网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#linux性能剖析手段"><span class="nav-number">7.1.</span> <span class="nav-text">linux性能剖析手段</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sun</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
