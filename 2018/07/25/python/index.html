<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="思 见" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="python课程简介Python基础爬虫与搜索[数据采集]restful api设计scrapy爬虫框架 数据分析pandas库Numpy库matplotlib 深度学习TensorFlow框架 python基础安装使用python3.6.1yum install zlib-devel bzip2-devel openssl-devel ncurese-devel gcczlib OpenStac">
<meta property="og:type" content="article">
<meta property="og:title" content="思 见">
<meta property="og:url" content="http://yoursite.com/2018/07/25/python/index.html">
<meta property="og:site_name" content="思 见">
<meta property="og:description" content="python课程简介Python基础爬虫与搜索[数据采集]restful api设计scrapy爬虫框架 数据分析pandas库Numpy库matplotlib 深度学习TensorFlow框架 python基础安装使用python3.6.1yum install zlib-devel bzip2-devel openssl-devel ncurese-devel gcczlib OpenStac">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2018/07/25/python/1.python中对象分类.png">
<meta property="og:image" content="http://yoursite.com/2018/07/25/python/2.元组.png">
<meta property="og:image" content="http://yoursite.com/2018/07/25/python/2.元组.png">
<meta property="og:image" content="http://yoursite.com/2018/07/25/python/3.内置函数.png">
<meta property="og:image" content="http://yoursite.com/2018/07/25/python/4.文件操作.png">
<meta property="og:image" content="http://yoursite.com/2018/07/25/python/5.工厂方法.png">
<meta property="og:image" content="http://yoursite.com/2018/07/25/python/6.习题.png">
<meta property="og:image" content="http://yoursite.com/2018/07/25/python/6.习题解释.png">
<meta property="og:image" content="http://yoursite.com/2018/07/25/python/8.深拷贝.png">
<meta property="og:image" content="http://yoursite.com/2018/07/25/python/9.浅拷贝.png">
<meta property="og:image" content="http://yoursite.com/2018/07/25/python/10.内建属性.png">
<meta property="og:image" content="http://yoursite.com/2018/07/25/python/11.常用标准模块.png">
<meta property="og:image" content="http://yoursite.com/2018/07/25/python/12.常用三方模块.png">
<meta property="og:image" content="http://yoursite.com/2018/07/25/python/13.pdb调试.png">
<meta property="og:image" content="http://yoursite.com/2018/07/25/python/14.线程的几种状态.png">
<meta property="og:image" content="http://yoursite.com/2018/07/25/python/15.IP地址.png">
<meta property="og:image" content="http://yoursite.com/2018/07/25/python/16.网络协议.png">
<meta property="og:image" content="http://yoursite.com/2018/07/25/python/17.tftp协议介绍.png">
<meta property="og:image" content="http://yoursite.com/2018/07/25/python/18.fmt意思.png">
<meta property="og:image" content="http://yoursite.com/2018/07/25/python/19.tcp服务器.png">
<meta property="og:image" content="http://yoursite.com/2018/07/25/python/20.多路复用select版.png">
<meta property="og:image" content="http://yoursite.com/2018/07/25/python/21.多路复用epoll版.png">
<meta property="og:updated_time" content="2018-07-25T02:23:55.404Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="思 见">
<meta name="twitter:description" content="python课程简介Python基础爬虫与搜索[数据采集]restful api设计scrapy爬虫框架 数据分析pandas库Numpy库matplotlib 深度学习TensorFlow框架 python基础安装使用python3.6.1yum install zlib-devel bzip2-devel openssl-devel ncurese-devel gcczlib OpenStac">
<meta name="twitter:image" content="http://yoursite.com/2018/07/25/python/1.python中对象分类.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/07/25/python/"/>





  <title>  | 思 见 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">思 见</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/25/python/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/curiosity.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思 见">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-25T10:23:55+08:00">
                2018-07-25
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/07/25/python/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/07/25/python/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="python课程简介"><a href="#python课程简介" class="headerlink" title="python课程简介"></a>python课程简介</h1><h2 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h2><h2 id="爬虫与搜索-数据采集"><a href="#爬虫与搜索-数据采集" class="headerlink" title="爬虫与搜索[数据采集]"></a>爬虫与搜索[数据采集]</h2><p>restful api设计<br>scrapy爬虫框架</p>
<h2 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h2><p>pandas库<br>Numpy库<br>matplotlib</p>
<h2 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h2><p>TensorFlow框架</p>
<h1 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用python3.6.1<br>yum install zlib-devel bzip2-devel openssl-devel ncurese-devel gcczlib</p>
<p>OpenStack-云计算</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul>
<li>for/while<br>while/for也可以跟else，意思是for循环结束之后执行，break会跳过else<br>for  :<br>  if  :<pre><code>break
</code></pre>else :</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><img src="1.python中对象分类.png" alt=""></p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>分为堆内存、栈内存。堆中放具体的数据，栈中放引用</p>
<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><ul>
<li>数值类型Numeric<br>布尔型True<br>浮点<br>整形</li>
<li>空值<br>None，在堆内存中也有值</li>
</ul>
<h3 id="字符串String"><a href="#字符串String" class="headerlink" title="字符串String"></a>字符串String</h3><p>  单双引号都可以”bus”，’bus’<br>  name=”abcdef” #就是字符串数组</p>
<p>  print(name[0])<br>  还可以从右往左数,-1是起始位置<br>  print(name[-1])</p>
<ul>
<li><p>切片[起始位置:结束位置:步长]，切片属于顺序型数据的共同用法，list,tuple<br>包头不包尾</p>
</li>
<li><p>find()<br> my_str = “hello world”<br> my_str.find(“world”)<br> 找不到返回-1</p>
</li>
<li><p>index()<br> my_str.index(“world”)<br> 找不到返回错误</p>
</li>
<li><p>join()<br> 合并2字符串</p>
</li>
<li>count()<br> 出现的次数</li>
<li><p>replace()<br> 替代字符串中某段</p>
</li>
<li><p>split()<br>与Java中相同，返回一个List<br>若不指定，会将所有的隔开符都隔开</p>
</li>
<li><p>partition()<br>也是切割，将形参中的字符串，隔离出来</p>
</li>
<li>capitalize()<br>字符串首字母</li>
<li>title()<br>字符串每个word的首字母大写</li>
<li>upper()</li>
<li><p>lower()</p>
</li>
<li><p>startwith()</p>
</li>
<li><p>endswith()<br>判断开头与结尾</p>
</li>
<li><p>ljust(50)</p>
</li>
<li>rjust(50)</li>
<li><p>center(50)<br>对齐</p>
</li>
<li><p>rstrip</p>
</li>
<li>lstrip</li>
<li><p>strip<br>删除空格</p>
</li>
<li><p>isalpha<br>都是字某返回true</p>
</li>
<li>isdigit<br>都是数字</li>
<li>isalnum<br>字母或者数字</li>
<li><p>isspace<br>只包含空格</p>
</li>
<li><p>join<br>列表转字符串<br>names=[‘1’,’2’,’’3]<br>“”.join(names)<br>“.”.join(names)：笛卡尔积</p>
</li>
</ul>
<h3 id="list列表"><a href="#list列表" class="headerlink" title="list列表[]"></a>list列表[]</h3><p>list<br>names=[]</p>
<ul>
<li>增<br>append<br>  在最后追加<br>extend<br>  两个列表的合并<br>insert<br>  任意位置插入</li>
<li>修改<br>name[2]=’888’</li>
<li>查<br>in/not in 关键字<br>  判断是否有或者没有<br>index(元素)<br>  返回元素的下标位<br>count<br>  统计元素在</li>
<li><p>删<br>del<br>  删除某个位置上的元素<br>  del a[2]<br>remove<br>  删除具体的内容<br>  a.remove<br>pop<br>  拿出最后一个数据</p>
</li>
<li><p>排序<br>sort()<br>  默认是升序<br>  sort(reverse=True)：降序<br>reverse()<br>  a.reverse()<br>  a就倒叙了<br>  a[-1::-1]<br>  返回a的倒叙，但a不会倒叙a=[-1::-1]可以<br>  ::是一直到的意思</p>
<ul>
<li>range<br>c=rang(1,10),lazy的在操作元素时，才会创建<br>c是一个列表</li>
</ul>
</li>
</ul>
<h3 id="tuple元组"><a href="#tuple元组" class="headerlink" title="tuple元组()"></a>tuple元组()</h3><p>元祖与列表类似，不同之处在于元组里的数据不能修改，元组使用(),列表使用[]</p>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>my_str=(‘aa’,’bb’,’cc’)</p>
<h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><p>my_str[0]  ‘aa’<br>count<br>index</p>
<h4 id="可变类型："><a href="#可变类型：" class="headerlink" title="可变类型："></a>可变类型：</h4><ul>
<li>可变类型：list</li>
<li>不可变类型:数值，字符串，元组<br>声明好之后，长度固定，不能修改其中的元素，不能追加<br>元组中的列表元素可以修改<br><img src="2.元组.png" alt=""></li>
</ul>
<h3 id="dict字典-map"><a href="#dict字典-map" class="headerlink" title="dict字典{} = map"></a>dict字典{} = map</h3><p>d = {“michael”:95,”bob”:75,”tracy”:85}</p>
<ul>
<li><p>访问<br>d.get(‘bob’)：键不存在，返回None<br>d[‘bob’]：键不存在，报错<br>d[‘john’]=’78’</p>
</li>
<li><p>删<br>del stus[‘bob’]<br>del stus<br>stus.pop(‘bob’)<br>内存立即回收，stus就不存在了<br>d.clear()<br>d还存在，元素不在了</p>
</li>
<li><p>函数lens(),keys(),values(),items()<br>   stu={“name”:”laowang”,”age”:33}</p>
<p>   for k in stu.keys():</p>
<pre><code>print(k)
</code></pre><p>   for v in stu.values():</p>
<pre><code>print(v)
</code></pre><p>   for item in stu.items():</p>
<pre><code>print(&quot;key为:%s,value为:%s&quot;%item)
</code></pre><p>   items()是元组</p>
<p>   “name” in stu 返回True            </p>
</li>
<li>key值需要可以hash<br>a=[1,2,4]<br>b={a:”test”}  #此时是不可以的<br>可以认为，可变类型不能作为key</li>
</ul>
<h3 id="set集合"><a href="#set集合" class="headerlink" title="set集合{}"></a>set集合{}</h3><p>a={1,3}<br>print a=set()是空集合</p>
<ul>
<li>增add</li>
<li>删pop</li>
<li>改</li>
<li>查</li>
</ul>
<h3 id="相互转化"><a href="#相互转化" class="headerlink" title="相互转化"></a>相互转化</h3><p>a = {1,2,3,4,4,4,4}<br>l = list(a)  #l是列表<br>s = set(l)   #s是集合<br>t = tuple(s) #t是元组</p>
<h3 id="可变类型与不可变类型"><a href="#可变类型与不可变类型" class="headerlink" title="可变类型与不可变类型"></a>可变类型与不可变类型</h3><ul>
<li><p>不可变类型:数值，字符串，元组<br>a=’abc’<br>a.replace(“a”,’A’)，它返回一个Abc，但a还是abc<br>id(a) 打印a执行的内存地址<br>声明好之后，长度固定，不能修改其中的元素，不能追加</p>
</li>
<li><p>可变类型：list，字典<br>可变类型就是在原址上可以增加修改的类型</p>
</li>
<li><p>总结</p>
<ol>
<li><p>变量与对象<br>变量：python可以认为都是引用<br>对象：对象有类型的差异，并且有具体的内存地址，是内存里具体的东西</p>
</li>
<li><p>赋值<br>python的赋值有2种：一种是引用的指向，二种是创建一个对象<br>直接一个变量等于另一个变量，都是引用的指向修改，不会创建对象<br>不可改变类型，重新赋值时，会创建新的对象。</p>
</li>
<li><p>传参<br>传参都是引用的指向，不会创建对象</p>
</li>
<li><p>python的缓存:见下面的内存管理<br>a = 256<br>b = 256<br>a is b #True</p>
<p>c = 257<br>d = 257<br>c is d #False<br>python会缓存一些小的对象，比如数值与小的字符串，于是出现以上的情况</p>
</li>
</ol>
</li>
<li><p>案例</p>
<ol>
<li><p>元组中的列表元素可以修改<br><img src="2.元组.png" alt=""></p>
</li>
<li><p>a=[1,2]<br>b=a<br>b+=[3,4]<br>这时候a也是[1,2,3,4]</p>
</li>
<li><p>def test(num):<br> num+=num<br> print(num)</p>
</li>
</ol>
<p>#a=10   ：数值是不可变类型，在num+=num时，会重新开辟空间使num重新指向<br>#a=[10] ：[]可变类型，在num+=num时，在原用的内存修改<br>test(a)<br>print(a)</p>
</li>
</ul>
<h3 id="基本类型转换"><a href="#基本类型转换" class="headerlink" title="基本类型转换"></a>基本类型转换</h3><p>整数字符串转换为对应的整数<br>int(‘12’)</p>
<p>小数字符串转换为对应小数<br>float(‘12.34’)</p>
<p>数字转换为字符串<br>str(123.45)</p>
<p>ASCII码转换为相应字符<br>chr(97)</p>
<p>字符转换为响应ASCII码<br>ord(‘a’)</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="dict-pair"><a href="#dict-pair" class="headerlink" title="dict = pair"></a>dict = pair</h4><p>map中可以放很多数据，而中仅能放一条<br>[{},{}]这种结构还差不多</p>
<h4 id="python是一种弱类型语言，"><a href="#python是一种弱类型语言，" class="headerlink" title="python是一种弱类型语言，"></a>python是一种弱类型语言，</h4><p>{“name”:’sun’,”age”:18}，name与age其实是结构</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="命名空间（namespace）"><a href="#命名空间（namespace）" class="headerlink" title="命名空间（namespace）"></a>命名空间（namespace）</h3><h3 id="全局变量与局部变量"><a href="#全局变量与局部变量" class="headerlink" title="全局变量与局部变量"></a>全局变量与局部变量</h3><ul>
<li>LEGB: locals &gt; enclosing fuction(闭包) &gt; globals &gt; builtins(内建)<br>在函数内部要使用global时,需要声明:global a<br>globals()函数可以看全局的属性<br>locals()函数,可以看到局部的属性<br>dir(<strong>builtin</strong>)<h2 id="和-is"><a href="#和-is" class="headerlink" title="== 和 is"></a>== 和 is</h2>is是比较两个引用是否指向了统一对象(引用比较) 或者说地址比较<br>== 是比较两个对象是否相等（值比较）<br>a = [1,2,3]<br>b = a</li>
</ul>
<p>a == b #True<br>a is b #True</p>
<p>c = a[:] 或者 c=list(a)<br>a == c #True<br>a is c #False</p>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><h3 id="进制、位运算"><a href="#进制、位运算" class="headerlink" title="进制、位运算"></a>进制、位运算</h3><p>int(o, 8) =  10 #把8转换为八进制的10<br>int(h, 16) = 10<br>bin(5) = ‘0b101’<br>bin(-5) = ‘=0b101’</p>
<p>位与&amp;<br>位或|<br>位异或^<br>取反~<br>左移&lt;&lt;<br>右移&gt;&gt;</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>表达式或者关键字没有(),且有：<br>函数才有()</p>
<h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><p><img src="3.内置函数.png" alt=""></p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>def print_hello():<br>    print(“人生苦短，我要学python”)</p>
<p>def test(r):<br>    s=3.14*(r**2)<br>    print(s)</p>
<p>def sum_2num(a,b):<br>    if not isinstance((a,b),(int,float)) #是否为int或者浮点数(int,float)是个数组<br>        print(“请输入正确的字符类型”)<br>        return<br>    return a+b</p>
<p>def create():<br>    a=1<br>    b=3<br>    return a,b<br>x,y=create()<br>z=create()  #z是元组</p>
<p>看到def后会加载函数，并不会执行</p>
<h3 id="全局变量与局部变量-1"><a href="#全局变量与局部变量-1" class="headerlink" title="全局变量与局部变量"></a>全局变量与局部变量</h3><p>作用域与C语言相同即，全局变量可以在函数内获取并修改<br>修改不可变类型的引用，global</p>
<h3 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h3><p>def test(x,y,*args):<br>  print(x,y)<br>  print(args)<br>不定长参数是以元组的方式传入<br>def test(x,y, **kwarg):<br>    print(x,y)<br>    print(kwarg)<br>此时候的不定参数是键值对</p>
<h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><h3 id="匿名函数lambda"><a href="#匿名函数lambda" class="headerlink" title="匿名函数lambda"></a>匿名函数lambda</h3><ul>
<li><p>lambda [arg1[,agr2…agrn]]:表达式<br>sum = lambda x,y:x+y<br>print(sum(22,45))</p>
</li>
<li><p>缺点不能简单的操作，因为函数体只能是表达式</p>
</li>
<li><p>lambda可以作为实参传递给函数<br>def test(a,b,func):</p>
<pre><code>result = func(a,b)
return result
</code></pre><p>print(test(23,33,lambda x,y:x*y))<br>感觉像是懒加载，以及lambda也是一个引用，定义在栈上</p>
</li>
<li><p>dict排序<br>stus=[{“name”:”zs”,”age”:12},{“name”:”ls”,”age”:14}]<br>stus.sort(key=lambda x:x[“name”]) #返回类表中每个元素name的value<br>print(stus)</p>
</li>
<li><p>动态语言：用户可以随意变化表达式<br> def test1(a,b,func):</p>
<pre><code>return func(a,b)
</code></pre><p> function = eval(input(“请输入表达式:”))  #eval可以将输入的字符串，转变为表达式<br> print(test1(4,5,function))</p>
</li>
</ul>
<h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><p>a=1<br>b=3</p>
<p>#借用元组来实现的<br>a,b=b,a</p>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>与C语言类似<br>f = open(“test.txt”,’w’)<br>r/w/a<br>r+打开一个文件用于读写，文件指针在开头<br>w+读写，如果文件已存在就将其覆盖，否则就创建<br>a+读写，不创建，文件指针在最后。<br>f.close()<br>f.write(“abcd”)</p>
<p>f.read()/f.read(6)：看参数<br>f.readline()读取一行：一行一行读</p>
<p>f.tell()返回文件指针位置<br>f.seek(offset,from) form：0-文件开头，1当前位置，2文件末尾<br>  f.seek(0,0)文件开头</p>
<h3 id="文件夹"><a href="#文件夹" class="headerlink" title="文件夹"></a>文件夹</h3><p> import os<br> file_list=os.listdir(“test/“)<br> for f in file_list<br>    print(f)<br> <img src="4.文件操作.png" alt=""></p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="从指定目录下，找包含有hello的py文件"><a href="#从指定目录下，找包含有hello的py文件" class="headerlink" title="从指定目录下，找包含有hello的py文件"></a>从指定目录下，找包含有hello的py文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">file_list=[]</span><br><span class="line">def find_hello(parent_dir,file_name):</span><br><span class="line">    file_abspath=os.path.join(parent_dir,file_name)</span><br><span class="line">    if os.path.isdir(file_abspath):</span><br><span class="line">        for f in os.listdir(file_abspath):</span><br><span class="line">           find_hello(file_abspath,f)</span><br><span class="line">    else:</span><br><span class="line">        if dir.endswith(&quot;.py&quot;):</span><br><span class="line">           if read_and_find_hello(file_abspath): #判断内容中是否有hello</span><br><span class="line">                file_list.append(file_abspath)</span><br><span class="line"></span><br><span class="line">def read_and_find_hello(file):</span><br><span class="line">   f = open(file,&quot;r&quot;)</span><br><span class="line">   while True:</span><br><span class="line">      line=f.readline()</span><br><span class="line">      if line==&quot;&quot;:</span><br><span class="line">         break</span><br><span class="line">      elif &quot;hello&quot; in line</span><br><span class="line">        f.close()</span><br><span class="line">        retrun True</span><br><span class="line">   else:</span><br><span class="line">      f.close()</span><br><span class="line">      return False</span><br><span class="line"></span><br><span class="line">find_hello(&quot;/home/&quot;,&quot;python&quot;)</span><br><span class="line">print(file_list)</span><br></pre></td></tr></table></figure>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><p>class 类名：<br>    属性<br>    方法列表<br>方法第一参数一定是self<br>对象名 = 类名()</p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>使用上与C++/Jave相同</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Car:</span><br><span class="line">         def start(self):</span><br><span class="line">                 print(&quot;汽车启动&quot;)</span><br><span class="line"> </span><br><span class="line">         def print_info(self):</span><br><span class="line">                 print(&quot;汽车名字%s,颜色%s&quot;%(self.name,self.color))</span><br><span class="line"></span><br><span class="line">car1= Car()</span><br><span class="line">car1.name=&quot;凯迪拉克&quot;</span><br><span class="line">car1.color=&quot;白色&quot;</span><br><span class="line">car1.start()</span><br><span class="line">car1.print_info()</span><br></pre></td></tr></table></figure>
<h3 id="不同"><a href="#不同" class="headerlink" title="不同"></a>不同</h3><p>  属性上很另类<br>  而且有self:self其实与this有些类似</p>
<h3 id="魔法方法xxx"><a href="#魔法方法xxx" class="headerlink" title="魔法方法xxx"></a>魔法方法<strong>xxx</strong></h3><h3 id="init-self"><a href="#init-self" class="headerlink" title="init(self)"></a><strong>init</strong>(self)</h3><p>类于构造函数，但构造函数是构造时，init是构造之后初始化的时候</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def __init__(self):</span><br><span class="line">    self.name=&quot;zs&quot;</span><br><span class="line">    self.age=18</span><br><span class="line"></span><br><span class="line">def __init__(self,name,age,height):</span><br><span class="line">    self.name=name</span><br><span class="line">    self.age=age</span><br><span class="line">    self.heigtht=height</span><br></pre></td></tr></table></figure>
<p>初始化对象的方法，不是构造方法：<strong>new</strong>()构造对象–&gt;得到一对象–&gt;<strong>init</strong>(self)</p>
<h3 id="del-self"><a href="#del-self" class="headerlink" title="del(self)"></a><strong>del</strong>(self)</h3><p>当内存中释放一个对象时，调用<strong>del</strong>()方法<br>类似于析构函数<br>注意python中=，都是引用，但其引用可以重新指向</p>
<h3 id="str-self"><a href="#str-self" class="headerlink" title="str(self)"></a><strong>str</strong>(self)</h3><p>def <strong>str</strong>(self):<br>    return “string here”<br>类似与Java的toString方法</p>
<h3 id="new-cls"><a href="#new-cls" class="headerlink" title="new(cls):"></a><strong>new</strong>(cls):</h3><ul>
<li>必须有返回值，类的对象</li>
<li>如果不返回，对象不会构建，也就不会运行<strong>init</strong>方法<br>return object.<strong>new</strong>(cls)</li>
<li>与init区别<br>1.new是构造，init是初始化<br>2.new是类方法[可以通过类来调用]，init是普通方法<br>3.先执行new后执行init</li>
</ul>
<h3 id="掷骰子"><a href="#掷骰子" class="headerlink" title="掷骰子"></a>掷骰子</h3><ul>
<li>range()也是包头不包尾</li>
<li>random.randint(1,7)需要引入import random</li>
<li>思路<br>掷骰子游戏可以有多个人来玩，多个骰子在一个骰子钟里抛掷相加得到结果<br>Game与Play是聚合，Play个数可以指定<br>Game与Dices（骰子钟）是组合关系<br>Dices与Dice也是聚合关系，个数可以指定</li>
</ul>
<h3 id="私有化（隐藏）"><a href="#私有化（隐藏）" class="headerlink" title="私有化（隐藏）"></a>私有化（隐藏）</h3><p>属性：__xxx</p>
<p>方法：def __xxx():</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li><p>定义<br>class Animal:<br>class Dog(Animal):<br>在子类后加()，写入父类即可。有些像函数，不可混。</p>
</li>
<li><p>差异<br>子类的<strong>init()</strong>会覆盖掉父类的<strong>init()</strong><br>经测试<strong>new</strong>方法也会覆盖掉父类的<br><strong>new</strong>会覆盖掉<strong>init</strong><br>父类的公有属性，如果父类<strong>init</strong>方法没有调用，也就继承不了，也就是说：属性没有继承super().<strong>init</strong>()可以手动去实现</p>
</li>
<li><p>多继承<br>class C(A,B):<br>就是多继承，继承关系的优先级C&gt;A&gt;B</p>
</li>
<li><p>print(C.<strong>mro</strong>)可以打印继承关系<br>可以所有类看出从object中继承，这一点与Java相同<br>其中的<strong>init</strong>(),<strong>del</strong>()</p>
</li>
<li><p>重写<br>子类与父类的方法名相同就叫重写<br>super().<strong>init</strong>()<br>重写中，可以通过super()调用父类的方法</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3></li>
<li>python是弱类型语言，没有多态<h3 id="类属性（对象属性的区别）与类方法"><a href="#类属性（对象属性的区别）与类方法" class="headerlink" title="类属性（对象属性的区别）与类方法"></a>类属性（对象属性的区别）与类方法</h3></li>
<li>类属性是类对象所拥有的属性，它被类对象的实例所共有，在内存中之后一个副本</li>
<li>就是C++/Java的静态成员变量</li>
<li>定义</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class People(object):</span><br><span class="line">    name = &quot;Tom&quot; #共有类属性</span><br><span class="line">    __age = 12  #私有类属性</span><br><span class="line"></span><br><span class="line">print(People.name)</span><br><span class="line">p = People()</span><br><span class="line">print(p.name)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>对象属性<br>就是对象自己的<br>self.name = name 这种</p>
</li>
<li><p>区别<br>类属性可以被子类继承，对象属性不能直接继承<br>继承仅是继承父类的方法，以及类属性<br>类属性只能通过类来修改：People.name = “ww”<br>  当时有p.name = “zs”定义了一个对象属性name</p>
</li>
<li><p>类方法<br>一定要在类上加一个修饰器（注解）<br>@classmethod<br>def getName(cls):<br>其中cls代表调用这个方法的类<br>类方法可以通过类名来调用People.getName()<br>类方法可以修改类属性     </p>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>@staticmethod<br>静态方法是类方法的特殊一种，属于类，没有默认传递的参数<br>@staticmethod<br>def getAge():</p>
</li>
</ul>
<p>调用与类方法相同：对象与类都可以调用<br>由于没有cls，只能通过类名在修改类属性</p>
<h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><p>1.伪单例：自己写getInstance()静态方法，通过调用此方法来获得对象<br>2.真单例：重写<strong>new</strong>方法，所有的构造的都是单例</p>
<h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><p>这个简单工厂就是用一个factory类的一个类方法，来生成继承关系的不同子类对象。<br><img src="5.工厂方法.png" alt=""></p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from enum import Enum</span><br><span class="line"></span><br><span class="line">class Color(Enum):</span><br><span class="line">   red = 1</span><br><span class="line">   green = 2</span><br><span class="line">   blue = 3</span><br></pre></td></tr></table></figure>
<h2 id="类的数据隐藏"><a href="#类的数据隐藏" class="headerlink" title="类的数据隐藏"></a>类的数据隐藏</h2><p><strong>x双下划线，属性私有，实现方法名字重整：</strong>num，在类dir(t)时，会改变私有对象的名字:_类名<strong>属性名，其实并没有真正的隐藏，只是外部的访问上改了名字<br>_x单下划线，被当作模块导入时，不导入。外边是可以访问的
</strong>xx__:名字空间的魔法属性:<strong>init</strong></p>
<p>self这里不是关键字，第一个代表对象本身，可以用this等来代替</p>
<h3 id="property用法"><a href="#property用法" class="headerlink" title="property用法"></a>property用法</h3><ul>
<li>使用property方法升级getter 与 setter</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Test:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.__money=0</span><br><span class="line"></span><br><span class="line">    def getMoney(self):</span><br><span class="line">        return self.__money</span><br><span class="line"></span><br><span class="line">    def setMoney(self,money)</span><br><span class="line">        self.__money=money</span><br><span class="line"></span><br><span class="line">    money = property(getMoney,setMoney)</span><br><span class="line"></span><br><span class="line">test=Test()</span><br><span class="line">test.money=20</span><br></pre></td></tr></table></figure>
<p>#这种写法就把money变成共有不就好了</p>
<ul>
<li>装饰器写法<br>@property  : getter<br>@money.setter  : setter<br>方法名与属性名的去掉__一致</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Test:</span><br><span class="line">   def __init__(self):</span><br><span class="line">        self.__money=0</span><br><span class="line">   </span><br><span class="line">   @property  #getter</span><br><span class="line">   def money(self):</span><br><span class="line">       return self.__money</span><br><span class="line"></span><br><span class="line">   @money.setter</span><br><span class="line">   def money(this,money)</span><br><span class="line">       this.__money = money</span><br><span class="line"></span><br><span class="line">t = Test()</span><br><span class="line">t.money = 20</span><br><span class="line">print(r.money)</span><br></pre></td></tr></table></figure>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><p>try..except，except就是catch<br>Exception/NameError/FileNotFoundError/ZeroDivisionError<br>except可以用元组来实现多个异常<br>as ex，ex是异常变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">  print(a)</span><br><span class="line">except (NameError/ZeroDivisionError) as ex:</span><br><span class="line">  print(ex)</span><br><span class="line">else:</span><br><span class="line">  print(&quot;没有异常&quot;)</span><br><span class="line">finally:</span><br><span class="line">  print(&quot;无论有没有都能被执行&quot;)</span><br></pre></td></tr></table></figure>
<p>抛异常：raise exception</p>
<p>异常嵌套，异常传递</p>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>class PasswordException(Exception):</p>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><ul>
<li>模块相当于jar包</li>
<li>import 即可<h2 id="模块与包"><a href="#模块与包" class="headerlink" title="模块与包"></a>模块与包</h2>相当于jar包<h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3></li>
<li><p>import 模块名<br>模块名.函数名()</p>
<p>import random<br>random.randint(1,5)</p>
</li>
<li><p>from 模块名 import 函数名(变量，类等)<br>from random import randint<br>randint(1,5)</p>
</li>
<li><p>from 模块 import *【几乎不用】<br>一个模块全部内容都导入</p>
</li>
<li><p>as 导入时，给模块重新命名<br>import random as rdm<br>rdm.randint(1,5)<br>random__file__</p>
</li>
<li><p>注意<br>若导入有相同的函数名，后导入的会覆盖先导入的</p>
</li>
</ul>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><strong>name</strong>:<strong>main</strong>()<br>if(<strong>name</strong>==”<strong>main</strong>“):#python解释器主动执行该模块代码为了测试<br>    print(isnull(“”))</p>
<p><strong>all</strong>：后边加列表，用于写出模块中需要导出的方法/变量/类，但这种方式只有from ..import *时可用，在python3中，使用较少<br><strong>all</strong>=[“isnull”]</p>
<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>本质上就是一个目录，把模块放入目录中，就可称为一个包<br>优先到当前目录，然后是python系统目录<br>  import 包(文件夹).模块(文件)<br>  from 包 import 模块</p>
<p>python3中目录就是一个包<br>python2中需要有<strong>init</strong>.py文件,即使是空文件也可以<br>如果在<strong>init</strong>.py中增加from . import module1，那么在其他中可以直接import包名</p>
<p>这里的import类似于c/c++的include</p>
<h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>把自己写的模块，发布到python的系统目录下</p>
<ul>
<li>setup.py<br>在包同级目录下增加setup.py文件，并写</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from distutils.core import setup</span><br><span class="line">setup(name=&quot;my_packet&quot;,version=&quot;1.0&quot;,description=&quot;描述&quot;,author=&quot;作者&quot;,py_modules=[&quot;my_packet.module1&quot;])</span><br></pre></td></tr></table></figure>
<ul>
<li>python3 setup.py build</li>
<li>python3 setup.py sdist<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3></li>
<li>找到模块安装包</li>
<li>解压</li>
<li>进入文件夹</li>
<li>执行python3 setup.py install即可<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h3>import sys<br>sys.argv<br>参数第一个是.py本身<br>sys.argv[1::]<h3 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h3>其实就是创建列表/字典的<br>a=[i for i in range(1,10)]<br>a=[i**i for i in range(1,10)]</li>
</ul>
<p>b=[x for x in range(1,3) for y in range(0,2)]<br>[1,1,2,2] 循环的嵌套1循环2次，2也也是2次</p>
<p>c=[x for x in range(1,101) if x%2==1]</p>
<h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><p><img src="6.习题.png" alt=""><br><img src="6.习题解释.png" alt=""><br>其实即使函数的默认参数只会创建一次,因为它懒</p>
<h2 id="坦克大战"><a href="#坦克大战" class="headerlink" title="坦克大战"></a>坦克大战</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>pip install pygame</p>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ol>
<li>游戏主界面</li>
<li>坦克<ul>
<li>敌方</li>
<li>我方</li>
</ul>
</li>
<li>炮弹</li>
<li>隔离墙</li>
<li>爆炸</li>
</ol>
<p>这些类都是sprite<br>pygame sprite 是pygame中所有类的基类<br>爆炸效果：由小到大切换图片</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol>
<li><p>如何完成爆炸的检索？</p>
<ul>
<li>第一种方式是炮弹运行检索所有坦克</li>
<li>自识别，炮弹遇到障碍物就有事件出发进行处理</li>
</ul>
</li>
<li><p>python的继承<br>python的继承，在父类里会写很多的东西，而在子类中只是写与父类不同的东西。</p>
</li>
<li><p>如果用类变量<br>那是否可以增减</p>
</li>
<li><p>删除<br>python在删除del某个变量后，变量就没有了，不是为None了</p>
</li>
<li><p>引用问题：<br>之间的阻隔物，是由一个图片在不同位置显示而造成的连续，但这对阻隔没法完成，于是新建了Iosolations类使创建一个一个的Wall类，并维护这些类的显示，访问（是否相遇）<br>这时候出现一个问题，创建的这些Wall类，竟然只显示在最后一个位置上<br>通过分析，位置没错，原因在于Python的对象都是引用（可改变位置的引用），这几个Wall类对象，都指向了一个rect位置，而这个位置经过修改赋值给了另外的Wall类，结果造成了都在最后一个位置上<br>修改：每个Wall对象，内部构件自己的rect，通过传入left,top来修改这些rect的显示位置。<br>试过深拷贝，但不好使，原因：深拷贝对容器之外的普通对象失效。</p>
</li>
</ol>
<ol start="6">
<li><p>墙黏坦克问题<br>解决好上个问题，在tank移动的时候，判断是否与墙相遇，如果相遇，则使其不能移动，这样就可以造成阻隔。<br>但这样造成另外一个问题，墙与坦克相遇后，就是不能移动了，像是墙把坦克给黏住了。解决这个问题，就把坦克移动增加了一个lastDirection，发现也不好使，因为通过不断变化方向还是可以移动进入墙。</p>
<p>修改：判断走完这一步，是否相遇，如果相遇，就补偿回来。这样既可。</p>
</li>
<li><p>坦克创建在墙里边的问题<br>坦克建立后，判断与墙是否相遇，如果相遇，重新给建立left坐标</p>
</li>
</ol>
<h1 id="python进阶"><a href="#python进阶" class="headerlink" title="python进阶"></a>python进阶</h1><h2 id="模块与导入模块的路径设置"><a href="#模块与导入模块的路径设置" class="headerlink" title="模块与导入模块的路径设置"></a>模块与导入模块的路径设置</h2><ul>
<li><p>查看模块搜索路径<br>import sys<br>sys.path<br>所谓模块的搜索路径，指的是path执行import时，搜索的路径，这点有点像Windows的path环境变量，以上函数是查看现有的路径</p>
</li>
<li><p>添加搜索路径<br>sys.path.append(‘/home/xxx文件夹’)  #加在最后<br>sys.path.insert(‘/home/xxx文件夹’)  #加在首部<br>这两个函数是添加新的路径</p>
</li>
<li><p>重新导入模块<br>from imp import *<br>reload(模块名)<br>这块重新加载</p>
</li>
<li><p>查看安装的模块</p>
<ol>
<li>在交互解释器中使用help(“modules”)</li>
<li>import sys ; sys.modules.keys()这个会把具体的包中模块也打印出来<br>这个主要是这个help命令，可以模块名<br>help(“pygame.Rect”)</li>
</ol>
<p>dir()<br>如dir(sys)，其实就是列出给出对象的属性，这个些属性有对象的<strong>dir</strong>()提供<br>如果是module对象，只有module的属性<br>如果是类对象，会列出其本身的属性，以及基类的属性</p>
<h3 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h3><p>dir能列出模块中的类、对象等属性，对于自己的代码，需要先通过sys.path.insert将模块的目录导入，然后再调用dir(模块名)来查看 </p>
</li>
</ul>
<h3 id="循环导入"><a href="#循环导入" class="headerlink" title="循环导入"></a>循环导入</h3><ul>
<li>两个模块互相的导入</li>
<li><p>怎样避免循环导入</p>
</li>
<li><p>类似与#ifdef __DEFINE_H_H吗？</p>
</li>
</ul>
<h2 id="深拷贝与浅拷贝-重点"><a href="#深拷贝与浅拷贝-重点" class="headerlink" title="深拷贝与浅拷贝[重点]"></a>深拷贝与浅拷贝[重点]</h2><p>浅拷贝这里就是拷贝了引用,深拷贝就是对一个对象所有层次的拷贝。其实与C++的深浅拷贝概念相同<br>就是deepcopy会递归的copy，而浅拷贝不会<br>import copy<br>  copy.deepcopy<br>  copy.copy</p>
<ul>
<li><p>实例：<br>a = [1,2,3]<br>b = [4,5]<br>c = [a,b]<br>d = c</p>
<p>import copy<br>e = copy.deepcopy(c)<br>f = copy.copy(c)<br><img src="8.深拷贝.png" alt=""></p>
<p><img src="9.浅拷贝.png" alt=""></p>
</li>
</ul>
<p>浅拷贝对不可变类型和可变类型的copy不同（元组与列表）<br>  a=(1,2,3)<br>  b = copy.copy(a)<br>  a is b #True<br>  对于不可变类型的copy，其实就是a=b，引用指向相同的地址</p>
<h2 id="【新】生成器，yield"><a href="#【新】生成器，yield" class="headerlink" title="【新】生成器，yield"></a>【新】生成器，yield</h2><ul>
<li>初识(列表生成器)<br>g=(x for x in range(5))<br>g.next(),没有更多元素时,抛出StopIteration的异常<br>生成器只能用一次<br>for i in g:<pre><code>print(i)
</code></pre></li>
<li><p>第二种方法:yield<br>def fib(times):<br>  n = 0<br>  a,b=0,1<br>  while n&lt;times:</p>
<pre><code>yield b   #yied投降,运行在这里就停一下,并且抛出后边的内容,调用一次next执行一次
a,b=b,a+b
n+=1
</code></pre><p>  return ‘done’</p>
<p> g = fit(5)</p>
<p> #输出<br> next(g)<br> for x in g:</p>
</li>
<li><p>生成器方法:<strong>next</strong>()<br>g = fib(5)<br>g.<strong>next</strong>()</p>
</li>
<li><p>生成器方法:send()<br>g = fib(5)<br>g.<strong>next</strong>()  / g.send(None)<br>g.send(“hehe”)  </p>
<p>send给生成器传递一个参数<br>在生成器内部:<br>temp = yield b  #生成器抛出b,传递进的”哈哈”赋值给temp</p>
</li>
</ul>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="可迭代对象：iterator"><a href="#可迭代对象：iterator" class="headerlink" title="可迭代对象：iterator"></a>可迭代对象：iterator</h3><p>from collection import Iterable<br>isinstance([],Iterable)<br>集合对象<br>生成器对象</p>
<h3 id="迭代器：可以被next对象调用，并不断返回下一个对象"><a href="#迭代器：可以被next对象调用，并不断返回下一个对象" class="headerlink" title="迭代器：可以被next对象调用，并不断返回下一个对象"></a>迭代器：可以被next对象调用，并不断返回下一个对象</h3><p>l = [1,2,3]<br>it = iter(l)<br>next(it)  #集合本身不是迭代器<br>from collector imort Iterator<br>isinstance(it,Iterator)</p>
<h2 id="【新】闭包"><a href="#【新】闭包" class="headerlink" title="【新】闭包"></a>【新】闭包</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>函数内部可以再定义内部函数,内部函数对外部函数的属性可以直接引用,则称内部函数为闭包<br>2个条件:嵌套函数定义,内部函数引用外部函数变量<br>只调用内部函数时,被引用的外部函数变量,会绑定到闭包中,一定程度上延长了生命周期<br>其实可以理解为,构成闭包时,外部函数的变量声明周期到了延长到了内部</p>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><h4 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def fun1():</span><br><span class="line">    def fun3():</span><br><span class="line">        print(&quot;fun3&quot;)</span><br><span class="line">    return fun3</span><br><span class="line">fun1()</span><br></pre></td></tr></table></figure>
<p>返回的是一个函数对象</p>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def outter(num):</span><br><span class="line">    def inner(num_in):</span><br><span class="line">        print(&quot;num_in is %d&quot;%num_in)</span><br><span class="line">        return num_in+num</span><br><span class="line">    return inner</span><br><span class="line">fun = outer(20)</span><br><span class="line">fun(10)</span><br></pre></td></tr></table></figure>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="一元一次方程-y-ax-b"><a href="#一元一次方程-y-ax-b" class="headerlink" title="一元一次方程:y = ax+b"></a>一元一次方程:y = ax+b</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def line_conf(a,b):</span><br><span class="line">    def line(x):</span><br><span class="line">       return a*x + b</span><br><span class="line">    return line</span><br><span class="line">line1 = line_conf(1,1)</span><br><span class="line">line2 = line_conf(4,5)</span><br><span class="line"></span><br><span class="line">print(line1(5))</span><br><span class="line">print(line2(5))</span><br></pre></td></tr></table></figure>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>装饰器其实就是一个闭包,把一个函数当作参数,其中对函数进行包装,返回一个替代版新函数,其实与设计语言中了一样,也类似AOP<br>2个特性:<br>   一个是把被装饰的函数替代为其他函数<br>   而是可以在加载模块时立即执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def w1(func):</span><br><span class="line">   def inner():</span><br><span class="line">       #验证1</span><br><span class="line">       #验证2</span><br><span class="line">       func()</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">@w1</span><br><span class="line">def f1()</span><br><span class="line">   print(&quot;f1&quot;)</span><br></pre></td></tr></table></figure>
<p>其实就是AOP</p>
<p>装饰器内部函数的参与与被装饰的参数相同<br>不定长参数：可以将内部函数的参数设置为不定长参数，(<em>args,**kwargs)
          </em>args表示任何多个无名参数，它是一个tuple；<strong>kwargs表示关键字参数，它是一个dict。并且同时使用*args和</strong>kwargs时，必须*args参数列要在**kwargs前<br>函数可以认为都有返回值，没有return时，return的是None</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li>引入日志：开放封闭原则，就是对增加开放，对修改封闭</li>
<li>函数执行时间统计</li>
<li>执行函数前预备处理</li>
<li>执行函数后清理功能</li>
<li>全校校验</li>
<li>缓存<h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def makeBold(fn):</span><br><span class="line">   def wrapped():</span><br><span class="line">      return &quot;&lt;b&gt;&quot; + fn() + &quot;&lt;/b&gt;&quot;</span><br><span class="line"></span><br><span class="line">@makeBold</span><br><span class="line">def test1():</span><br><span class="line">   return &quot;hello world&quot;</span><br><span class="line"></span><br><span class="line">print(test1())</span><br></pre></td></tr></table></figure>
<h3 id="通用装饰器"><a href="#通用装饰器" class="headerlink" title="通用装饰器"></a>通用装饰器</h3><ul>
<li>不定长参数</li>
<li>带返回值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from time import ctime</span><br><span class="line">def doca(fun):</span><br><span class="line">   def wrapper(*args,**kwargs):</span><br><span class="line">      print(&quot;%s called at %s&quot;%(fun.__name__,ctime()))</span><br><span class="line">      ret = fun()</span><br><span class="line">      return ret</span><br><span class="line">   return wrapper</span><br><span class="line"></span><br><span class="line">@doca</span><br><span class="line">def foo():</span><br><span class="line">  print(&quot;i am foo&quot;)</span><br><span class="line"></span><br><span class="line">@doca</span><br><span class="line">def gegInfo():</span><br><span class="line">   return &quot;--hehe--&quot;</span><br><span class="line"></span><br><span class="line">@doca</span><br><span class="line">def sum(a,b):</span><br><span class="line">  return a+b</span><br></pre></td></tr></table></figure>
<h2 id="【特】动态语言特性"><a href="#【特】动态语言特性" class="headerlink" title="【特】动态语言特性"></a>【特】动态语言特性</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>动态语言：在运行过程中，可以修改代码,大多数脚本语言：python,JavaScript,PHP,Ruby<br>静态语言：编译时已经确定好的代码，运行过程中不能修改,C,C++,Java</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li><p>为对象动态添加属性</p>
<p>class Person(object):</p>
<pre><code>def __init__(self,name=None,age=None)
    self.name = name
    self.age = age
</code></pre><p>p = Person(“小明”,”12”)<br>p.sex = “male”   #这里动态为p定义了属性sex<br>print(p.sex)<br>dir(p)<br>这里动态添加的属性，只是对p这个对象添加的，其他的Person类的对象是没有的<br>这里可以动态的添加类的动态属性，这样所有的对象都会有且一致。</p>
</li>
<li><p>为对象动态添加实例方法：<br>def showInfo(self):</p>
<pre><code>print(self.name)
print(self.age)
</code></pre><p>import types<br>p.showInfo = types.MethodType(showInfo, p)#这里就是用p作为self来传递给showInfo，做一个装饰器即可。<br>p.showInfo()</p>
</li>
<li><p>为类动态添加类方法<br>@classmethod<br> def fun1(cls):</p>
<pre><code>print(&quot;class Method&quot;)
</code></pre><p>Person.fun1 = fun1<br>p.fun1()</p>
</li>
<li><p>为类添加静态方法<br>@staticmethod<br>def fun2(a,b):<br>   return a+b<br>Person.fun2 = fun2<br>print(p.fun2(1+2))</p>
</li>
</ul>
<h3 id="限制修改对象的属性"><a href="#限制修改对象的属性" class="headerlink" title="限制修改对象的属性"></a>限制修改对象的属性</h3><p>class Person(object):<br>  <strong>slots</strong>=(“name”,”age”)<br>这样就会限制对象往里添加属性，只限于name与age</p>
<h2 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h2><h3 id="前情"><a href="#前情" class="headerlink" title="前情"></a>前情</h3><h4 id="函数对象-与-类"><a href="#函数对象-与-类" class="headerlink" title="函数对象 与 类"></a>函数对象 与 类</h4><p>装饰器函数就是一个接口约束，它必须接受一个callable对象作为参数，然后返回一个callable对象<br>一般callable对象都是函数，但也有例外，只要某个类重写了<strong>call</strong>()方法那么就可以调用了</p>
<h4 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h4><p>class Test(object):<br>   def <strong>call</strong>(self):<br>      print(“call me”)</p>
<p> t = Test()<br> t()</p>
<h3 id="类装饰器-1"><a href="#类装饰器-1" class="headerlink" title="类装饰器"></a>类装饰器</h3><p> class Test(object):<br>    def <strong>init</strong>(self, func):<br>        print(“初始化”)<br>        print(“func name is %s”%func__name__)<br>        self.__func = func</p>
<p>   def <strong>call</strong>(self):<br>        print(“装饰器中的功能”)<br>        self.__func()</p>
<p>  #这里会生成一个Test对象，调用<strong>init</strong>方法，并且将test()作为参数产地给init<br>  @Test<br>  def test():<br>     print(“—test—“)<br>  test()           #调用时，其实是调用Test对象的<strong>call</strong></p>
<h2 id="【特】内存管理"><a href="#【特】内存管理" class="headerlink" title="【特】内存管理"></a>【特】内存管理</h2><h3 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h3><p>Python为了优化速度，<br>小整数：使用了[-5,257)对象池，避免为整数频繁申请和销毁内存。[257,无穷)都是新建对象<br>单个字符：也使用对象池，常驻内存<br>一个单词的字符串：也是在对象池中。采用引用计数共用，引用计数为0则销毁。</p>
<h4 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h4><p> c = ‘a’<br> b = ‘a’<br> b is a #True</p>
<p> s1 = “hello”<br> s2 = “hello”<br> s1 = s2 #True</p>
<p> s3 = “hello world”<br> s4 = “hello world”<br> s3 = s4 #False</p>
<h3 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>为新生成的对象分配内存，识别那些垃圾对象，从垃圾对象那里回收内存<br>python采用的是引用计数机制为主，标记-清除、隔代收集两种机制为辅的策略</p>
<p>python里每个东西都是对象，他们的核心是一个结构体：PyObject</p>
<p>typedef struct_object{<br>    int obj_refcnt;<br>    struct_typeobject *ob_type;<br>}</p>
<p>#define Py_INCREE(op) ((op)-&gt;ob_refcnt++)</p>
<p>#define Py_DECREE(op) \<br>    if(–(op)-&gt;ob_refcnt!=0) \<br>      ;\<br>    else \<br>      _Py_Dealloc((PyObject *)(op))</p>
<h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><p>实时，一旦没有引用，内存就直接释放，不用其他机制的等待特定时机</p>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>多占点内存<br>有可能出现循环引用：a中有b，b中有a.这是用的是隔代收集来收集</p>
<h5 id="导致-1的"><a href="#导致-1的" class="headerlink" title="导致+1的"></a>导致+1的</h5><ul>
<li>对象被创建：a=23</li>
<li>对象被引用：b=a</li>
<li>对象被传参：func(a)</li>
<li>对象作为一个元素，存在容器里:list=[a,a]<h5 id="导致-1的-1"><a href="#导致-1的-1" class="headerlink" title="导致-1的"></a>导致-1的</h5></li>
<li>对象别名被显示销毁，del a</li>
<li>对象别名被赋予新的对象 a = 24</li>
<li>一个对象离开它的作用域，如f函数执行完毕，func函数的局部变量都会-1</li>
<li>对象所在的容器被销毁，或者从容器中删除。<h5 id="查看引用计数"><a href="#查看引用计数" class="headerlink" title="查看引用计数"></a>查看引用计数</h5>import sys<br>a = “hello world”<br>sys.getrefcount(a)<br>此时最少打印2，因为a创建+1，传参+1</li>
</ul>
<h5 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h5><ol>
<li>调用gc.collect()</li>
<li>当gc模块的计数器达到阀值（有3个）的时候</li>
<li>程序退出</li>
</ol>
<h5 id="gc模块"><a href="#gc模块" class="headerlink" title="gc模块"></a>gc模块</h5><p>gc.garbage列表<br>gc.get_threshold()获取gc模块中自动执行垃圾回收的频率<br>gc._threshold(thrshold0[,th])<br>gc.get_count()，隔代收集中每代的个数<br>gc.collect([generation])隔代收集的0代表直线查第一代，1代表检查1.2代<br>gc模块唯一处理不了的是循环引用的类都有<strong>del</strong>方法，所以项目中避免定义<strong>del</strong>方法<br>gc.disable()手动关掉垃圾回收</p>
<h4 id="隔代收集"><a href="#隔代收集" class="headerlink" title="隔代收集"></a>隔代收集</h4><h2 id="内建"><a href="#内建" class="headerlink" title="内建"></a>内建</h2><h3 id="方法方法"><a href="#方法方法" class="headerlink" title="方法方法"></a>方法方法</h3><p><img src="10.内建属性.png" alt=""></p>
<ul>
<li><strong>new</strong>：构造函数</li>
<li><strong>init</strong>：初始化函数</li>
<li><strong>clas</strong>：实例所在类</li>
<li><strong>str</strong>：类似与Java的toString</li>
<li><strong>repr</strong>：</li>
<li><strong>del</strong>：析构</li>
<li><strong>dict</strong>:实例地定义属性</li>
<li><strong>doc</strong>：类文档，子类不继承</li>
<li><strong>getattibute</strong>:属性访问拦截器</li>
<li><p><strong>bases</strong>:类的所有父类构成元素</p>
</li>
<li><p><strong>getattribute</strong>属性访问拦截器<br>正常使用<br>class School(object):<br>  def <strong>init</strong>(self,s1):</p>
<pre><code>self.subject1 = s1
self.subject2 = &apos;c++&apos;
</code></pre><p>  def <strong>getattribute</strong>(self, obj):</p>
<pre><code>if obj == &apos;subject1&apos;:
    print(&quot;log subject1&quot;)
    return &apos;redirect python&apos;
else:   #注意else一定要有，否则其他属性就是None了
    return object.__getattribute__(self,ojb)
</code></pre><p>s = School(‘Pyhont’)<br>print(s.subject1)<br>print(s.subject2)</p>
<p>坑<br>class Person(object):<br>  def <strong>getattribute</strong>(self,obj):</p>
<pre><code>print(&quot;---test---&quot;)
if obj.startwith(&quot;a&quot;):
   return &quot;haha&quot;
else:
   return self.test
</code></pre><p>  def test(self):</p>
<pre><code>print(&quot;heihei&quot;)
</code></pre><p>函数执行内存都在栈上<br> t=Person()<br> t.a<br> t.b #会让程序死掉，因为会递归调用<strong>getattribute</strong>所有就崩掉了</p>
<h3 id="内建方法"><a href="#内建方法" class="headerlink" title="内建方法"></a>内建方法</h3></li>
<li>dir<br>dir(<strong>buildins</strong>)</li>
<li>range(1,10,2)</li>
<li><p>map(function, sequence[,sequence,…])根据提供的函数，对指定序列做映射<br>map(lambda x:x*x,[1,2,3])：结果为[1,4,9],python2直接是序列，python3是可迭代的对象<br>map(lamdbda x,y:x+y,[1,2,3],[4,5,6]) ：结果为[5,7,9]</p>
<p>def f1(x,y):<br>   return (x,y)<br>l1 = [1,2,3]<br>l2 = [‘a’,’b’,’c’]<br>l3 = map(f1,l1,l2)<br>print(list(l3))</p>
</li>
<li><p>filter(function or None,sequence)对指定序列执行过滤操作<br>filter(lambda x:x%2,[1,2,3,4])<br>filter(None,”hello”)</p>
</li>
<li><p>reduce(function,sequence[,initial])对参数序列中元素进行累积<br>python3中，reduce从全局名字空间中移除，放在functools模块里<br>from functools import reduce<br>reduce(lambda x,y:x+y, [1,2,3,4]) #10<br>reduce(lambda x,y:x+y, [1,2,3,4],5)  #15<br>reduce(lambda x,y:x+y, [‘aa’,’bb’,’cc’],’dd’)  #’ddaabbcc’</p>
</li>
</ul>
<h3 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h3><ul>
<li>支持的运算：<br>|:union：并集<br>&amp;：intersection:交集<br>-:difference:差集<br>^:sysmmetric_difference：对称差集，x^y，在x或y中，但不会同时出现在二者之中</li>
</ul>
<h2 id="常用模块"><a href="#常用模块" class="headerlink" title="常用模块"></a>常用模块</h2><h3 id="functools"><a href="#functools" class="headerlink" title="functools"></a>functools</h3><ul>
<li><p>partial：偏函数<br>把一个函数的某些参数设置默认参数，返回一个新的采纳数，调用这个函数会更简单。<br>import functools<br>def showarg(*args,**kwagrs):<br>   print(args)<br>   print(kwargs)</p>
<p>p1=functools.partial(showarg,1,2,3)<br>p1()  #1,2,3 #{}<br>p1(4,5,6)  #1,2,3,4,5,6 #{}<br>p1(a=’python’, b=’c++’)  #1,2,3 #{“a”:”python”,”b”:”c++”}</p>
<p>p2=functools.partial(showarg,a=3,b=’linux’)<br>p2()<br>p2(1,2)<br>p2(a=”ptyon”,b=”c++”)#这个会将默认值改掉</p>
</li>
<li><p>wraps：包装函数<br>使用装饰器后，被装饰的函数已经是另外一个函数了，wraps的装饰器可以消除这样的副作用</p>
<p>import functools<br>def note(func):<br>   @functools.wraps(func)<br>   def wrapper():</p>
<pre><code>print(&quot;note something&quot;)
return func()
</code></pre><p>   return wrapper</p>
<p>@note<br>def test():<br>   print(“i am test”)</p>
<p>test()<br>print(test.<strong>doc</strong>) 如果不加，则返回的是wrapper(), 反之为test<br>其实就是在新家的这个装饰器内部，修改了wrapper的<strong>doc</strong></p>
<h3 id="常用标准模块"><a href="#常用标准模块" class="headerlink" title="常用标准模块"></a>常用标准模块</h3><p><img src="11.常用标准模块.png" alt=""></p>
</li>
</ul>
<h3 id="常用三方模块"><a href="#常用三方模块" class="headerlink" title="常用三方模块"></a>常用三方模块</h3><p> <img src="12.常用三方模块.png" alt=""></p>
<h2 id="pdb调试"><a href="#pdb调试" class="headerlink" title="pdb调试"></a>pdb调试</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><ul>
<li><p>执行时调试<br>python -m pdb some.py<br>只用这种就行<br>-m 指的是module， 像脚本一样运行模块</p>
</li>
<li><p>交互调试<br>import pdb<br>pdb.run(‘testfun(args)’)</p>
</li>
<li><p>程序下断点<br>import pdb<br>pdb.set_trace()<br>运行到这之后停住，使用与gdb类似，p打印，n单步，s进入函数，c继续执行，<br><img src="13.pdb调试.png" alt=""></p>
</li>
</ul>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="fork方法"><a href="#fork方法" class="headerlink" title="fork方法"></a>fork方法</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>fork调用一次返回2次，父进程返回子进程id，子进程返回0<br>一个父进程可以fork出很多子进程，所以父进程要记下每个子进程的id，而子进程只需要调用getppid()就可以拿到父进程的id</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>import os<br>imprt time<br>pid = os.fork()<br>if pid&lt;0:<br>   time.sleep(2)<br>   print(“fork调用失败”)<br>elif pid==0:<br>   time.sleep(1)<br>   print(“我是子进程(%s),我的父进程是(%s)”%(os.getpid(), os.getppid()))<br>else:<br>   print(“我是父进程(%s),我的子进程是(%s)”%(os.getpid(), pid))</p>
<p>print(“父子进程都可以执行这里的代码”)</p>
<h4 id="多个fork"><a href="#多个fork" class="headerlink" title="多个fork"></a>多个fork</h4><p>这里创建了4个进程</p>
<p>import os<br>pid = os.fork()<br>if pid==0:<br>   print(“子进程11”)<br>else:<br>   print(父进程11)</p>
<p>pid = os.fork()<br>if pid == 0:<br>   print(“子进程22”)<br>else:<br>   print(“父进程22”)</p>
<h4 id="复习-1"><a href="#复习-1" class="headerlink" title="复习"></a>复习</h4><p>fork返回值是子进程的pid,如果本身是子进程,返回值就是0</p>
<h3 id="通过Process对象创建子进程"><a href="#通过Process对象创建子进程" class="headerlink" title="通过Process对象创建子进程"></a>通过Process对象创建子进程</h3><h4 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h4><p>from multiprocessing import Process<br>import os</p>
<p>def run_proc(name):  #子进程只执行这个函数<br>   print(“子进程运行中，name=%s,pid=%d”%(name,os.getpid()))</p>
<p>if <strong>name</strong> == “<strong>main</strong>“<br>   print(“父进程%d”%s.getpid())<br>   p = Process(target=run_proc,args=(‘test’,))<br>   print(“子进程将要执行”)<br>   p.start()<br>   p.join()  #加这句话，父进程等待子进程结束之后再执行<br>   print(“子进程执行结束”)</p>
<h4 id="Process常用方法"><a href="#Process常用方法" class="headerlink" title="Process常用方法"></a>Process常用方法</h4><p>is_alive:判断进程是否执行<br>join([timeout])是否等待进程实例执行结束，或等待多少秒<br>start(),启动<br>run()，没有制定target时执行<br>terminat()，不管任务是否完成，终止任务，一般父进程来终止子进程</p>
<h4 id="Process常用属性"><a href="#Process常用属性" class="headerlink" title="Process常用属性"></a>Process常用属性</h4><p>name:当前进程实例别名，默认为Process-N<br>pid,当前进程pid</p>
<h3 id="通过Prcess子类创建子进程"><a href="#通过Prcess子类创建子进程" class="headerlink" title="通过Prcess子类创建子进程"></a>通过Prcess子类创建子进程</h3><h4 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h4><p>from multiprocessing import Process<br>import time<br>import os</p>
<p>class ProcessSubClass(Process):<br>   def <strong>init</strong>(self,interval):<br>     super().<strong>init</strong>()<br>     self,interval = interval</p>
<p>   #重写父类run<br>   def run(self):<br>       t_start= time.time()<br>       time.sleep(self.interval)<br>       t_end = tim.time()<br>       print(%s执行结束，耗时%d%(os.getpid(),t_end-t_start))</p>
<p> if <strong>name</strong>==”<strong>main</strong>“:<br>   print(“主进程执行开始”)<br>   p = ProcessSubClass(2)<br>   p.start()<br>   p.join()<br>   print(“主进程执行结束”)</p>
<h3 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h3><p>multiprocessing模块提供的Pool方法<br>如果池已经满了，只能等待，如果没有满，并且有空闲的，则去空闲的，反之，创建一个新进程。</p>
<h4 id="实例-8"><a href="#实例-8" class="headerlink" title="实例"></a>实例</h4><p>from multiprocessing import Pool<br>import os,time,random</p>
<p>def worker(msg):<br>   t_start = time.time()<br>   print(“子进程%d,%d”,%(os.getpid(),msg))<br>   time.sleep(random.randint(1,3)*2)<br>   t_stop = time.time()<br>   print(“执行完毕，用时:%d”%(t_stop-t_start))</p>
<p>#创建进程池<br>pool = Pool(3)</p>
<p>for i in range(0,10):</p>
<p>   #从进程池申请进程，传参为函数名、参数元组</p>
<p>   #apply_async是异步申请，apply是同步。异步同时请求3个，然后同时执行；同步一个一个请求，上一个进程退出才能执行下一个<br>   pool.apply_async(worker,(i,))</p>
<p>#关闭进程池，close之后再写join，进程池中的进程已经是start状态，所以不需要再start了<br>pool.close()<br>pool.join()</p>
<h4 id="multiprocessing-Pool函数解析"><a href="#multiprocessing-Pool函数解析" class="headerlink" title="multiprocessing.Pool函数解析"></a>multiprocessing.Pool函数解析</h4><ul>
<li>apply_async(func[,args[,kwagrs]]):</li>
<li>apply</li>
<li>close():进程池不再接受新的任务，已用的进程慢慢关闭</li>
<li>terminate()：不管任务是否完成，立即终止</li>
<li>join()：与Process相同</li>
</ul>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><h4 id="进程之间"><a href="#进程之间" class="headerlink" title="进程之间"></a>进程之间</h4><p>from multiProcess import Process<br>from multiProcess import Queue</p>
<p>def writer(q):<br>   for item in “ABCDE”<br>       print(“正在往消息队列中写入%s”%item)<br>       q.put(item)<br>       time.sleep(1)</p>
<p>def reader(q):<br>   while True:<br>   if not q.empty():<br>      item = q.get()<br>      print(“从消息队列中读出%s”%item)<br>      time.sleep(random.random())<br>   else:<br>      break</p>
<p>q = Queue()<br>pw = Process(target=writer,args=(q,))<br>pw.start()<br>pw.join()</p>
<p>pr = Process(target=reader,args=(q,))<br>pr.start()<br>pr.join()</p>
<h4 id="进程池-1"><a href="#进程池-1" class="headerlink" title="进程池"></a>进程池</h4><p>from multiProcess import Pool,Manager<br>import time,random</p>
<p>def writer(q):<br>   for item in “ABCDE”<br>       print(“正在往消息队列中写入%s”%item)<br>       q.put(item)<br>       time.sleep(1)</p>
<p>def reader(q):<br>   while True:<br>   if not q.empty():<br>      item = q.get()<br>      print(“从消息队列中读出%s”%item)<br>      time.sleep(random.random())<br>   else:<br>      break</p>
<p>q = Manager().Queue()  #进程池中，只能使用Manager创建的消息队列<br>pool = Pool(3)<br>Pool.apply(writer,(q,))  #执行结束之后，再执行下一个进程<br>Pool.apply(reader,(q,))</p>
<p>Pool.close()<br>Pool.join()</p>
<h3 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h3><p>python的进程一部分继承了linux轻进程的特点</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h3><p>进程是作为资源分配的单位<br>调度和执行的单位</p>
<p>python的thread模块以及threading模块<br>threading模块对thread做了一些包装</p>
<h3 id="实例-9"><a href="#实例-9" class="headerlink" title="实例"></a>实例</h3><p>import threading<br>import time</p>
<p>def fun(num):<br>    print(“线程%d执行”%num)<br>    time.sleep(2)</p>
<p>for i in range(5):<br>    t = threading.Thread(target=fun,args=(i+1,))<br>    t.start()</p>
<h3 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h3><ul>
<li>threading.enumerate():当前线程数量</li>
</ul>
<h3 id="线程创建方式"><a href="#线程创建方式" class="headerlink" title="线程创建方式"></a>线程创建方式</h3><ul>
<li>threading.Tread的对象</li>
<li><p>子类化thread.Tread，实现run方法<br>import threading,time<br>class MyThread(threading.Thread):</p>
<pre><code>def run(self):
        for i in range(5):
                time.sleep(1)
                #这里self.name是父类的属性，默认是Thread-N
                print(&quot;I am &quot;+ self.name+&quot;@&quot;+str(i))
</code></pre><p>if <strong>name</strong>==”<strong>main</strong>“:</p>
<pre><code>t = MyThread()
t.start()
</code></pre><p>传参可以通过重新定义<strong>init</strong>方法来传参</p>
</li>
</ul>
<h3 id="线程的几种状态"><a href="#线程的几种状态" class="headerlink" title="线程的几种状态"></a>线程的几种状态</h3><p><img src="14.线程的几种状态.png" alt=""><br>就绪，运行，阻塞状态<br>就绪状态到运行状态是需要系统的调用，才进入运行状态，运行状态受阻塞的事件，进入阻塞状态<br>运行状态下的时间片用完，进入就绪状态</p>
<h3 id="线程之间通信"><a href="#线程之间通信" class="headerlink" title="线程之间通信"></a>线程之间通信</h3><h4 id="共享全局变量"><a href="#共享全局变量" class="headerlink" title="共享全局变量"></a>共享全局变量</h4><h4 id="传参方式"><a href="#传参方式" class="headerlink" title="传参方式"></a>传参方式</h4><p>将全局变量作为参数传递给线程<br>w1 = threading.Tread(target=worker1,args=(numlist,))<br>这里的传参方式，直接调用函数传参需要注意的事项相同，对于可不变类型与不可变类型需要注意。对于可变参数，传递的是引用。不可变参数传递会创建新对象。</p>
<h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>操作分为3步骤：<br>cpu线程内存将g_num读到寄存器<br>在寄存器中+1<br>将寄存器写回内存</p>
<h4 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h4><p>为保证线程安全<br>threading模块中定义了Lock类，可以处理锁定<br>mutex = threading.Lock()</p>
<p>mutex.acquire([blocking]),返回一个bool变量<br>   blocking默认为True，阻塞;False不阻塞<br>mutex.release()</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>这个太熟悉了,不说了</p>
<h4 id="使用锁使线程顺序执行"><a href="#使用锁使线程顺序执行" class="headerlink" title="使用锁使线程顺序执行"></a>使用锁使线程顺序执行</h4><p>就是每个线程一个锁.初始时,除了第一个线程的锁,其他锁都锁死,第一个线程执行完,开第二把锁,第二个执行完开第三把,依次类推.</p>
<h4 id="Queue模块"><a href="#Queue模块" class="headerlink" title="Queue模块"></a>Queue模块</h4><p>python的Queue模块</p>
<ul>
<li>FIFO(先入先出):Queue</li>
<li>LIFO(后入先出):LifoQueue</li>
<li>优先级队列:PriorityQueue</li>
</ul>
<p>python2中from Queue import Queue<br>python3中from queue import Queue<br>使用方法与进程的相同<br>queue.put(对象)<br>queue.get()</p>
<h4 id="ThreadLocal变量"><a href="#ThreadLocal变量" class="headerlink" title="ThreadLocal变量"></a>ThreadLocal变量</h4><p>ThreadLocal变量虽是全局变量，但每个线程都只读写自己线程的独立副本，互不干扰。解决了一个线程中各个函数之间相互传递的问题。<br>threadLocal最常用的地方就是为每个线程绑定一个数据库连接，Http请求，用户身份信息等，这样一个线程的所有调用到的处理函数，都可以非常方便的访问这些这些资源</p>
<p>import threading<br>local_school = threading.local()  #这里的local说明可能不是一个类，是个函数也不对，听奇怪不遵循python3的类首字母大写的规范</p>
<p>就是一个线程函数中调用另一函数，这两个函数之间的数据传递。<br>其实是由于python的传参，对于可变类型传递的都是引用，造成了线程内部调用的函数都是线程不安全的，所以使用了这种类似与Queue的方法,将这些传参都放到全局变量里去获取。这个与queue不同的是threadLocal对各个线程是独立的，像是每个线程都有一个的样子。而且它是key-value方式存储</p>
<h4 id="复习-2"><a href="#复习-2" class="headerlink" title="复习"></a>复习</h4><p>主要是对ThreadLocal的理解，local可以看作是一个对象，它在不同线程中变量相同但数据不同。</p>
<h2 id="【新】协程"><a href="#【新】协程" class="headerlink" title="【新】协程"></a>【新】协程</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>比线程更小的执行单元，是在线程下的运行单元，协程一般由用户来实现，比线程占用资源更少<br>用处：<br>  IO密集型程序比较适合协程，而CPU密集型不适合协程<br>底层：<br>  yield来停下，然后用next来实现</p>
<h3 id="greenlet使用"><a href="#greenlet使用" class="headerlink" title="greenlet使用"></a>greenlet使用</h3><p>from greenlet import greenlet<br>import time</p>
<p>def test1():<br>   while True:<br>     print(“—AAA—“)<br>     gr2.switch()#这里切换到test2方法中运行<br>def test2():<br>   while True:<br>     print(“—BBB—“)<br>     gr1.switch()</p>
<p>gr1 = greenlet(test1)<br>gr2 = greenlet(test2)<br>gr1.switch</p>
<h3 id="gevent"><a href="#gevent" class="headerlink" title="gevent"></a>gevent</h3><p>import gevent<br>def f(n):<br>   for i in range(n):<br>      print(“%s:%d”%(gevent.getcurrent(),n))<br>      gevent.sleep(1)  #需要有io等待，这里模拟耗时任务，需要用gevent中的sleep，有IO等待，不需要人工调用，gevent自动切换</p>
<p>g1 = gevent.spawn(f,5)<br>g2 = gevent.spawn(f,5)<br>g3 = gevent.spawn(f,5)</p>
<p>g1.join()<br>g2.join()<br>g3.join()</p>
<h3 id="并发下载器"><a href="#并发下载器" class="headerlink" title="并发下载器"></a>并发下载器</h3><p>from gevent import monkey<br>import gevent<br>from  urllib import request</p>
<p>#有IO需要有这句话，才可以对IO进行耗时进行捕获，从而自动切换<br>monkey.patch_all()</p>
<p>def myDownload(url):<br>   print(url)<br>   response = request.urlopen(url)<br>   data = response.read()<br>   prin(“%d bytes received from %s”%(len(data),url)</p>
<p>gevent.joinall([<br>gevnet.spawn(myDownload,”<a href="http://www.baidu.com&quot;)" target="_blank" rel="noopener">http://www.baidu.com&quot;)</a>,<br>gevnet.spawn(myDownload,”<a href="http://www.sina.com&quot;" target="_blank" rel="noopener">http://www.sina.com&quot;</a>)<br>gevnet.spawn(myDownload,”<a href="http://www.weibo.com&quot;" target="_blank" rel="noopener">http://www.weibo.com&quot;</a>)<br>])</p>
<h3 id="复习-3"><a href="#复习-3" class="headerlink" title="复习"></a>复习</h3><p>并发下载器，提示了多线程/多协程去爬取网页的技术，网页的爬取与网页的分析是可以分开来使用的，多线程可以用作很多方面。</p>
<h2 id="python网络"><a href="#python网络" class="headerlink" title="python网络"></a>python网络</h2><ul>
<li><p>网络地址与主机地址<br><img src="15.IP地址.png" alt=""><br>A类：1.0.0.1 - 126.255.255.254 可用的A类网络有126个每个网络容纳167 7214个主机<br>B类：128.1.0.1 - 191.255.255.254 B类网络有16384个，容纳主机65534个<br>C类：192.0.1.1 - 223.255.254 C类网络209 7152个，容纳主机254个<br>D类：第一个字节以1110开始，它并不指向特定的网络，目前这一类地址被用在多点广播中多点国博地址用来一次寻址一组计算机地址范围224.0.0.1 - 239.255.255.254<br>E类：以1111开始，为将来保留，作为实验使用</p>
<p>私有IP 有一部分ip用于局域网使用，不再公网中使用，包括</p>
<pre><code>-A类 10.0.0.0 - 10.255.255.255
-B类 172.16.0.0 - 172.31.255.255
-C类 192.168.0.0 - 192.168.255.255
- 127.0.0.1 - 127.255.255.255用户回路测试
</code></pre><p>共有IP ip<br>路由器完成公有ip与私有ip之间的转换：所以说一台私有ip的电脑不能作为网络服务器，因为外界不能正确访问到它</p>
</li>
<li><p>端口号<br>端口号只有整数，范围从0～65535<br>知名端口号，0～1023.如80:http, 21:ftp<br>动态端口：1024～65535<br>netstat -an</p>
</li>
<li><p>协议<br><img src="16.网络协议.png" alt=""><br>socket: cs架构与bs架构</p>
<h2 id="socket-udp"><a href="#socket-udp" class="headerlink" title="socket-udp"></a>socket-udp</h2><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3></li>
<li>import socket</li>
<li><p>socket.socket(AddressFamily, Type)<br>AddressFamily:AF_INET<br>Type:SOCK_STRAEM(tcp),SOCK_DGRAM(udp)</p>
<h3 id="udp应用"><a href="#udp应用" class="headerlink" title="udp应用"></a>udp应用</h3><p>语音广播，视频，QQ，TFTP,SNMP,DNS，RIP（路由信息协议，报告股票市场）</p>
<h3 id="收发数据"><a href="#收发数据" class="headerlink" title="收发数据"></a>收发数据</h3><p>updSocket = socke(AF_INET,SOCKET_DGRAM)<br>sendAddr=(‘192.168.1.1’,8080)<br>sendData = raw_input(“请输入要发的数据”)<br>updSocket.sendto(sendData,sendAddr)</p>
<p>bindAddr=(‘192.168.1.2’,7788)<br>udpSokcet.bind(bindAddr)<br>rcvData = udpSocket.recvfrom(1024) #1024代表本次接受的最大字节数,此处接受收时会阻塞<br>print(rcvData)<br>updSocket.close()</p>
</li>
</ul>
<h2 id="tftp"><a href="#tftp" class="headerlink" title="tftp"></a>tftp</h2><ul>
<li>使用协议udp，端口69</li>
<li>使用wireshark抓包</li>
<li><p>使用tftpd32来做tftp服务器</p>
</li>
<li><p>过程：</p>
<ol>
<li>客户端发请求，下载还是上传（操作类型）、文件名</li>
<li>服务器收到请求确认：如果文件没有，发出错信息；反之，发确认信息，或者直接发文件一部分</li>
<li>客户端收到文件后：如果收到文件数据，需要发确认信息，并且将数据保存本地<pre><code>如果收到出错信息，终止下载
</code></pre></li>
<li>循环过程：服务器发文件一部分，客户端确认，知道文件发完</li>
<li>如果文件结束，应该有一个文件结束的标志<br><img src="17.tftp协议介绍.png" alt=""><br>操作码：1是读即下载，2是写即上传，3是数据包，4确认，5出错</li>
</ol>
</li>
</ul>
<p>struct模块，处理C语言的结构体<br>pack(): pack(fmt,v1,v2…)<br>unpack(): unpack(fmt,string)<br>calcsize(fmt)，计算给点内存</p>
<p>fmt：!大端，windows下下小端，linux下大端，网络也是大端。大端就是高位在前<br><img src="18.fmt意思.png" alt=""></p>
<h2 id="socket-tcp"><a href="#socket-tcp" class="headerlink" title="socket-tcp"></a>socket-tcp</h2><h3 id="服务器流程："><a href="#服务器流程：" class="headerlink" title="服务器流程："></a>服务器流程：</h3><ol>
<li>创建套接字</li>
<li>bind绑定ip与port</li>
<li>listen是套接字变为可以被动链接</li>
<li>accept等待客户端的连接</li>
<li>recv/send接收发送数据<br><img src="19.tcp服务器.png" alt=""></li>
</ol>
<h3 id="客户端历程"><a href="#客户端历程" class="headerlink" title="客户端历程"></a>客户端历程</h3><ol>
<li>创建socket</li>
<li>connect</li>
<li>send/recv</li>
<li>close</li>
</ol>
<h2 id="【重】多路复用"><a href="#【重】多路复用" class="headerlink" title="【重】多路复用"></a>【重】多路复用</h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>可以把socket当作文件读写的，用多路复用来监听<br><img src="20.多路复用select版.png" alt=""></p>
<p>import select</p>
<p>socketServer = socket(AF_INET,SOCK_STREAM)<br>socketServer.setsockopt(SOL_SOCKET,SO_REUSEADDR,1)<br>inputs=[socketServer,sys.stdin]<br>readable,writeable,exceptional = select.select(inputs,[],[])<br>for r in readable:<br>    if r == socketServer:<br>       conn,addr = r.accept()<br>       inputs.append(conn)<br>    elif r== sys.stdin:<br>       pass<br>    else:<br>       data = r.recv(1024)<br>       if data:<br>         r.send(data)<br>        else:<br>          inputs.remove(r)</p>
<p>select 类似与中断，同时监听多少个,是一种轮询的方式</p>
<h3 id="epoll只有linux用"><a href="#epoll只有linux用" class="headerlink" title="epoll只有linux用"></a>epoll只有linux用</h3><p><img src="21.多路复用epoll版.png" alt=""><br>from socket import *<br>import select,sys</p>
<p>epoll = select.epoll()<br>epoll.register(tcpsocket.fileno(), select.EPOLLIN|select.EPOLLET)<br>epoll.register(sys.stdin.fileno(), select.EPOLLIN|select.EPOLLET)</p>
<p>conections = {}<br>adress={}</p>
<p>epoll_list = epoll.poll()<br>for fd,events in epoll_list:<br>   if fd == tcpsocket.fileno()<br>      conn,addr = tcpsocket.accept()<br>      connections[conn.fileno()] = conn<br>      address[conn.fileno()] = adress<br>      epoll.register(conn.fileno(), select.EPOLLIN|select.EPOLLET)<br>   elif fd == sys.stdin.fileno():<br>      pass<br>   elif events == select.EPOLLIN:<br>     data = connections[fd].rect(1024)<br>     if data:<br>         connections[fd].send(data)<br>     else:<br>         conections[fd].close()<br>         connections.pop(fd)<br>         address.pop(fd)</p>
<h2 id="【重】网络工具"><a href="#【重】网络工具" class="headerlink" title="【重】网络工具"></a>【重】网络工具</h2><h3 id="NetAssist-网络调试助手"><a href="#NetAssist-网络调试助手" class="headerlink" title="NetAssist:网络调试助手"></a>NetAssist:网络调试助手</h3><p>可以用tcp，udp协议与写的代码进行交互</p>
<h3 id="wireShark-网络抓波工具"><a href="#wireShark-网络抓波工具" class="headerlink" title="wireShark:网络抓波工具"></a>wireShark:网络抓波工具</h3><p>选中网卡，能抓到该网卡上的网络传输数据</p>
<h3 id="tftpd32：tftp服务器"><a href="#tftpd32：tftp服务器" class="headerlink" title="tftpd32：tftp服务器"></a>tftpd32：tftp服务器</h3><p>选中文件目录，提供文件上传、下载服务</p>
<h3 id="Packet-Tracer"><a href="#Packet-Tracer" class="headerlink" title="Packet Tracer"></a>Packet Tracer</h3><ol>
<li>集线器与交换机区别<br>集线器就是做转发，集线器网络容易出网络风暴<br>交换机有路由，可以做寻址等</li>
<li><p>arp<br>arp攻击：修改arp表，将所有的ip都指向攻击者，然后收到后进行篡改<br>arp就是寻址，根据ip去寻找mac地址，然后记录在本地的arp列表中</p>
</li>
<li><p>路由器作用</p>
<ul>
<li>连通不同的网络：<br>路由器相当于双网卡，一段连一个网络。一个网络中，需要设置一个网关。如果是同一网段，路由器直接发送个给对应机器，不同网段，则直接发送给网关<br>不同网络通信时，显示主机广播自己，然后寻址网关的的mac地址，网关返回后，主机将arp层的目的mac写为网关，ip当然还是要连接的另一网络的ip</li>
<li>路由寻址<br>多台路由器时，需要有路由表，仿真期间，用的是静态路由表，每个arp都根据路由表传递给下一个ip，返回下一个路由的mac地址，记录在前一个路由器中，这样，在发送imcp时，路由器根据需要，改写目的mac即可。</li>
</ul>
</li>
<li><p>Http<br>http包被tcp包含。前边握手包，后边结束包</p>
</li>
</ol>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="mycat"><a href="#mycat" class="headerlink" title="mycat"></a>mycat</h3><p>都是关系型数据库，就是在多个关系型数据库（尤其是mysql）上搭建的中间件，搭建成关系型数据库集群。<br>其实类似于zookeeper</p>
<h3 id="python下mysql的使用"><a href="#python下mysql的使用" class="headerlink" title="python下mysql的使用"></a>python下mysql的使用</h3><h4 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h4><p>pip3 install PyMySQL</p>
<h4 id="Connection对象"><a href="#Connection对象" class="headerlink" title="Connection对象"></a>Connection对象</h4><ul>
<li>建立与数据库的连接</li>
<li>创建对象，调用connect()方法<br>host:主机名，数据库名，用户名，密码，端口默认3306(oracle是1521)，参数charset默认’gb2312’</li>
<li>方法<br>close()关闭<br>commit()提交<br>rollback()回滚<br>cursor()游标</li>
</ul>
<h4 id="Cursor对象"><a href="#Cursor对象" class="headerlink" title="Cursor对象"></a>Cursor对象</h4><ul>
<li>执行sql语句</li>
<li>创建对象，Connection对象的cursor()方法<br>cursor = conn.cursor</li>
<li>方法<br>excute(operation[,parameters])<br>fetchone()<br>next()<br>fetchall()</li>
</ul>
<h4 id="实例-10"><a href="#实例-10" class="headerlink" title="实例"></a>实例</h4><p>import pymysql<br>connection = pymysql.connect(“localhost”,”root”,”sun12358”,”pythondb”)<br>cursor = connection.cursor()<br>cursor.execute(“select * from emp”)<br>rl = cursor.fetchall()</p>
<p>cursor.close()<br>connection.close()</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li><p>日期字符转换<br>datetime.datetime.strftime(emp[4 ], “%Y-%M-%D”)<br>emp[4].strftime(“%Y{y}%m{m}%d{d}”).format(y=’年’,m=’月’,d=’日’)</p>
</li>
<li><p>sql注入：select * from dept where depton &gt; 18 or 1=1<br>where后边的传参一定要注意</p>
</li>
</ul>
<h4 id="数据库代码封装"><a href="#数据库代码封装" class="headerlink" title="数据库代码封装"></a>数据库代码封装</h4><h4 id="复习-4"><a href="#复习-4" class="headerlink" title="复习"></a>复习</h4><p>竟然用cursor去执行，而不是用connection，statement等等</p>
<h1 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h1><ul>
<li>由礼物购买想到的<br>送礼物有3个元素决定：送礼物人，礼物，接收礼物人<br>礼物是由送礼物者与受礼物者决定<br>需要分析两个人的特性，再给予推荐<br>特性可能包括：2者关系，年龄，居住地，职业，健康状况（医院），经济水平（银行），礼物时间等等<br>礼物特点：历史含义，产地特性，时间特性等等</li>
</ul>
<h1 id="python基础复习"><a href="#python基础复习" class="headerlink" title="python基础复习"></a>python基础复习</h1><h2 id="基本语句"><a href="#基本语句" class="headerlink" title="基本语句"></a>基本语句</h2><h3 id="与"><a href="#与" class="headerlink" title="/ 与 //"></a>/ 与 //</h3><p>  / 是浮点除法，//是整数除法<br>  在python2.x中 / 与C语言中相同，即必须有浮点数结果才是浮点，否则是整数</p>
<h3 id="new与init"><a href="#new与init" class="headerlink" title="new与init"></a><strong>new</strong>与<strong>init</strong></h3><ol>
<li><strong>new</strong>是构造函数，是一个类函数.<strong>init</strong>是初始化函数，是对象函数</li>
<li><strong>new</strong>返回一个实例，而<strong>init</strong>不返回</li>
<li>只有在<strong>new</strong>返回实例后<strong>init</strong>才会被调用</li>
</ol>
<h3 id="xxx-xxx-xxx"><a href="#xxx-xxx-xxx" class="headerlink" title="xxx, _xxx, __xxx"></a><strong>xxx</strong>, _xxx, __xxx</h3><pre><code>_xxx 不能用’from module import *’导入  （相当于protected） 

__xxx__ 系统定义名字   (系统内置的，比如关键字)

__xxx 类中的私有变量名  （privated），所以更加不能使用from module import进行导入了,可以通过 _类名_xxx来访问。
</code></pre><h3 id="and-or-逻辑运算"><a href="#and-or-逻辑运算" class="headerlink" title="and or 逻辑运算"></a>and or 逻辑运算</h3><p>   x and y ： 布尔”与” - 如果x为False，x and y 返回False，否则它返回 y 的计算值<br>   x or y: 布尔”或” - 如果 x 是 True，它返回 True，否则它返回 y 的计算值</p>
<p>   注意计算值不一定是布尔值，可能是数字、字母等</p>
<h3 id="name"><a href="#name" class="headerlink" title="name"></a><strong>name</strong></h3><p>  直接运行与模块引入模块时，不同</p>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>   dict3 = {[1,2,3]: “uestc”}<br>   字典类型 dict 的键值必须是不可变的，否则 “通过唯一的 key 值确定对应的 value” 将不成立。字典的键可以是元组。<br>    d = {}字典<br>　   d = {,}集合set<br>    a = [‘name’,’age’]<br>    b=[‘dong’,32]<br>    c = dict(zip(a,b))</p>
<h3 id="上下文管理器with"><a href="#上下文管理器with" class="headerlink" title="上下文管理器with:"></a>上下文管理器with:</h3><p>  上下文管理器（Context Manager）：支持上下文管理协议的对象，这种对象实现了<strong>enter</strong>() 和 <strong>exit</strong>() 方法。上下文管理器定义执行 with 语句时要建立的运行时上下文，负责执行 with 语句块上下文中的进入与退出操作。通常使用 with 语句调用上下文管理器，也可以通过直接调用其方法来使用。</p>
<p>   with 语句的语法格式<br>   with context_expression [as target(s)]:<br>       with-body<br>   这里 context_expression 要返回一个上下文管理器对象，该对象并不赋值给 as 子句中的 target(s) ，如果指定了 as 子句的话，会将上下文管理器的 <strong>enter</strong>() 方法的返回值赋值给 target(s)。target(s) 可以是单个变量，或者由“()”括起来的元组（不能是仅仅由“,”分隔的变量列表，必须加“()”）</p>
<h3 id="调试："><a href="#调试：" class="headerlink" title="调试："></a>调试：</h3><p>  　- 执行时调试<br> 　　python -m pdb some.py<br> 　　只用这种就行<br> 　 -m 指的是module， 像脚本一样运行模块</p>
<pre><code>- 交互调试
</code></pre><p>  　import pdb<br>  　pdb.run(‘testfun(args)’)</p>
<p>  　- 程序下断点<br> 　 import pdb<br> 　 pdb.set_trace()<br> 　 运行到这之后停住，使用与gdb类似，p打印，n单步，s进入函数，c继续执行，</p>
<h3 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h3><p>　　sorted(a)  #本来就是按升序排序,reverse=True，就是降序<br>   a.sort()</p>
<pre><code>s = set(a)
for i in s:
   print(i,a.count(i))

def demo(*v):
print(v)
print(max(v))
print(sum(v))
demo(1,2,3)
demo(1,2,3,4)
demo(1,2,3,4,5)


def Sorted(v):
t = v[::]
r = []
while t:
    tt = min(t)
    r.append(tt)
    t.remove(tt)
return r
</code></pre><p>   x = [1,3,5,2,1,0,9,7]<br>   print(x)<br>   print(Sorted(x))</p>
<h2 id="基本模块"><a href="#基本模块" class="headerlink" title="基本模块"></a>基本模块</h2><ul>
<li><p>re<br>主要2种用法：<br>re.find(r’\d[4-5]\s\d{1,2}’,’aetbert’ )</p>
<p>patten = re.compile(r’\b[a-zA-Z]{3}\b’)<br>patten.findall(x)</p>
<p>个数：<br>   +*? {}<br>范围：<br>  [a-z]<br>语法糖：<br>  \b \w \s \d<br>界定符：<br>  ^ $</p>
</li>
<li><p>os<br>os.getcwd()<br>os.chdir()<br>os.listdir()</p>
<p>os.path.isdir()<br>os.path.join(dir+file)</p>
</li>
</ul>
<h2 id="语言特色"><a href="#语言特色" class="headerlink" title="语言特色"></a>语言特色</h2><h3 id="C-C内存管理"><a href="#C-C内存管理" class="headerlink" title="C++/C内存管理"></a>C++/C内存管理</h3><p>一个由C/C++编译的程序占用的内存分为以下几个部分：<br>1、栈区（stack）—  由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。<br>2、堆区（heap） —  一般由程序员分配释放，若程序员不释放，程序结束时可能由OS（操作系统）回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。<br>3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。<br>4、文字常量区  —常量字符串就是放在这里的。程序结束后由系统释放。<br>5、程序代码区—存放函数体的二进制代码。  </p>
<h3 id="python内存管理"><a href="#python内存管理" class="headerlink" title="python内存管理"></a>python内存管理</h3><h4 id="对象池-1"><a href="#对象池-1" class="headerlink" title="对象池"></a>对象池</h4><p>Python为了优化速度，<br>小整数：使用了[-5,257)对象池，避免为整数频繁申请和销毁内存。[257,无穷)都是新建对象<br>单个字符：也使用对象池，常驻内存<br>一个单词的字符串：也是在对象池中。采用引用计数共用，引用计数为0则销毁。</p>
<h4 id="垃圾收集-1"><a href="#垃圾收集-1" class="headerlink" title="垃圾收集"></a>垃圾收集</h4><h5 id="引用计数-1"><a href="#引用计数-1" class="headerlink" title="引用计数"></a>引用计数</h5><h6 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h6><p>实时，一旦没有引用，内存就直接释放，不用其他机制的等待特定时机</p>
<h6 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h6><p>多占点内存<br>有可能出现循环引用：a中有b，b中有a.这是用的是隔代收集来收集</p>
<h5 id="隔代收集-1"><a href="#隔代收集-1" class="headerlink" title="隔代收集"></a>隔代收集</h5>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/07/21/redis/" rel="next" title="redis基础">
                <i class="fa fa-chevron-left"></i> redis基础
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/curiosity.jpg"
               alt="sun" />
          <p class="site-author-name" itemprop="name">sun</p>
           
              <p class="site-description motion-element" itemprop="description">有一片天空，能留下鸟的痕迹</p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#python课程简介"><span class="nav-number">1.</span> <span class="nav-text">python课程简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Python基础"><span class="nav-number">1.1.</span> <span class="nav-text">Python基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#爬虫与搜索-数据采集"><span class="nav-number">1.2.</span> <span class="nav-text">爬虫与搜索[数据采集]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据分析"><span class="nav-number">1.3.</span> <span class="nav-text">数据分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深度学习"><span class="nav-number">1.4.</span> <span class="nav-text">深度学习</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#python基础"><span class="nav-number">2.</span> <span class="nav-text">python基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#安装"><span class="nav-number">2.1.</span> <span class="nav-text">安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#语法"><span class="nav-number">2.2.</span> <span class="nav-text">语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变量"><span class="nav-number">2.3.</span> <span class="nav-text">变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内存"><span class="nav-number">2.3.1.</span> <span class="nav-text">内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本类型"><span class="nav-number">2.3.2.</span> <span class="nav-text">基本类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串String"><span class="nav-number">2.3.3.</span> <span class="nav-text">字符串String</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#list列表"><span class="nav-number">2.3.4.</span> <span class="nav-text">list列表[]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tuple元组"><span class="nav-number">2.3.5.</span> <span class="nav-text">tuple元组()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建"><span class="nav-number">2.3.5.1.</span> <span class="nav-text">创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查"><span class="nav-number">2.3.5.2.</span> <span class="nav-text">查</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可变类型："><span class="nav-number">2.3.5.3.</span> <span class="nav-text">可变类型：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dict字典-map"><span class="nav-number">2.3.6.</span> <span class="nav-text">dict字典{} = map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set集合"><span class="nav-number">2.3.7.</span> <span class="nav-text">set集合{}</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#相互转化"><span class="nav-number">2.3.8.</span> <span class="nav-text">相互转化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可变类型与不可变类型"><span class="nav-number">2.3.9.</span> <span class="nav-text">可变类型与不可变类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本类型转换"><span class="nav-number">2.3.10.</span> <span class="nav-text">基本类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">2.3.11.</span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dict-pair"><span class="nav-number">2.3.11.1.</span> <span class="nav-text">dict = pair</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#python是一种弱类型语言，"><span class="nav-number">2.3.11.2.</span> <span class="nav-text">python是一种弱类型语言，</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#作用域"><span class="nav-number">2.4.</span> <span class="nav-text">作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#命名空间（namespace）"><span class="nav-number">2.4.1.</span> <span class="nav-text">命名空间（namespace）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#全局变量与局部变量"><span class="nav-number">2.4.2.</span> <span class="nav-text">全局变量与局部变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#和-is"><span class="nav-number">2.5.</span> <span class="nav-text">== 和 is</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运算"><span class="nav-number">2.6.</span> <span class="nav-text">运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进制、位运算"><span class="nav-number">2.6.1.</span> <span class="nav-text">进制、位运算</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数"><span class="nav-number">2.7.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内置函数"><span class="nav-number">2.7.1.</span> <span class="nav-text">内置函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#语法-1"><span class="nav-number">2.7.2.</span> <span class="nav-text">语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#全局变量与局部变量-1"><span class="nav-number">2.7.3.</span> <span class="nav-text">全局变量与局部变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不定长参数"><span class="nav-number">2.7.4.</span> <span class="nav-text">不定长参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#递归函数"><span class="nav-number">2.7.5.</span> <span class="nav-text">递归函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#匿名函数lambda"><span class="nav-number">2.7.6.</span> <span class="nav-text">匿名函数lambda</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#交换"><span class="nav-number">2.7.7.</span> <span class="nav-text">交换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件操作"><span class="nav-number">2.8.</span> <span class="nav-text">文件操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件"><span class="nav-number">2.8.1.</span> <span class="nav-text">文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件夹"><span class="nav-number">2.8.2.</span> <span class="nav-text">文件夹</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例"><span class="nav-number">2.8.3.</span> <span class="nav-text">实例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#从指定目录下，找包含有hello的py文件"><span class="nav-number">2.8.3.1.</span> <span class="nav-text">从指定目录下，找包含有hello的py文件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类和对象"><span class="nav-number">2.9.</span> <span class="nav-text">类和对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义类"><span class="nav-number">2.9.1.</span> <span class="nav-text">定义类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例-1"><span class="nav-number">2.9.2.</span> <span class="nav-text">实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不同"><span class="nav-number">2.9.3.</span> <span class="nav-text">不同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#魔法方法xxx"><span class="nav-number">2.9.4.</span> <span class="nav-text">魔法方法xxx</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#init-self"><span class="nav-number">2.9.5.</span> <span class="nav-text">init(self)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#del-self"><span class="nav-number">2.9.6.</span> <span class="nav-text">del(self)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#str-self"><span class="nav-number">2.9.7.</span> <span class="nav-text">str(self)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new-cls"><span class="nav-number">2.9.8.</span> <span class="nav-text">new(cls):</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#掷骰子"><span class="nav-number">2.9.9.</span> <span class="nav-text">掷骰子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#私有化（隐藏）"><span class="nav-number">2.9.10.</span> <span class="nav-text">私有化（隐藏）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#继承"><span class="nav-number">2.9.11.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多态"><span class="nav-number">2.9.12.</span> <span class="nav-text">多态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类属性（对象属性的区别）与类方法"><span class="nav-number">2.9.13.</span> <span class="nav-text">类属性（对象属性的区别）与类方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态方法"><span class="nav-number">2.9.14.</span> <span class="nav-text">静态方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单例"><span class="nav-number">2.9.15.</span> <span class="nav-text">单例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简单工厂"><span class="nav-number">2.9.16.</span> <span class="nav-text">简单工厂</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#枚举"><span class="nav-number">2.10.</span> <span class="nav-text">枚举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的数据隐藏"><span class="nav-number">2.11.</span> <span class="nav-text">类的数据隐藏</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#property用法"><span class="nav-number">2.11.1.</span> <span class="nav-text">property用法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异常"><span class="nav-number">2.12.</span> <span class="nav-text">异常</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#语法-2"><span class="nav-number">2.12.1.</span> <span class="nav-text">语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义异常"><span class="nav-number">2.12.2.</span> <span class="nav-text">自定义异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模块"><span class="nav-number">2.12.3.</span> <span class="nav-text">模块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模块与包"><span class="nav-number">2.13.</span> <span class="nav-text">模块与包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#导入"><span class="nav-number">2.13.1.</span> <span class="nav-text">导入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#测试"><span class="nav-number">2.13.2.</span> <span class="nav-text">测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#包"><span class="nav-number">2.13.3.</span> <span class="nav-text">包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#发布"><span class="nav-number">2.13.4.</span> <span class="nav-text">发布</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安装-1"><span class="nav-number">2.13.5.</span> <span class="nav-text">安装</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#杂项"><span class="nav-number">2.14.</span> <span class="nav-text">杂项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#传参"><span class="nav-number">2.14.1.</span> <span class="nav-text">传参</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#列表推导式"><span class="nav-number">2.14.2.</span> <span class="nav-text">列表推导式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#习题"><span class="nav-number">2.14.3.</span> <span class="nav-text">习题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#坦克大战"><span class="nav-number">2.15.</span> <span class="nav-text">坦克大战</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#环境"><span class="nav-number">2.15.1.</span> <span class="nav-text">环境</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类"><span class="nav-number">2.15.2.</span> <span class="nav-text">类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#问题"><span class="nav-number">2.15.3.</span> <span class="nav-text">问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#python进阶"><span class="nav-number">3.</span> <span class="nav-text">python进阶</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#模块与导入模块的路径设置"><span class="nav-number">3.1.</span> <span class="nav-text">模块与导入模块的路径设置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#复习"><span class="nav-number">3.1.1.</span> <span class="nav-text">复习</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#循环导入"><span class="nav-number">3.1.2.</span> <span class="nav-text">循环导入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深拷贝与浅拷贝-重点"><span class="nav-number">3.2.</span> <span class="nav-text">深拷贝与浅拷贝[重点]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#【新】生成器，yield"><span class="nav-number">3.3.</span> <span class="nav-text">【新】生成器，yield</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代器"><span class="nav-number">3.4.</span> <span class="nav-text">迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#可迭代对象：iterator"><span class="nav-number">3.4.1.</span> <span class="nav-text">可迭代对象：iterator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代器：可以被next对象调用，并不断返回下一个对象"><span class="nav-number">3.4.2.</span> <span class="nav-text">迭代器：可以被next对象调用，并不断返回下一个对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#【新】闭包"><span class="nav-number">3.5.</span> <span class="nav-text">【新】闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义"><span class="nav-number">3.5.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例-2"><span class="nav-number">3.5.2.</span> <span class="nav-text">实例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#嵌套函数"><span class="nav-number">3.5.2.1.</span> <span class="nav-text">嵌套函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#闭包"><span class="nav-number">3.5.2.2.</span> <span class="nav-text">闭包</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#应用"><span class="nav-number">3.5.3.</span> <span class="nav-text">应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一元一次方程-y-ax-b"><span class="nav-number">3.5.3.1.</span> <span class="nav-text">一元一次方程:y = ax+b</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#装饰器"><span class="nav-number">3.6.</span> <span class="nav-text">装饰器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义-1"><span class="nav-number">3.6.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#功能"><span class="nav-number">3.6.2.</span> <span class="nav-text">功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例-3"><span class="nav-number">3.6.3.</span> <span class="nav-text">实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通用装饰器"><span class="nav-number">3.6.4.</span> <span class="nav-text">通用装饰器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#【特】动态语言特性"><span class="nav-number">3.7.</span> <span class="nav-text">【特】动态语言特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义-2"><span class="nav-number">3.7.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特性"><span class="nav-number">3.7.2.</span> <span class="nav-text">特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#限制修改对象的属性"><span class="nav-number">3.7.3.</span> <span class="nav-text">限制修改对象的属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类装饰器"><span class="nav-number">3.8.</span> <span class="nav-text">类装饰器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#前情"><span class="nav-number">3.8.1.</span> <span class="nav-text">前情</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数对象-与-类"><span class="nav-number">3.8.1.1.</span> <span class="nav-text">函数对象 与 类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实例-4"><span class="nav-number">3.8.1.2.</span> <span class="nav-text">实例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类装饰器-1"><span class="nav-number">3.8.2.</span> <span class="nav-text">类装饰器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#【特】内存管理"><span class="nav-number">3.9.</span> <span class="nav-text">【特】内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对象池"><span class="nav-number">3.9.1.</span> <span class="nav-text">对象池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实例-5"><span class="nav-number">3.9.1.1.</span> <span class="nav-text">实例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾收集"><span class="nav-number">3.9.2.</span> <span class="nav-text">垃圾收集</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#简介"><span class="nav-number">3.9.2.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#引用计数"><span class="nav-number">3.9.2.2.</span> <span class="nav-text">引用计数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#优点："><span class="nav-number">3.9.2.2.1.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#缺点："><span class="nav-number">3.9.2.2.2.</span> <span class="nav-text">缺点：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#导致-1的"><span class="nav-number">3.9.2.2.3.</span> <span class="nav-text">导致+1的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#导致-1的-1"><span class="nav-number">3.9.2.2.4.</span> <span class="nav-text">导致-1的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#查看引用计数"><span class="nav-number">3.9.2.2.5.</span> <span class="nav-text">查看引用计数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#垃圾回收"><span class="nav-number">3.9.2.2.6.</span> <span class="nav-text">垃圾回收</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#gc模块"><span class="nav-number">3.9.2.2.7.</span> <span class="nav-text">gc模块</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#隔代收集"><span class="nav-number">3.9.2.3.</span> <span class="nav-text">隔代收集</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内建"><span class="nav-number">3.10.</span> <span class="nav-text">内建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法方法"><span class="nav-number">3.10.1.</span> <span class="nav-text">方法方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内建方法"><span class="nav-number">3.10.2.</span> <span class="nav-text">内建方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合对象"><span class="nav-number">3.10.3.</span> <span class="nav-text">集合对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常用模块"><span class="nav-number">3.11.</span> <span class="nav-text">常用模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#functools"><span class="nav-number">3.11.1.</span> <span class="nav-text">functools</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用标准模块"><span class="nav-number">3.11.2.</span> <span class="nav-text">常用标准模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用三方模块"><span class="nav-number">3.11.3.</span> <span class="nav-text">常用三方模块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pdb调试"><span class="nav-number">3.12.</span> <span class="nav-text">pdb调试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简介-1"><span class="nav-number">3.12.1.</span> <span class="nav-text">简介</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程"><span class="nav-number">3.13.</span> <span class="nav-text">进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fork方法"><span class="nav-number">3.13.1.</span> <span class="nav-text">fork方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#简介-2"><span class="nav-number">3.13.1.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用"><span class="nav-number">3.13.1.2.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多个fork"><span class="nav-number">3.13.1.3.</span> <span class="nav-text">多个fork</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复习-1"><span class="nav-number">3.13.1.4.</span> <span class="nav-text">复习</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过Process对象创建子进程"><span class="nav-number">3.13.2.</span> <span class="nav-text">通过Process对象创建子进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实例-6"><span class="nav-number">3.13.2.1.</span> <span class="nav-text">实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Process常用方法"><span class="nav-number">3.13.2.2.</span> <span class="nav-text">Process常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Process常用属性"><span class="nav-number">3.13.2.3.</span> <span class="nav-text">Process常用属性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过Prcess子类创建子进程"><span class="nav-number">3.13.3.</span> <span class="nav-text">通过Prcess子类创建子进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实例-7"><span class="nav-number">3.13.3.1.</span> <span class="nav-text">实例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程池"><span class="nav-number">3.13.4.</span> <span class="nav-text">进程池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实例-8"><span class="nav-number">3.13.4.1.</span> <span class="nav-text">实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#multiprocessing-Pool函数解析"><span class="nav-number">3.13.4.2.</span> <span class="nav-text">multiprocessing.Pool函数解析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息队列"><span class="nav-number">3.13.5.</span> <span class="nav-text">消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#进程之间"><span class="nav-number">3.13.5.1.</span> <span class="nav-text">进程之间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程池-1"><span class="nav-number">3.13.5.2.</span> <span class="nav-text">进程池</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#感受"><span class="nav-number">3.13.6.</span> <span class="nav-text">感受</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程"><span class="nav-number">3.14.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程简介"><span class="nav-number">3.14.1.</span> <span class="nav-text">线程简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例-9"><span class="nav-number">3.14.2.</span> <span class="nav-text">实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数-1"><span class="nav-number">3.14.3.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程创建方式"><span class="nav-number">3.14.4.</span> <span class="nav-text">线程创建方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程的几种状态"><span class="nav-number">3.14.5.</span> <span class="nav-text">线程的几种状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程之间通信"><span class="nav-number">3.14.6.</span> <span class="nav-text">线程之间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#共享全局变量"><span class="nav-number">3.14.6.1.</span> <span class="nav-text">共享全局变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#传参方式"><span class="nav-number">3.14.6.2.</span> <span class="nav-text">传参方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程安全"><span class="nav-number">3.14.6.3.</span> <span class="nav-text">线程安全</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程锁"><span class="nav-number">3.14.6.4.</span> <span class="nav-text">线程锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁"><span class="nav-number">3.14.6.5.</span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用锁使线程顺序执行"><span class="nav-number">3.14.6.6.</span> <span class="nav-text">使用锁使线程顺序执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Queue模块"><span class="nav-number">3.14.6.7.</span> <span class="nav-text">Queue模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocal变量"><span class="nav-number">3.14.6.8.</span> <span class="nav-text">ThreadLocal变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复习-2"><span class="nav-number">3.14.6.9.</span> <span class="nav-text">复习</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#【新】协程"><span class="nav-number">3.15.</span> <span class="nav-text">【新】协程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#介绍"><span class="nav-number">3.15.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#greenlet使用"><span class="nav-number">3.15.2.</span> <span class="nav-text">greenlet使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gevent"><span class="nav-number">3.15.3.</span> <span class="nav-text">gevent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并发下载器"><span class="nav-number">3.15.4.</span> <span class="nav-text">并发下载器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复习-3"><span class="nav-number">3.15.5.</span> <span class="nav-text">复习</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#python网络"><span class="nav-number">3.16.</span> <span class="nav-text">python网络</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#socket-udp"><span class="nav-number">3.17.</span> <span class="nav-text">socket-udp</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-1"><span class="nav-number">3.17.1.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#udp应用"><span class="nav-number">3.17.2.</span> <span class="nav-text">udp应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#收发数据"><span class="nav-number">3.17.3.</span> <span class="nav-text">收发数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tftp"><span class="nav-number">3.18.</span> <span class="nav-text">tftp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#socket-tcp"><span class="nav-number">3.19.</span> <span class="nav-text">socket-tcp</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#服务器流程："><span class="nav-number">3.19.1.</span> <span class="nav-text">服务器流程：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#客户端历程"><span class="nav-number">3.19.2.</span> <span class="nav-text">客户端历程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#【重】多路复用"><span class="nav-number">3.20.</span> <span class="nav-text">【重】多路复用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#select"><span class="nav-number">3.20.1.</span> <span class="nav-text">select</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll只有linux用"><span class="nav-number">3.20.2.</span> <span class="nav-text">epoll只有linux用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#【重】网络工具"><span class="nav-number">3.21.</span> <span class="nav-text">【重】网络工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NetAssist-网络调试助手"><span class="nav-number">3.21.1.</span> <span class="nav-text">NetAssist:网络调试助手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wireShark-网络抓波工具"><span class="nav-number">3.21.2.</span> <span class="nav-text">wireShark:网络抓波工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tftpd32：tftp服务器"><span class="nav-number">3.21.3.</span> <span class="nav-text">tftpd32：tftp服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Packet-Tracer"><span class="nav-number">3.21.4.</span> <span class="nav-text">Packet Tracer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库"><span class="nav-number">3.22.</span> <span class="nav-text">数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mycat"><span class="nav-number">3.22.1.</span> <span class="nav-text">mycat</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#python下mysql的使用"><span class="nav-number">3.22.2.</span> <span class="nav-text">python下mysql的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#安装-2"><span class="nav-number">3.22.2.1.</span> <span class="nav-text">安装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Connection对象"><span class="nav-number">3.22.2.2.</span> <span class="nav-text">Connection对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cursor对象"><span class="nav-number">3.22.2.3.</span> <span class="nav-text">Cursor对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实例-10"><span class="nav-number">3.22.2.4.</span> <span class="nav-text">实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他"><span class="nav-number">3.22.2.5.</span> <span class="nav-text">其他</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据库代码封装"><span class="nav-number">3.22.2.6.</span> <span class="nav-text">数据库代码封装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复习-4"><span class="nav-number">3.22.2.7.</span> <span class="nav-text">复习</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#想法"><span class="nav-number">4.</span> <span class="nav-text">想法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#python基础复习"><span class="nav-number">5.</span> <span class="nav-text">python基础复习</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本语句"><span class="nav-number">5.1.</span> <span class="nav-text">基本语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#与"><span class="nav-number">5.1.1.</span> <span class="nav-text">/ 与 //</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new与init"><span class="nav-number">5.1.2.</span> <span class="nav-text">new与init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#xxx-xxx-xxx"><span class="nav-number">5.1.3.</span> <span class="nav-text">xxx, _xxx, __xxx</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#and-or-逻辑运算"><span class="nav-number">5.1.4.</span> <span class="nav-text">and or 逻辑运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#name"><span class="nav-number">5.1.5.</span> <span class="nav-text">name</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字典"><span class="nav-number">5.1.6.</span> <span class="nav-text">字典</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#上下文管理器with"><span class="nav-number">5.1.7.</span> <span class="nav-text">上下文管理器with:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调试："><span class="nav-number">5.1.8.</span> <span class="nav-text">调试：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本函数"><span class="nav-number">5.1.9.</span> <span class="nav-text">基本函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本模块"><span class="nav-number">5.2.</span> <span class="nav-text">基本模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#语言特色"><span class="nav-number">5.3.</span> <span class="nav-text">语言特色</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-C内存管理"><span class="nav-number">5.3.1.</span> <span class="nav-text">C++/C内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#python内存管理"><span class="nav-number">5.3.2.</span> <span class="nav-text">python内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对象池-1"><span class="nav-number">5.3.2.1.</span> <span class="nav-text">对象池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#垃圾收集-1"><span class="nav-number">5.3.2.2.</span> <span class="nav-text">垃圾收集</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#引用计数-1"><span class="nav-number">5.3.2.2.1.</span> <span class="nav-text">引用计数</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#优点：-1"><span class="nav-number">5.3.2.2.1.1.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#缺点：-1"><span class="nav-number">5.3.2.2.1.2.</span> <span class="nav-text">缺点：</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#隔代收集-1"><span class="nav-number">5.3.2.2.2.</span> <span class="nav-text">隔代收集</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sun</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'Sun';
      var disqus_identifier = '2018/07/25/python/';

      var disqus_title = "";


      function run_disqus_script(disqus_script) {
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');

      
        var disqus_config = function () {
            this.page.url = disqus_url;
            this.page.identifier = disqus_identifier;
            this.page.title = disqus_title;
        };
        run_disqus_script('embed.js');
      

    </script>
  










  
  

  

  

  

  


  

</body>
</html>
