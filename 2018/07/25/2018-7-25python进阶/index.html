<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="python," />





  <link rel="alternate" href="/atom.xml" title="思 见" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="本文主要包括：闭包与装饰器，内存管理，常用的模块介绍，pdb调试，进程及线程，python网络(tcp/udp/select/poll)，数据库等">
<meta name="keywords" content="python">
<meta property="og:type" content="article">
<meta property="og:title" content="python进阶">
<meta property="og:url" content="http://yoursite.com/2018/07/25/2018-7-25python进阶/index.html">
<meta property="og:site_name" content="思 见">
<meta property="og:description" content="本文主要包括：闭包与装饰器，内存管理，常用的模块介绍，pdb调试，进程及线程，python网络(tcp/udp/select/poll)，数据库等">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2018/07/25/2018-7-25python进阶/8.深拷贝.png">
<meta property="og:image" content="http://yoursite.com/2018/07/25/2018-7-25python进阶/9.浅拷贝.png">
<meta property="og:image" content="http://yoursite.com/2018/07/25/2018-7-25python进阶/10.内建属性.png">
<meta property="og:image" content="http://yoursite.com/2018/07/25/2018-7-25python进阶/11.常用标准模块.png">
<meta property="og:image" content="http://yoursite.com/2018/07/25/2018-7-25python进阶/12.常用三方模块.png">
<meta property="og:image" content="http://yoursite.com/2018/07/25/2018-7-25python进阶/13.pdb调试.png">
<meta property="og:image" content="http://yoursite.com/2018/07/25/2018-7-25python进阶/14.线程的几种状态.png">
<meta property="og:image" content="http://yoursite.com/2018/07/25/2018-7-25python进阶/15.IP地址.png">
<meta property="og:image" content="http://yoursite.com/2018/07/25/2018-7-25python进阶/16.网络协议.png">
<meta property="og:image" content="http://yoursite.com/2018/07/25/2018-7-25python进阶/17.tftp协议介绍.png">
<meta property="og:image" content="http://yoursite.com/2018/07/25/2018-7-25python进阶/18.fmt意思.png">
<meta property="og:image" content="http://yoursite.com/2018/07/25/2018-7-25python进阶/19.tcp服务器.png">
<meta property="og:image" content="http://yoursite.com/2018/07/25/2018-7-25python进阶/20.多路复用select版.png">
<meta property="og:image" content="http://yoursite.com/2018/07/25/2018-7-25python进阶/21.多路复用epoll版.png">
<meta property="og:updated_time" content="2019-02-15T08:01:26.550Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="python进阶">
<meta name="twitter:description" content="本文主要包括：闭包与装饰器，内存管理，常用的模块介绍，pdb调试，进程及线程，python网络(tcp/udp/select/poll)，数据库等">
<meta name="twitter:image" content="http://yoursite.com/2018/07/25/2018-7-25python进阶/8.深拷贝.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/07/25/2018-7-25python进阶/"/>





  <title> python进阶 | 思 见 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">思 见</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/25/2018-7-25python进阶/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/curiosity.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思 见">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                python进阶
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-25T11:00:00+08:00">
                2018-07-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/知识/" itemprop="url" rel="index">
                    <span itemprop="name">知识</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本文主要包括：闭包与装饰器，内存管理，常用的模块介绍，pdb调试，进程及线程，python网络(tcp/udp/select/poll)，数据库等<br><a id="more"></a></p>
<h1 id="python进阶"><a href="#python进阶" class="headerlink" title="python进阶"></a>python进阶</h1><h2 id="模块与导入模块的路径设置"><a href="#模块与导入模块的路径设置" class="headerlink" title="模块与导入模块的路径设置"></a>模块与导入模块的路径设置</h2><ul>
<li><p>查看模块搜索路径<br>import sys<br>sys.path<br>所谓模块的搜索路径，指的是path执行import时，搜索的路径，这点有点像Windows的path环境变量，以上函数是查看现有的路径</p>
</li>
<li><p>添加搜索路径<br>sys.path.append(‘/home/xxx文件夹’)  #加在最后<br>sys.path.insert(‘/home/xxx文件夹’)  #加在首部<br>这两个函数是添加新的路径</p>
</li>
<li><p>重新导入模块<br>from imp import *<br>reload(模块名)<br>这块重新加载</p>
</li>
<li><p>查看安装的模块</p>
<ol>
<li>在交互解释器中使用help(“modules”)</li>
<li>import sys ; sys.modules.keys()这个会把具体的包中模块也打印出来<br>这个主要是这个help命令，可以模块名<br>help(“pygame.Rect”)</li>
</ol>
<p>dir()<br>如dir(sys)，其实就是列出给出对象的属性，这个些属性有对象的<strong>dir</strong>()提供<br>如果是module对象，只有module的属性<br>如果是类对象，会列出其本身的属性，以及基类的属性</p>
<h3 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h3><p>dir能列出模块中的类、对象等属性，对于自己的代码，需要先通过sys.path.insert将模块的目录导入，然后再调用dir(模块名)来查看 </p>
</li>
</ul>
<h3 id="循环导入"><a href="#循环导入" class="headerlink" title="循环导入"></a>循环导入</h3><ul>
<li>两个模块互相的导入</li>
<li><p>怎样避免循环导入</p>
</li>
<li><p>类似与#ifdef __DEFINE_H_H吗？</p>
</li>
</ul>
<h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><p>浅拷贝这里就是拷贝了引用,深拷贝就是对一个对象所有层次的拷贝。其实与C++的深浅拷贝概念相同<br>就是deepcopy会递归的copy，而浅拷贝不会<br>import copy<br>  copy.deepcopy<br>  copy.copy</p>
<ul>
<li><p>实例：<br>a = [1,2,3]<br>b = [4,5]<br>c = [a,b]<br>d = c</p>
<p>import copy<br>e = copy.deepcopy(c)<br>f = copy.copy(c)<br><img src="8.深拷贝.png" alt=""></p>
<p><img src="9.浅拷贝.png" alt=""></p>
</li>
</ul>
<p>浅拷贝对不可变类型和可变类型的copy不同（元组与列表）<br>  a=(1,2,3)<br>  b = copy.copy(a)<br>  a is b #True<br>  对于不可变类型的copy，其实就是a=b，引用指向相同的地址</p>
<h2 id="【新】生成器，yield"><a href="#【新】生成器，yield" class="headerlink" title="【新】生成器，yield"></a>【新】生成器，yield</h2><ul>
<li>初识(列表生成器)<br>g=(x for x in range(5))<br>g.next(),没有更多元素时,抛出StopIteration的异常<br>生成器只能用一次<br>for i in g:<pre><code>print(i)
</code></pre></li>
<li><p>第二种方法:yield<br>def fib(times):<br>  n = 0<br>  a,b=0,1<br>  while n&lt;times:</p>
<pre><code>yield b   #yied投降,运行在这里就停一下,并且抛出后边的内容,调用一次next执行一次
a,b=b,a+b
n+=1
</code></pre><p>  return ‘done’</p>
<p> g = fit(5)</p>
<p> #输出<br> next(g)<br> for x in g:</p>
</li>
<li><p>生成器方法:<strong>next</strong>()<br>g = fib(5)<br>g.<strong>next</strong>()</p>
</li>
<li><p>生成器方法:send()<br>g = fib(5)<br>g.<strong>next</strong>()  / g.send(None)<br>g.send(“hehe”)  </p>
<p>send给生成器传递一个参数<br>在生成器内部:<br>temp = yield b  #生成器抛出b,传递进的”哈哈”赋值给temp</p>
</li>
</ul>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="可迭代对象：iterator"><a href="#可迭代对象：iterator" class="headerlink" title="可迭代对象：iterator"></a>可迭代对象：iterator</h3><p>from collection import Iterable<br>isinstance([],Iterable)<br>集合对象<br>生成器对象</p>
<h3 id="迭代器：可以被next对象调用，并不断返回下一个对象"><a href="#迭代器：可以被next对象调用，并不断返回下一个对象" class="headerlink" title="迭代器：可以被next对象调用，并不断返回下一个对象"></a>迭代器：可以被next对象调用，并不断返回下一个对象</h3><p>l = [1,2,3]<br>it = iter(l)<br>next(it)  #集合本身不是迭代器<br>from collector imort Iterator<br>isinstance(it,Iterator)</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>函数内部可以再定义内部函数,内部函数对外部函数的属性可以直接引用,则称内部函数为闭包<br>2个条件:嵌套函数定义,内部函数引用外部函数变量<br>只调用内部函数时,被引用的外部函数变量,会绑定到闭包中,一定程度上延长了生命周期<br>其实可以理解为,构成闭包时,外部函数的变量声明周期到了延长到了内部</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def fun1():</span><br><span class="line">    def fun3():</span><br><span class="line">        print(&quot;fun3&quot;)</span><br><span class="line">    return fun3</span><br><span class="line">fun1()</span><br></pre></td></tr></table></figure>
<p>返回的是一个函数对象</p>
<h4 id="闭包-1"><a href="#闭包-1" class="headerlink" title="闭包"></a>闭包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def outter(num):</span><br><span class="line">    def inner(num_in):</span><br><span class="line">        print(&quot;num_in is %d&quot;%num_in)</span><br><span class="line">        return num_in+num</span><br><span class="line">    return inner</span><br><span class="line">fun = outer(20)</span><br><span class="line">fun(10)</span><br></pre></td></tr></table></figure>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="一元一次方程-y-ax-b"><a href="#一元一次方程-y-ax-b" class="headerlink" title="一元一次方程:y = ax+b"></a>一元一次方程:y = ax+b</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def line_conf(a,b):</span><br><span class="line">    def line(x):</span><br><span class="line">       return a*x + b</span><br><span class="line">    return line</span><br><span class="line">line1 = line_conf(1,1)</span><br><span class="line">line2 = line_conf(4,5)</span><br><span class="line"></span><br><span class="line">print(line1(5))</span><br><span class="line">print(line2(5))</span><br></pre></td></tr></table></figure>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>装饰器其实就是一个闭包,把一个函数当作参数,其中对函数进行包装,返回一个替代版新函数,其实与设计语言中了一样,也类似AOP<br>2个特性:<br>   一个是把被装饰的函数替代为其他函数<br>   而是可以在加载模块时立即执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def w1(func):</span><br><span class="line">   def inner():</span><br><span class="line">       #验证1</span><br><span class="line">       #验证2</span><br><span class="line">       func()</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">@w1</span><br><span class="line">def f1()</span><br><span class="line">   print(&quot;f1&quot;)</span><br></pre></td></tr></table></figure>
<p>其实就是AOP</p>
<p>装饰器内部函数的参与与被装饰的参数相同<br>不定长参数：可以将内部函数的参数设置为不定长参数，(<em>args,**kwargs)
          </em>args表示任何多个无名参数，它是一个tuple；<strong>kwargs表示关键字参数，它是一个dict。并且同时使用*args和</strong>kwargs时，必须*args参数列要在**kwargs前<br>函数可以认为都有返回值，没有return时，return的是None</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li>引入日志：开放封闭原则，就是对增加开放，对修改封闭</li>
<li>函数执行时间统计</li>
<li>执行函数前预备处理</li>
<li>执行函数后清理功能</li>
<li>全校校验</li>
<li>缓存<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def makeBold(fn):</span><br><span class="line">   def wrapped():</span><br><span class="line">      return &quot;&lt;b&gt;&quot; + fn() + &quot;&lt;/b&gt;&quot;</span><br><span class="line"></span><br><span class="line">@makeBold</span><br><span class="line">def test1():</span><br><span class="line">   return &quot;hello world&quot;</span><br><span class="line"></span><br><span class="line">print(test1())</span><br></pre></td></tr></table></figure>
<h3 id="通用装饰器"><a href="#通用装饰器" class="headerlink" title="通用装饰器"></a>通用装饰器</h3><ul>
<li>不定长参数</li>
<li>带返回值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from time import ctime</span><br><span class="line">def doca(fun):</span><br><span class="line">   def wrapper(*args,**kwargs):</span><br><span class="line">      print(&quot;%s called at %s&quot;%(fun.__name__,ctime()))</span><br><span class="line">      ret = fun()</span><br><span class="line">      return ret</span><br><span class="line">   return wrapper</span><br><span class="line"></span><br><span class="line">@doca</span><br><span class="line">def foo():</span><br><span class="line">  print(&quot;i am foo&quot;)</span><br><span class="line"></span><br><span class="line">@doca</span><br><span class="line">def gegInfo():</span><br><span class="line">   return &quot;--hehe--&quot;</span><br><span class="line"></span><br><span class="line">@doca</span><br><span class="line">def sum(a,b):</span><br><span class="line">  return a+b</span><br></pre></td></tr></table></figure>
<h2 id="动态语言特性"><a href="#动态语言特性" class="headerlink" title="动态语言特性"></a>动态语言特性</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>动态语言：在运行过程中，可以修改代码,大多数脚本语言：python,JavaScript,PHP,Ruby<br>静态语言：编译时已经确定好的代码，运行过程中不能修改,C,C++,Java</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>为对象动态添加属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line">    def __init__(self,name=None,age=None)</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">p = Person(&quot;小明&quot;,&quot;12&quot;)</span><br><span class="line">p.sex = &quot;male&quot;   #这里动态为p定义了属性sex</span><br><span class="line">print(p.sex)</span><br><span class="line">dir(p)</span><br></pre></td></tr></table></figure>
<p>  这里动态添加的属性，只是对p这个对象添加的，其他的Person类的对象是没有的<br>  这里可以动态的添加类的动态属性，这样所有的对象都会有且一致。</p>
<ul>
<li>为对象动态添加实例方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def showInfo(self):</span><br><span class="line">    print(self.name)</span><br><span class="line">    print(self.age)</span><br><span class="line"></span><br><span class="line">import types</span><br><span class="line">p.showInfo = types.MethodType(showInfo, p)#这里就是用p作为self来传递给showInfo，做一个装饰器即可。</span><br><span class="line">p.showInfo()</span><br></pre></td></tr></table></figure>
<ul>
<li>为类动态添加类方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@classmethod</span><br><span class="line"> def fun1(cls):</span><br><span class="line">    print(&quot;class Method&quot;)</span><br><span class="line"></span><br><span class="line">Person.fun1 = fun1</span><br><span class="line">p.fun1()</span><br></pre></td></tr></table></figure>
<ul>
<li>为类添加静态方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@staticmethod</span><br><span class="line">def fun2(a,b):</span><br><span class="line">   return a+b</span><br><span class="line">Person.fun2 = fun2</span><br><span class="line">print(p.fun2(1+2))</span><br></pre></td></tr></table></figure>
<h3 id="限制修改对象的属性"><a href="#限制修改对象的属性" class="headerlink" title="限制修改对象的属性"></a>限制修改对象的属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line">  __slots__=(&quot;name&quot;,&quot;age&quot;)</span><br></pre></td></tr></table></figure>
<p>这样就会限制对象往里添加属性，只限于name与age</p>
<h2 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h2><h3 id="前情"><a href="#前情" class="headerlink" title="前情"></a>前情</h3><h4 id="函数对象-与-类"><a href="#函数对象-与-类" class="headerlink" title="函数对象 与 类"></a>函数对象 与 类</h4><p>装饰器函数就是一个接口约束，它必须接受一个callable对象作为参数，然后返回一个callable对象<br>一般callable对象都是函数，但也有例外，只要某个类重写了<strong>call</strong>()方法那么就可以调用了</p>
<h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Test(object):</span><br><span class="line">   def __call__(self):</span><br><span class="line">      print(&quot;call me&quot;)</span><br><span class="line"></span><br><span class="line"> t = Test()</span><br><span class="line"> t()</span><br></pre></td></tr></table></figure>
<h3 id="类装饰器-1"><a href="#类装饰器-1" class="headerlink" title="类装饰器"></a>类装饰器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Test(object):</span><br><span class="line">   def __init__(self, func):</span><br><span class="line">       print(&quot;初始化&quot;)</span><br><span class="line">       print(&quot;func name is %s&quot;%func__name__)</span><br><span class="line">       self.__func = func</span><br><span class="line"></span><br><span class="line">  def __call__(self):</span><br><span class="line">       print(&quot;装饰器中的功能&quot;)</span><br><span class="line">       self.__func()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> #这里会生成一个Test对象，调用__init__方法，并且将test()作为参数产地给init</span><br><span class="line"> @Test       </span><br><span class="line"> def test():</span><br><span class="line">    print(&quot;---test---&quot;)</span><br><span class="line"> test()           #调用时，其实是调用Test对象的__call__</span><br></pre></td></tr></table></figure>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h3><p>Python为了优化速度，<br>小整数：使用了[-5,257)对象池，避免为整数频繁申请和销毁内存。[257,无穷)都是新建对象<br>单个字符：也使用对象池，常驻内存<br>一个单词的字符串：也是在对象池中。采用引用计数共用，引用计数为0则销毁。</p>
<h4 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">c = &apos;a&apos;</span><br><span class="line">b = &apos;a&apos;</span><br><span class="line">b is a #True</span><br><span class="line"></span><br><span class="line">s1 = &quot;hello&quot;</span><br><span class="line">s2 = &quot;hello&quot;</span><br><span class="line">s1 = s2 #True</span><br><span class="line"></span><br><span class="line">s3 = &quot;hello world&quot;</span><br><span class="line">s4 = &quot;hello world&quot;</span><br><span class="line">s3 = s4 #False</span><br></pre></td></tr></table></figure>
<h3 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>为新生成的对象分配内存，识别那些垃圾对象，从垃圾对象那里回收内存<br>python采用的是引用计数机制为主，标记-清除、隔代收集两种机制为辅的策略</p>
<p>python里每个东西都是对象，他们的核心是一个结构体：PyObject</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct_object&#123;</span><br><span class="line">    int obj_refcnt;</span><br><span class="line">    struct_typeobject *ob_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define Py_INCREE(op) ((op)-&gt;ob_refcnt++)</span><br><span class="line">#define Py_DECREE(op) \</span><br><span class="line">    if(--(op)-&gt;ob_refcnt!=0) \</span><br><span class="line">      ;\</span><br><span class="line">    else \</span><br><span class="line">      _Py_Dealloc((PyObject *)(op))</span><br></pre></td></tr></table></figure>
<h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><p>实时，一旦没有引用，内存就直接释放，不用其他机制的等待特定时机</p>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>多占点内存<br>有可能出现循环引用：a中有b，b中有a.这是用的是隔代收集来收集</p>
<h5 id="导致-1的"><a href="#导致-1的" class="headerlink" title="导致+1的"></a>导致+1的</h5><ul>
<li>对象被创建：a=23</li>
<li>对象被引用：b=a</li>
<li>对象被传参：func(a)</li>
<li>对象作为一个元素，存在容器里:list=[a,a]<h5 id="导致-1的-1"><a href="#导致-1的-1" class="headerlink" title="导致-1的"></a>导致-1的</h5></li>
<li>对象别名被显示销毁，del a</li>
<li>对象别名被赋予新的对象 a = 24</li>
<li>一个对象离开它的作用域，如f函数执行完毕，func函数的局部变量都会-1</li>
<li>对象所在的容器被销毁，或者从容器中删除。<h5 id="查看引用计数"><a href="#查看引用计数" class="headerlink" title="查看引用计数"></a>查看引用计数</h5></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">a = &quot;hello world&quot;</span><br><span class="line">sys.getrefcount(a)</span><br></pre></td></tr></table></figure>
<p>此时最少打印2，因为a创建+1，传参+1</p>
<h5 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h5><ol>
<li>调用gc.collect()</li>
<li>当gc模块的计数器达到阀值（有3个）的时候</li>
<li>程序退出</li>
</ol>
<h5 id="gc模块"><a href="#gc模块" class="headerlink" title="gc模块"></a>gc模块</h5><p>gc.garbage列表<br>gc.get_threshold()获取gc模块中自动执行垃圾回收的频率<br>gc._threshold(thrshold0[,th])<br>gc.get_count()，隔代收集中每代的个数<br>gc.collect([generation])隔代收集的0代表直线查第一代，1代表检查1.2代<br>gc模块唯一处理不了的是循环引用的类都有<strong>del</strong>方法，所以项目中避免定义<strong>del</strong>方法<br>gc.disable()手动关掉垃圾回收</p>
<h4 id="隔代收集"><a href="#隔代收集" class="headerlink" title="隔代收集"></a>隔代收集</h4><h2 id="内建"><a href="#内建" class="headerlink" title="内建"></a>内建</h2><h3 id="方法方法"><a href="#方法方法" class="headerlink" title="方法方法"></a>方法方法</h3><p><img src="10.内建属性.png" alt=""></p>
<ul>
<li><strong>new</strong>：构造函数</li>
<li><strong>init</strong>：初始化函数</li>
<li><strong>clas</strong>：实例所在类</li>
<li><strong>str</strong>：类似与Java的toString</li>
<li><strong>repr</strong>：</li>
<li><strong>del</strong>：析构</li>
<li><strong>dict</strong>:实例地定义属性</li>
<li><strong>doc</strong>：类文档，子类不继承</li>
<li><strong>getattibute</strong>:属性访问拦截器</li>
<li><p><strong>bases</strong>:类的所有父类构成元素</p>
</li>
<li><p><strong>getattribute</strong>属性访问拦截器<br>正常使用</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class School(object):</span><br><span class="line">   def __init__(self,s1):</span><br><span class="line">       self.subject1 = s1</span><br><span class="line">       self.subject2 = &apos;c++&apos;</span><br><span class="line"></span><br><span class="line">   def __getattribute__(self, obj):</span><br><span class="line">       if obj == &apos;subject1&apos;:</span><br><span class="line">           print(&quot;log subject1&quot;)</span><br><span class="line">           return &apos;redirect python&apos;</span><br><span class="line">       else:   #注意else一定要有，否则其他属性就是None了</span><br><span class="line">           return object.__getattribute__(self,ojb)</span><br><span class="line"></span><br><span class="line"> s = School(&apos;Pyhont&apos;)</span><br><span class="line"> print(s.subject1)</span><br><span class="line"> print(s.subject2)</span><br></pre></td></tr></table></figure>
<p> 坑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line">   def __getattribute__(self,obj):</span><br><span class="line">      print(&quot;---test---&quot;)</span><br><span class="line">      if obj.startwith(&quot;a&quot;):</span><br><span class="line">         return &quot;haha&quot;</span><br><span class="line">      else:</span><br><span class="line">         return self.test</span><br><span class="line"></span><br><span class="line">   def test(self):</span><br><span class="line">      print(&quot;heihei&quot;)</span><br><span class="line"></span><br><span class="line">  # 函数执行内存都在栈上</span><br><span class="line">  t=Person()</span><br><span class="line">  t.a </span><br><span class="line">  t.b #会让程序死掉，因为会递归调用__getattribute__所有就崩掉了</span><br></pre></td></tr></table></figure>
<h3 id="内建方法"><a href="#内建方法" class="headerlink" title="内建方法"></a>内建方法</h3><ul>
<li>dir<br>dir(<strong>buildins</strong>)</li>
<li>range(1,10,2)</li>
<li><p>map(function, sequence[,sequence,…])根据提供的函数，对指定序列做映射<br>map(lambda x:x*x,[1,2,3])：结果为[1,4,9],python2直接是序列，python3是可迭代的对象<br>map(lamdbda x,y:x+y,[1,2,3],[4,5,6]) ：结果为[5,7,9]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def f1(x,y):</span><br><span class="line">   return (x,y)</span><br><span class="line">l1 = [1,2,3]</span><br><span class="line">l2 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]</span><br><span class="line">l3 = map(f1,l1,l2)</span><br><span class="line">print(list(l3))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>filter(function or None,sequence)对指定序列执行过滤操作<br>filter(lambda x:x%2,[1,2,3,4])<br>filter(None,”hello”)</p>
</li>
<li><p>reduce(function,sequence[,initial])对参数序列中元素进行累积<br>python3中，reduce从全局名字空间中移除，放在functools模块里<br>from functools import reduce<br>reduce(lambda x,y:x+y, [1,2,3,4]) #10<br>reduce(lambda x,y:x+y, [1,2,3,4],5)  #15<br>reduce(lambda x,y:x+y, [‘aa’,’bb’,’cc’],’dd’)  #’ddaabbcc’</p>
</li>
</ul>
<h3 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h3><ul>
<li>支持的运算：<br>|:union：并集<br>&amp;：intersection:交集<br>-:difference:差集<br>^:sysmmetric_difference：对称差集，x^y，在x或y中，但不会同时出现在二者之中</li>
</ul>
<h2 id="常用模块"><a href="#常用模块" class="headerlink" title="常用模块"></a>常用模块</h2><h3 id="functools"><a href="#functools" class="headerlink" title="functools"></a>functools</h3><ul>
<li><p>partial：偏函数<br>把一个函数的某些参数设置默认参数，返回一个新的采纳数，调用这个函数会更简单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line">def showarg(*args,**kwagrs):</span><br><span class="line">   print(args)</span><br><span class="line">   print(kwargs)</span><br><span class="line"></span><br><span class="line">p1=functools.partial(showarg,1,2,3)</span><br><span class="line">p1()  #1,2,3 #&#123;&#125;</span><br><span class="line">p1(4,5,6)  #1,2,3,4,5,6 #&#123;&#125;</span><br><span class="line">p1(a=&apos;python&apos;, b=&apos;c++&apos;)  #1,2,3 #&#123;&quot;a&quot;:&quot;python&quot;,&quot;b&quot;:&quot;c++&quot;&#125;</span><br><span class="line"></span><br><span class="line">p2=functools.partial(showarg,a=3,b=&apos;linux&apos;)</span><br><span class="line">p2()</span><br><span class="line">p2(1,2)</span><br><span class="line">p2(a=&quot;ptyon&quot;,b=&quot;c++&quot;)#这个会将默认值改掉</span><br></pre></td></tr></table></figure>
</li>
<li><p>wraps：包装函数<br>使用装饰器后，被装饰的函数已经是另外一个函数了，wraps的装饰器可以消除这样的副作用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line">def note(func):</span><br><span class="line">   @functools.wraps(func)</span><br><span class="line">   def wrapper():</span><br><span class="line">      print(&quot;note something&quot;)</span><br><span class="line">      return func()</span><br><span class="line">   return wrapper</span><br><span class="line"></span><br><span class="line">@note</span><br><span class="line">def test():</span><br><span class="line">   print(&quot;i am test&quot;)</span><br><span class="line"></span><br><span class="line">test()</span><br><span class="line">print(test.__doc__) 如果不加，则返回的是wrapper(), 反之为test</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  其实就是在新家的这个装饰器内部，修改了wrapper的<strong>doc</strong></p>
<h3 id="常用标准模块"><a href="#常用标准模块" class="headerlink" title="常用标准模块"></a>常用标准模块</h3><p><img src="11.常用标准模块.png" alt=""></p>
<h3 id="常用三方模块"><a href="#常用三方模块" class="headerlink" title="常用三方模块"></a>常用三方模块</h3><p> <img src="12.常用三方模块.png" alt=""></p>
<h2 id="pdb调试"><a href="#pdb调试" class="headerlink" title="pdb调试"></a>pdb调试</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><ul>
<li><p>执行时调试<br>python -m pdb some.py<br>只用这种就行<br>-m 指的是module， 像脚本一样运行模块</p>
</li>
<li><p>交互调试<br>import pdb<br>pdb.run(‘testfun(args)’)</p>
</li>
<li><p>程序下断点<br>import pdb<br>pdb.set_trace()<br>运行到这之后停住，使用与gdb类似，p打印，n单步，s进入函数，c继续执行，<br><img src="13.pdb调试.png" alt=""></p>
</li>
</ul>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="fork方法"><a href="#fork方法" class="headerlink" title="fork方法"></a>fork方法</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>fork调用一次返回2次，父进程返回子进程id，子进程返回0<br>一个父进程可以fork出很多子进程，所以父进程要记下每个子进程的id，而子进程只需要调用getppid()就可以拿到父进程的id</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">imprt time</span><br><span class="line">pid = os.fork()</span><br><span class="line">if pid&lt;0:</span><br><span class="line">   time.sleep(2)</span><br><span class="line">   print(&quot;fork调用失败&quot;)</span><br><span class="line">elif pid==0:</span><br><span class="line">   time.sleep(1)</span><br><span class="line">   print(&quot;我是子进程(%s),我的父进程是(%s)&quot;%(os.getpid(), os.getppid()))</span><br><span class="line">else:</span><br><span class="line">   print(&quot;我是父进程(%s),我的子进程是(%s)&quot;%(os.getpid(), pid))</span><br><span class="line"></span><br><span class="line">print(&quot;父子进程都可以执行这里的代码&quot;)</span><br></pre></td></tr></table></figure>
<h4 id="多个fork"><a href="#多个fork" class="headerlink" title="多个fork"></a>多个fork</h4><p>这里创建了4个进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">pid = os.fork()</span><br><span class="line">if pid==0:</span><br><span class="line">   print(&quot;子进程11&quot;)</span><br><span class="line">else:</span><br><span class="line">   print(父进程11)</span><br><span class="line"></span><br><span class="line">pid = os.fork()</span><br><span class="line">if pid == 0:</span><br><span class="line">   print(&quot;子进程22&quot;)</span><br><span class="line">else:</span><br><span class="line">   print(&quot;父进程22&quot;)</span><br></pre></td></tr></table></figure>
<h4 id="复习-1"><a href="#复习-1" class="headerlink" title="复习"></a>复习</h4><p>fork返回值是子进程的pid,如果本身是子进程,返回值就是0</p>
<h3 id="通过Process对象创建子进程"><a href="#通过Process对象创建子进程" class="headerlink" title="通过Process对象创建子进程"></a>通过Process对象创建子进程</h3><h4 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">def run_proc(name):  #子进程只执行这个函数</span><br><span class="line">   print(&quot;子进程运行中，name=%s,pid=%d&quot;%(name,os.getpid()))</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;</span><br><span class="line">   print(&quot;父进程%d&quot;%s.getpid())</span><br><span class="line">   p = Process(target=run_proc,args=(&apos;test&apos;,))</span><br><span class="line">   print(&quot;子进程将要执行&quot;)</span><br><span class="line">   p.start()</span><br><span class="line">   p.join()  #加这句话，父进程等待子进程结束之后再执行</span><br><span class="line">   print(&quot;子进程执行结束&quot;)</span><br></pre></td></tr></table></figure>
<h4 id="Process常用方法"><a href="#Process常用方法" class="headerlink" title="Process常用方法"></a>Process常用方法</h4><p>is_alive:判断进程是否执行<br>join([timeout])是否等待进程实例执行结束，或等待多少秒<br>start(),启动<br>run()，没有制定target时执行<br>terminat()，不管任务是否完成，终止任务，一般父进程来终止子进程</p>
<h4 id="Process常用属性"><a href="#Process常用属性" class="headerlink" title="Process常用属性"></a>Process常用属性</h4><p>name:当前进程实例别名，默认为Process-N<br>pid,当前进程pid</p>
<h3 id="通过Prcess子类创建子进程"><a href="#通过Prcess子类创建子进程" class="headerlink" title="通过Prcess子类创建子进程"></a>通过Prcess子类创建子进程</h3><h4 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">import time</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">class ProcessSubClass(Process):</span><br><span class="line">   def __init__(self,interval):</span><br><span class="line">     super().__init__()</span><br><span class="line">     self,interval = interval</span><br><span class="line"></span><br><span class="line">   #重写父类run</span><br><span class="line">   def run(self):</span><br><span class="line">       t_start= time.time()</span><br><span class="line">       time.sleep(self.interval)</span><br><span class="line">       t_end = tim.time()</span><br><span class="line">       print(%s执行结束，耗时%d%(os.getpid(),t_end-t_start))</span><br><span class="line"></span><br><span class="line"> if __name__==&quot;__main__&quot;:</span><br><span class="line">   print(&quot;主进程执行开始&quot;)</span><br><span class="line">   p = ProcessSubClass(2)</span><br><span class="line">   p.start()</span><br><span class="line">   p.join()</span><br><span class="line">   print(&quot;主进程执行结束&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h3><p>multiprocessing模块提供的Pool方法<br>如果池已经满了，只能等待，如果没有满，并且有空闲的，则去空闲的，反之，创建一个新进程。</p>
<h4 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Pool</span><br><span class="line">import os,time,random</span><br><span class="line"></span><br><span class="line">def worker(msg):</span><br><span class="line">   t_start = time.time()</span><br><span class="line">   print(&quot;子进程%d,%d&quot;,%(os.getpid(),msg))</span><br><span class="line">   time.sleep(random.randint(1,3)*2)</span><br><span class="line">   t_stop = time.time()</span><br><span class="line">   print(&quot;执行完毕，用时:%d&quot;%(t_stop-t_start))</span><br></pre></td></tr></table></figure>
<p>#创建进程池<br>pool = Pool(3)</p>
<p>for i in range(0,10):</p>
<p>   #从进程池申请进程，传参为函数名、参数元组</p>
<p>   #apply_async是异步申请，apply是同步。异步同时请求3个，然后同时执行；同步一个一个请求，上一个进程退出才能执行下一个<br>   pool.apply_async(worker,(i,))</p>
<p>#关闭进程池，close之后再写join，进程池中的进程已经是start状态，所以不需要再start了<br>pool.close()<br>pool.join()</p>
<h4 id="multiprocessing-Pool函数解析"><a href="#multiprocessing-Pool函数解析" class="headerlink" title="multiprocessing.Pool函数解析"></a>multiprocessing.Pool函数解析</h4><ul>
<li>apply_async(func[,args[,kwagrs]]):</li>
<li>apply</li>
<li>close():进程池不再接受新的任务，已用的进程慢慢关闭</li>
<li>terminate()：不管任务是否完成，立即终止</li>
<li>join()：与Process相同</li>
</ul>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><h4 id="进程之间"><a href="#进程之间" class="headerlink" title="进程之间"></a>进程之间</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">from multiProcess import Process</span><br><span class="line">from multiProcess import Queue</span><br><span class="line"></span><br><span class="line">def writer(q):</span><br><span class="line">   for item in &quot;ABCDE&quot;</span><br><span class="line">       print(&quot;正在往消息队列中写入%s&quot;%item)</span><br><span class="line">       q.put(item)</span><br><span class="line">       time.sleep(1)</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">def reader(q):</span><br><span class="line">   while True:</span><br><span class="line">   if not q.empty():</span><br><span class="line">      item = q.get()</span><br><span class="line">      print(&quot;从消息队列中读出%s&quot;%item)</span><br><span class="line">      time.sleep(random.random())</span><br><span class="line">   else:</span><br><span class="line">      break</span><br><span class="line"></span><br><span class="line">q = Queue()</span><br><span class="line">pw = Process(target=writer,args=(q,))</span><br><span class="line">pw.start()</span><br><span class="line">pw.join()</span><br><span class="line"></span><br><span class="line">pr = Process(target=reader,args=(q,))</span><br><span class="line">pr.start()</span><br><span class="line">pr.join()</span><br></pre></td></tr></table></figure>
<h4 id="进程池-1"><a href="#进程池-1" class="headerlink" title="进程池"></a>进程池</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">from multiProcess import Pool,Manager</span><br><span class="line">import time,random</span><br><span class="line"></span><br><span class="line">def writer(q):</span><br><span class="line">   for item in &quot;ABCDE&quot;</span><br><span class="line">       print(&quot;正在往消息队列中写入%s&quot;%item)</span><br><span class="line">       q.put(item)</span><br><span class="line">       time.sleep(1)</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">def reader(q):</span><br><span class="line">   while True:</span><br><span class="line">   if not q.empty():</span><br><span class="line">      item = q.get()</span><br><span class="line">      print(&quot;从消息队列中读出%s&quot;%item)</span><br><span class="line">      time.sleep(random.random())</span><br><span class="line">   else:</span><br><span class="line">      break</span><br><span class="line"></span><br><span class="line">q = Manager().Queue()  #进程池中，只能使用Manager创建的消息队列</span><br><span class="line">pool = Pool(3)</span><br><span class="line">Pool.apply(writer,(q,))  #执行结束之后，再执行下一个进程</span><br><span class="line">Pool.apply(reader,(q,))</span><br><span class="line"></span><br><span class="line">Pool.close()</span><br><span class="line">Pool.join()</span><br></pre></td></tr></table></figure>
<h3 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h3><p>python的进程一部分继承了linux轻进程的特点</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h3><p>进程是作为资源分配的单位<br>调度和执行的单位</p>
<p>python的thread模块以及threading模块<br>threading模块对thread做了一些包装</p>
<h3 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def fun(num):</span><br><span class="line">    print(&quot;线程%d执行&quot;%num)</span><br><span class="line">    time.sleep(2)</span><br><span class="line"></span><br><span class="line">for i in range(5):</span><br><span class="line">    t = threading.Thread(target=fun,args=(i+1,))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li>threading.enumerate():当前线程数量</li>
</ul>
<h3 id="线程创建方式"><a href="#线程创建方式" class="headerlink" title="线程创建方式"></a>线程创建方式</h3><ul>
<li>threading.Tread的对象</li>
<li>子类化thread.Tread，实现run方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import threading,time</span><br><span class="line">class MyThread(threading.Thread):</span><br><span class="line">      def run(self):</span><br><span class="line">              for i in range(5):</span><br><span class="line">                      time.sleep(1)</span><br><span class="line">                      #这里self.name是父类的属性，默认是Thread-N</span><br><span class="line">                      print(&quot;I am &quot;+ self.name+&quot;@&quot;+str(i))</span><br><span class="line"></span><br><span class="line">if __name__==&quot;__main__&quot;:</span><br><span class="line">      t = MyThread()</span><br><span class="line">      t.start()</span><br></pre></td></tr></table></figure>
<p>  传参可以通过重新定义<strong>init</strong>方法来传参</p>
<h3 id="线程的几种状态"><a href="#线程的几种状态" class="headerlink" title="线程的几种状态"></a>线程的几种状态</h3><p><img src="14.线程的几种状态.png" alt=""><br>就绪，运行，阻塞状态<br>就绪状态到运行状态是需要系统的调用，才进入运行状态，运行状态受阻塞的事件，进入阻塞状态<br>运行状态下的时间片用完，进入就绪状态</p>
<h3 id="线程之间通信"><a href="#线程之间通信" class="headerlink" title="线程之间通信"></a>线程之间通信</h3><h4 id="共享全局变量"><a href="#共享全局变量" class="headerlink" title="共享全局变量"></a>共享全局变量</h4><h4 id="传参方式"><a href="#传参方式" class="headerlink" title="传参方式"></a>传参方式</h4><p>将全局变量作为参数传递给线程<br>w1 = threading.Tread(target=worker1,args=(numlist,))<br>这里的传参方式，直接调用函数传参需要注意的事项相同，对于可不变类型与不可变类型需要注意。对于可变参数，传递的是引用。不可变参数传递会创建新对象。</p>
<h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>操作分为3步骤：<br>cpu线程内存将g_num读到寄存器<br>在寄存器中+1<br>将寄存器写回内存</p>
<h4 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h4><p>为保证线程安全<br>threading模块中定义了Lock类，可以处理锁定<br>mutex = threading.Lock()</p>
<p>mutex.acquire([blocking]),返回一个bool变量<br>   blocking默认为True，阻塞;False不阻塞<br>mutex.release()</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>这个太熟悉了,不说了</p>
<h4 id="使用锁使线程顺序执行"><a href="#使用锁使线程顺序执行" class="headerlink" title="使用锁使线程顺序执行"></a>使用锁使线程顺序执行</h4><p>就是每个线程一个锁.初始时,除了第一个线程的锁,其他锁都锁死,第一个线程执行完,开第二把锁,第二个执行完开第三把,依次类推.</p>
<h4 id="Queue模块"><a href="#Queue模块" class="headerlink" title="Queue模块"></a>Queue模块</h4><p>python的Queue模块</p>
<ul>
<li>FIFO(先入先出):Queue</li>
<li>LIFO(后入先出):LifoQueue</li>
<li>优先级队列:PriorityQueue</li>
</ul>
<p>python2中from Queue import Queue<br>python3中from queue import Queue<br>使用方法与进程的相同<br>queue.put(对象)<br>queue.get()</p>
<h4 id="ThreadLocal变量"><a href="#ThreadLocal变量" class="headerlink" title="ThreadLocal变量"></a>ThreadLocal变量</h4><p>ThreadLocal变量虽是全局变量，但每个线程都只读写自己线程的独立副本，互不干扰。解决了一个线程中各个函数之间相互传递的问题。<br>threadLocal最常用的地方就是为每个线程绑定一个数据库连接，Http请求，用户身份信息等，这样一个线程的所有调用到的处理函数，都可以非常方便的访问这些这些资源</p>
<p>import threading<br>local_school = threading.local()  #这里的local说明可能不是一个类，是个函数也不对，听奇怪不遵循python3的类首字母大写的规范</p>
<p>就是一个线程函数中调用另一函数，这两个函数之间的数据传递。<br>其实是由于python的传参，对于可变类型传递的都是引用，造成了线程内部调用的函数都是线程不安全的，所以使用了这种类似与Queue的方法,将这些传参都放到全局变量里去获取。这个与queue不同的是threadLocal对各个线程是独立的，像是每个线程都有一个的样子。而且它是key-value方式存储</p>
<h4 id="复习-2"><a href="#复习-2" class="headerlink" title="复习"></a>复习</h4><p>主要是对ThreadLocal的理解，local可以看作是一个对象，它在不同线程中变量相同但数据不同。</p>
<h2 id="【新】协程"><a href="#【新】协程" class="headerlink" title="【新】协程"></a>【新】协程</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>比线程更小的执行单元，是在线程下的运行单元，协程一般由用户来实现，比线程占用资源更少<br>用处：<br>  IO密集型程序比较适合协程，而CPU密集型不适合协程<br>底层：<br>  yield来停下，然后用next来实现</p>
<h3 id="greenlet使用"><a href="#greenlet使用" class="headerlink" title="greenlet使用"></a>greenlet使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from greenlet import greenlet</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def test1():</span><br><span class="line">   while True:</span><br><span class="line">     print(&quot;---AAA---&quot;)</span><br><span class="line">     gr2.switch()#这里切换到test2方法中运行</span><br><span class="line">def test2():</span><br><span class="line">   while True:</span><br><span class="line">     print(&quot;---BBB---&quot;)</span><br><span class="line">     gr1.switch()</span><br><span class="line"> </span><br><span class="line">gr1 = greenlet(test1)</span><br><span class="line">gr2 = greenlet(test2)</span><br><span class="line">gr1.switch</span><br></pre></td></tr></table></figure>
<h3 id="gevent"><a href="#gevent" class="headerlink" title="gevent"></a>gevent</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import gevent</span><br><span class="line">def f(n):</span><br><span class="line">   for i in range(n):</span><br><span class="line">      print(&quot;%s:%d&quot;%(gevent.getcurrent(),n))</span><br><span class="line">      gevent.sleep(1)  #需要有io等待，这里模拟耗时任务，需要用gevent中的sleep，有IO等待，不需要人工调用，gevent自动切换</span><br><span class="line"></span><br><span class="line">g1 = gevent.spawn(f,5)</span><br><span class="line">g2 = gevent.spawn(f,5)</span><br><span class="line">g3 = gevent.spawn(f,5)</span><br><span class="line"></span><br><span class="line">g1.join()</span><br><span class="line">g2.join()</span><br><span class="line">g3.join()</span><br></pre></td></tr></table></figure>
<h3 id="并发下载器"><a href="#并发下载器" class="headerlink" title="并发下载器"></a>并发下载器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from gevent import monkey</span><br><span class="line">import gevent</span><br><span class="line">from  urllib import request</span><br><span class="line"></span><br><span class="line">#有IO需要有这句话，才可以对IO进行耗时进行捕获，从而自动切换</span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br><span class="line">def myDownload(url):</span><br><span class="line">   print(url)</span><br><span class="line">   response = request.urlopen(url)</span><br><span class="line">   data = response.read()</span><br><span class="line">   prin(&quot;%d bytes received from %s&quot;%(len(data),url)</span><br><span class="line"></span><br><span class="line">gevent.joinall([</span><br><span class="line">gevnet.spawn(myDownload,&quot;http://www.baidu.com&quot;),</span><br><span class="line">gevnet.spawn(myDownload,&quot;http://www.sina.com&quot;)</span><br><span class="line">gevnet.spawn(myDownload,&quot;http://www.weibo.com&quot;)</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<h3 id="复习-3"><a href="#复习-3" class="headerlink" title="复习"></a>复习</h3><p>并发下载器，提示了多线程/多协程去爬取网页的技术，网页的爬取与网页的分析是可以分开来使用的，多线程可以用作很多方面。</p>
<h2 id="网络简介"><a href="#网络简介" class="headerlink" title="网络简介"></a>网络简介</h2><ul>
<li><p>网络地址与主机地址<br><img src="15.IP地址.png" alt=""><br>A类：1.0.0.1 - 126.255.255.254 可用的A类网络有126个每个网络容纳167 7214个主机<br>B类：128.1.0.1 - 191.255.255.254 B类网络有16384个，容纳主机65534个<br>C类：192.0.1.1 - 223.255.254 C类网络209 7152个，容纳主机254个<br>D类：第一个字节以1110开始，它并不指向特定的网络，目前这一类地址被用在多点广播中多点国博地址用来一次寻址一组计算机地址范围224.0.0.1 - 239.255.255.254<br>E类：以1111开始，为将来保留，作为实验使用</p>
<p>私有IP 有一部分ip用于局域网使用，不再公网中使用，包括</p>
<pre><code>-A类 10.0.0.0 - 10.255.255.255
-B类 172.16.0.0 - 172.31.255.255
-C类 192.168.0.0 - 192.168.255.255
- 127.0.0.1 - 127.255.255.255用户回路测试
</code></pre><p>共有IP ip<br>路由器完成公有ip与私有ip之间的转换：所以说一台私有ip的电脑不能作为网络服务器，因为外界不能正确访问到它</p>
</li>
<li><p>端口号<br>端口号只有整数，范围从0～65535<br>知名端口号，0～1023.如80:http, 21:ftp<br>动态端口：1024～65535<br>netstat -an</p>
</li>
<li><p>协议<br><img src="16.网络协议.png" alt=""><br>socket: cs架构与bs架构</p>
</li>
</ul>
<h2 id="socket-udp"><a href="#socket-udp" class="headerlink" title="socket-udp"></a>socket-udp</h2><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">socket.socket(AddressFamily, Type)</span><br><span class="line">  AddressFamily:AF_INET</span><br><span class="line">  Type:SOCK_STRAEM(tcp),SOCK_DGRAM(udp)</span><br></pre></td></tr></table></figure>
<h3 id="udp应用"><a href="#udp应用" class="headerlink" title="udp应用"></a>udp应用</h3><p>语音广播，视频，QQ，TFTP,SNMP,DNS，RIP（路由信息协议，报告股票市场）</p>
<h3 id="收发数据"><a href="#收发数据" class="headerlink" title="收发数据"></a>收发数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">updSocket = socke(AF_INET,SOCKET_DGRAM)</span><br><span class="line">sendAddr=(&apos;192.168.1.1&apos;,8080)</span><br><span class="line">sendData = raw_input(&quot;请输入要发的数据&quot;)</span><br><span class="line">updSocket.sendto(sendData,sendAddr)</span><br><span class="line"></span><br><span class="line">bindAddr=(&apos;192.168.1.2&apos;,7788)</span><br><span class="line">udpSokcet.bind(bindAddr)</span><br><span class="line">rcvData = udpSocket.recvfrom(1024) #1024代表本次接受的最大字节数,此处接受收时会阻塞</span><br><span class="line">print(rcvData)</span><br><span class="line">updSocket.close()</span><br></pre></td></tr></table></figure>
<h2 id="tftp"><a href="#tftp" class="headerlink" title="tftp"></a>tftp</h2><ul>
<li>使用协议udp，端口69</li>
<li>使用wireshark抓包</li>
<li><p>使用tftpd32来做tftp服务器</p>
</li>
<li><p>过程：</p>
<ol>
<li>客户端发请求，下载还是上传（操作类型）、文件名</li>
<li>服务器收到请求确认：如果文件没有，发出错信息；反之，发确认信息，或者直接发文件一部分</li>
<li>客户端收到文件后：如果收到文件数据，需要发确认信息，并且将数据保存本地<pre><code>如果收到出错信息，终止下载
</code></pre></li>
<li>循环过程：服务器发文件一部分，客户端确认，知道文件发完</li>
<li>如果文件结束，应该有一个文件结束的标志<br><img src="17.tftp协议介绍.png" alt=""><br>操作码：1是读即下载，2是写即上传，3是数据包，4确认，5出错</li>
</ol>
</li>
</ul>
<p>struct模块，处理C语言的结构体<br>pack(): pack(fmt,v1,v2…)<br>unpack(): unpack(fmt,string)<br>calcsize(fmt)，计算给点内存</p>
<p>fmt：!大端，windows下下小端，linux下大端，网络也是大端。大端就是高位在前<br><img src="18.fmt意思.png" alt=""></p>
<h2 id="socket-tcp"><a href="#socket-tcp" class="headerlink" title="socket-tcp"></a>socket-tcp</h2><h3 id="服务器流程："><a href="#服务器流程：" class="headerlink" title="服务器流程："></a>服务器流程：</h3><ol>
<li>创建套接字</li>
<li>bind绑定ip与port</li>
<li>listen是套接字变为可以被动链接</li>
<li>accept等待客户端的连接</li>
<li>recv/send接收发送数据<br><img src="19.tcp服务器.png" alt=""></li>
</ol>
<h3 id="客户端历程"><a href="#客户端历程" class="headerlink" title="客户端历程"></a>客户端历程</h3><ol>
<li>创建socket</li>
<li>connect</li>
<li>send/recv</li>
<li>close</li>
</ol>
<h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>可以把socket当作文件读写的，用多路复用来监听<br><img src="20.多路复用select版.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import select</span><br><span class="line"></span><br><span class="line">socketServer = socket(AF_INET,SOCK_STREAM)</span><br><span class="line">socketServer.setsockopt(SOL_SOCKET,SO_REUSEADDR,1)</span><br><span class="line">inputs=[socketServer,sys.stdin]</span><br><span class="line">readable,writeable,exceptional = select.select(inputs,[],[])</span><br><span class="line">for r in readable:</span><br><span class="line">    if r == socketServer:</span><br><span class="line">       conn,addr = r.accept()</span><br><span class="line">       inputs.append(conn)</span><br><span class="line">    elif r== sys.stdin:</span><br><span class="line">       pass</span><br><span class="line">    else:</span><br><span class="line">       data = r.recv(1024)</span><br><span class="line">       if data:</span><br><span class="line">         r.send(data)</span><br><span class="line">        else:</span><br><span class="line">          inputs.remove(r)</span><br></pre></td></tr></table></figure>
<p>select 类似与中断，同时监听多少个,是一种轮询的方式</p>
<h3 id="epoll只有linux用"><a href="#epoll只有linux用" class="headerlink" title="epoll只有linux用"></a>epoll只有linux用</h3><p><img src="21.多路复用epoll版.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">from socket import *</span><br><span class="line">import select,sys</span><br><span class="line"></span><br><span class="line">epoll = select.epoll()</span><br><span class="line">epoll.register(tcpsocket.fileno(), select.EPOLLIN|select.EPOLLET)</span><br><span class="line">epoll.register(sys.stdin.fileno(), select.EPOLLIN|select.EPOLLET)</span><br><span class="line"></span><br><span class="line">conections = &#123;&#125;</span><br><span class="line">adress=&#123;&#125;</span><br><span class="line"></span><br><span class="line">epoll_list = epoll.poll()</span><br><span class="line">for fd,events in epoll_list:</span><br><span class="line">   if fd == tcpsocket.fileno()</span><br><span class="line">      conn,addr = tcpsocket.accept()</span><br><span class="line">      connections[conn.fileno()] = conn</span><br><span class="line">      address[conn.fileno()] = adress</span><br><span class="line">      epoll.register(conn.fileno(), select.EPOLLIN|select.EPOLLET)</span><br><span class="line">   elif fd == sys.stdin.fileno():</span><br><span class="line">      pass</span><br><span class="line">   elif events == select.EPOLLIN:</span><br><span class="line">     data = connections[fd].rect(1024)</span><br><span class="line">     if data:</span><br><span class="line">         connections[fd].send(data)</span><br><span class="line">     else:</span><br><span class="line">         conections[fd].close()</span><br><span class="line">         connections.pop(fd)</span><br><span class="line">         address.pop(fd)</span><br></pre></td></tr></table></figure>
<h2 id="网络工具"><a href="#网络工具" class="headerlink" title="网络工具"></a>网络工具</h2><h3 id="NetAssist-网络调试助手"><a href="#NetAssist-网络调试助手" class="headerlink" title="NetAssist:网络调试助手"></a>NetAssist:网络调试助手</h3><p>可以用tcp，udp协议与写的代码进行交互</p>
<h3 id="wireShark-网络抓波工具"><a href="#wireShark-网络抓波工具" class="headerlink" title="wireShark:网络抓波工具"></a>wireShark:网络抓波工具</h3><p>选中网卡，能抓到该网卡上的网络传输数据</p>
<h3 id="tftpd32：tftp服务器"><a href="#tftpd32：tftp服务器" class="headerlink" title="tftpd32：tftp服务器"></a>tftpd32：tftp服务器</h3><p>选中文件目录，提供文件上传、下载服务</p>
<h3 id="Packet-Tracer"><a href="#Packet-Tracer" class="headerlink" title="Packet Tracer"></a>Packet Tracer</h3><ol>
<li>集线器与交换机区别<br>集线器就是做转发，集线器网络容易出网络风暴<br>交换机有路由，可以做寻址等</li>
<li><p>arp<br>arp攻击：修改arp表，将所有的ip都指向攻击者，然后收到后进行篡改<br>arp就是寻址，根据ip去寻找mac地址，然后记录在本地的arp列表中</p>
</li>
<li><p>路由器作用</p>
<ul>
<li>连通不同的网络：<br>路由器相当于双网卡，一段连一个网络。一个网络中，需要设置一个网关。如果是同一网段，路由器直接发送个给对应机器，不同网段，则直接发送给网关<br>不同网络通信时，显示主机广播自己，然后寻址网关的的mac地址，网关返回后，主机将arp层的目的mac写为网关，ip当然还是要连接的另一网络的ip</li>
<li>路由寻址<br>多台路由器时，需要有路由表，仿真期间，用的是静态路由表，每个arp都根据路由表传递给下一个ip，返回下一个路由的mac地址，记录在前一个路由器中，这样，在发送imcp时，路由器根据需要，改写目的mac即可。</li>
</ul>
</li>
<li><p>Http<br>http包被tcp包含。前边握手包，后边结束包</p>
</li>
</ol>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="mycat"><a href="#mycat" class="headerlink" title="mycat"></a>mycat</h3><p>都是关系型数据库，就是在多个关系型数据库（尤其是mysql）上搭建的中间件，搭建成关系型数据库集群。<br>其实类似于zookeeper</p>
<h3 id="python下mysql的使用"><a href="#python下mysql的使用" class="headerlink" title="python下mysql的使用"></a>python下mysql的使用</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>pip3 install PyMySQL</p>
<h4 id="Connection对象"><a href="#Connection对象" class="headerlink" title="Connection对象"></a>Connection对象</h4><ul>
<li>建立与数据库的连接</li>
<li>创建对象，调用connect()方法<br>host:主机名，数据库名，用户名，密码，端口默认3306(oracle是1521)，参数charset默认’gb2312’</li>
<li>方法<br>close()关闭<br>commit()提交<br>rollback()回滚<br>cursor()游标</li>
</ul>
<h4 id="Cursor对象"><a href="#Cursor对象" class="headerlink" title="Cursor对象"></a>Cursor对象</h4><ul>
<li>执行sql语句</li>
<li>创建对象，Connection对象的cursor()方法<br>cursor = conn.cursor</li>
<li>方法<br>excute(operation[,parameters])<br>fetchone()<br>next()<br>fetchall()</li>
</ul>
<h4 id="实例-8"><a href="#实例-8" class="headerlink" title="实例"></a>实例</h4><p>import pymysql<br>connection = pymysql.connect(“localhost”,”root”,”sun12358”,”pythondb”)<br>cursor = connection.cursor()<br>cursor.execute(“select * from emp”)<br>rl = cursor.fetchall()</p>
<p>cursor.close()<br>connection.close()</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li><p>日期字符转换<br>datetime.datetime.strftime(emp[4 ], “%Y-%M-%D”)<br>emp[4].strftime(“%Y{y}%m{m}%d{d}”).format(y=’年’,m=’月’,d=’日’)</p>
</li>
<li><p>sql注入：select * from dept where depton &gt; 18 or 1=1<br>where后边的传参一定要注意</p>
</li>
</ul>
<h1 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h1><h2 id="基本语句"><a href="#基本语句" class="headerlink" title="基本语句"></a>基本语句</h2><h3 id="xxx-xxx-xxx"><a href="#xxx-xxx-xxx" class="headerlink" title="xxx, _xxx, __xxx"></a><strong>xxx</strong>, _xxx, __xxx</h3><pre><code>_xxx 不能用’from module import *’导入  （相当于protected） 

__xxx__ 系统定义名字   (系统内置的，比如关键字)

__xxx 类中的私有变量名  （privated），所以更加不能使用from module import进行导入了,可以通过 _类名_xxx来访问。
</code></pre><h3 id="上下文管理器with"><a href="#上下文管理器with" class="headerlink" title="上下文管理器with:"></a>上下文管理器with:</h3><p>  上下文管理器（Context Manager）：支持上下文管理协议的对象，这种对象实现了<strong>enter</strong>() 和 <strong>exit</strong>() 方法。上下文管理器定义执行 with 语句时要建立的运行时上下文，负责执行 with 语句块上下文中的进入与退出操作。通常使用 with 语句调用上下文管理器，也可以通过直接调用其方法来使用。</p>
<p>   with 语句的语法格式<br>   with context_expression [as target(s)]:<br>       with-body<br>   这里 context_expression 要返回一个上下文管理器对象，该对象并不赋值给 as 子句中的 target(s) ，如果指定了 as 子句的话，会将上下文管理器的 <strong>enter</strong>() 方法的返回值赋值给 target(s)。target(s) 可以是单个变量，或者由“()”括起来的元组（不能是仅仅由“,”分隔的变量列表，必须加“()”）</p>
<h3 id="调试："><a href="#调试：" class="headerlink" title="调试："></a>调试：</h3><p>  　- 执行时调试<br> 　　python -m pdb some.py<br> 　　只用这种就行<br> 　 -m 指的是module， 像脚本一样运行模块</p>
<pre><code>- 交互调试
</code></pre><p>  　import pdb<br>  　pdb.run(‘testfun(args)’)</p>
<p>  　- 程序下断点<br> 　 import pdb<br> 　 pdb.set_trace()<br> 　 运行到这之后停住，使用与gdb类似，p打印，n单步，s进入函数，c继续执行，</p>
<h2 id="基本模块"><a href="#基本模块" class="headerlink" title="基本模块"></a>基本模块</h2><ul>
<li><p>re<br>主要2种用法：<br>re.find(r’\d[4-5]\s\d{1,2}’,’aetbert’ )</p>
<p>patten = re.compile(r’\b[a-zA-Z]{3}\b’)<br>patten.findall(x)</p>
<p>个数：<br>   +*? {}<br>范围：<br>  [a-z]<br>语法糖：<br>  \b \w \s \d<br>界定符：<br>  ^ $</p>
</li>
</ul>
<h2 id="语言特色"><a href="#语言特色" class="headerlink" title="语言特色"></a>语言特色</h2><h3 id="C-C内存管理"><a href="#C-C内存管理" class="headerlink" title="C++/C内存管理"></a>C++/C内存管理</h3><p>一个由C/C++编译的程序占用的内存分为以下几个部分：<br>1、栈区（stack）—  由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。<br>2、堆区（heap） —  一般由程序员分配释放，若程序员不释放，程序结束时可能由OS（操作系统）回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。<br>3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。<br>4、文字常量区  —常量字符串就是放在这里的。程序结束后由系统释放。<br>5、程序代码区—存放函数体的二进制代码。  </p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/python/" rel="tag"># python</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/07/25/2018-7-25python基础/" rel="next" title="python基础">
                <i class="fa fa-chevron-left"></i> python基础
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/07/26/2018-7-26python爬虫/" rel="prev" title="python爬虫">
                python爬虫 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/curiosity.jpg"
               alt="sun" />
          <p class="site-author-name" itemprop="name">sun</p>
           
              <p class="site-description motion-element" itemprop="description">有一片天空，能留下鸟的痕迹</p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">83</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">36</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#python进阶"><span class="nav-number">1.</span> <span class="nav-text">python进阶</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#模块与导入模块的路径设置"><span class="nav-number">1.1.</span> <span class="nav-text">模块与导入模块的路径设置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#复习"><span class="nav-number">1.1.1.</span> <span class="nav-text">复习</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#循环导入"><span class="nav-number">1.1.2.</span> <span class="nav-text">循环导入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深拷贝与浅拷贝"><span class="nav-number">1.2.</span> <span class="nav-text">深拷贝与浅拷贝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#【新】生成器，yield"><span class="nav-number">1.3.</span> <span class="nav-text">【新】生成器，yield</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代器"><span class="nav-number">1.4.</span> <span class="nav-text">迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#可迭代对象：iterator"><span class="nav-number">1.4.1.</span> <span class="nav-text">可迭代对象：iterator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代器：可以被next对象调用，并不断返回下一个对象"><span class="nav-number">1.4.2.</span> <span class="nav-text">迭代器：可以被next对象调用，并不断返回下一个对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#闭包"><span class="nav-number">1.5.</span> <span class="nav-text">闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义"><span class="nav-number">1.5.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例"><span class="nav-number">1.5.2.</span> <span class="nav-text">实例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#嵌套函数"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">嵌套函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#闭包-1"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">闭包</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#应用"><span class="nav-number">1.5.3.</span> <span class="nav-text">应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一元一次方程-y-ax-b"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">一元一次方程:y = ax+b</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#装饰器"><span class="nav-number">1.6.</span> <span class="nav-text">装饰器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义-1"><span class="nav-number">1.6.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#功能"><span class="nav-number">1.6.2.</span> <span class="nav-text">功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例-1"><span class="nav-number">1.6.3.</span> <span class="nav-text">实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通用装饰器"><span class="nav-number">1.6.4.</span> <span class="nav-text">通用装饰器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态语言特性"><span class="nav-number">1.7.</span> <span class="nav-text">动态语言特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义-2"><span class="nav-number">1.7.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特性"><span class="nav-number">1.7.2.</span> <span class="nav-text">特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#限制修改对象的属性"><span class="nav-number">1.7.3.</span> <span class="nav-text">限制修改对象的属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类装饰器"><span class="nav-number">1.8.</span> <span class="nav-text">类装饰器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#前情"><span class="nav-number">1.8.1.</span> <span class="nav-text">前情</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数对象-与-类"><span class="nav-number">1.8.1.1.</span> <span class="nav-text">函数对象 与 类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实例-2"><span class="nav-number">1.8.1.2.</span> <span class="nav-text">实例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类装饰器-1"><span class="nav-number">1.8.2.</span> <span class="nav-text">类装饰器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存管理"><span class="nav-number">1.9.</span> <span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对象池"><span class="nav-number">1.9.1.</span> <span class="nav-text">对象池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实例-3"><span class="nav-number">1.9.1.1.</span> <span class="nav-text">实例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾收集"><span class="nav-number">1.9.2.</span> <span class="nav-text">垃圾收集</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#简介"><span class="nav-number">1.9.2.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#引用计数"><span class="nav-number">1.9.2.2.</span> <span class="nav-text">引用计数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#优点："><span class="nav-number">1.9.2.2.1.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#缺点："><span class="nav-number">1.9.2.2.2.</span> <span class="nav-text">缺点：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#导致-1的"><span class="nav-number">1.9.2.2.3.</span> <span class="nav-text">导致+1的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#导致-1的-1"><span class="nav-number">1.9.2.2.4.</span> <span class="nav-text">导致-1的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#查看引用计数"><span class="nav-number">1.9.2.2.5.</span> <span class="nav-text">查看引用计数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#垃圾回收"><span class="nav-number">1.9.2.2.6.</span> <span class="nav-text">垃圾回收</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#gc模块"><span class="nav-number">1.9.2.2.7.</span> <span class="nav-text">gc模块</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#隔代收集"><span class="nav-number">1.9.2.3.</span> <span class="nav-text">隔代收集</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内建"><span class="nav-number">1.10.</span> <span class="nav-text">内建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法方法"><span class="nav-number">1.10.1.</span> <span class="nav-text">方法方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内建方法"><span class="nav-number">1.10.2.</span> <span class="nav-text">内建方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合对象"><span class="nav-number">1.10.3.</span> <span class="nav-text">集合对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常用模块"><span class="nav-number">1.11.</span> <span class="nav-text">常用模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#functools"><span class="nav-number">1.11.1.</span> <span class="nav-text">functools</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用标准模块"><span class="nav-number">1.11.2.</span> <span class="nav-text">常用标准模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用三方模块"><span class="nav-number">1.11.3.</span> <span class="nav-text">常用三方模块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pdb调试"><span class="nav-number">1.12.</span> <span class="nav-text">pdb调试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简介-1"><span class="nav-number">1.12.1.</span> <span class="nav-text">简介</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程"><span class="nav-number">1.13.</span> <span class="nav-text">进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fork方法"><span class="nav-number">1.13.1.</span> <span class="nav-text">fork方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#简介-2"><span class="nav-number">1.13.1.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用"><span class="nav-number">1.13.1.2.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多个fork"><span class="nav-number">1.13.1.3.</span> <span class="nav-text">多个fork</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复习-1"><span class="nav-number">1.13.1.4.</span> <span class="nav-text">复习</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过Process对象创建子进程"><span class="nav-number">1.13.2.</span> <span class="nav-text">通过Process对象创建子进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实例-4"><span class="nav-number">1.13.2.1.</span> <span class="nav-text">实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Process常用方法"><span class="nav-number">1.13.2.2.</span> <span class="nav-text">Process常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Process常用属性"><span class="nav-number">1.13.2.3.</span> <span class="nav-text">Process常用属性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过Prcess子类创建子进程"><span class="nav-number">1.13.3.</span> <span class="nav-text">通过Prcess子类创建子进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实例-5"><span class="nav-number">1.13.3.1.</span> <span class="nav-text">实例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程池"><span class="nav-number">1.13.4.</span> <span class="nav-text">进程池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实例-6"><span class="nav-number">1.13.4.1.</span> <span class="nav-text">实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#multiprocessing-Pool函数解析"><span class="nav-number">1.13.4.2.</span> <span class="nav-text">multiprocessing.Pool函数解析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息队列"><span class="nav-number">1.13.5.</span> <span class="nav-text">消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#进程之间"><span class="nav-number">1.13.5.1.</span> <span class="nav-text">进程之间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程池-1"><span class="nav-number">1.13.5.2.</span> <span class="nav-text">进程池</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#感受"><span class="nav-number">1.13.6.</span> <span class="nav-text">感受</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程"><span class="nav-number">1.14.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程简介"><span class="nav-number">1.14.1.</span> <span class="nav-text">线程简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例-7"><span class="nav-number">1.14.2.</span> <span class="nav-text">实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数"><span class="nav-number">1.14.3.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程创建方式"><span class="nav-number">1.14.4.</span> <span class="nav-text">线程创建方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程的几种状态"><span class="nav-number">1.14.5.</span> <span class="nav-text">线程的几种状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程之间通信"><span class="nav-number">1.14.6.</span> <span class="nav-text">线程之间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#共享全局变量"><span class="nav-number">1.14.6.1.</span> <span class="nav-text">共享全局变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#传参方式"><span class="nav-number">1.14.6.2.</span> <span class="nav-text">传参方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程安全"><span class="nav-number">1.14.6.3.</span> <span class="nav-text">线程安全</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程锁"><span class="nav-number">1.14.6.4.</span> <span class="nav-text">线程锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁"><span class="nav-number">1.14.6.5.</span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用锁使线程顺序执行"><span class="nav-number">1.14.6.6.</span> <span class="nav-text">使用锁使线程顺序执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Queue模块"><span class="nav-number">1.14.6.7.</span> <span class="nav-text">Queue模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocal变量"><span class="nav-number">1.14.6.8.</span> <span class="nav-text">ThreadLocal变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复习-2"><span class="nav-number">1.14.6.9.</span> <span class="nav-text">复习</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#【新】协程"><span class="nav-number">1.15.</span> <span class="nav-text">【新】协程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#介绍"><span class="nav-number">1.15.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#greenlet使用"><span class="nav-number">1.15.2.</span> <span class="nav-text">greenlet使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gevent"><span class="nav-number">1.15.3.</span> <span class="nav-text">gevent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并发下载器"><span class="nav-number">1.15.4.</span> <span class="nav-text">并发下载器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复习-3"><span class="nav-number">1.15.5.</span> <span class="nav-text">复习</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络简介"><span class="nav-number">1.16.</span> <span class="nav-text">网络简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#socket-udp"><span class="nav-number">1.17.</span> <span class="nav-text">socket-udp</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-1"><span class="nav-number">1.17.1.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#udp应用"><span class="nav-number">1.17.2.</span> <span class="nav-text">udp应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#收发数据"><span class="nav-number">1.17.3.</span> <span class="nav-text">收发数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tftp"><span class="nav-number">1.18.</span> <span class="nav-text">tftp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#socket-tcp"><span class="nav-number">1.19.</span> <span class="nav-text">socket-tcp</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#服务器流程："><span class="nav-number">1.19.1.</span> <span class="nav-text">服务器流程：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#客户端历程"><span class="nav-number">1.19.2.</span> <span class="nav-text">客户端历程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多路复用"><span class="nav-number">1.20.</span> <span class="nav-text">多路复用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#select"><span class="nav-number">1.20.1.</span> <span class="nav-text">select</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll只有linux用"><span class="nav-number">1.20.2.</span> <span class="nav-text">epoll只有linux用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络工具"><span class="nav-number">1.21.</span> <span class="nav-text">网络工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NetAssist-网络调试助手"><span class="nav-number">1.21.1.</span> <span class="nav-text">NetAssist:网络调试助手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wireShark-网络抓波工具"><span class="nav-number">1.21.2.</span> <span class="nav-text">wireShark:网络抓波工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tftpd32：tftp服务器"><span class="nav-number">1.21.3.</span> <span class="nav-text">tftpd32：tftp服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Packet-Tracer"><span class="nav-number">1.21.4.</span> <span class="nav-text">Packet Tracer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库"><span class="nav-number">1.22.</span> <span class="nav-text">数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mycat"><span class="nav-number">1.22.1.</span> <span class="nav-text">mycat</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#python下mysql的使用"><span class="nav-number">1.22.2.</span> <span class="nav-text">python下mysql的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#安装"><span class="nav-number">1.22.2.1.</span> <span class="nav-text">安装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Connection对象"><span class="nav-number">1.22.2.2.</span> <span class="nav-text">Connection对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cursor对象"><span class="nav-number">1.22.2.3.</span> <span class="nav-text">Cursor对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实例-8"><span class="nav-number">1.22.2.4.</span> <span class="nav-text">实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他"><span class="nav-number">1.22.2.5.</span> <span class="nav-text">其他</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#其他-1"><span class="nav-number">2.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本语句"><span class="nav-number">2.1.</span> <span class="nav-text">基本语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#xxx-xxx-xxx"><span class="nav-number">2.1.1.</span> <span class="nav-text">xxx, _xxx, __xxx</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#上下文管理器with"><span class="nav-number">2.1.2.</span> <span class="nav-text">上下文管理器with:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调试："><span class="nav-number">2.1.3.</span> <span class="nav-text">调试：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本模块"><span class="nav-number">2.2.</span> <span class="nav-text">基本模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#语言特色"><span class="nav-number">2.3.</span> <span class="nav-text">语言特色</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-C内存管理"><span class="nav-number">2.3.1.</span> <span class="nav-text">C++/C内存管理</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sun</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
