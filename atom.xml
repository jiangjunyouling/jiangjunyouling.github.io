<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>思 见</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-25T03:24:25.045Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>sun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>http识别</title>
    <link href="http://yoursite.com/2018/07/25/http%E8%AF%86%E5%88%AB%E3%80%81%E8%AE%A4%E8%AF%81/"/>
    <id>http://yoursite.com/2018/07/25/http识别、认证/</id>
    <published>2018-07-25T03:24:25.045Z</published>
    <updated>2018-07-25T03:24:25.045Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了客户端的识别，包括ip、胖url、cookie<br><a id="more"></a></p><h1 id="客户端识别"><a href="#客户端识别" class="headerlink" title="客户端识别"></a>客户端识别</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>无状态<br>HTTP最初是一个匿名、无状态的请求/响应协议。服务器处理来自客户的请求，然后向客户回送一条响应。web服务器几乎没有什么信息可以判断是哪个用户发送的请求，也无法记录访问用户的请求序列。</li><li><p>有状态<br>现在，他们需要对客户端有更多的了解，并在用户浏览页面时，对其进行跟踪。<br>如今一般在用的技术有：用户登录、胖url、cookie（ip技术已经基本淘汰）</p><h2 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h2><p>早期开发者曾尝试将客户端的ip地址作为一种标识形式使用。web服务器可以找到http对应的tcp连接，调用类似与getpeername(tcp_socket,…)函数来获取ip</p></li><li><p>存在问题：<br>1.ip记录的是机器，而不是用户，在多人共享一台机器时就无法区分。<br>2.动态分配ip</p><ol><li>NAT防火墙会隐藏后边那些实际客户端的ip</li><li>代理的存在，web服务看到的是代理的ip<h2 id="用户登录：Authorization首部，即认证"><a href="#用户登录：Authorization首部，即认证" class="headerlink" title="用户登录：Authorization首部，即认证"></a>用户登录：Authorization首部，即认证</h2></li></ol></li><li>用户访问服务器</li><li>服务器返回401</li><li>浏览器显示登录框</li><li>在请求时用Authorization首部在下一条对服务器请求提供这些信息<br>这个部分就是基本认证部分：<br>[[../image/http/基本认证.png]]</li></ul><h2 id="胖url"><a href="#胖url" class="headerlink" title="胖url"></a>胖url</h2><ul><li><p>web服务器为每个用户生成特定版本的URL来追踪用户的身份。通常会对真正的URL进行扩展，在URL路径结束的地方添加一些状态信息。用户浏览网页时，web服务器动态生成一些超连接，继续维护URL中的状态信息。</p></li><li><p>存在问题：<br>丑陋的url<br>无法共享URL，共享时可能泄密<br>破坏缓存，不再有可供公共访问的url需要缓存<br>额外的服务器负荷</p></li></ul><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><ul><li><p>cookie如何工作<br>[[../image/http/cookie.png]]<br>首次访问时，web服务器给用户“拍上”一个独有的cookie，浏览器记住服务器返回Set-Cookie首部中cookie内容，并将cookie存储在浏览器的cookie数据库中。将来用户访问同一站点时，浏览器会挑中那个服务器用户上的cooike，将其传送回去。</p></li><li><p>cookie组成<br>网景的cookie会将cookie存在一个cookies.txt文本文件中如：<br>| 名称       | 值            | 说明                           |<br>| domain     | <a href="http://www.fedex.com" target="_blank" rel="noopener">www.fedex.com</a> | 域                             |<br>| allh       | FALSE         | 是域中所有的主机都获取cookie？ |<br>| path       | /             | 域中与cookie相关的路径前缀     |<br>| secure     | FALSE         | 是否只有SSL才发送这个cookie    |<br>| expiration | 1136109676    | 过期时间间隔                   |<br>| name       | cc            | cookie变量的名字               |<br>| value      | /us/          | cookie变量的值                 |</p><p>domain:<br>告诉浏览器，只有往这个域访问时才使用此cookie<br>set-cookie: user=”mary17”; domain=”airtravelbargains.com”</p><p>path:<br>告诉浏览器，只有往域的这个路径访问时，才是有此cookie<br>set-cookie: user=”mary17”; domain=”airtravelbargains.com”; path=/autos/</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了客户端的识别，包括ip、胖url、cookie&lt;br&gt;
    
    </summary>
    
      <category term="数据" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>htto协议基础</title>
    <link href="http://yoursite.com/2018/07/25/http%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/07/25/http协议基础/</id>
    <published>2018-07-25T03:23:16.613Z</published>
    <updated>2018-07-25T03:23:16.613Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍http的协议基础：主要包括报文的结构、请求的方法、url、状态码、header，以及http的连接</p><a id="more"></a><h1 id="报文协议基础"><a href="#报文协议基础" class="headerlink" title="报文协议基础"></a>报文协议基础</h1><h2 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h2><h3 id="起始行"><a href="#起始行" class="headerlink" title="起始行"></a>起始行</h3> <!-- ![test](/images/curiosity.jpg) --><p><img src="Http报文.png" alt="test"><br>如图：<br>请求报文起始行：方法 url 协议类型<br>响应报文起始行：协议类型 响应码 响应码的说明</p><h3 id="首部"><a href="#首部" class="headerlink" title="首部"></a>首部</h3><p>部首就是一系列键值对组合，用来说明连接及主体的数据的意义。下边会着重介绍请求与响应报文的相应首部。</p><h3 id="主体"><a href="#主体" class="headerlink" title="主体"></a>主体</h3><p>由任意数据组成的数据块。如上可以直接是字符串，上传的文件，表单等数据。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><table><thead><tr><th>方法</th><th style="text-align:center">描述</th><th style="text-align:right">是否包含主体</th></tr></thead><tbody><tr><td>GET</td><td style="text-align:center">从服务器获取资源</td><td style="text-align:right">N</td></tr><tr><td>HEAD</td><td style="text-align:center">只获取资源的首部</td><td style="text-align:right">N</td></tr><tr><td>POST</td><td style="text-align:center">发送需要处理的数据</td><td style="text-align:right">Y</td></tr><tr><td>PUT</td><td style="text-align:center">将主体部分存储在服务器上</td><td style="text-align:right">Y</td></tr><tr><td>TRACE</td><td style="text-align:center">追踪报文路径</td><td style="text-align:right">N</td></tr><tr><td>OPTIONS</td><td style="text-align:center">在服务器上可以执行哪些方法</td><td style="text-align:right">N</td></tr><tr><td>DELETE</td><td style="text-align:center">从服务器上删除文件.与put相对</td><td style="text-align:right">N</td></tr></tbody></table><ul><li>HEAD<br>与GET行为类似，但服务器只返回首部。一般用于：<ul><li>通过状态码，查看资源是否存在</li><li>在不获取资源情况下了解资源的类型</li><li>通过首部，测试资源是否被修改？【这个还不明白，难道是对比资源的长度】</li></ul></li><li><p>PUT与POST<br>put方法与post方法都是往服务器上传数据。put语义是让服务器用请求主体数据来创建一个由所请求url命名的新文档。如果已经存在，则替换它。<br>post将表单数据发送的服务器。<br>现在这里文件上传时，一般也是用post表单的方式上传。<br>put区分？</p></li><li><p>TRACE<br><img src="TRACE方法.png" alt="test"><br>如上图所示，主要用于验证请求穿过的代理</p></li><li><p>OPTIONS<br><img src="OPTIONS方法.png" alt="test"><br>用于请求服务器告知其支持的各种方法.</p><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2></li><li><p>组成部分<br><img src="URL组成.png" alt="test"></p><ul><li>URL的sheme，也就是协议类型，https/http/ftp等等</li><li>服务器位置</li><li>资源路径</li></ul></li><li><p>格式<br><img src="url格式.png" alt="test"></p></li><li><p>相对url</p><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2></li></ul><h3 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h3><table><thead><tr><th>整体范围</th><th style="text-align:center">已定义范围</th><th style="text-align:right">分类</th></tr></thead><tbody><tr><td>100-199</td><td style="text-align:center">100-101</td><td style="text-align:right">信息提示</td></tr><tr><td>200-299</td><td style="text-align:center">200-206</td><td style="text-align:right">成功</td></tr><tr><td>300-399</td><td style="text-align:center">300-305</td><td style="text-align:right">重定向</td></tr><tr><td>400-499</td><td style="text-align:center">400-415</td><td style="text-align:right">客户端错误</td></tr><tr><td>500-599</td><td style="text-align:center">500-505</td><td style="text-align:right">服务器错误</td></tr></tbody></table><h3 id="常见："><a href="#常见：" class="headerlink" title="常见："></a>常见：</h3><table><thead><tr><th>状态码</th><th style="text-align:center">原因</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>200</td><td style="text-align:center">OK</td><td style="text-align:right"></td></tr><tr><td>201</td><td style="text-align:center">Created</td><td style="text-align:right">创建成功</td></tr><tr><td>202</td><td style="text-align:center">Accepted</td><td style="text-align:right">请求被接受</td></tr><tr><td>300</td><td style="text-align:center">Multiple Choices</td><td style="text-align:right">url指向多个资源，Location</td></tr><tr><td>301</td><td style="text-align:center">Moved Permanently</td><td style="text-align:right">URL被移到Location</td></tr><tr><td>302</td><td style="text-align:center">Found</td><td style="text-align:right">URL临时定位资源到Location</td></tr><tr><td>400</td><td style="text-align:center">Bad Requese</td><td style="text-align:right">错误请求</td></tr><tr><td>401</td><td style="text-align:center">Unauthorized</td><td style="text-align:right">未授权，未登录</td></tr><tr><td>403</td><td style="text-align:center">Forbidden</td><td style="text-align:right">禁止访问</td></tr><tr><td>404</td><td style="text-align:center">Not Found</td><td style="text-align:right">没有url对应资源</td></tr><tr><td>405</td><td style="text-align:center">Method Not Allowed</td><td style="text-align:right"></td></tr><tr><td>406</td><td style="text-align:center">Not Acception</td><td style="text-align:right">客户端指令资源类型，服务器没有</td></tr><tr><td>500</td><td style="text-align:center">InternelServerErro</td><td style="text-align:right">服务器内部错误</td></tr><tr><td>502</td><td style="text-align:center">Bad Gateway</td><td style="text-align:right">代理无法连接到父网关</td></tr><tr><td>503</td><td style="text-align:center">Service Unavailabe</td><td style="text-align:right">服务器无法提供服务</td></tr></tbody></table><h2 id="首部Header"><a href="#首部Header" class="headerlink" title="首部Header"></a>首部Header</h2><h3 id="通用首部"><a href="#通用首部" class="headerlink" title="通用首部"></a>通用首部</h3><p>客户端与服务端通用的首部，常见如下</p><table><thead><tr><th>首部</th><th style="text-align:right">描述</th></tr></thead><tbody><tr><td>Connection</td><td style="text-align:right">指定请求/响应连接有关选项</td></tr><tr><td>Date</td><td style="text-align:right">报文创建时间</td></tr><tr><td>Transfer-Encoding</td><td style="text-align:right">报文编码的方式</td></tr><tr><td>Trailer</td><td style="text-align:right">报文采用分块传输编码时，列出报trailer信息</td></tr><tr><td>via</td><td style="text-align:right">trace方法时，经过的中间节点</td></tr><tr><td>Cache-Control</td><td style="text-align:right">随报文传送缓存指示</td></tr></tbody></table><h3 id="请求首部"><a href="#请求首部" class="headerlink" title="请求首部"></a>请求首部</h3><p>客户端特有首部，为服务器提供一些额外的（客户端）信息。</p><table><thead><tr><th>首部</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>Client-IP</td><td style="text-align:center">客户端ip</td></tr><tr><td>From</td><td style="text-align:center">客户端email</td></tr><tr><td>Host</td><td style="text-align:center">请求服务器的ip与端口（一般是url）</td></tr><tr><td>Referer</td><td style="text-align:center">提供了当前uri文档的url</td></tr><tr><td>User-Agent</td><td style="text-align:center">浏览器名</td></tr><tr><td>Accept</td><td style="text-align:center">告知服务器应该发送那些类型</td></tr><tr><td>Accept-Charset</td><td style="text-align:center">告知服务器字符集</td></tr><tr><td>Accept-Encoding</td><td style="text-align:center">告知服务器编码方式</td></tr><tr><td>If-Match</td><td style="text-align:center">条件请求：标记匹配，则请求</td></tr><tr><td>Authorization</td><td style="text-align:center">安全请求：认证数据</td></tr><tr><td>Cookie</td><td style="text-align:center">安全请求：cookie</td></tr></tbody></table><h3 id="响应首部"><a href="#响应首部" class="headerlink" title="响应首部"></a>响应首部</h3><p>服务器特有首部，为客户的提供信息</p><table><thead><tr><th>首部</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>Age</td><td style="text-align:center">响应持续时间</td></tr><tr><td>Public</td><td style="text-align:center">服务器为其资源提供的请求方法列表</td></tr><tr><td>Proxy-Authenticate</td><td style="text-align:center">安全响应：代理对客户端的质询列表</td></tr><tr><td>Set-Cookie</td><td style="text-align:center">安全响应：设置cookie</td></tr><tr><td>WWW-Authenticate</td><td style="text-align:center">安全响应：服务器对客户端的质询列表</td></tr></tbody></table><h3 id="实体首部"><a href="#实体首部" class="headerlink" title="实体首部"></a>实体首部</h3><p>用于对应主体部分的首部</p><table><thead><tr><th>首部</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>Content-Type</td><td style="text-align:center">主体类型</td></tr><tr><td>Content-Length</td><td style="text-align:center">主体长度或尺寸</td></tr><tr><td>Content-Location</td><td style="text-align:center">资源实际所处位置</td></tr><tr><td>Content-Encoding</td><td style="text-align:center">主体编码方式</td></tr><tr><td>Content-MD5</td><td style="text-align:center">主体MD5校验和</td></tr><tr><td>Content-Base</td><td style="text-align:center">相对URL的基URL</td></tr><tr><td>Last-Modified</td><td style="text-align:center">实体最后一次被修改的时间</td></tr><tr><td>Expires</td><td style="text-align:center">实体过期，要从源端再次获取时间与日期</td></tr></tbody></table><h1 id="连接："><a href="#连接：" class="headerlink" title="连接："></a>连接：</h1><h2 id="Connection首部"><a href="#Connection首部" class="headerlink" title="Connection首部"></a>Connection首部</h2><p>  浏览器与服务器之间，可以经过很多层代理，整个连接被分成了好多块小的连接。Connection首部由一个逗号分隔的标签列表，这些标签指定了在小连接之间的选项，不会传播到其它小连接上去。<br>  接收端接收到Connection首部时，首先会解析这些选线，并将其应用。然后在此报文转发给下一跳之前，删除Connection首部及列表中的所有首部。</p><p>  http首部字段名标签包括：<br>  Http首部字段名，列出只与此连接相关的首部<br>  任意标签值，用于描述此连接的非标准选项<br>  close，说明操作完成之后需关这条连接。</p><h2 id="串行加载"><a href="#串行加载" class="headerlink" title="串行加载"></a>串行加载</h2><p><img src="串行连接.png" alt="test"><br>如上图，一个网页有3个图片，串行加载需要4个http事物来显示页面，每个事物都需要建立一个新的连接，这样整个网页加载的速度就会累加起来。</p><h2 id="并行连接"><a href="#并行连接" class="headerlink" title="并行连接"></a>并行连接</h2><p><img src="并行连接.png" alt="test"><br>如图，并行连接就是并发4个连接去请求资源，这样加载速度就会提升。<br>并行连接受到带宽、内存的影响，会引起很多问题。<br>一般浏览器确实使用并行连接，但连接数会很小（通常4个）。</p><h2 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h2><p><img src="并行连接.png" alt="test"><br>如图，持久连接就是4个资源在一个连接中去请求，这样就避免了重新建立连接带来的延时。</p><ul><li><p>Keep-Alive操作<br>客户端通过Connection:Keep-Alive首部请求持久连接<br>服务器如果愿意建立持久连接，就在相应首部中返回Connection:Keep-Alive，反之没有<br>客户端若接收到Keep-Alive，则建立持久连接，反之就会关闭连接。</p></li><li><p>哑代理<br><img src="哑连接.png" alt="test"><br>哑代理就是一些老代理，他们不支持持久连接，而且会转发所有的首部，包括Connection:Keep-Alive。这样就造成浏览器与服务器都认为可以建立持久连接，而哑代理却忽略与客户端连接上的再次请求(半关闭)，造成持久连接失败。</p><p>一种解决方案：Proxy-Connection。这里就不展开了，这种方案也存在问题，仅当服务器与浏览器之间存在一个代理时可用。反之不可。</p></li><li><p>http/1.1持久连接<br>http/1.1用Persistent Connection来代替Keep-Alive.Http/1.1持久连接在默认情况下是激活的，需要关闭时显示添加Connection:close首部来关闭。</p></li></ul><h2 id="管道化连接"><a href="#管道化连接" class="headerlink" title="管道化连接"></a>管道化连接</h2><p><img src="管道化持久连接.png" alt="test"><br>HTTP/1.1允许在建立可选的请求管道。在相应到达之前，经多条请求放入发送队列。</p><ul><li><p>连接关闭<br>任何一种技术都会有其要解决的问题，也有其带来的问题，如管道连接。管道连接带来的问题是由于服务器可以随意关闭连接，客户端发送出的连接还未到达，连接就关闭了，这样就造成了客户端并不知道发送的数据到了没有。另外服务器永远无法确定在关闭“空闲”连接那一刻，在线路另一端有没有数据要发送。<br>这个挺费解的，tcp关闭是4次握手，一端关闭会发送关闭，等待ack后才进入半关闭状态？</p><p>每条HTTP响应都应有精确的Content-Length首部。这样接收端可以根据若实体长度与Content-Length匹配来确定连接是否完成。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍http的协议基础：主要包括报文的结构、请求的方法、url、状态码、header，以及http的连接&lt;/p&gt;
    
    </summary>
    
      <category term="数据" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>http网络结构</title>
    <link href="http://yoursite.com/2018/07/25/http%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2018/07/25/http网络结构/</id>
    <published>2018-07-25T03:21:17.289Z</published>
    <updated>2018-07-25T03:21:17.289Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍http的网络结构：包括web服务器、中间层（代理/网关/隧道等）、客户端（爬虫）<br><a id="more"></a></p><h1 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h1><h2 id="web服务器："><a href="#web服务器：" class="headerlink" title="web服务器："></a>web服务器：</h2><h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h3><p>Web服务器逻辑实现了HTTP协议，管理着Web资源，并负责提供Web服务器的管理功能。</p><h3 id="小实现-跟tcp服务端编写一样"><a href="#小实现-跟tcp服务端编写一样" class="headerlink" title="小实现:跟tcp服务端编写一样"></a>小实现:跟tcp服务端编写一样</h3><p><img src="Web服务器.png" alt=""></p><ul><li>建立连接：接受一个客户端连接</li><li>接收请求：从网络中读取一条HTTP请求报文</li><li>处理请求：对请求报文进行解释，并采取行动</li><li>访问资源：访问报文中指定的资源</li><li>构建响应：构建带有正确首部的HTTP响应报文</li><li>发送响应：将相应报文发送给的客户端</li><li>记录事务处理过程：将事务有关的内容记录在日志文件中<h2 id="中间商"><a href="#中间商" class="headerlink" title="中间商"></a>中间商</h2><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3></li><li><p>代理位于客户端与服务器之间，于是它既是服务器也是客户端。Http客户端会向代理发生报文，代理必须像Web服务器一样，正确地处理请求和连接，然后返回响应。同时，代理自身要向服务器发送请求。<br>攻守兼备^_^</p></li><li><p>代理vs网关<br>严格说，代理连接的是2个使用相同协议的应用程序，而网关是不同协议，但其实人为设定，它们从设计模式上看，都是代理。</p></li></ul><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><ul><li><p>出口代理<br>本地网络的出口，便于控制本地网络与外部网络之间的流量。小学使用出口代理防止早熟的少年浏览不该浏览的内容。</p></li><li><p>反向代理<br>部署在Web服务器前，处理所有传送给Web服务器的求，并只在必要时间向Web服务器请求资源。如：Nginx。感觉这才是入口代理。</p></li><li><p>网络交换代理（中间代理）<br>可以将具有足够能力的代理放在网络之间的对等交换点上，通过缓存在减轻因特网节点的拥堵，并对流量进行监视。<br>PS：这一块书上表述不清，它的入口代理感觉就是缓存，也就是这里的交换代理，故删掉。</p></li></ul><h4 id="代理获取流量的方式"><a href="#代理获取流量的方式" class="headerlink" title="代理获取流量的方式"></a>代理获取流量的方式</h4><ul><li><p>修改客户端<br>手动修改浏览器的代理配置</p></li><li><p>修改网络【拦截】<br>通过网络基础设施（交换机、路由器），通过技术手段在没有客户端参与情况下，拦截网络流量并将其导入代理。</p></li><li><p>修改DNS的命名空间【反向代理】<br>反向代理会直接加班Web服务器的名字和IP。可以手动编辑DNS名称列表，或者用特殊的动态DNS服务器根据需要来确定适当的代理或者服务器。</p></li><li><p>修改Web服务器<br>重定向命令到代理上</p></li></ul><h4 id="与代理相关问题"><a href="#与代理相关问题" class="headerlink" title="与代理相关问题"></a>与代理相关问题</h4><ul><li>代理请求URI与服务器uri差异<br>客户端向web服务器发送请求，请求行只包括部分URI；而向代理发送，会包含全部<br><img src="URI差异.png" alt=""></li><li>拦截和反向代理对主机信息的隐藏<h4 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h4><img src="追踪.png" alt=""></li><li>TRACE方法</li><li>Via首部<h4 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h4>由于客户端、服务器、代理实现不同版本HTTP规范，以及对特性支持各不相同，可能会存在一些棘手问题。<br>可以通过OPTIONS方法，客户端（代理）可以发现Web服务器或者某个特定资源所支持的功能（所支持的方法）。这样在正式交互之前，确定服务器的能力。</li><li>Allow首部<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><h4 id="代理解决的问题：慢"><a href="#代理解决的问题：慢" class="headerlink" title="代理解决的问题：慢"></a>代理解决的问题：慢</h4></li><li>冗余数据传输</li><li>带宽瓶颈</li><li>瞬时拥塞</li><li>距离延时<h4 id="处理问题所用的方法"><a href="#处理问题所用的方法" class="headerlink" title="处理问题所用的方法"></a>处理问题所用的方法</h4><img src="缓存命中.png" alt=""><br>如图即可，采用的方法与电脑的缓存相同。<h4 id="代理的处理步骤：对比服务器7步骤"><a href="#代理的处理步骤：对比服务器7步骤" class="headerlink" title="代理的处理步骤：对比服务器7步骤"></a>代理的处理步骤：对比服务器7步骤</h4><img src="缓存步骤.png" alt=""></li><li>接收：缓存请求报文</li><li>解析：解析报文，提出URL与首部</li><li>查询：查询是否有本地副本可用，没有就获取一份，并存在本地</li><li>新鲜度检测：就是确定数据一致性</li><li>创建响应</li><li>发送响应</li><li>日志</li></ul><p>则合理用过If-Modified-Since/If-None-Match等首部</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>为了保证新鲜度（数据一致性）采用了很多的算法，这里不在叙述了</li><li>缓存和广告：这个挺有意思<br>ISP的很多收益通过广告来实现，每次点击广告就收取一定的收益。而代理会隐藏实际的次数，这样就使服务器收益降低。^_^<h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><h4 id="网关要解决的问题"><a href="#网关要解决的问题" class="headerlink" title="网关要解决的问题"></a>网关要解决的问题</h4>网络上的资源太多了，这些资源的获取使用不同的协议来访问，于是通过http就不能实现对资源的访问。从一个角度上看，网关就是协议的转换，将http转换成其他协议来实现资源的访问，从另一个角度看，网关就是把其他协议访问资源做http代理，使其能被共有的http协议访问。<h4 id="几种网关"><a href="#几种网关" class="headerlink" title="几种网关"></a>几种网关</h4></li><li>协议网关：HTTP/FTP服务器端FTP网关<br><img src="HTTP_FTP网关.png" alt=""><br>网关接收到请求后，会打开一条与FTP服务器端口（21）的FTP连接，通过FTP协议获取对象。</li><li><p>协议网关：HTTPS/HTTP客户端安全网关<br><img src="http_https网关.png" alt=""><br>对http进行加密，对https进行解密完成协议转换。</p></li><li><p>资源网关：HTTP/CGI服务器端应用程序网关<br>资源网关其实就是服务器，这时候它不是返回文件，而是调用应用程序。<br>CGI（Common Gateway Interface）:其实就是Web服务器调用应用程序的接口，Web服务用它来装载程序以响应URL的请求，并收集程序的输出数据，将其在http响应中回送。</p><h3 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h3></li><li><p>概述<br>web隧道允许用户通过HTTP连接发送非HTTP流量，这样可以在http上稍带其他协议数据。使用web隧道最常见的原因是在http连接中嵌入非http流量，这样，这些流量就可以穿过只允许web流量穿过的防火墙。<br><img src="隧道.png" alt=""><br>隧道就是用http报文发送ssl协议报文，来穿过防火墙。</p></li><li><p>SSL与http/https网关对比<br>网关需要完整的ssl实现，来完成http/https的转换<br>隧道连接本质是ssl，只是中间一段用http报文来传输。</p><h2 id="Web客户端：爬虫"><a href="#Web客户端：爬虫" class="headerlink" title="Web客户端：爬虫"></a>Web客户端：爬虫</h2><h3 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h3></li><li><p>爬虫是一种机器人，它们会递归的对各种web站点进行遍历，获取第一个web页面，然后从那个页面中解析指向的其他页面，接着爬取那些页面，依次类推的爬取。</p></li><li><p>根集选择<br>在Web结构中，有些页面是独立的，没有任何连接指向它们。如下图：<br><img src="网络结构示意图.png" alt=""><br>要遍历整个网络，根集可以选择A、G、S</p><h3 id="爬虫面对的问题"><a href="#爬虫面对的问题" class="headerlink" title="爬虫面对的问题"></a>爬虫面对的问题</h3></li><li><p>机器人爬行时，要避免环路。环路就是几个页面相互引用成环，使爬虫一直在这些页面中重复爬行。</p></li><li><p>文件系统连接环路<br>符号链接引起:<br><img src="文件系统环路.png" alt=""></p></li><li><p>动态虚拟web空间<br>有的应用程序可以在传输中构造出包含同一服务器上虚拟URL连接的HTML。 当爬虫去请求时，这个“邪恶”的服务器会捏造出带有新的URL的新HTML来。</p><h3 id="爬虫HTTP"><a href="#爬虫HTTP" class="headerlink" title="爬虫HTTP"></a>爬虫HTTP</h3><p>鼓励爬虫加入一些识别首部，这样在追踪错误爬虫时，或者向服务器提供爬虫所能处理内容类型时，是有用的。</p></li><li><p>User-Agent<br>将爬虫的名字告知服务器</p></li><li><p>From<br>提供机器人管理者的email</p></li><li><p>accept<br>告知服务器可以发送哪些类型（文本、图片等）</p></li><li><p>referer<br>有些站点管理者尝试记录机器人是如何找到其站点的</p></li><li><p>host<br>一个主机有多个域名，若不指明host，可能获取错内容。</p><h3 id="爬虫要遵守的规范：robots-txt"><a href="#爬虫要遵守的规范：robots-txt" class="headerlink" title="爬虫要遵守的规范：robots.txt"></a>爬虫要遵守的规范：robots.txt</h3></li><li>web服务器可以在服务器文档根目录提供一个可选的、名为robots.txt的文件。这个文件说明机器人可以访问服务的哪些部分。</li><li><p>爬虫在请求页面时，要先去查看robots.txt文件，看它是否有访问的权限。</p></li><li><p>robots.txt文件的格式<br>User-Agent：slurp<br>User-Agent: webcrawler<br>Disallow:/private</p><p>User-Agent:*<br>Disallow</p><p>以一个或者多个User-Agent开始，说明哪些机器人会受此记录影响，然后跟着Disallow和Allow，说明这些机器人可以访问哪些URL</p><h3 id="爬虫的应用：搜索引擎"><a href="#爬虫的应用：搜索引擎" class="headerlink" title="爬虫的应用：搜索引擎"></a>爬虫的应用：搜索引擎</h3><p><img src="搜索引擎.png" alt=""><br>搜索引擎爬虫搜索web页面，然后将内容添加全文索引数据库中。用户引擎文章对全文索引进行查询。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍http的网络结构：包括web服务器、中间层（代理/网关/隧道等）、客户端（爬虫）&lt;br&gt;
    
    </summary>
    
      <category term="数据" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>python进阶</title>
    <link href="http://yoursite.com/2018/07/25/python%E8%BF%9B%E9%98%B6/"/>
    <id>http://yoursite.com/2018/07/25/python进阶/</id>
    <published>2018-07-25T02:36:35.000Z</published>
    <updated>2018-07-25T03:18:16.501Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要包括：闭包与装饰器，内存管理，常用的模块介绍，pdb调试，进程及线程，python网络(tcp/udp/select/poll)，数据库等<br><a id="more"></a></p><h1 id="python进阶"><a href="#python进阶" class="headerlink" title="python进阶"></a>python进阶</h1><h2 id="模块与导入模块的路径设置"><a href="#模块与导入模块的路径设置" class="headerlink" title="模块与导入模块的路径设置"></a>模块与导入模块的路径设置</h2><ul><li><p>查看模块搜索路径<br>import sys<br>sys.path<br>所谓模块的搜索路径，指的是path执行import时，搜索的路径，这点有点像Windows的path环境变量，以上函数是查看现有的路径</p></li><li><p>添加搜索路径<br>sys.path.append(‘/home/xxx文件夹’)  #加在最后<br>sys.path.insert(‘/home/xxx文件夹’)  #加在首部<br>这两个函数是添加新的路径</p></li><li><p>重新导入模块<br>from imp import *<br>reload(模块名)<br>这块重新加载</p></li><li><p>查看安装的模块</p><ol><li>在交互解释器中使用help(“modules”)</li><li>import sys ; sys.modules.keys()这个会把具体的包中模块也打印出来<br>这个主要是这个help命令，可以模块名<br>help(“pygame.Rect”)</li></ol><p>dir()<br>如dir(sys)，其实就是列出给出对象的属性，这个些属性有对象的<strong>dir</strong>()提供<br>如果是module对象，只有module的属性<br>如果是类对象，会列出其本身的属性，以及基类的属性</p><h3 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h3><p>dir能列出模块中的类、对象等属性，对于自己的代码，需要先通过sys.path.insert将模块的目录导入，然后再调用dir(模块名)来查看 </p></li></ul><h3 id="循环导入"><a href="#循环导入" class="headerlink" title="循环导入"></a>循环导入</h3><ul><li>两个模块互相的导入</li><li><p>怎样避免循环导入</p></li><li><p>类似与#ifdef __DEFINE_H_H吗？</p></li></ul><h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><p>浅拷贝这里就是拷贝了引用,深拷贝就是对一个对象所有层次的拷贝。其实与C++的深浅拷贝概念相同<br>就是deepcopy会递归的copy，而浅拷贝不会<br>import copy<br>  copy.deepcopy<br>  copy.copy</p><ul><li><p>实例：<br>a = [1,2,3]<br>b = [4,5]<br>c = [a,b]<br>d = c</p><p>import copy<br>e = copy.deepcopy(c)<br>f = copy.copy(c)<br><img src="8.深拷贝.png" alt=""></p><p><img src="9.浅拷贝.png" alt=""></p></li></ul><p>浅拷贝对不可变类型和可变类型的copy不同（元组与列表）<br>  a=(1,2,3)<br>  b = copy.copy(a)<br>  a is b #True<br>  对于不可变类型的copy，其实就是a=b，引用指向相同的地址</p><h2 id="【新】生成器，yield"><a href="#【新】生成器，yield" class="headerlink" title="【新】生成器，yield"></a>【新】生成器，yield</h2><ul><li>初识(列表生成器)<br>g=(x for x in range(5))<br>g.next(),没有更多元素时,抛出StopIteration的异常<br>生成器只能用一次<br>for i in g:<pre><code>print(i)</code></pre></li><li><p>第二种方法:yield<br>def fib(times):<br>  n = 0<br>  a,b=0,1<br>  while n&lt;times:</p><pre><code>yield b   #yied投降,运行在这里就停一下,并且抛出后边的内容,调用一次next执行一次a,b=b,a+bn+=1</code></pre><p>  return ‘done’</p><p> g = fit(5)</p><p> #输出<br> next(g)<br> for x in g:</p></li><li><p>生成器方法:<strong>next</strong>()<br>g = fib(5)<br>g.<strong>next</strong>()</p></li><li><p>生成器方法:send()<br>g = fib(5)<br>g.<strong>next</strong>()  / g.send(None)<br>g.send(“hehe”)  </p><p>send给生成器传递一个参数<br>在生成器内部:<br>temp = yield b  #生成器抛出b,传递进的”哈哈”赋值给temp</p></li></ul><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="可迭代对象：iterator"><a href="#可迭代对象：iterator" class="headerlink" title="可迭代对象：iterator"></a>可迭代对象：iterator</h3><p>from collection import Iterable<br>isinstance([],Iterable)<br>集合对象<br>生成器对象</p><h3 id="迭代器：可以被next对象调用，并不断返回下一个对象"><a href="#迭代器：可以被next对象调用，并不断返回下一个对象" class="headerlink" title="迭代器：可以被next对象调用，并不断返回下一个对象"></a>迭代器：可以被next对象调用，并不断返回下一个对象</h3><p>l = [1,2,3]<br>it = iter(l)<br>next(it)  #集合本身不是迭代器<br>from collector imort Iterator<br>isinstance(it,Iterator)</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>函数内部可以再定义内部函数,内部函数对外部函数的属性可以直接引用,则称内部函数为闭包<br>2个条件:嵌套函数定义,内部函数引用外部函数变量<br>只调用内部函数时,被引用的外部函数变量,会绑定到闭包中,一定程度上延长了生命周期<br>其实可以理解为,构成闭包时,外部函数的变量声明周期到了延长到了内部</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def fun1():</span><br><span class="line">    def fun3():</span><br><span class="line">        print(&quot;fun3&quot;)</span><br><span class="line">    return fun3</span><br><span class="line">fun1()</span><br></pre></td></tr></table></figure><p>返回的是一个函数对象</p><h4 id="闭包-1"><a href="#闭包-1" class="headerlink" title="闭包"></a>闭包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def outter(num):</span><br><span class="line">    def inner(num_in):</span><br><span class="line">        print(&quot;num_in is %d&quot;%num_in)</span><br><span class="line">        return num_in+num</span><br><span class="line">    return inner</span><br><span class="line">fun = outer(20)</span><br><span class="line">fun(10)</span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="一元一次方程-y-ax-b"><a href="#一元一次方程-y-ax-b" class="headerlink" title="一元一次方程:y = ax+b"></a>一元一次方程:y = ax+b</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def line_conf(a,b):</span><br><span class="line">    def line(x):</span><br><span class="line">       return a*x + b</span><br><span class="line">    return line</span><br><span class="line">line1 = line_conf(1,1)</span><br><span class="line">line2 = line_conf(4,5)</span><br><span class="line"></span><br><span class="line">print(line1(5))</span><br><span class="line">print(line2(5))</span><br></pre></td></tr></table></figure><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>装饰器其实就是一个闭包,把一个函数当作参数,其中对函数进行包装,返回一个替代版新函数,其实与设计语言中了一样,也类似AOP<br>2个特性:<br>   一个是把被装饰的函数替代为其他函数<br>   而是可以在加载模块时立即执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def w1(func):</span><br><span class="line">   def inner():</span><br><span class="line">       #验证1</span><br><span class="line">       #验证2</span><br><span class="line">       func()</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">@w1</span><br><span class="line">def f1()</span><br><span class="line">   print(&quot;f1&quot;)</span><br></pre></td></tr></table></figure><p>其实就是AOP</p><p>装饰器内部函数的参与与被装饰的参数相同<br>不定长参数：可以将内部函数的参数设置为不定长参数，(<em>args,**kwargs)          </em>args表示任何多个无名参数，它是一个tuple；<strong>kwargs表示关键字参数，它是一个dict。并且同时使用*args和</strong>kwargs时，必须*args参数列要在**kwargs前<br>函数可以认为都有返回值，没有return时，return的是None</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li>引入日志：开放封闭原则，就是对增加开放，对修改封闭</li><li>函数执行时间统计</li><li>执行函数前预备处理</li><li>执行函数后清理功能</li><li>全校校验</li><li>缓存<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def makeBold(fn):</span><br><span class="line">   def wrapped():</span><br><span class="line">      return &quot;&lt;b&gt;&quot; + fn() + &quot;&lt;/b&gt;&quot;</span><br><span class="line"></span><br><span class="line">@makeBold</span><br><span class="line">def test1():</span><br><span class="line">   return &quot;hello world&quot;</span><br><span class="line"></span><br><span class="line">print(test1())</span><br></pre></td></tr></table></figure><h3 id="通用装饰器"><a href="#通用装饰器" class="headerlink" title="通用装饰器"></a>通用装饰器</h3><ul><li>不定长参数</li><li>带返回值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from time import ctime</span><br><span class="line">def doca(fun):</span><br><span class="line">   def wrapper(*args,**kwargs):</span><br><span class="line">      print(&quot;%s called at %s&quot;%(fun.__name__,ctime()))</span><br><span class="line">      ret = fun()</span><br><span class="line">      return ret</span><br><span class="line">   return wrapper</span><br><span class="line"></span><br><span class="line">@doca</span><br><span class="line">def foo():</span><br><span class="line">  print(&quot;i am foo&quot;)</span><br><span class="line"></span><br><span class="line">@doca</span><br><span class="line">def gegInfo():</span><br><span class="line">   return &quot;--hehe--&quot;</span><br><span class="line"></span><br><span class="line">@doca</span><br><span class="line">def sum(a,b):</span><br><span class="line">  return a+b</span><br></pre></td></tr></table></figure><h2 id="动态语言特性"><a href="#动态语言特性" class="headerlink" title="动态语言特性"></a>动态语言特性</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>动态语言：在运行过程中，可以修改代码,大多数脚本语言：python,JavaScript,PHP,Ruby<br>静态语言：编译时已经确定好的代码，运行过程中不能修改,C,C++,Java</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>为对象动态添加属性</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line">    def __init__(self,name=None,age=None)</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">p = Person(&quot;小明&quot;,&quot;12&quot;)</span><br><span class="line">p.sex = &quot;male&quot;   #这里动态为p定义了属性sex</span><br><span class="line">print(p.sex)</span><br><span class="line">dir(p)</span><br></pre></td></tr></table></figure><p>  这里动态添加的属性，只是对p这个对象添加的，其他的Person类的对象是没有的<br>  这里可以动态的添加类的动态属性，这样所有的对象都会有且一致。</p><ul><li>为对象动态添加实例方法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def showInfo(self):</span><br><span class="line">    print(self.name)</span><br><span class="line">    print(self.age)</span><br><span class="line"></span><br><span class="line">import types</span><br><span class="line">p.showInfo = types.MethodType(showInfo, p)#这里就是用p作为self来传递给showInfo，做一个装饰器即可。</span><br><span class="line">p.showInfo()</span><br></pre></td></tr></table></figure><ul><li>为类动态添加类方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@classmethod</span><br><span class="line"> def fun1(cls):</span><br><span class="line">    print(&quot;class Method&quot;)</span><br><span class="line"></span><br><span class="line">Person.fun1 = fun1</span><br><span class="line">p.fun1()</span><br></pre></td></tr></table></figure><ul><li>为类添加静态方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@staticmethod</span><br><span class="line">def fun2(a,b):</span><br><span class="line">   return a+b</span><br><span class="line">Person.fun2 = fun2</span><br><span class="line">print(p.fun2(1+2))</span><br></pre></td></tr></table></figure><h3 id="限制修改对象的属性"><a href="#限制修改对象的属性" class="headerlink" title="限制修改对象的属性"></a>限制修改对象的属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line">  __slots__=(&quot;name&quot;,&quot;age&quot;)</span><br></pre></td></tr></table></figure><p>这样就会限制对象往里添加属性，只限于name与age</p><h2 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h2><h3 id="前情"><a href="#前情" class="headerlink" title="前情"></a>前情</h3><h4 id="函数对象-与-类"><a href="#函数对象-与-类" class="headerlink" title="函数对象 与 类"></a>函数对象 与 类</h4><p>装饰器函数就是一个接口约束，它必须接受一个callable对象作为参数，然后返回一个callable对象<br>一般callable对象都是函数，但也有例外，只要某个类重写了<strong>call</strong>()方法那么就可以调用了</p><h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Test(object):</span><br><span class="line">   def __call__(self):</span><br><span class="line">      print(&quot;call me&quot;)</span><br><span class="line"></span><br><span class="line"> t = Test()</span><br><span class="line"> t()</span><br></pre></td></tr></table></figure><h3 id="类装饰器-1"><a href="#类装饰器-1" class="headerlink" title="类装饰器"></a>类装饰器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Test(object):</span><br><span class="line">   def __init__(self, func):</span><br><span class="line">       print(&quot;初始化&quot;)</span><br><span class="line">       print(&quot;func name is %s&quot;%func__name__)</span><br><span class="line">       self.__func = func</span><br><span class="line"></span><br><span class="line">  def __call__(self):</span><br><span class="line">       print(&quot;装饰器中的功能&quot;)</span><br><span class="line">       self.__func()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> #这里会生成一个Test对象，调用__init__方法，并且将test()作为参数产地给init</span><br><span class="line"> @Test       </span><br><span class="line"> def test():</span><br><span class="line">    print(&quot;---test---&quot;)</span><br><span class="line"> test()           #调用时，其实是调用Test对象的__call__</span><br></pre></td></tr></table></figure><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h3><p>Python为了优化速度，<br>小整数：使用了[-5,257)对象池，避免为整数频繁申请和销毁内存。[257,无穷)都是新建对象<br>单个字符：也使用对象池，常驻内存<br>一个单词的字符串：也是在对象池中。采用引用计数共用，引用计数为0则销毁。</p><h4 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">c = &apos;a&apos;</span><br><span class="line">b = &apos;a&apos;</span><br><span class="line">b is a #True</span><br><span class="line"></span><br><span class="line">s1 = &quot;hello&quot;</span><br><span class="line">s2 = &quot;hello&quot;</span><br><span class="line">s1 = s2 #True</span><br><span class="line"></span><br><span class="line">s3 = &quot;hello world&quot;</span><br><span class="line">s4 = &quot;hello world&quot;</span><br><span class="line">s3 = s4 #False</span><br></pre></td></tr></table></figure><h3 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>为新生成的对象分配内存，识别那些垃圾对象，从垃圾对象那里回收内存<br>python采用的是引用计数机制为主，标记-清除、隔代收集两种机制为辅的策略</p><p>python里每个东西都是对象，他们的核心是一个结构体：PyObject</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct_object&#123;</span><br><span class="line">    int obj_refcnt;</span><br><span class="line">    struct_typeobject *ob_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define Py_INCREE(op) ((op)-&gt;ob_refcnt++)</span><br><span class="line">#define Py_DECREE(op) \</span><br><span class="line">    if(--(op)-&gt;ob_refcnt!=0) \</span><br><span class="line">      ;\</span><br><span class="line">    else \</span><br><span class="line">      _Py_Dealloc((PyObject *)(op))</span><br></pre></td></tr></table></figure><h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><p>实时，一旦没有引用，内存就直接释放，不用其他机制的等待特定时机</p><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>多占点内存<br>有可能出现循环引用：a中有b，b中有a.这是用的是隔代收集来收集</p><h5 id="导致-1的"><a href="#导致-1的" class="headerlink" title="导致+1的"></a>导致+1的</h5><ul><li>对象被创建：a=23</li><li>对象被引用：b=a</li><li>对象被传参：func(a)</li><li>对象作为一个元素，存在容器里:list=[a,a]<h5 id="导致-1的-1"><a href="#导致-1的-1" class="headerlink" title="导致-1的"></a>导致-1的</h5></li><li>对象别名被显示销毁，del a</li><li>对象别名被赋予新的对象 a = 24</li><li>一个对象离开它的作用域，如f函数执行完毕，func函数的局部变量都会-1</li><li>对象所在的容器被销毁，或者从容器中删除。<h5 id="查看引用计数"><a href="#查看引用计数" class="headerlink" title="查看引用计数"></a>查看引用计数</h5></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">a = &quot;hello world&quot;</span><br><span class="line">sys.getrefcount(a)</span><br></pre></td></tr></table></figure><p>此时最少打印2，因为a创建+1，传参+1</p><h5 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h5><ol><li>调用gc.collect()</li><li>当gc模块的计数器达到阀值（有3个）的时候</li><li>程序退出</li></ol><h5 id="gc模块"><a href="#gc模块" class="headerlink" title="gc模块"></a>gc模块</h5><p>gc.garbage列表<br>gc.get_threshold()获取gc模块中自动执行垃圾回收的频率<br>gc._threshold(thrshold0[,th])<br>gc.get_count()，隔代收集中每代的个数<br>gc.collect([generation])隔代收集的0代表直线查第一代，1代表检查1.2代<br>gc模块唯一处理不了的是循环引用的类都有<strong>del</strong>方法，所以项目中避免定义<strong>del</strong>方法<br>gc.disable()手动关掉垃圾回收</p><h4 id="隔代收集"><a href="#隔代收集" class="headerlink" title="隔代收集"></a>隔代收集</h4><h2 id="内建"><a href="#内建" class="headerlink" title="内建"></a>内建</h2><h3 id="方法方法"><a href="#方法方法" class="headerlink" title="方法方法"></a>方法方法</h3><p><img src="10.内建属性.png" alt=""></p><ul><li><strong>new</strong>：构造函数</li><li><strong>init</strong>：初始化函数</li><li><strong>clas</strong>：实例所在类</li><li><strong>str</strong>：类似与Java的toString</li><li><strong>repr</strong>：</li><li><strong>del</strong>：析构</li><li><strong>dict</strong>:实例地定义属性</li><li><strong>doc</strong>：类文档，子类不继承</li><li><strong>getattibute</strong>:属性访问拦截器</li><li><p><strong>bases</strong>:类的所有父类构成元素</p></li><li><p><strong>getattribute</strong>属性访问拦截器<br>正常使用</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class School(object):</span><br><span class="line">   def __init__(self,s1):</span><br><span class="line">       self.subject1 = s1</span><br><span class="line">       self.subject2 = &apos;c++&apos;</span><br><span class="line"></span><br><span class="line">   def __getattribute__(self, obj):</span><br><span class="line">       if obj == &apos;subject1&apos;:</span><br><span class="line">           print(&quot;log subject1&quot;)</span><br><span class="line">           return &apos;redirect python&apos;</span><br><span class="line">       else:   #注意else一定要有，否则其他属性就是None了</span><br><span class="line">           return object.__getattribute__(self,ojb)</span><br><span class="line"></span><br><span class="line"> s = School(&apos;Pyhont&apos;)</span><br><span class="line"> print(s.subject1)</span><br><span class="line"> print(s.subject2)</span><br></pre></td></tr></table></figure><p> 坑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line">   def __getattribute__(self,obj):</span><br><span class="line">      print(&quot;---test---&quot;)</span><br><span class="line">      if obj.startwith(&quot;a&quot;):</span><br><span class="line">         return &quot;haha&quot;</span><br><span class="line">      else:</span><br><span class="line">         return self.test</span><br><span class="line"></span><br><span class="line">   def test(self):</span><br><span class="line">      print(&quot;heihei&quot;)</span><br><span class="line"></span><br><span class="line">  # 函数执行内存都在栈上</span><br><span class="line">  t=Person()</span><br><span class="line">  t.a </span><br><span class="line">  t.b #会让程序死掉，因为会递归调用__getattribute__所有就崩掉了</span><br></pre></td></tr></table></figure><h3 id="内建方法"><a href="#内建方法" class="headerlink" title="内建方法"></a>内建方法</h3><ul><li>dir<br>dir(<strong>buildins</strong>)</li><li>range(1,10,2)</li><li><p>map(function, sequence[,sequence,…])根据提供的函数，对指定序列做映射<br>map(lambda x:x*x,[1,2,3])：结果为[1,4,9],python2直接是序列，python3是可迭代的对象<br>map(lamdbda x,y:x+y,[1,2,3],[4,5,6]) ：结果为[5,7,9]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def f1(x,y):</span><br><span class="line">   return (x,y)</span><br><span class="line">l1 = [1,2,3]</span><br><span class="line">l2 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]</span><br><span class="line">l3 = map(f1,l1,l2)</span><br><span class="line">print(list(l3))</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>filter(function or None,sequence)对指定序列执行过滤操作<br>filter(lambda x:x%2,[1,2,3,4])<br>filter(None,”hello”)</p></li><li><p>reduce(function,sequence[,initial])对参数序列中元素进行累积<br>python3中，reduce从全局名字空间中移除，放在functools模块里<br>from functools import reduce<br>reduce(lambda x,y:x+y, [1,2,3,4]) #10<br>reduce(lambda x,y:x+y, [1,2,3,4],5)  #15<br>reduce(lambda x,y:x+y, [‘aa’,’bb’,’cc’],’dd’)  #’ddaabbcc’</p></li></ul><h3 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h3><ul><li>支持的运算：<br>|:union：并集<br>&amp;：intersection:交集<br>-:difference:差集<br>^:sysmmetric_difference：对称差集，x^y，在x或y中，但不会同时出现在二者之中</li></ul><h2 id="常用模块"><a href="#常用模块" class="headerlink" title="常用模块"></a>常用模块</h2><h3 id="functools"><a href="#functools" class="headerlink" title="functools"></a>functools</h3><ul><li><p>partial：偏函数<br>把一个函数的某些参数设置默认参数，返回一个新的采纳数，调用这个函数会更简单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line">def showarg(*args,**kwagrs):</span><br><span class="line">   print(args)</span><br><span class="line">   print(kwargs)</span><br><span class="line"></span><br><span class="line">p1=functools.partial(showarg,1,2,3)</span><br><span class="line">p1()  #1,2,3 #&#123;&#125;</span><br><span class="line">p1(4,5,6)  #1,2,3,4,5,6 #&#123;&#125;</span><br><span class="line">p1(a=&apos;python&apos;, b=&apos;c++&apos;)  #1,2,3 #&#123;&quot;a&quot;:&quot;python&quot;,&quot;b&quot;:&quot;c++&quot;&#125;</span><br><span class="line"></span><br><span class="line">p2=functools.partial(showarg,a=3,b=&apos;linux&apos;)</span><br><span class="line">p2()</span><br><span class="line">p2(1,2)</span><br><span class="line">p2(a=&quot;ptyon&quot;,b=&quot;c++&quot;)#这个会将默认值改掉</span><br></pre></td></tr></table></figure></li><li><p>wraps：包装函数<br>使用装饰器后，被装饰的函数已经是另外一个函数了，wraps的装饰器可以消除这样的副作用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line">def note(func):</span><br><span class="line">   @functools.wraps(func)</span><br><span class="line">   def wrapper():</span><br><span class="line">      print(&quot;note something&quot;)</span><br><span class="line">      return func()</span><br><span class="line">   return wrapper</span><br><span class="line"></span><br><span class="line">@note</span><br><span class="line">def test():</span><br><span class="line">   print(&quot;i am test&quot;)</span><br><span class="line"></span><br><span class="line">test()</span><br><span class="line">print(test.__doc__) 如果不加，则返回的是wrapper(), 反之为test</span><br></pre></td></tr></table></figure></li></ul><p>  其实就是在新家的这个装饰器内部，修改了wrapper的<strong>doc</strong></p><h3 id="常用标准模块"><a href="#常用标准模块" class="headerlink" title="常用标准模块"></a>常用标准模块</h3><p><img src="11.常用标准模块.png" alt=""></p><h3 id="常用三方模块"><a href="#常用三方模块" class="headerlink" title="常用三方模块"></a>常用三方模块</h3><p> <img src="12.常用三方模块.png" alt=""></p><h2 id="pdb调试"><a href="#pdb调试" class="headerlink" title="pdb调试"></a>pdb调试</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><ul><li><p>执行时调试<br>python -m pdb some.py<br>只用这种就行<br>-m 指的是module， 像脚本一样运行模块</p></li><li><p>交互调试<br>import pdb<br>pdb.run(‘testfun(args)’)</p></li><li><p>程序下断点<br>import pdb<br>pdb.set_trace()<br>运行到这之后停住，使用与gdb类似，p打印，n单步，s进入函数，c继续执行，<br><img src="13.pdb调试.png" alt=""></p></li></ul><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="fork方法"><a href="#fork方法" class="headerlink" title="fork方法"></a>fork方法</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>fork调用一次返回2次，父进程返回子进程id，子进程返回0<br>一个父进程可以fork出很多子进程，所以父进程要记下每个子进程的id，而子进程只需要调用getppid()就可以拿到父进程的id</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">imprt time</span><br><span class="line">pid = os.fork()</span><br><span class="line">if pid&lt;0:</span><br><span class="line">   time.sleep(2)</span><br><span class="line">   print(&quot;fork调用失败&quot;)</span><br><span class="line">elif pid==0:</span><br><span class="line">   time.sleep(1)</span><br><span class="line">   print(&quot;我是子进程(%s),我的父进程是(%s)&quot;%(os.getpid(), os.getppid()))</span><br><span class="line">else:</span><br><span class="line">   print(&quot;我是父进程(%s),我的子进程是(%s)&quot;%(os.getpid(), pid))</span><br><span class="line"></span><br><span class="line">print(&quot;父子进程都可以执行这里的代码&quot;)</span><br></pre></td></tr></table></figure><h4 id="多个fork"><a href="#多个fork" class="headerlink" title="多个fork"></a>多个fork</h4><p>这里创建了4个进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">pid = os.fork()</span><br><span class="line">if pid==0:</span><br><span class="line">   print(&quot;子进程11&quot;)</span><br><span class="line">else:</span><br><span class="line">   print(父进程11)</span><br><span class="line"></span><br><span class="line">pid = os.fork()</span><br><span class="line">if pid == 0:</span><br><span class="line">   print(&quot;子进程22&quot;)</span><br><span class="line">else:</span><br><span class="line">   print(&quot;父进程22&quot;)</span><br></pre></td></tr></table></figure><h4 id="复习-1"><a href="#复习-1" class="headerlink" title="复习"></a>复习</h4><p>fork返回值是子进程的pid,如果本身是子进程,返回值就是0</p><h3 id="通过Process对象创建子进程"><a href="#通过Process对象创建子进程" class="headerlink" title="通过Process对象创建子进程"></a>通过Process对象创建子进程</h3><h4 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">def run_proc(name):  #子进程只执行这个函数</span><br><span class="line">   print(&quot;子进程运行中，name=%s,pid=%d&quot;%(name,os.getpid()))</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;</span><br><span class="line">   print(&quot;父进程%d&quot;%s.getpid())</span><br><span class="line">   p = Process(target=run_proc,args=(&apos;test&apos;,))</span><br><span class="line">   print(&quot;子进程将要执行&quot;)</span><br><span class="line">   p.start()</span><br><span class="line">   p.join()  #加这句话，父进程等待子进程结束之后再执行</span><br><span class="line">   print(&quot;子进程执行结束&quot;)</span><br></pre></td></tr></table></figure><h4 id="Process常用方法"><a href="#Process常用方法" class="headerlink" title="Process常用方法"></a>Process常用方法</h4><p>is_alive:判断进程是否执行<br>join([timeout])是否等待进程实例执行结束，或等待多少秒<br>start(),启动<br>run()，没有制定target时执行<br>terminat()，不管任务是否完成，终止任务，一般父进程来终止子进程</p><h4 id="Process常用属性"><a href="#Process常用属性" class="headerlink" title="Process常用属性"></a>Process常用属性</h4><p>name:当前进程实例别名，默认为Process-N<br>pid,当前进程pid</p><h3 id="通过Prcess子类创建子进程"><a href="#通过Prcess子类创建子进程" class="headerlink" title="通过Prcess子类创建子进程"></a>通过Prcess子类创建子进程</h3><h4 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">import time</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">class ProcessSubClass(Process):</span><br><span class="line">   def __init__(self,interval):</span><br><span class="line">     super().__init__()</span><br><span class="line">     self,interval = interval</span><br><span class="line"></span><br><span class="line">   #重写父类run</span><br><span class="line">   def run(self):</span><br><span class="line">       t_start= time.time()</span><br><span class="line">       time.sleep(self.interval)</span><br><span class="line">       t_end = tim.time()</span><br><span class="line">       print(%s执行结束，耗时%d%(os.getpid(),t_end-t_start))</span><br><span class="line"></span><br><span class="line"> if __name__==&quot;__main__&quot;:</span><br><span class="line">   print(&quot;主进程执行开始&quot;)</span><br><span class="line">   p = ProcessSubClass(2)</span><br><span class="line">   p.start()</span><br><span class="line">   p.join()</span><br><span class="line">   print(&quot;主进程执行结束&quot;)</span><br></pre></td></tr></table></figure><h3 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h3><p>multiprocessing模块提供的Pool方法<br>如果池已经满了，只能等待，如果没有满，并且有空闲的，则去空闲的，反之，创建一个新进程。</p><h4 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Pool</span><br><span class="line">import os,time,random</span><br><span class="line"></span><br><span class="line">def worker(msg):</span><br><span class="line">   t_start = time.time()</span><br><span class="line">   print(&quot;子进程%d,%d&quot;,%(os.getpid(),msg))</span><br><span class="line">   time.sleep(random.randint(1,3)*2)</span><br><span class="line">   t_stop = time.time()</span><br><span class="line">   print(&quot;执行完毕，用时:%d&quot;%(t_stop-t_start))</span><br></pre></td></tr></table></figure><p>#创建进程池<br>pool = Pool(3)</p><p>for i in range(0,10):</p><p>   #从进程池申请进程，传参为函数名、参数元组</p><p>   #apply_async是异步申请，apply是同步。异步同时请求3个，然后同时执行；同步一个一个请求，上一个进程退出才能执行下一个<br>   pool.apply_async(worker,(i,))</p><p>#关闭进程池，close之后再写join，进程池中的进程已经是start状态，所以不需要再start了<br>pool.close()<br>pool.join()</p><h4 id="multiprocessing-Pool函数解析"><a href="#multiprocessing-Pool函数解析" class="headerlink" title="multiprocessing.Pool函数解析"></a>multiprocessing.Pool函数解析</h4><ul><li>apply_async(func[,args[,kwagrs]]):</li><li>apply</li><li>close():进程池不再接受新的任务，已用的进程慢慢关闭</li><li>terminate()：不管任务是否完成，立即终止</li><li>join()：与Process相同</li></ul><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><h4 id="进程之间"><a href="#进程之间" class="headerlink" title="进程之间"></a>进程之间</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">from multiProcess import Process</span><br><span class="line">from multiProcess import Queue</span><br><span class="line"></span><br><span class="line">def writer(q):</span><br><span class="line">   for item in &quot;ABCDE&quot;</span><br><span class="line">       print(&quot;正在往消息队列中写入%s&quot;%item)</span><br><span class="line">       q.put(item)</span><br><span class="line">       time.sleep(1)</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">def reader(q):</span><br><span class="line">   while True:</span><br><span class="line">   if not q.empty():</span><br><span class="line">      item = q.get()</span><br><span class="line">      print(&quot;从消息队列中读出%s&quot;%item)</span><br><span class="line">      time.sleep(random.random())</span><br><span class="line">   else:</span><br><span class="line">      break</span><br><span class="line"></span><br><span class="line">q = Queue()</span><br><span class="line">pw = Process(target=writer,args=(q,))</span><br><span class="line">pw.start()</span><br><span class="line">pw.join()</span><br><span class="line"></span><br><span class="line">pr = Process(target=reader,args=(q,))</span><br><span class="line">pr.start()</span><br><span class="line">pr.join()</span><br></pre></td></tr></table></figure><h4 id="进程池-1"><a href="#进程池-1" class="headerlink" title="进程池"></a>进程池</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">from multiProcess import Pool,Manager</span><br><span class="line">import time,random</span><br><span class="line"></span><br><span class="line">def writer(q):</span><br><span class="line">   for item in &quot;ABCDE&quot;</span><br><span class="line">       print(&quot;正在往消息队列中写入%s&quot;%item)</span><br><span class="line">       q.put(item)</span><br><span class="line">       time.sleep(1)</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">def reader(q):</span><br><span class="line">   while True:</span><br><span class="line">   if not q.empty():</span><br><span class="line">      item = q.get()</span><br><span class="line">      print(&quot;从消息队列中读出%s&quot;%item)</span><br><span class="line">      time.sleep(random.random())</span><br><span class="line">   else:</span><br><span class="line">      break</span><br><span class="line"></span><br><span class="line">q = Manager().Queue()  #进程池中，只能使用Manager创建的消息队列</span><br><span class="line">pool = Pool(3)</span><br><span class="line">Pool.apply(writer,(q,))  #执行结束之后，再执行下一个进程</span><br><span class="line">Pool.apply(reader,(q,))</span><br><span class="line"></span><br><span class="line">Pool.close()</span><br><span class="line">Pool.join()</span><br></pre></td></tr></table></figure><h3 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h3><p>python的进程一部分继承了linux轻进程的特点</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h3><p>进程是作为资源分配的单位<br>调度和执行的单位</p><p>python的thread模块以及threading模块<br>threading模块对thread做了一些包装</p><h3 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def fun(num):</span><br><span class="line">    print(&quot;线程%d执行&quot;%num)</span><br><span class="line">    time.sleep(2)</span><br><span class="line"></span><br><span class="line">for i in range(5):</span><br><span class="line">    t = threading.Thread(target=fun,args=(i+1,))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul><li>threading.enumerate():当前线程数量</li></ul><h3 id="线程创建方式"><a href="#线程创建方式" class="headerlink" title="线程创建方式"></a>线程创建方式</h3><ul><li>threading.Tread的对象</li><li>子类化thread.Tread，实现run方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import threading,time</span><br><span class="line">class MyThread(threading.Thread):</span><br><span class="line">      def run(self):</span><br><span class="line">              for i in range(5):</span><br><span class="line">                      time.sleep(1)</span><br><span class="line">                      #这里self.name是父类的属性，默认是Thread-N</span><br><span class="line">                      print(&quot;I am &quot;+ self.name+&quot;@&quot;+str(i))</span><br><span class="line"></span><br><span class="line">if __name__==&quot;__main__&quot;:</span><br><span class="line">      t = MyThread()</span><br><span class="line">      t.start()</span><br></pre></td></tr></table></figure><p>  传参可以通过重新定义<strong>init</strong>方法来传参</p><h3 id="线程的几种状态"><a href="#线程的几种状态" class="headerlink" title="线程的几种状态"></a>线程的几种状态</h3><p><img src="14.线程的几种状态.png" alt=""><br>就绪，运行，阻塞状态<br>就绪状态到运行状态是需要系统的调用，才进入运行状态，运行状态受阻塞的事件，进入阻塞状态<br>运行状态下的时间片用完，进入就绪状态</p><h3 id="线程之间通信"><a href="#线程之间通信" class="headerlink" title="线程之间通信"></a>线程之间通信</h3><h4 id="共享全局变量"><a href="#共享全局变量" class="headerlink" title="共享全局变量"></a>共享全局变量</h4><h4 id="传参方式"><a href="#传参方式" class="headerlink" title="传参方式"></a>传参方式</h4><p>将全局变量作为参数传递给线程<br>w1 = threading.Tread(target=worker1,args=(numlist,))<br>这里的传参方式，直接调用函数传参需要注意的事项相同，对于可不变类型与不可变类型需要注意。对于可变参数，传递的是引用。不可变参数传递会创建新对象。</p><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>操作分为3步骤：<br>cpu线程内存将g_num读到寄存器<br>在寄存器中+1<br>将寄存器写回内存</p><h4 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h4><p>为保证线程安全<br>threading模块中定义了Lock类，可以处理锁定<br>mutex = threading.Lock()</p><p>mutex.acquire([blocking]),返回一个bool变量<br>   blocking默认为True，阻塞;False不阻塞<br>mutex.release()</p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>这个太熟悉了,不说了</p><h4 id="使用锁使线程顺序执行"><a href="#使用锁使线程顺序执行" class="headerlink" title="使用锁使线程顺序执行"></a>使用锁使线程顺序执行</h4><p>就是每个线程一个锁.初始时,除了第一个线程的锁,其他锁都锁死,第一个线程执行完,开第二把锁,第二个执行完开第三把,依次类推.</p><h4 id="Queue模块"><a href="#Queue模块" class="headerlink" title="Queue模块"></a>Queue模块</h4><p>python的Queue模块</p><ul><li>FIFO(先入先出):Queue</li><li>LIFO(后入先出):LifoQueue</li><li>优先级队列:PriorityQueue</li></ul><p>python2中from Queue import Queue<br>python3中from queue import Queue<br>使用方法与进程的相同<br>queue.put(对象)<br>queue.get()</p><h4 id="ThreadLocal变量"><a href="#ThreadLocal变量" class="headerlink" title="ThreadLocal变量"></a>ThreadLocal变量</h4><p>ThreadLocal变量虽是全局变量，但每个线程都只读写自己线程的独立副本，互不干扰。解决了一个线程中各个函数之间相互传递的问题。<br>threadLocal最常用的地方就是为每个线程绑定一个数据库连接，Http请求，用户身份信息等，这样一个线程的所有调用到的处理函数，都可以非常方便的访问这些这些资源</p><p>import threading<br>local_school = threading.local()  #这里的local说明可能不是一个类，是个函数也不对，听奇怪不遵循python3的类首字母大写的规范</p><p>就是一个线程函数中调用另一函数，这两个函数之间的数据传递。<br>其实是由于python的传参，对于可变类型传递的都是引用，造成了线程内部调用的函数都是线程不安全的，所以使用了这种类似与Queue的方法,将这些传参都放到全局变量里去获取。这个与queue不同的是threadLocal对各个线程是独立的，像是每个线程都有一个的样子。而且它是key-value方式存储</p><h4 id="复习-2"><a href="#复习-2" class="headerlink" title="复习"></a>复习</h4><p>主要是对ThreadLocal的理解，local可以看作是一个对象，它在不同线程中变量相同但数据不同。</p><h2 id="【新】协程"><a href="#【新】协程" class="headerlink" title="【新】协程"></a>【新】协程</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>比线程更小的执行单元，是在线程下的运行单元，协程一般由用户来实现，比线程占用资源更少<br>用处：<br>  IO密集型程序比较适合协程，而CPU密集型不适合协程<br>底层：<br>  yield来停下，然后用next来实现</p><h3 id="greenlet使用"><a href="#greenlet使用" class="headerlink" title="greenlet使用"></a>greenlet使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from greenlet import greenlet</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def test1():</span><br><span class="line">   while True:</span><br><span class="line">     print(&quot;---AAA---&quot;)</span><br><span class="line">     gr2.switch()#这里切换到test2方法中运行</span><br><span class="line">def test2():</span><br><span class="line">   while True:</span><br><span class="line">     print(&quot;---BBB---&quot;)</span><br><span class="line">     gr1.switch()</span><br><span class="line"> </span><br><span class="line">gr1 = greenlet(test1)</span><br><span class="line">gr2 = greenlet(test2)</span><br><span class="line">gr1.switch</span><br></pre></td></tr></table></figure><h3 id="gevent"><a href="#gevent" class="headerlink" title="gevent"></a>gevent</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import gevent</span><br><span class="line">def f(n):</span><br><span class="line">   for i in range(n):</span><br><span class="line">      print(&quot;%s:%d&quot;%(gevent.getcurrent(),n))</span><br><span class="line">      gevent.sleep(1)  #需要有io等待，这里模拟耗时任务，需要用gevent中的sleep，有IO等待，不需要人工调用，gevent自动切换</span><br><span class="line"></span><br><span class="line">g1 = gevent.spawn(f,5)</span><br><span class="line">g2 = gevent.spawn(f,5)</span><br><span class="line">g3 = gevent.spawn(f,5)</span><br><span class="line"></span><br><span class="line">g1.join()</span><br><span class="line">g2.join()</span><br><span class="line">g3.join()</span><br></pre></td></tr></table></figure><h3 id="并发下载器"><a href="#并发下载器" class="headerlink" title="并发下载器"></a>并发下载器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from gevent import monkey</span><br><span class="line">import gevent</span><br><span class="line">from  urllib import request</span><br><span class="line"></span><br><span class="line">#有IO需要有这句话，才可以对IO进行耗时进行捕获，从而自动切换</span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br><span class="line">def myDownload(url):</span><br><span class="line">   print(url)</span><br><span class="line">   response = request.urlopen(url)</span><br><span class="line">   data = response.read()</span><br><span class="line">   prin(&quot;%d bytes received from %s&quot;%(len(data),url)</span><br><span class="line"></span><br><span class="line">gevent.joinall([</span><br><span class="line">gevnet.spawn(myDownload,&quot;http://www.baidu.com&quot;),</span><br><span class="line">gevnet.spawn(myDownload,&quot;http://www.sina.com&quot;)</span><br><span class="line">gevnet.spawn(myDownload,&quot;http://www.weibo.com&quot;)</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h3 id="复习-3"><a href="#复习-3" class="headerlink" title="复习"></a>复习</h3><p>并发下载器，提示了多线程/多协程去爬取网页的技术，网页的爬取与网页的分析是可以分开来使用的，多线程可以用作很多方面。</p><h2 id="网络简介"><a href="#网络简介" class="headerlink" title="网络简介"></a>网络简介</h2><ul><li><p>网络地址与主机地址<br><img src="15.IP地址.png" alt=""><br>A类：1.0.0.1 - 126.255.255.254 可用的A类网络有126个每个网络容纳167 7214个主机<br>B类：128.1.0.1 - 191.255.255.254 B类网络有16384个，容纳主机65534个<br>C类：192.0.1.1 - 223.255.254 C类网络209 7152个，容纳主机254个<br>D类：第一个字节以1110开始，它并不指向特定的网络，目前这一类地址被用在多点广播中多点国博地址用来一次寻址一组计算机地址范围224.0.0.1 - 239.255.255.254<br>E类：以1111开始，为将来保留，作为实验使用</p><p>私有IP 有一部分ip用于局域网使用，不再公网中使用，包括</p><pre><code>-A类 10.0.0.0 - 10.255.255.255-B类 172.16.0.0 - 172.31.255.255-C类 192.168.0.0 - 192.168.255.255- 127.0.0.1 - 127.255.255.255用户回路测试</code></pre><p>共有IP ip<br>路由器完成公有ip与私有ip之间的转换：所以说一台私有ip的电脑不能作为网络服务器，因为外界不能正确访问到它</p></li><li><p>端口号<br>端口号只有整数，范围从0～65535<br>知名端口号，0～1023.如80:http, 21:ftp<br>动态端口：1024～65535<br>netstat -an</p></li><li><p>协议<br><img src="16.网络协议.png" alt=""><br>socket: cs架构与bs架构</p></li></ul><h2 id="socket-udp"><a href="#socket-udp" class="headerlink" title="socket-udp"></a>socket-udp</h2><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">socket.socket(AddressFamily, Type)</span><br><span class="line">  AddressFamily:AF_INET</span><br><span class="line">  Type:SOCK_STRAEM(tcp),SOCK_DGRAM(udp)</span><br></pre></td></tr></table></figure><h3 id="udp应用"><a href="#udp应用" class="headerlink" title="udp应用"></a>udp应用</h3><p>语音广播，视频，QQ，TFTP,SNMP,DNS，RIP（路由信息协议，报告股票市场）</p><h3 id="收发数据"><a href="#收发数据" class="headerlink" title="收发数据"></a>收发数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">updSocket = socke(AF_INET,SOCKET_DGRAM)</span><br><span class="line">sendAddr=(&apos;192.168.1.1&apos;,8080)</span><br><span class="line">sendData = raw_input(&quot;请输入要发的数据&quot;)</span><br><span class="line">updSocket.sendto(sendData,sendAddr)</span><br><span class="line"></span><br><span class="line">bindAddr=(&apos;192.168.1.2&apos;,7788)</span><br><span class="line">udpSokcet.bind(bindAddr)</span><br><span class="line">rcvData = udpSocket.recvfrom(1024) #1024代表本次接受的最大字节数,此处接受收时会阻塞</span><br><span class="line">print(rcvData)</span><br><span class="line">updSocket.close()</span><br></pre></td></tr></table></figure><h2 id="tftp"><a href="#tftp" class="headerlink" title="tftp"></a>tftp</h2><ul><li>使用协议udp，端口69</li><li>使用wireshark抓包</li><li><p>使用tftpd32来做tftp服务器</p></li><li><p>过程：</p><ol><li>客户端发请求，下载还是上传（操作类型）、文件名</li><li>服务器收到请求确认：如果文件没有，发出错信息；反之，发确认信息，或者直接发文件一部分</li><li>客户端收到文件后：如果收到文件数据，需要发确认信息，并且将数据保存本地<pre><code>如果收到出错信息，终止下载</code></pre></li><li>循环过程：服务器发文件一部分，客户端确认，知道文件发完</li><li>如果文件结束，应该有一个文件结束的标志<br><img src="17.tftp协议介绍.png" alt=""><br>操作码：1是读即下载，2是写即上传，3是数据包，4确认，5出错</li></ol></li></ul><p>struct模块，处理C语言的结构体<br>pack(): pack(fmt,v1,v2…)<br>unpack(): unpack(fmt,string)<br>calcsize(fmt)，计算给点内存</p><p>fmt：!大端，windows下下小端，linux下大端，网络也是大端。大端就是高位在前<br><img src="18.fmt意思.png" alt=""></p><h2 id="socket-tcp"><a href="#socket-tcp" class="headerlink" title="socket-tcp"></a>socket-tcp</h2><h3 id="服务器流程："><a href="#服务器流程：" class="headerlink" title="服务器流程："></a>服务器流程：</h3><ol><li>创建套接字</li><li>bind绑定ip与port</li><li>listen是套接字变为可以被动链接</li><li>accept等待客户端的连接</li><li>recv/send接收发送数据<br><img src="19.tcp服务器.png" alt=""></li></ol><h3 id="客户端历程"><a href="#客户端历程" class="headerlink" title="客户端历程"></a>客户端历程</h3><ol><li>创建socket</li><li>connect</li><li>send/recv</li><li>close</li></ol><h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>可以把socket当作文件读写的，用多路复用来监听<br><img src="20.多路复用select版.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import select</span><br><span class="line"></span><br><span class="line">socketServer = socket(AF_INET,SOCK_STREAM)</span><br><span class="line">socketServer.setsockopt(SOL_SOCKET,SO_REUSEADDR,1)</span><br><span class="line">inputs=[socketServer,sys.stdin]</span><br><span class="line">readable,writeable,exceptional = select.select(inputs,[],[])</span><br><span class="line">for r in readable:</span><br><span class="line">    if r == socketServer:</span><br><span class="line">       conn,addr = r.accept()</span><br><span class="line">       inputs.append(conn)</span><br><span class="line">    elif r== sys.stdin:</span><br><span class="line">       pass</span><br><span class="line">    else:</span><br><span class="line">       data = r.recv(1024)</span><br><span class="line">       if data:</span><br><span class="line">         r.send(data)</span><br><span class="line">        else:</span><br><span class="line">          inputs.remove(r)</span><br></pre></td></tr></table></figure><p>select 类似与中断，同时监听多少个,是一种轮询的方式</p><h3 id="epoll只有linux用"><a href="#epoll只有linux用" class="headerlink" title="epoll只有linux用"></a>epoll只有linux用</h3><p><img src="21.多路复用epoll版.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">from socket import *</span><br><span class="line">import select,sys</span><br><span class="line"></span><br><span class="line">epoll = select.epoll()</span><br><span class="line">epoll.register(tcpsocket.fileno(), select.EPOLLIN|select.EPOLLET)</span><br><span class="line">epoll.register(sys.stdin.fileno(), select.EPOLLIN|select.EPOLLET)</span><br><span class="line"></span><br><span class="line">conections = &#123;&#125;</span><br><span class="line">adress=&#123;&#125;</span><br><span class="line"></span><br><span class="line">epoll_list = epoll.poll()</span><br><span class="line">for fd,events in epoll_list:</span><br><span class="line">   if fd == tcpsocket.fileno()</span><br><span class="line">      conn,addr = tcpsocket.accept()</span><br><span class="line">      connections[conn.fileno()] = conn</span><br><span class="line">      address[conn.fileno()] = adress</span><br><span class="line">      epoll.register(conn.fileno(), select.EPOLLIN|select.EPOLLET)</span><br><span class="line">   elif fd == sys.stdin.fileno():</span><br><span class="line">      pass</span><br><span class="line">   elif events == select.EPOLLIN:</span><br><span class="line">     data = connections[fd].rect(1024)</span><br><span class="line">     if data:</span><br><span class="line">         connections[fd].send(data)</span><br><span class="line">     else:</span><br><span class="line">         conections[fd].close()</span><br><span class="line">         connections.pop(fd)</span><br><span class="line">         address.pop(fd)</span><br></pre></td></tr></table></figure><h2 id="网络工具"><a href="#网络工具" class="headerlink" title="网络工具"></a>网络工具</h2><h3 id="NetAssist-网络调试助手"><a href="#NetAssist-网络调试助手" class="headerlink" title="NetAssist:网络调试助手"></a>NetAssist:网络调试助手</h3><p>可以用tcp，udp协议与写的代码进行交互</p><h3 id="wireShark-网络抓波工具"><a href="#wireShark-网络抓波工具" class="headerlink" title="wireShark:网络抓波工具"></a>wireShark:网络抓波工具</h3><p>选中网卡，能抓到该网卡上的网络传输数据</p><h3 id="tftpd32：tftp服务器"><a href="#tftpd32：tftp服务器" class="headerlink" title="tftpd32：tftp服务器"></a>tftpd32：tftp服务器</h3><p>选中文件目录，提供文件上传、下载服务</p><h3 id="Packet-Tracer"><a href="#Packet-Tracer" class="headerlink" title="Packet Tracer"></a>Packet Tracer</h3><ol><li>集线器与交换机区别<br>集线器就是做转发，集线器网络容易出网络风暴<br>交换机有路由，可以做寻址等</li><li><p>arp<br>arp攻击：修改arp表，将所有的ip都指向攻击者，然后收到后进行篡改<br>arp就是寻址，根据ip去寻找mac地址，然后记录在本地的arp列表中</p></li><li><p>路由器作用</p><ul><li>连通不同的网络：<br>路由器相当于双网卡，一段连一个网络。一个网络中，需要设置一个网关。如果是同一网段，路由器直接发送个给对应机器，不同网段，则直接发送给网关<br>不同网络通信时，显示主机广播自己，然后寻址网关的的mac地址，网关返回后，主机将arp层的目的mac写为网关，ip当然还是要连接的另一网络的ip</li><li>路由寻址<br>多台路由器时，需要有路由表，仿真期间，用的是静态路由表，每个arp都根据路由表传递给下一个ip，返回下一个路由的mac地址，记录在前一个路由器中，这样，在发送imcp时，路由器根据需要，改写目的mac即可。</li></ul></li><li><p>Http<br>http包被tcp包含。前边握手包，后边结束包</p></li></ol><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="mycat"><a href="#mycat" class="headerlink" title="mycat"></a>mycat</h3><p>都是关系型数据库，就是在多个关系型数据库（尤其是mysql）上搭建的中间件，搭建成关系型数据库集群。<br>其实类似于zookeeper</p><h3 id="python下mysql的使用"><a href="#python下mysql的使用" class="headerlink" title="python下mysql的使用"></a>python下mysql的使用</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>pip3 install PyMySQL</p><h4 id="Connection对象"><a href="#Connection对象" class="headerlink" title="Connection对象"></a>Connection对象</h4><ul><li>建立与数据库的连接</li><li>创建对象，调用connect()方法<br>host:主机名，数据库名，用户名，密码，端口默认3306(oracle是1521)，参数charset默认’gb2312’</li><li>方法<br>close()关闭<br>commit()提交<br>rollback()回滚<br>cursor()游标</li></ul><h4 id="Cursor对象"><a href="#Cursor对象" class="headerlink" title="Cursor对象"></a>Cursor对象</h4><ul><li>执行sql语句</li><li>创建对象，Connection对象的cursor()方法<br>cursor = conn.cursor</li><li>方法<br>excute(operation[,parameters])<br>fetchone()<br>next()<br>fetchall()</li></ul><h4 id="实例-8"><a href="#实例-8" class="headerlink" title="实例"></a>实例</h4><p>import pymysql<br>connection = pymysql.connect(“localhost”,”root”,”sun12358”,”pythondb”)<br>cursor = connection.cursor()<br>cursor.execute(“select * from emp”)<br>rl = cursor.fetchall()</p><p>cursor.close()<br>connection.close()</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li><p>日期字符转换<br>datetime.datetime.strftime(emp[4 ], “%Y-%M-%D”)<br>emp[4].strftime(“%Y{y}%m{m}%d{d}”).format(y=’年’,m=’月’,d=’日’)</p></li><li><p>sql注入：select * from dept where depton &gt; 18 or 1=1<br>where后边的传参一定要注意</p></li></ul><h1 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h1><h2 id="基本语句"><a href="#基本语句" class="headerlink" title="基本语句"></a>基本语句</h2><h3 id="xxx-xxx-xxx"><a href="#xxx-xxx-xxx" class="headerlink" title="xxx, _xxx, __xxx"></a><strong>xxx</strong>, _xxx, __xxx</h3><pre><code>_xxx 不能用’from module import *’导入  （相当于protected） __xxx__ 系统定义名字   (系统内置的，比如关键字)__xxx 类中的私有变量名  （privated），所以更加不能使用from module import进行导入了,可以通过 _类名_xxx来访问。</code></pre><h3 id="上下文管理器with"><a href="#上下文管理器with" class="headerlink" title="上下文管理器with:"></a>上下文管理器with:</h3><p>  上下文管理器（Context Manager）：支持上下文管理协议的对象，这种对象实现了<strong>enter</strong>() 和 <strong>exit</strong>() 方法。上下文管理器定义执行 with 语句时要建立的运行时上下文，负责执行 with 语句块上下文中的进入与退出操作。通常使用 with 语句调用上下文管理器，也可以通过直接调用其方法来使用。</p><p>   with 语句的语法格式<br>   with context_expression [as target(s)]:<br>       with-body<br>   这里 context_expression 要返回一个上下文管理器对象，该对象并不赋值给 as 子句中的 target(s) ，如果指定了 as 子句的话，会将上下文管理器的 <strong>enter</strong>() 方法的返回值赋值给 target(s)。target(s) 可以是单个变量，或者由“()”括起来的元组（不能是仅仅由“,”分隔的变量列表，必须加“()”）</p><h3 id="调试："><a href="#调试：" class="headerlink" title="调试："></a>调试：</h3><p>  　- 执行时调试<br> 　　python -m pdb some.py<br> 　　只用这种就行<br> 　 -m 指的是module， 像脚本一样运行模块</p><pre><code>- 交互调试</code></pre><p>  　import pdb<br>  　pdb.run(‘testfun(args)’)</p><p>  　- 程序下断点<br> 　 import pdb<br> 　 pdb.set_trace()<br> 　 运行到这之后停住，使用与gdb类似，p打印，n单步，s进入函数，c继续执行，</p><h2 id="基本模块"><a href="#基本模块" class="headerlink" title="基本模块"></a>基本模块</h2><ul><li><p>re<br>主要2种用法：<br>re.find(r’\d[4-5]\s\d{1,2}’,’aetbert’ )</p><p>patten = re.compile(r’\b[a-zA-Z]{3}\b’)<br>patten.findall(x)</p><p>个数：<br>   +*? {}<br>范围：<br>  [a-z]<br>语法糖：<br>  \b \w \s \d<br>界定符：<br>  ^ $</p></li></ul><h2 id="语言特色"><a href="#语言特色" class="headerlink" title="语言特色"></a>语言特色</h2><h3 id="C-C内存管理"><a href="#C-C内存管理" class="headerlink" title="C++/C内存管理"></a>C++/C内存管理</h3><p>一个由C/C++编译的程序占用的内存分为以下几个部分：<br>1、栈区（stack）—  由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。<br>2、堆区（heap） —  一般由程序员分配释放，若程序员不释放，程序结束时可能由OS（操作系统）回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。<br>3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。<br>4、文字常量区  —常量字符串就是放在这里的。程序结束后由系统释放。<br>5、程序代码区—存放函数体的二进制代码。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要包括：闭包与装饰器，内存管理，常用的模块介绍，pdb调试，进程及线程，python网络(tcp/udp/select/poll)，数据库等&lt;br&gt;
    
    </summary>
    
      <category term="语言" scheme="http://yoursite.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python基础</title>
    <link href="http://yoursite.com/2018/07/25/python%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/07/25/python基础/</id>
    <published>2018-07-25T02:36:30.000Z</published>
    <updated>2018-07-25T03:14:46.637Z</updated>
    
    <content type="html"><![CDATA[<p>本文包括：语法、变量、运算、函数、文件、类与对象、枚举、异常<br><a id="more"></a></p><h1 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用python3.6.1<br>yum install zlib-devel bzip2-devel openssl-devel ncurese-devel gcczlib</p><p>OpenStack-云计算</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul><li>for/while<br>while/for也可以跟else，意思是for循环结束之后执行，break会跳过else<br>for  :<br>  if  :<pre><code>break</code></pre>else :</li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><img src="1.python中对象分类.png" alt=""></p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>分为堆内存、栈内存。堆中放具体的数据，栈中放引用</p><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><ul><li>数值类型Numeric<br>布尔型True<br>浮点<br>整形</li><li>空值<br>None，在堆内存中也有值</li></ul><h3 id="字符串String"><a href="#字符串String" class="headerlink" title="字符串String"></a>字符串String</h3><p>  单双引号都可以”bus”，’bus’<br>  name=”abcdef” #就是字符串数组</p><p>  print(name[0])<br>  还可以从右往左数,-1是起始位置<br>  print(name[-1])</p><ul><li><p>切片[起始位置:结束位置:步长]，切片属于顺序型数据的共同用法，list,tuple<br>包头不包尾</p></li><li><p>find()<br> my_str = “hello world”<br> my_str.find(“world”)<br> 找不到返回-1</p></li><li><p>index()<br> my_str.index(“world”)<br> 找不到返回错误</p></li><li><p>join()<br> 合并2字符串</p></li><li>count()<br> 出现的次数</li><li><p>replace()<br> 替代字符串中某段</p></li><li><p>split()<br>与Java中相同，返回一个List<br>若不指定，会将所有的隔开符都隔开</p></li><li><p>partition()<br>也是切割，将形参中的字符串，隔离出来</p></li><li>capitalize()<br>字符串首字母</li><li>title()<br>字符串每个word的首字母大写</li><li>upper()</li><li><p>lower()</p></li><li><p>startwith()</p></li><li><p>endswith()<br>判断开头与结尾</p></li><li><p>ljust(50)</p></li><li>rjust(50)</li><li><p>center(50)<br>对齐</p></li><li><p>rstrip</p></li><li>lstrip</li><li><p>strip<br>删除空格</p></li><li><p>isalpha<br>都是字某返回true</p></li><li>isdigit<br>都是数字</li><li>isalnum<br>字母或者数字</li><li><p>isspace<br>只包含空格</p></li><li><p>join<br>列表转字符串<br>names=[‘1’,’2’,’’3]<br>“”.join(names)<br>“.”.join(names)：笛卡尔积</p></li></ul><h3 id="list列表"><a href="#list列表" class="headerlink" title="list列表[]"></a>list列表[]</h3><p>list<br>names=[]</p><ul><li>增<br>append<br>  在最后追加<br>extend<br>  两个列表的合并<br>insert<br>  任意位置插入</li><li>修改<br>name[2]=’888’</li><li>查<br>in/not in 关键字<br>  判断是否有或者没有<br>index(元素)<br>  返回元素的下标位<br>count<br>  统计元素在</li><li><p>删<br>del<br>  删除某个位置上的元素<br>  del a[2]<br>remove<br>  删除具体的内容<br>  a.remove<br>pop<br>  拿出最后一个数据</p></li><li><p>排序<br>sort()<br>  默认是升序<br>  sort(reverse=True)：降序<br>reverse()<br>  a.reverse()<br>  a就倒叙了<br>  a[-1::-1]<br>  返回a的倒叙，但a不会倒叙a=[-1::-1]可以<br>  ::是一直到的意思</p><ul><li>range<br>c=rang(1,10),lazy的在操作元素时，才会创建<br>c是一个列表</li></ul></li></ul><h3 id="tuple元组"><a href="#tuple元组" class="headerlink" title="tuple元组()"></a>tuple元组()</h3><p>元祖与列表类似，不同之处在于元组里的数据不能修改，元组使用(),列表使用[]</p><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>my_str=(‘aa’,’bb’,’cc’)</p><h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><p>my_str[0]  ‘aa’<br>count<br>index</p><h4 id="可变类型："><a href="#可变类型：" class="headerlink" title="可变类型："></a>可变类型：</h4><ul><li>可变类型：list</li><li>不可变类型:数值，字符串，元组<br>声明好之后，长度固定，不能修改其中的元素，不能追加<br>元组中的列表元素可以修改<br><img src="2.元组.png" alt=""></li></ul><h3 id="dict字典-map"><a href="#dict字典-map" class="headerlink" title="dict字典{} = map"></a>dict字典{} = map</h3><p>d = {“michael”:95,”bob”:75,”tracy”:85}</p><ul><li><p>访问<br>d.get(‘bob’)：键不存在，返回None<br>d[‘bob’]：键不存在，报错<br>d[‘john’]=’78’</p></li><li><p>删<br>del stus[‘bob’]<br>del stus<br>stus.pop(‘bob’)<br>内存立即回收，stus就不存在了<br>d.clear()<br>d还存在，元素不在了</p></li><li><p>函数lens(),keys(),values(),items()</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">stu=&#123;&quot;name&quot;:&quot;laowang&quot;,&quot;age&quot;:33&#125;</span><br><span class="line"></span><br><span class="line">for k in stu.keys():</span><br><span class="line">        print(k)</span><br><span class="line"></span><br><span class="line">for v in stu.values():</span><br><span class="line">        print(v)</span><br><span class="line"></span><br><span class="line">for item in stu.items():</span><br><span class="line">        print(&quot;key为:%s,value为:%s&quot;%item)</span><br><span class="line">items()是元组</span><br></pre></td></tr></table></figure><pre><code>&quot;name&quot; in stu 返回True            </code></pre><ul><li>key值需要可以hash<br>a=[1,2,4]<br>b={a:”test”}  #此时是不可以的<br>可以认为，可变类型不能作为key</li></ul><h3 id="set集合"><a href="#set集合" class="headerlink" title="set集合{}"></a>set集合{}</h3><p>a={1,3}<br>print a=set()是空集合</p><ul><li>增add</li><li>删pop</li><li>改</li><li>查</li></ul><h3 id="相互转化"><a href="#相互转化" class="headerlink" title="相互转化"></a>相互转化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;1,2,3,4,4,4,4&#125;</span><br><span class="line">l = list(a)  #l是列表</span><br><span class="line">s = set(l)   #s是集合</span><br><span class="line">t = tuple(s) #t是元组</span><br></pre></td></tr></table></figure><h3 id="可变类型与不可变类型"><a href="#可变类型与不可变类型" class="headerlink" title="可变类型与不可变类型"></a>可变类型与不可变类型</h3><ul><li><p>不可变类型:数值，字符串，元组<br>a=’abc’<br>a.replace(“a”,’A’)，它返回一个Abc，但a还是abc<br>id(a) 打印a执行的内存地址<br>声明好之后，长度固定，不能修改其中的元素，不能追加</p></li><li><p>可变类型：list，字典<br>可变类型就是在原址上可以增加修改的类型</p></li><li><p>总结</p><ol><li><p>变量与对象<br>变量：python可以认为都是引用<br>对象：对象有类型的差异，并且有具体的内存地址，是内存里具体的东西</p></li><li><p>赋值<br>python的赋值有2种：一种是引用的指向，二种是创建一个对象<br>直接一个变量等于另一个变量，都是引用的指向修改，不会创建对象<br>不可改变类型，重新赋值时，会创建新的对象。</p></li><li><p>传参<br>传参都是引用的指向，不会创建对象</p></li><li><p>python的缓存:见下面的内存管理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = 256</span><br><span class="line">b = 256</span><br><span class="line">a is b #True</span><br><span class="line"></span><br><span class="line">c = 257</span><br><span class="line">d = 257</span><br><span class="line">c is d #False</span><br></pre></td></tr></table></figure></li></ol></li></ul><pre><code>python会缓存一些小的对象，比如数值与小的字符串，于是出现以上的情况</code></pre><ul><li><p>案例</p><ol><li>元组中的列表元素可以修改<br><img src="2.元组.png" alt=""></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a=[1,2]</span><br><span class="line">b=a</span><br><span class="line">b+=[3,4]</span><br><span class="line">#这时候a也是[1,2,3,4]</span><br><span class="line"></span><br><span class="line">def test(num):</span><br><span class="line">  num+=num</span><br><span class="line">  print(num)</span><br><span class="line"></span><br><span class="line">#a=10   ：数值是不可变类型，在num+=num时，会重新开辟空间使num重新指向</span><br><span class="line">#a=[10] ：[]可变类型，在num+=num时，在原用的内存修改</span><br><span class="line">test(a)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure></li></ul><h3 id="基本类型转换"><a href="#基本类型转换" class="headerlink" title="基本类型转换"></a>基本类型转换</h3><p>整数字符串转换为对应的整数<br>int(‘12’)</p><p>小数字符串转换为对应小数<br>float(‘12.34’)</p><p>数字转换为字符串<br>str(123.45)</p><p>ASCII码转换为相应字符<br>chr(97)</p><p>字符转换为响应ASCII码<br>ord(‘a’)</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="dict-pair"><a href="#dict-pair" class="headerlink" title="dict = pair"></a>dict = pair</h4><p>map中可以放很多数据，而中仅能放一条<br>[{},{}]这种结构还差不多</p><h4 id="python是一种弱类型语言，"><a href="#python是一种弱类型语言，" class="headerlink" title="python是一种弱类型语言，"></a>python是一种弱类型语言，</h4><p>{“name”:’sun’,”age”:18}，name与age其实是结构</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="命名空间（namespace）"><a href="#命名空间（namespace）" class="headerlink" title="命名空间（namespace）"></a>命名空间（namespace）</h3><h3 id="全局变量与局部变量"><a href="#全局变量与局部变量" class="headerlink" title="全局变量与局部变量"></a>全局变量与局部变量</h3><ul><li>LEGB: locals &gt; enclosing fuction(闭包) &gt; globals &gt; builtins(内建)<br>在函数内部要使用global时,需要声明:global a<br>globals()函数可以看全局的属性<br>locals()函数,可以看到局部的属性<br>dir(<strong>builtin</strong>)<h2 id="和-is"><a href="#和-is" class="headerlink" title="== 和 is"></a>== 和 is</h2>is是比较两个引用是否指向了统一对象(引用比较) 或者说地址比较<br>== 是比较两个对象是否相等（值比较）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = [1,2,3]</span><br><span class="line">b = a</span><br><span class="line"></span><br><span class="line">a == b #True</span><br><span class="line">a is b #True</span><br><span class="line"></span><br><span class="line">c = a[:] 或者 c=list(a)</span><br><span class="line">a == c #True</span><br><span class="line">a is c #False</span><br></pre></td></tr></table></figure><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><h3 id="进制、位运算"><a href="#进制、位运算" class="headerlink" title="进制、位运算"></a>进制、位运算</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int(o, 8) =  10 #把8转换为八进制的10</span><br><span class="line">int(h, 16) = 10</span><br><span class="line">bin(5) = &apos;0b101&apos;</span><br><span class="line">bin(-5) = &apos;=0b101&apos;</span><br></pre></td></tr></table></figure><p>位与&amp;<br>位或|<br>位异或^<br>取反~<br>左移&lt;&lt;<br>右移&gt;&gt;</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>表达式或者关键字没有(),且有：<br>函数才有()</p><h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><p><img src="3.内置函数.png" alt=""></p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def print_hello():</span><br><span class="line">    print(&quot;人生苦短，我要学python&quot;)</span><br><span class="line"></span><br><span class="line">def test(r):</span><br><span class="line">    s=3.14*(r**2)</span><br><span class="line">    print(s)</span><br><span class="line"></span><br><span class="line">def sum_2num(a,b):</span><br><span class="line">    if not isinstance((a,b),(int,float)) #是否为int或者浮点数(int,float)是个数组</span><br><span class="line">        print(&quot;请输入正确的字符类型&quot;)</span><br><span class="line">        return</span><br><span class="line">    return a+b</span><br><span class="line"></span><br><span class="line">def create():</span><br><span class="line">    a=1</span><br><span class="line">    b=3</span><br><span class="line">    return a,b</span><br><span class="line">x,y=create()</span><br><span class="line">z=create()  #z是元组</span><br></pre></td></tr></table></figure><p>看到def后会加载函数，并不会执行</p><h3 id="全局变量与局部变量-1"><a href="#全局变量与局部变量-1" class="headerlink" title="全局变量与局部变量"></a>全局变量与局部变量</h3><p>作用域与C语言相同即，全局变量可以在函数内获取并修改<br>修改不可变类型的引用，global</p><h3 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def test(x,y,*args):</span><br><span class="line">  print(x,y)</span><br><span class="line">  print(args)</span><br></pre></td></tr></table></figure><p>不定长参数是以元组的方式传入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def test(x,y, **kwarg):</span><br><span class="line">    print(x,y)</span><br><span class="line">    print(kwarg)</span><br></pre></td></tr></table></figure><p>此时候的不定参数是键值对</p><h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><h3 id="匿名函数lambda"><a href="#匿名函数lambda" class="headerlink" title="匿名函数lambda"></a>匿名函数lambda</h3><ul><li><p>lambda [arg1[,agr2…agrn]]:表达式<br>sum = lambda x,y:x+y<br>print(sum(22,45))</p></li><li><p>缺点不能简单的操作，因为函数体只能是表达式</p></li><li><p>lambda可以作为实参传递给函数</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def test(a,b,func):</span><br><span class="line">          result = func(a,b)</span><br><span class="line">          return result</span><br><span class="line">    </span><br><span class="line">print(test(23,33,lambda x,y:x*y))</span><br></pre></td></tr></table></figure><p>  感觉像是懒加载，以及lambda也是一个引用，定义在栈上</p><ul><li>dict排序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stus=[&#123;&quot;name&quot;:&quot;zs&quot;,&quot;age&quot;:12&#125;,&#123;&quot;name&quot;:&quot;ls&quot;,&quot;age&quot;:14&#125;]</span><br><span class="line">stus.sort(key=lambda x:x[&quot;name&quot;]) #返回类表中每个元素name的value</span><br><span class="line">print(stus)</span><br></pre></td></tr></table></figure><ul><li>动态语言：用户可以随意变化表达式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def test1(a,b,func):</span><br><span class="line">          return func(a,b)</span><br><span class="line">function = eval(input(&quot;请输入表达式:&quot;))  #eval可以将输入的字符串，转变为表达式</span><br><span class="line">print(test1(4,5,function))</span><br></pre></td></tr></table></figure><h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><p>a=1<br>b=3</p><p>#借用元组来实现的<br>a,b=b,a</p><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>与C语言类似<br>f = open(“test.txt”,’w’)<br>r/w/a<br>r+打开一个文件用于读写，文件指针在开头<br>w+读写，如果文件已存在就将其覆盖，否则就创建<br>a+读写，不创建，文件指针在最后。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">f.close()</span><br><span class="line">f.write(&quot;abcd&quot;)</span><br><span class="line"></span><br><span class="line">f.read()/f.read(6)：看参数</span><br><span class="line">f.readline()读取一行：一行一行读</span><br><span class="line"></span><br><span class="line">f.tell()返回文件指针位置</span><br><span class="line">f.seek(offset,from) form：0-文件开头，1当前位置，2文件末尾</span><br><span class="line">  f.seek(0,0)文件开头</span><br></pre></td></tr></table></figure><h3 id="文件夹"><a href="#文件夹" class="headerlink" title="文件夹"></a>文件夹</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">file_list=os.listdir(&quot;test/&quot;)</span><br><span class="line">for f in file_list</span><br><span class="line">   print(f)</span><br></pre></td></tr></table></figure><p> <img src="4.文件操作.png" alt=""></p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="从指定目录下，找包含有hello的py文件"><a href="#从指定目录下，找包含有hello的py文件" class="headerlink" title="从指定目录下，找包含有hello的py文件"></a>从指定目录下，找包含有hello的py文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">file_list=[]</span><br><span class="line">def find_hello(parent_dir,file_name):</span><br><span class="line">    file_abspath=os.path.join(parent_dir,file_name)</span><br><span class="line">    if os.path.isdir(file_abspath):</span><br><span class="line">        for f in os.listdir(file_abspath):</span><br><span class="line">           find_hello(file_abspath,f)</span><br><span class="line">    else:</span><br><span class="line">        if dir.endswith(&quot;.py&quot;):</span><br><span class="line">           if read_and_find_hello(file_abspath): #判断内容中是否有hello</span><br><span class="line">                file_list.append(file_abspath)</span><br><span class="line"></span><br><span class="line">def read_and_find_hello(file):</span><br><span class="line">   f = open(file,&quot;r&quot;)</span><br><span class="line">   while True:</span><br><span class="line">      line=f.readline()</span><br><span class="line">      if line==&quot;&quot;:</span><br><span class="line">         break</span><br><span class="line">      elif &quot;hello&quot; in line</span><br><span class="line">        f.close()</span><br><span class="line">        retrun True</span><br><span class="line">   else:</span><br><span class="line">      f.close()</span><br><span class="line">      return False</span><br><span class="line"></span><br><span class="line">find_hello(&quot;/home/&quot;,&quot;python&quot;)</span><br><span class="line">print(file_list)</span><br></pre></td></tr></table></figure><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><p>class 类名：<br>    属性<br>    方法列表<br>方法第一参数一定是self<br>对象名 = 类名()</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>使用上与C++/Jave相同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Car:</span><br><span class="line">         def start(self):</span><br><span class="line">                 print(&quot;汽车启动&quot;)</span><br><span class="line"> </span><br><span class="line">         def print_info(self):</span><br><span class="line">                 print(&quot;汽车名字%s,颜色%s&quot;%(self.name,self.color))</span><br><span class="line"></span><br><span class="line">car1= Car()</span><br><span class="line">car1.name=&quot;凯迪拉克&quot;</span><br><span class="line">car1.color=&quot;白色&quot;</span><br><span class="line">car1.start()</span><br><span class="line">car1.print_info()</span><br></pre></td></tr></table></figure><h3 id="不同"><a href="#不同" class="headerlink" title="不同"></a>不同</h3><p>  属性上很另类<br>  而且有self:self其实与this有些类似</p><h3 id="魔法方法xxx"><a href="#魔法方法xxx" class="headerlink" title="魔法方法xxx"></a>魔法方法<strong>xxx</strong></h3><h3 id="init-self"><a href="#init-self" class="headerlink" title="init(self)"></a><strong>init</strong>(self)</h3><p>类于构造函数，但构造函数是构造时，init是构造之后初始化的时候</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def __init__(self):</span><br><span class="line">    self.name=&quot;zs&quot;</span><br><span class="line">    self.age=18</span><br><span class="line"></span><br><span class="line">def __init__(self,name,age,height):</span><br><span class="line">    self.name=name</span><br><span class="line">    self.age=age</span><br><span class="line">    self.heigtht=height</span><br></pre></td></tr></table></figure><p>初始化对象的方法，不是构造方法：<strong>new</strong>()构造对象–&gt;得到一对象–&gt;<strong>init</strong>(self)</p><h3 id="del-self"><a href="#del-self" class="headerlink" title="del(self)"></a><strong>del</strong>(self)</h3><p>当内存中释放一个对象时，调用<strong>del</strong>()方法<br>类似于析构函数<br>注意python中=，都是引用，但其引用可以重新指向</p><h3 id="str-self"><a href="#str-self" class="headerlink" title="str(self)"></a><strong>str</strong>(self)</h3><p>def <strong>str</strong>(self):<br>    return “string here”<br>类似与Java的toString方法</p><h3 id="new-cls"><a href="#new-cls" class="headerlink" title="new(cls):"></a><strong>new</strong>(cls):</h3><ul><li>必须有返回值，类的对象</li><li>如果不返回，对象不会构建，也就不会运行<strong>init</strong>方法<br>return object.<strong>new</strong>(cls)</li><li>与init区别<br>1.new是构造，init是初始化<br>2.new是类方法[可以通过类来调用]，init是普通方法<br>3.先执行new后执行init</li></ul><h3 id="掷骰子"><a href="#掷骰子" class="headerlink" title="掷骰子"></a>掷骰子</h3><ul><li>range()也是包头不包尾</li><li>random.randint(1,7)需要引入import random</li><li>思路<br>掷骰子游戏可以有多个人来玩，多个骰子在一个骰子钟里抛掷相加得到结果<br>Game与Play是聚合，Play个数可以指定<br>Game与Dices（骰子钟）是组合关系<br>Dices与Dice也是聚合关系，个数可以指定</li></ul><h3 id="私有化（隐藏）"><a href="#私有化（隐藏）" class="headerlink" title="私有化（隐藏）"></a>私有化（隐藏）</h3><p>属性：__xxx</p><p>方法：def __xxx():</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li><p>定义<br>class Animal:<br>class Dog(Animal):<br>在子类后加()，写入父类即可。有些像函数，不可混。</p></li><li><p>差异<br>子类的<strong>init()</strong>会覆盖掉父类的<strong>init()</strong><br>经测试<strong>new</strong>方法也会覆盖掉父类的<br><strong>new</strong>会覆盖掉<strong>init</strong><br>父类的公有属性，如果父类<strong>init</strong>方法没有调用，也就继承不了，也就是说：属性没有继承super().<strong>init</strong>()可以手动去实现</p></li><li><p>多继承<br>class C(A,B):<br>就是多继承，继承关系的优先级C&gt;A&gt;B</p></li><li><p>print(C.<strong>mro</strong>)可以打印继承关系<br>可以所有类看出从object中继承，这一点与Java相同<br>其中的<strong>init</strong>(),<strong>del</strong>()</p></li><li><p>重写<br>子类与父类的方法名相同就叫重写<br>super().<strong>init</strong>()<br>重写中，可以通过super()调用父类的方法</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3></li><li>python是弱类型语言，没有多态<h3 id="类属性（对象属性的区别）与类方法"><a href="#类属性（对象属性的区别）与类方法" class="headerlink" title="类属性（对象属性的区别）与类方法"></a>类属性（对象属性的区别）与类方法</h3></li><li>类属性是类对象所拥有的属性，它被类对象的实例所共有，在内存中之后一个副本</li><li>就是C++/Java的静态成员变量</li><li>定义</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class People(object):</span><br><span class="line">    name = &quot;Tom&quot; #共有类属性</span><br><span class="line">    __age = 12  #私有类属性</span><br><span class="line"></span><br><span class="line">print(People.name)</span><br><span class="line">p = People()</span><br><span class="line">print(p.name)</span><br></pre></td></tr></table></figure><ul><li><p>对象属性<br>就是对象自己的<br>self.name = name 这种</p></li><li><p>区别<br>类属性可以被子类继承，对象属性不能直接继承<br>继承仅是继承父类的方法，以及类属性<br>类属性只能通过类来修改：People.name = “ww”<br>  当时有p.name = “zs”定义了一个对象属性name</p></li><li><p>类方法<br>一定要在类上加一个修饰器（注解）<br>@classmethod<br>def getName(cls):<br>其中cls代表调用这个方法的类<br>类方法可以通过类名来调用People.getName()<br>类方法可以修改类属性     </p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>@staticmethod<br>静态方法是类方法的特殊一种，属于类，没有默认传递的参数<br>@staticmethod<br>def getAge():</p></li></ul><p>调用与类方法相同：对象与类都可以调用<br>由于没有cls，只能通过类名在修改类属性</p><h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><p>1.伪单例：自己写getInstance()静态方法，通过调用此方法来获得对象<br>2.真单例：重写<strong>new</strong>方法，所有的构造的都是单例</p><h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><p>这个简单工厂就是用一个factory类的一个类方法，来生成继承关系的不同子类对象。<br><img src="5.工厂方法.png" alt=""></p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from enum import Enum</span><br><span class="line"></span><br><span class="line">class Color(Enum):</span><br><span class="line">   red = 1</span><br><span class="line">   green = 2</span><br><span class="line">   blue = 3</span><br></pre></td></tr></table></figure><h2 id="类的数据隐藏"><a href="#类的数据隐藏" class="headerlink" title="类的数据隐藏"></a>类的数据隐藏</h2><p><strong>x双下划线，属性私有，实现方法名字重整：</strong>num，在类dir(t)时，会改变私有对象的名字:_类名<strong>属性名，其实并没有真正的隐藏，只是外部的访问上改了名字<br>_x单下划线，被当作模块导入时，不导入。外边是可以访问的</strong>xx__:名字空间的魔法属性:<strong>init</strong></p><p>self这里不是关键字，第一个代表对象本身，可以用this等来代替</p><h3 id="property用法"><a href="#property用法" class="headerlink" title="property用法"></a>property用法</h3><ul><li>使用property方法升级getter 与 setter</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Test:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.__money=0</span><br><span class="line"></span><br><span class="line">    def getMoney(self):</span><br><span class="line">        return self.__money</span><br><span class="line"></span><br><span class="line">    def setMoney(self,money)</span><br><span class="line">        self.__money=money</span><br><span class="line"></span><br><span class="line">    money = property(getMoney,setMoney)</span><br><span class="line"></span><br><span class="line">test=Test()</span><br><span class="line">test.money=20</span><br></pre></td></tr></table></figure><p>#这种写法就把money变成共有不就好了</p><ul><li>装饰器写法<br>@property  : getter<br>@money.setter  : setter<br>方法名与属性名的去掉__一致</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Test:</span><br><span class="line">   def __init__(self):</span><br><span class="line">        self.__money=0</span><br><span class="line">   </span><br><span class="line">   @property  #getter</span><br><span class="line">   def money(self):</span><br><span class="line">       return self.__money</span><br><span class="line"></span><br><span class="line">   @money.setter</span><br><span class="line">   def money(this,money)</span><br><span class="line">       this.__money = money</span><br><span class="line"></span><br><span class="line">t = Test()</span><br><span class="line">t.money = 20</span><br><span class="line">print(r.money)</span><br></pre></td></tr></table></figure><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><p>try..except，except就是catch<br>Exception/NameError/FileNotFoundError/ZeroDivisionError<br>except可以用元组来实现多个异常<br>as ex，ex是异常变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">  print(a)</span><br><span class="line">except (NameError/ZeroDivisionError) as ex:</span><br><span class="line">  print(ex)</span><br><span class="line">else:</span><br><span class="line">  print(&quot;没有异常&quot;)</span><br><span class="line">finally:</span><br><span class="line">  print(&quot;无论有没有都能被执行&quot;)</span><br></pre></td></tr></table></figure><p>抛异常：raise exception</p><p>异常嵌套，异常传递</p><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>class PasswordException(Exception):</p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><ul><li>模块相当于jar包</li><li>import 即可<h2 id="模块与包"><a href="#模块与包" class="headerlink" title="模块与包"></a>模块与包</h2>相当于jar包<h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3></li><li><p>import 模块名<br>模块名.函数名()</p><p>import random<br>random.randint(1,5)</p></li><li><p>from 模块名 import 函数名(变量，类等)<br>from random import randint<br>randint(1,5)</p></li><li><p>from 模块 import *【几乎不用】<br>一个模块全部内容都导入</p></li><li><p>as 导入时，给模块重新命名<br>import random as rdm<br>rdm.randint(1,5)<br>random__file__</p></li><li><p>注意<br>若导入有相同的函数名，后导入的会覆盖先导入的</p></li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><strong>name</strong>:<strong>main</strong>()<br>if(<strong>name</strong>==”<strong>main</strong>“):#python解释器主动执行该模块代码为了测试<br>    print(isnull(“”))</p><p><strong>all</strong>：后边加列表，用于写出模块中需要导出的方法/变量/类，但这种方式只有from ..import *时可用，在python3中，使用较少<br><strong>all</strong>=[“isnull”]</p><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>本质上就是一个目录，把模块放入目录中，就可称为一个包<br>优先到当前目录，然后是python系统目录<br>  import 包(文件夹).模块(文件)<br>  from 包 import 模块</p><p>python3中目录就是一个包<br>python2中需要有<strong>init</strong>.py文件,即使是空文件也可以<br>如果在<strong>init</strong>.py中增加from . import module1，那么在其他中可以直接import包名</p><p>这里的import类似于c/c++的include</p><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>把自己写的模块，发布到python的系统目录下</p><ul><li>setup.py<br>在包同级目录下增加setup.py文件，并写</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from distutils.core import setup</span><br><span class="line">setup(name=&quot;my_packet&quot;,version=&quot;1.0&quot;,description=&quot;描述&quot;,author=&quot;作者&quot;,py_modules=[&quot;my_packet.module1&quot;])</span><br></pre></td></tr></table></figure><ul><li>python3 setup.py build</li><li>python3 setup.py sdist<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3></li><li>找到模块安装包</li><li>解压</li><li>进入文件夹</li><li>执行python3 setup.py install即可</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h3><p> import sys<br> sys.argv<br>  参数第一个是.py本身<br> sys.argv[1::]</p><h3 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h3><p>其实就是创建列表/字典的<br>a=[i for i in range(1,10)]<br>a=[i**i for i in range(1,10)]</p><p>b=[x for x in range(1,3) for y in range(0,2)]<br>[1,1,2,2] 循环的嵌套1循环2次，2也也是2次</p><p>c=[x for x in range(1,101) if x%2==1]</p><h3 id="传参-1"><a href="#传参-1" class="headerlink" title="传参"></a>传参</h3><p><img src="6.习题.png" alt=""><br><img src="6.习题解释.png" alt=""><br>其实即使函数的默认参数只会创建一次,因为它懒</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文包括：语法、变量、运算、函数、文件、类与对象、枚举、异常&lt;br&gt;
    
    </summary>
    
      <category term="语言" scheme="http://yoursite.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>redis基础</title>
    <link href="http://yoursite.com/2018/07/21/redis/"/>
    <id>http://yoursite.com/2018/07/21/redis/</id>
    <published>2018-07-21T03:59:23.000Z</published>
    <updated>2018-07-25T02:04:32.132Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍redis的基础，包括redis的数据结构，发布订阅，事务，数据持久化，主从结构等内容。<br>本文是学习《redis实战》整理的博客。<br><a id="more"></a></p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>redis存储的本身就是key:value形式的数据，所说的数据结构，指的是value的结构。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>key: string<br><img src="字符串类型.png" alt=""></p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ul><li>基本操作</li></ul><table><thead><tr><th>命令</th><th style="text-align:center">行为</th><th style="text-align:right">使用</th></tr></thead><tbody><tr><td>set</td><td style="text-align:center">设置存储在给定key中的值</td><td style="text-align:right">set name sun</td></tr><tr><td>get</td><td style="text-align:center">获取存储在给定key中的值</td><td style="text-align:right">get name</td></tr><tr><td>del</td><td style="text-align:center">删除存储在给定key中的值</td><td style="text-align:right">del name</td></tr></tbody></table><ul><li>数值操作<br>其实这个不应该说字符串，因为它的value值可以是数值，包括整数与浮点数。</li></ul><table><thead><tr><th>命令</th><th style="text-align:center">行为</th><th style="text-align:right">使用</th></tr></thead><tbody><tr><td>incr</td><td style="text-align:center">将键对应的值+1</td><td style="text-align:right">incr age</td></tr><tr><td>decr</td><td style="text-align:center">将键对应的值-1</td><td style="text-align:right">decr age</td></tr><tr><td>incrby</td><td style="text-align:center">将键对应值+amount</td><td style="text-align:right">incrby age 10</td></tr><tr><td>decrby</td><td style="text-align:center">将键对应值-amount</td><td style="text-align:right">decrby age 10</td></tr><tr><td>incrbyfloat</td><td style="text-align:center">将键对应值加浮点amount</td><td style="text-align:right">incrbyfloat height 5.6</td></tr></tbody></table><p>  对一个不存在的键或者一个保存了空串的键执行自增或者自减操作，那么redis在执行操作时，会将这个键的值当作0来处理。如果对无法转换成数值的字符串进行操作，那么返回一个错误。</p><ul><li>字串操作</li></ul><table><thead><tr><th>命令</th><th style="text-align:center">行为</th><th style="text-align:right">使用</th></tr></thead><tbody><tr><td>append</td><td style="text-align:center">将value追加给定键的值的末尾</td><td style="text-align:right">append key value</td></tr><tr><td>getrange</td><td style="text-align:center">获取一个由偏移量start-end的字串</td><td style="text-align:right">getrange key start end</td></tr><tr><td>setrange</td><td style="text-align:center">将从offset偏移量设置为定值</td><td style="text-align:right">setrange key offset value</td></tr><tr><td>getbit</td><td style="text-align:center">将字符串堪称二进制位串，返回offset的二进制</td><td style="text-align:right">getbit key offset</td></tr><tr><td>setbit</td><td style="text-align:center">将offset的二进制设为value</td><td style="text-align:right">setbit key offset value</td></tr><tr><td>bitcount</td><td style="text-align:center">统计二进制位串中1的数量</td><td style="text-align:right">bitcount key [start end]</td></tr><tr><td>bitop</td><td style="text-align:center">按位操作，包括and/or/xor/not</td><td style="text-align:right">bitop operation dest-key key-name</td></tr></tbody></table><p>  个人而言这些操作并没有什么用</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p>key：list<br><img src="列表类型.png" alt=""><br>这个列表可以认为是双向的队列，左边与右边都能push与pop</p><h3 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h3><ul><li>基本操作</li></ul><table><thead><tr><th>命令</th><th style="text-align:center">行为</th><th style="text-align:right">使用</th></tr></thead><tbody><tr><td>rpush</td><td style="text-align:center">将value推入列表右端</td><td style="text-align:right">rpush students wang</td></tr><tr><td>lpush</td><td style="text-align:center">将value推入列表的左端</td><td style="text-align:right">lpush students liu</td></tr><tr><td>rpop</td><td style="text-align:center">从右端弹出一个值，并返回此值</td><td style="text-align:right">rpop students</td></tr><tr><td>lpop</td><td style="text-align:center">从左端弹出一个值，并返回此值</td><td style="text-align:right">lpop students</td></tr><tr><td>lrange</td><td style="text-align:center">从左端切片</td><td style="text-align:right">lrange students 0 -1</td></tr><tr><td>lindex</td><td style="text-align:center">左端的下标操作</td><td style="text-align:right">lindex students 1</td></tr><tr><td>ltrim</td><td style="text-align:center">对列表进行剪裁，只保留start-end</td><td style="text-align:right">ltrim students 2 -1</td></tr></tbody></table><ul><li>阻塞操作</li></ul><table><thead><tr><th>命令</th><th style="text-align:center">行为</th><th style="text-align:right">使用</th></tr></thead><tbody><tr><td>blpop</td><td style="text-align:center">从第一个非空类表中弹出元素，或者为空在timeout内阻塞</td><td style="text-align:right">blpop key1 [key2…] timeout</td></tr><tr><td>brpop</td><td style="text-align:center">右端的阻塞pop</td><td style="text-align:right">brpop key1 [key2..] timeout</td></tr><tr><td>rpoplpush</td><td style="text-align:center">从source-key列表弹出元素，然后推入dest-key的左端</td><td style="text-align:right">rpoplpush source-key dest-key</td></tr><tr><td>brpoplpush</td><td style="text-align:center">阻塞的brpoplbush</td><td style="text-align:right">brpoplpush source-key dest-key timeout</td></tr></tbody></table><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h3><p>key: set<br><img src="集合类型.png" alt=""></p><h3 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a>操作</h3><ul><li>基本操作</li></ul><table><thead><tr><th>命令</th><th style="text-align:center">行为</th><th style="text-align:right">使用</th></tr></thead><tbody><tr><td>sadd</td><td style="text-align:center">往集合中添加元素</td><td style="text-align:right">sadd family father</td></tr><tr><td>smembers</td><td style="text-align:center">返回所有元素</td><td style="text-align:right">smembers family</td></tr><tr><td>sismember</td><td style="text-align:center">检测给定元素是否在集合中</td><td style="text-align:right">sismember family mother</td></tr><tr><td>srem</td><td style="text-align:center">如果元素在，则移除</td><td style="text-align:right">srem family thief</td></tr><tr><td>scard</td><td style="text-align:center">返回集合包括的元素数量</td><td style="text-align:right">scard family</td></tr><tr><td>srandmember</td><td style="text-align:center">从集合中随机返回一个或多个元素</td><td style="text-align:right">srandmember key [count]</td></tr><tr><td>spop</td><td style="text-align:center">随机移除一个元素，并返回</td><td style="text-align:right">spop key</td></tr><tr><td>smove</td><td style="text-align:center">如果一个移动到另一个</td><td style="text-align:right">smove source-key dest-key item</td></tr></tbody></table><ul><li>集合操作</li></ul><table><thead><tr><th>命令</th><th style="text-align:center">行为</th><th style="text-align:right">使用</th></tr></thead><tbody><tr><td>sinter</td><td style="text-align:center">两个集合取交集</td><td style="text-align:right">sinter family1 family2</td></tr><tr><td>sunion</td><td style="text-align:center">两个集合取并集</td><td style="text-align:right">sunion family1 family2</td></tr><tr><td>sdiff</td><td style="text-align:center">两个集合取差集</td><td style="text-align:right">sdiff family1 family2</td></tr><tr><td>sinterstore</td><td style="text-align:center">交集然后存储到另一集合</td><td style="text-align:right">sinterstore dest-key key1 [key2..]</td></tr><tr><td>sunionstore</td><td style="text-align:center">并集然后转存到另一集合</td><td style="text-align:right">suninstore dest-key key1 [key2..]</td></tr><tr><td>sdiffstore</td><td style="text-align:center">差集然后转存到另一集合</td><td style="text-align:right">sdiffstore dest-key key1 [key2..]</td></tr></tbody></table><h2 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h2><h3 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h3><p>key：hash(Map)<br><img src="散列类型.png" alt=""><br>散列类型其实就是字典类型</p><h3 id="操作-3"><a href="#操作-3" class="headerlink" title="操作"></a>操作</h3><ul><li>基本操作</li></ul><table><thead><tr><th>命令</th><th style="text-align:center">行为</th><th style="text-align:right">使用</th></tr></thead><tbody><tr><td>hset</td><td style="text-align:center">添加键值对</td><td style="text-align:right">hset family father yanfeng</td></tr><tr><td>hget</td><td style="text-align:center">获取指定键的值</td><td style="text-align:right">hget family father</td></tr><tr><td>hgetall</td><td style="text-align:center">获取所有键值对</td><td style="text-align:right">hgetall family</td></tr><tr><td>hdel</td><td style="text-align:center">如果键存在则删除</td><td style="text-align:right">hdel family father</td></tr><tr><td>hlen</td><td style="text-align:center">返回键值对数量</td><td style="text-align:right">hlen key</td></tr></tbody></table><ul><li>其他操作</li></ul><table><thead><tr><th>命令</th><th style="text-align:center">行为</th><th style="text-align:right">使用</th></tr></thead><tbody><tr><td>hexists</td><td style="text-align:center">检查键是否存在</td><td style="text-align:right">hexists family father</td></tr><tr><td>hkeys</td><td style="text-align:center">获取散列包含的所有键</td><td style="text-align:right">hkeys family</td></tr><tr><td>hvals</td><td style="text-align:center">获取散列包含的所有值</td><td style="text-align:right">kvals family</td></tr><tr><td>hincrby</td><td style="text-align:center">与incrby类似</td><td style="text-align:right">hincrby course english 10</td></tr><tr><td>hincrbyfloat</td><td style="text-align:center">与incrbyfloat类似</td><td style="text-align:right">hincrbyfloat height wang 5.4</td></tr></tbody></table><h2 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h2><h3 id="结构-4"><a href="#结构-4" class="headerlink" title="结构"></a>结构</h3><p>key: zset<br><img src="有序集合.png" alt=""><br>有序集合是一种特殊的散列，它能通过value值排序</p><h3 id="操作-4"><a href="#操作-4" class="headerlink" title="操作"></a>操作</h3><ul><li>基本操作</li></ul><table><thead><tr><th>命令</th><th style="text-align:center">行为</th><th style="text-align:right">使用</th></tr></thead><tbody><tr><td>zadd</td><td style="text-align:center">将给定分值的成员添加到有序集合</td><td style="text-align:right">zadd enScore 98 sun   [96 wang]</td></tr><tr><td>zrem</td><td style="text-align:center">如果元素存在则删除</td><td style="text-align:right">zrem enScore sun [wang]</td></tr><tr><td>zincrby</td><td style="text-align:center">同incrby</td><td style="text-align:right">zincry enScore 1 sun</td></tr><tr><td>zrange</td><td style="text-align:center">切片</td><td style="text-align:right">zrange enScore 0 -1 [withscores]</td></tr><tr><td>zrangebyscore</td><td style="text-align:center">获取在给定分值范围内的所有元素</td><td style="text-align:right">zrangebyscore enScore 90 100 [withsores]</td></tr><tr><td>zcount</td><td style="text-align:center">获取在给定分值范围内的元素数量</td><td style="text-align:right">zcount enScore 90 100</td></tr><tr><td>zcard</td><td style="text-align:center">返回包含的元素数量</td><td style="text-align:right">zcard enScore</td></tr><tr><td>zscore</td><td style="text-align:center">返回member的分数</td><td style="text-align:right">zrank enScore sun</td></tr><tr><td>zrank</td><td style="text-align:center">返回成员的排名</td><td style="text-align:right">zrank enScore sun</td></tr></tbody></table><ul><li>其他操作</li></ul><table><thead><tr><th>命令</th><th style="text-align:center">行为</th><th style="text-align:right">使用</th></tr></thead><tbody><tr><td>zrevrank</td><td style="text-align:center">返回成员member的排名，由大到小</td><td style="text-align:right">zrevrank enScore sun</td></tr><tr><td>zrevrange</td><td style="text-align:center">同zrange,由大到小</td><td style="text-align:right">zrevrange enScore 0 -1 [withscores]</td></tr><tr><td>zrevrangebyscore</td><td style="text-align:center">同zrangebyscore，由大到小</td><td style="text-align:right">zrevrangebyscore enScore 90 100 [with scores]</td></tr><tr><td>zremrangebyrank</td><td style="text-align:center">移除排名start-end间元素</td><td style="text-align:right">zremrangebyrank enScore 10 20</td></tr><tr><td>zremrangebyscore</td><td style="text-align:center">移除分值介于min-max间的元素</td><td style="text-align:right">zremrangebyscore enScore 90 100</td></tr><tr><td>zinterstore</td><td style="text-align:center">同sinterstore，执行的是+</td><td style="text-align:right">zinterstore dest-key  key1 [key2..]</td></tr><tr><td>zunionstore</td><td style="text-align:center">同sunionstore，执行的是min</td><td style="text-align:right">zunionstore dest-key  key1 [key2..]</td></tr></tbody></table><p>  zinterstore<br>  <img src="zinterstore.png" alt=""></p><p> zuninstore<br>  <img src="zunionstore.png" alt=""></p><h2 id="键的过期时间"><a href="#键的过期时间" class="headerlink" title="键的过期时间"></a>键的过期时间</h2><table><thead><tr><th>命令</th><th style="text-align:center">示例</th><th style="text-align:right">描述</th></tr></thead><tbody><tr><td>expire</td><td style="text-align:center">expire key seconds</td><td style="text-align:right">让键在指定seconds秒后过期</td></tr><tr><td>expireat</td><td style="text-align:center">expireat key timestamp</td><td style="text-align:right">让键在指定时间戳过期</td></tr><tr><td>pexpire</td><td style="text-align:center">pexpire key milliseconds</td><td style="text-align:right">让键在指定milliseconds毫秒后过期</td></tr><tr><td>pexpireat</td><td style="text-align:center">pexpireat key timestamp</td><td style="text-align:right">让键在指定的毫秒级时间戳上过期</td></tr><tr><td>ttl</td><td style="text-align:center">ttl key</td><td style="text-align:right">查看给定键距离过期还有多少秒</td></tr><tr><td>pttl</td><td style="text-align:center">pttl key</td><td style="text-align:right">查看给定键距离过期时间有多少毫秒</td></tr></tbody></table><h1 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h1><p>发送者向频道发送二进制字符串消息。每当有消息被发送至频道时，频道的所有订阅者都会收到消息。<br>使用上发布订阅用于在不同进程之间传递数据。</p><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><table><thead><tr><th>命令</th><th style="text-align:center">用例</th><th style="text-align:right">描述</th></tr></thead><tbody><tr><td>SUBSCRIBE</td><td style="text-align:center">SUBSCRIBE CHANNEL1 [CHANNEL2]</td><td style="text-align:right">订阅给定的一个或多个频道</td></tr><tr><td>UNSUBSCRIBE</td><td style="text-align:center">UNSUBSCRIBE [CHANNEL1 [CHANNEL2]]</td><td style="text-align:right">退订给定频道或全部频道</td></tr><tr><td>PSUBSCIBE</td><td style="text-align:center">PSUBSCIBE PATTERN1 [PATTERN2]</td><td style="text-align:right">订阅与模式匹配的所有频道</td></tr><tr><td>punsubscibe</td><td style="text-align:center">punsubscibe pattern1 [pattern2]</td><td style="text-align:right">退订与模式匹配的所有频道</td></tr><tr><td>publish</td><td style="text-align:center">publish channel message</td><td style="text-align:right">向给定频道发送消息</td></tr></tbody></table><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>发布订阅会存在2个问题:</p><ul><li><p>redis系统的稳定性<br>如果客户端订阅某个频道,但读取消息的速度很慢,那么会使redis输出缓冲区越来越大,这导致redis数度变慢,甚至直接崩溃.<br>此问题与redis版本有关,新版本会控制输出缓冲区的大小,过慢就会断开订阅</p></li><li><p>数据传输的可靠性<br>客户端在执行订阅操作的过程中断线,会使其丢失在断线期间的所有消息.<br>这个会可以在后边去处理.</p></li></ul><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="multi-exec"><a href="#multi-exec" class="headerlink" title="multi/exec"></a>multi/exec</h2><p>和关系数据库那种可以在执行过程中进行回滚的事物不同.在Redis中，被multi和exec命令包围的所有命令会一个接一个执行，直到所有命令都执行完毕为止。直到一个事务执行完毕之后，Redis才会处理其他客户端的命令。<br>当Redis从一个客户端接受到multi命令时，Reis会将这个客户端之后发送的所有命令都放到一个队列中，直到这个客户端发送exec命令为止，然后redis在不被打断的情况下，一个接一个的执行队列中的命令。</p><h1 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>redis提供了两种不同的持久化方法。<br>一种叫快照(snapshotting)，它可以将存在于某一时刻的所有数据都写到硬盘里。<br>另一种叫追加(append-only file)AOF,它会在执行命令写命令时，将被执行的写命令复制到硬盘里。（类似与oracle的重写日志）</p><p>持久化一方面可以防止系统而将数据备份到另一个远程位置，另一方面也是将长时间运算的结果保留下来（类似与spark的图运算）</p><p><img src="redis持久化选项.png" alt=""></p><h2 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h2><ul><li><p>快照存储位置<br>快照被写入DBFILENAME选项指定的文件里，并存在DIR选项指定的路径上。</p></li><li><p>创建快照方法</p><ul><li><p>客户端可以向REDIS发送BGSAVE命令来创建一个快照。<br>REDIS会调用FORK来创建一个子进程，负责将快照写入硬盘，而父进程继续处理命令【所有WINDOWS不支持】</p></li><li><p>客户端可以向REDIS发送SAVE命令来创建快照。<br>REDIS服务接到SAVE命令在快照创建完毕之前，不再相应其他命令，也就是单线程完成的。</p></li><li><p>设置了SAVE选项<br>SAVE 60 10000。从REDIS最近一次创建快照开始算，当满足60秒内有10000次写入，REDIS自动触发BGSAVE</p></li><li><p>关闭<br>当REDIS通过SHUTDOWN命令接收到关闭服务器的请求时，或者TERM信号时，会执行一个SAVE命令。</p></li><li><p>同步<br>当一个REDIS服务连接到另一个REDIS服务，并向对方发送SYNC命令开始一次复制操作的时候</p></li></ul></li></ul><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><ul><li><p>APPENDONLY<br>通过将APPENDONLY YES选项来打开，简单说AOF持久化会将被执行的写命令写到AOF文件末尾，以此来记录数据发生的变化。因此，REDIS只要从头到尾执行一次AOF文件所包括的写命令，就可以恢复。</p></li><li><p>APPENDFSYNC配置</p><p>| 选项     | 同步频率                 |<br>| - | -: |<br>| ALWAYS   | 每个写命令都立即写入硬盘 |<br>| EVERYSEC | 每秒执行一次写           |<br>| NO       | 让操作系统来决定何时写   |</p><p>对应NO选项，如果磁盘处理写的操作不快，当缓冲区被顶戴写入硬盘的数据填满时，REDIS写操作会被阻塞，并导致REDIS处理命令请求速度变慢。一般不用NO</p></li><li><p>BGREWRITEAOF<br>对于AOF，一些情况下AOF文件会不断的增大，这时，用户可以向REDIS发送BGREWRITEAOF命令。这个命令会通过移除AOF文件中冗余命令来重写AOF，以减小它。<br>BGREWRITEAOF原理跟BGSAVE类似：REDIS会创建一个子进程，然后有子进程负责AOF文件的重写。<br>可以通过AUTO-AOF-REWRITE-PERCENTAGE选项与AUTO-AOF-REWRITE-MIN-SIZE选项来自动执行BGREWRITEAOF。例如设置AUTO-AOF-REWRITE-PERCENTAGE 100 AUTO-AOF-REWITE-MIN-SIZE 64M当AOF文件的大于64MB并且AOF的体积比上一次重写之后的体积大至少（100%）1倍时候，REDIS执行。 </p></li></ul><h1 id="集群结构"><a href="#集群结构" class="headerlink" title="集群结构"></a>集群结构</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>关系型数据库通常会使用一个主服务器向多个从服务器发送更新，并使用从服务器来处理所有读请求，来增加扩展。redis也采用相同的方法来实现自己的复制特性，并作为扩展性能的一种手段。</p><h2 id="主辅同步"><a href="#主辅同步" class="headerlink" title="主辅同步"></a>主辅同步</h2><ul><li><p>开启<br>开启从服务的必须选项只有slaveof一个。当redis服务启动时，指定一个包括slaveof host port选项的配置，那么redis会根据配置来连接主服务器。<br>对已一个正财运行的redis服务器，可以通过发送SLAVEOF no one /SLAVEOF host port来终止或者开启从服务。</p></li><li><p>过程<br><img src="从服务连接主服务的步骤.png" alt=""><br>从服务在进行同步时，会清空自己的所有数据。<br>redis不支持主主复制</p></li></ul><h2 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h2><ul><li><p>主从链<br>主服务和从服务并没有特别不同之处，所以从服务也可以拥有自己的从服务，并由此形成了主从链。<br><img src="主从链.png" alt=""></p></li><li><p>检验硬盘写入<br>为了验证主服务是否已经将写数据发送到从服务，用户需要向主服务写入真正数据之后，再向主服务写入一个唯一的虚构值（哨兵），然后通过检查虚构值是否存在来判断写数据是否已经到达从服务。<br>检查数据是否保存到硬盘要困难多。检查info命令的输出结果中aof_pending_bio_fsync属性的值是否为0，如果是，则表明服务器已经将所有已知数据保存到硬盘上了。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍redis的基础，包括redis的数据结构，发布订阅，事务，数据持久化，主从结构等内容。&lt;br&gt;本文是学习《redis实战》整理的博客。&lt;br&gt;
    
    </summary>
    
      <category term="数据" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Mongo基础</title>
    <link href="http://yoursite.com/2018/07/18/mongo%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/07/18/mongo基础/</id>
    <published>2018-07-18T03:59:23.000Z</published>
    <updated>2018-07-19T04:49:33.778Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客从船长那摘抄，原始位置：<a href="https://github.com/zxhyJack/MyBlog/blob/master/mongodb/mongodb.md" target="_blank" rel="noopener">Jack博客链接</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul><li>MongoDB 是一个基于分布式文件存储的数据库</li><li>属于NoSQL数据库，是介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的</li><li>旨在为WEB应用提供可扩展的高性能数据存储解决方案</li><li><p>数据结构： 键值对（key-value），类似JSON对象</p><pre><code>{  name：&apos;Paul&apos;,  age:21,  gender:&apos;man&apos;}</code></pre></li></ul><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><ul><li><p>创建</p><pre><code>use database_name</code></pre></li></ul><p>如果数据库存在，则进入指定数据库，否则，创建数据库<br>此时需要写入数据，数据库才能真正创建成功</p><ul><li><p>查看所有数据库</p><pre><code>show databases | dbs</code></pre></li><li><p>创建集合</p><pre><code>db.createCollection(collection_name)</code></pre></li><li><p>删除数据库<br>先进入要删除的数据库，然后执行命令</p><pre><code>db.dropDatabase()</code></pre></li><li><p>删除集合</p><pre><code>db.collection_name.drop()</code></pre></li></ul><h2 id="数据表操作"><a href="#数据表操作" class="headerlink" title="数据表操作"></a>数据表操作</h2><ul><li><p>增</p><pre><code>db.collection_name.insert(document)</code></pre></li><li><p>查</p><pre><code>db.collection.find(&lt;query&gt;,&lt;projection&gt;)- query: 查询条件- projection: 投影操作</code></pre></li><li><p>改</p><pre><code>db.collection.updateOne(&lt;query&gt;,&lt;update&gt;) // 更新第一个符合条件的集合db.collection.updateMany(&lt;query&gt;,&lt;update&gt;)  // 更新所有符合条件的集合- query: 查询条件- update： 更新的内容</code></pre></li><li><p>删</p><pre><code>db.collection_name.deleteOne(&lt;query&gt;) // 删除第一个符合条件的集合db.collection_name.deleteMany(&lt;query&gt;) // 删除所有符合条件的集合</code></pre></li></ul><h1 id="数据操作（重点）"><a href="#数据操作（重点）" class="headerlink" title="数据操作（重点）"></a>数据操作（重点）</h1><p>数据库的核心——CRUD，增加和删除较为简单，查询和修改较复杂</p><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><ul><li><p>$gt 大于</p></li><li><p>$lt 小于</p></li><li><p>$gte  大于等于</p></li><li><p>$lte  小于等于</p></li><li><p>$eq | (key: value)  等于</p></li><li><p>$ne 不等于</p></li></ul><p>先往数据库中添加一些数据</p><pre><code>db.students.insert({&apos;name&apos;:&apos;张三&apos;,&apos;sex&apos;:&apos;男&apos;,&apos;age&apos;:19,&apos;score&apos;: 89,&apos;address&apos;: &apos;海淀区&apos;})db.students.insert({&apos;name&apos;:&apos;李四&apos;,&apos;sex&apos;:&apos;女&apos;,&apos;age&apos;:20,&apos;score&apos;: 100,&apos;address&apos;: &apos;朝阳区&apos;})db.students.insert({&apos;name&apos;:&apos;王五&apos;,&apos;sex&apos;:&apos;男&apos;,&apos;age&apos;:22,&apos;score&apos;: 50,&apos;address&apos;: &apos;西城区&apos;})db.students.insert({&apos;name&apos;:&apos;赵六&apos;,&apos;sex&apos;:&apos;女&apos;,&apos;age&apos;:21,&apos;score&apos;: 60,&apos;address&apos;: &apos;东城区&apos;})</code></pre><p>exp:</p><ol><li><p>查询姓名是张三的学生信息</p><pre><code>db.students.find({name:’张三’}).pretty()</code></pre></li><li><p>查询年龄大于19岁的学生</p><pre><code>db.students.find({age:{$gt:19}}).pretty()</code></pre></li><li><p>查询成绩大于等于60分的学生</p><pre><code>db.students.find({score:{$gte:60}}).pretty() </code></pre></li></ol><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ul><li><p><code>$and</code>   与</p></li><li><p><code>$or</code>   或</p></li><li><p><code>$not | $nor</code>  非</p></li></ul><p>exp:</p><ol><li><p>查询年龄在19 ~ 22岁的学生信息</p><pre><code>db.students.find({age:{$gte:19,$lte:22}}).pretty()</code></pre></li></ol><p>逻辑运算中与连接是最容易的，只需要利用<code>,</code>分割多个条件即可</p><ol start="2"><li><p>查询年龄小于20岁，或者成绩大于90分的学生信息</p><pre><code>db.students.find({$or:    [     {age:{$lt:20}},    {score:{$gt:90}}    ]}).pretty()</code></pre></li><li><p>查询年龄大于等于20岁，且成绩小于等于90分的学生信息</p><pre><code>db.students.find({$and:    [     {age:{$gte:20}},    {score:{$lte:90}}    ]}).pretty()</code></pre></li></ol><h3 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h3><p>$in: 在范围之中<br>$nin: 不在范围之中</p><p>exp:</p><ol><li><p>查询姓名是”张三“、”李四、”王五“的学生</p><pre><code>db.students.find({name: {$in:[&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;]}}).pret ty()</code></pre></li><li><p>查询姓名不是”张三“、”李四、”王五“的学生</p><pre><code>db.students.find({name: {$nin:[&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;]}}).pretty()</code></pre></li></ol><h3 id="数组查询"><a href="#数组查询" class="headerlink" title="数组查询"></a>数组查询</h3><ul><li><p>$all </p></li><li><p>$size </p></li><li><p>$slice </p></li><li><p>$elemMatch</p></li></ul><p>首先在数据库中新增一些数据</p><pre><code>db.students.insert({name:&apos;a&apos;,sex:&apos;男&apos;,age:19,score:89,address:&apos;海淀区&apos;,course:[&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;,&apos;音乐&apos;,&apos;政治&apos;]})db.students.insert({name:&apos;b&apos;,sex:&apos;男&apos;,age:19,score:89,address:&apos;海淀区&apos;,course:[&apos;语文&apos;,&apos;数学&apos;]})db.students.insert({name:&apos;c&apos;,sex:&apos;男&apos;,age:19,score:89,address:&apos;海淀区&apos;,course:[&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;]})db.students.insert({name:&apos;d&apos;,sex:&apos;男&apos;,age:19,score:89,address:&apos;海淀区&apos;,course:[&apos;英语&apos;,&apos;音乐&apos;,&apos;政治&apos;]})db.students.insert({name:&apos;e&apos;,sex:&apos;男&apos;,age:19,score:89,address:&apos;海淀区&apos;,course:[&apos;语文&apos;,&apos;政治&apos;]})</code></pre><p><code>$all</code>: 表示全都包括，用法：</p><pre><code>{$all:[内容1,内容2]}</code></pre><p>exp:</p><p>查询同时参加语文和数学的学生</p><pre><code>db.students.find({course:{$all:[&apos;语文&apos;,&apos;数学&apos;]}}).pretty()</code></pre><p>数组的操作，可以利用索引，使用<code>key.index</code>的方式来定义索引</p><p>查询数组中第二个内容是数学的学生(sh)</p><pre><code>db.students.find({&apos;course.1&apos;:&apos;数学&apos;}).pretty()</code></pre><p><code>$size</code>: 控制数组元素数量</p><p>exp:</p><p>查询只有两门课程的学生</p><pre><code>db.students.find({course:{$size: 2}}).pretty()</code></pre><p><code>$slice</code>: 控制查询结果的返回数量</p><p>exp:</p><p>查询年龄是19岁的学生，要求之显示两门参加的课程</p><pre><code>db.students.find({age:19},{course:{$slice:2}}).pretty()</code></pre><p>此时查询返回的是前两门课程，可以设置参数来取出想要的内容</p><pre><code>$slice:-2   //后两门$slice: [1,2]   // 第一个参数表示跳过的数据量，第二个参数表示返回的数据量</code></pre><h3 id="嵌套集合运算"><a href="#嵌套集合运算" class="headerlink" title="嵌套集合运算"></a>嵌套集合运算</h3><p>对象里面套对象</p><p>在数据库中新增数据</p><pre><code>db.students.insert({    name:&apos;A&apos;,sex:&apos;男&apos;,age:19,score:89,address:&apos;海淀区&apos;,    course:[&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;,&apos;音乐&apos;,&apos;政治&apos;],    parents:[        {name:&apos;A(father)&apos;,age:50,job:&apos;工人&apos;},        {name:&apos;A(mother)&apos;,age:50,job:&apos;职员&apos;}    ]})db.students.insert({    name:&apos;B&apos;,sex:&apos;男&apos;,age:19,score:89,address:&apos;海淀区&apos;,    course:[&apos;语文&apos;,&apos;数学&apos;],    parents:[        {name:&apos;B(father)&apos;,age:50,job:&apos;处长&apos;},        {name:&apos;B(mother)&apos;,age:50,job:&apos;局长&apos;}    ]})db.students.insert({    name:&apos;C&apos;,sex:&apos;男&apos;,age:19,score:89,address:&apos;海淀区&apos;,    course:[&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;],    parents:[        {name:&apos;C(father)&apos;,age:50,job:&apos;工人&apos;},        {name:&apos;C(mother)&apos;,age:50,job:&apos;局长&apos;}        ]})</code></pre><p>对于嵌套的集合中数据的判断只能通过<code>$elemMatch</code>完成</p><p>语法：<code>{ &lt;field&gt;: { $elemMatch: { &lt;query1&gt;, &lt;query2&gt;, ... } } }</code></p><p>exp:</p><p>查询父母中有人是局长的信息</p><pre><code>db.students.find({parents: {$elemMatch: {job: &apos;局长&apos;}}}).pretty()</code></pre><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p><code>sort({ field: value })</code> value是1表示升序，-1表示降序</p><p>exp:</p><p>学生信息按照分数降序排列</p><pre><code>db.students.find().sort({score:-1}).pretty()</code></pre><h3 id="分页显示"><a href="#分页显示" class="headerlink" title="分页显示"></a>分页显示</h3><p><code>skip(n)</code>: 跳过n条数据</p><p><code>limit(n)</code>: 返回n条数据</p><p>exp:</p><ol><li><p>分页显示，第一页，每页显示5条数据</p><pre><code>db.students.find({}).skip(0).limit(5).pretty()</code></pre></li><li><p>分页显示，第二页，每页显示5条数据</p><pre><code>db.students.find({}).skip(5).limit(5).pretty()</code></pre></li></ol><h3 id="判断某个字段是否存在"><a href="#判断某个字段是否存在" class="headerlink" title="判断某个字段是否存在"></a>判断某个字段是否存在</h3><p><code>{$exists:flag}</code>  flag为true表示存在，false表示不存在</p><p>exp:</p><ol><li><p>查询具有parents成员的学生</p><pre><code>db.students.find({parents:{$exists: true}}).pretty()</code></pre></li><li><p>查询不具有course成员的学生</p><pre><code>db.students.find({course: {$exists: false}}).pretty()</code></pre></li></ol><h3 id="取模"><a href="#取模" class="headerlink" title="取模"></a>取模</h3><p><code>$mod:[除数，余数]</code></p><p>exp: 查询年龄除以20余1的学生信息</p><pre><code>db.students.find({age:{$mod:[20,1]}}).pretty()</code></pre><h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p><code>updateOne()</code>     修改匹配的第一条数据</p><p><code>updateMany()</code>    修改所有匹配的数据</p><p>格式：<code>updateOne(&lt;filter&gt;,&lt;update&gt;)</code></p><h3 id="修改器"><a href="#修改器" class="headerlink" title="修改器"></a>修改器</h3><ul><li><code>$inc</code></li><li><code>$set</code></li><li><code>$unset</code></li><li><code>$push</code></li><li><code>$addToSet</code></li><li><code>$pop</code></li><li><code>$pull</code></li><li><code>$pullAll</code></li><li><code>$rename</code></li></ul><p><strong><code>$inc</code>：操作数字字段的数据内容</strong></p><p>语法: <code>{&quot;$inc&quot; : {成员 : 内容}}</code></p><p>exp: 将所有年龄为19岁的学生成绩一律减少30分，年龄增加1</p><pre><code>db.students.updateMany({age:19},{$inc:{score:-30,age:1}})</code></pre><p><strong><code>$set</code>：更新内容</strong></p><p>语法：<code>{$set: :{属性: 新内容}}</code></p><p>exp: 将20岁学生的成绩修改为89</p><pre><code>db.students.updateMany({age: 20},{$set: {score: 89}})</code></pre><p><strong><code>$unset</code>：删除某个属性及其内容</strong></p><p>语法：<code>{$unset: {属性: 1}}</code></p><p>exp:删除张三的年龄和成绩信息</p><pre><code>db.students.updateOne({name:&apos;张三&apos;},{$unset: {age: 1,score: 1}})</code></pre><p><strong><code>$push</code>：向数组中添加数据</strong></p><p>语法：<code>{$push: {属性: value}}</code></p><p>exp:在李四的课程中添加语文</p><pre><code>db.students.updateOne({name: &apos;李四&apos;},{$push: {course: &apos;语文&apos;}})</code></pre><p>如果需要向数组中添加多个数据，则需要用到<code>$each</code></p><p>exp: 在李四的课程中添加数学、英语</p><pre><code>db.students.updateOne(    {name:&apos;李四&apos;},    {$push:        {            course:{$each: [&apos;数学&apos;,&apos;英语&apos;]}        }    })</code></pre><p><strong><code>$addToSet</code>：向数组里面添加一个新的数据</strong></p><p>与<code>$push</code>的区别，<code>$push</code>添加的数据可能是重复的，<code>$addToSet</code>只有这个数据不存在时才会添加（去重）</p><p>语法：<code>{$addToSet: {属性：value}}</code></p><p>exp:王五新增一门舞蹈课程</p><pre><code>db.students.updateOne(    {name:&apos;王五&apos;},    {$addToSet: {course:&apos;舞蹈&apos;}})</code></pre><p><strong><code>$pop</code>：删除数组内的数据</strong></p><p>语法：<code>{$pop: {field: value}}</code>,value为-1表示删除第一个，value为1表示删除最后一个</p><p>exp:删除王五的第一个课程</p><pre><code>db.students.updateOne({name:&apos;王五&apos;},{$pop:{course:-1}})</code></pre><p>只是删除属性的内容，属性还在</p><p><strong><code>$pull</code>：从数组中删除一个指定内容的数据</strong></p><p>语法：<code>{$pull: {field：value}}</code> 进行数据比对，如果是该数据则删除</p><p>exp:删除李四的语文课程</p><pre><code>db.students.updateOne({name: &apos;李四&apos;},{$pull:{course:&apos;语文&apos;}})</code></pre><p><strong><code>$pullAll</code>：一次删除多个数据</strong></p><p>语法：<code>{$pullAll:{field:[value1,value2...]}}</code></p><p>exp:删除a的语文数学英语课程</p><pre><code>db.students.updateOne({name:&apos;a&apos;},{$pullAll:{course:[&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;]}})</code></pre><p><strong><code>$rename</code>：属性重命名</strong></p><p>语法： <code>{$rename: {旧属性名：新属性名}}</code></p><p>exp:把张三的name属性名改为姓名</p><pre><code>db.students.updateOne({name:&apos;张三&apos;},{$rename:{name:&apos;姓名&apos;}})</code></pre><h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><p>remove函数是有两个可选项：<br>·删除条件：满足条件的数据被删除；<br>·是否只删除一个数据，如果设置为true或者是1表示只删除一个</p><p>exp：删除所有姓名里面带有“谷”的信息，默认情况下会全部删除<br>        db.students.remove({name: /谷/})</p><p>范例：删除姓名带有“高”的信息，要求只删除一个<br>        db.students.remove({name: /高/},true)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇博客从船长那摘抄，原始位置：&lt;a href=&quot;https://github.com/zxhyJack/MyBlog/blob/master/mongodb/mongodb.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Jack博客链接&lt;/a&gt;&lt;/
      
    
    </summary>
    
      <category term="数据" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Mongo" scheme="http://yoursite.com/tags/Mongo/"/>
    
  </entry>
  
  <entry>
    <title>Mongo进阶</title>
    <link href="http://yoursite.com/2018/07/18/mongo%E8%BF%9B%E9%98%B6/"/>
    <id>http://yoursite.com/2018/07/18/mongo进阶/</id>
    <published>2018-07-18T03:59:23.000Z</published>
    <updated>2018-07-19T06:08:11.240Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客根据船长原文件整理</p><h1 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h1><p>  所谓的游标就是指的数据可以一行行的进行操作，类似于关系型数据库处理。在MongoDB数据库里面对于游标的控制非常的简 单，只需要使用find()函数就可以返回游标了。对于返回的游标如果要想进行操作，使用两个函数。</p><p>  <code>hasNext()</code></p><p>  <code>next()</code></p><p>  相当于每一个数据都单独拿出来进行逐行的控制。当游标数据取出来之后，实际上每行数据返回的都是一个Object型的内容</p><p>  exp:</p><pre><code>`var cursor = db.students.find()while(cursor.hasNext()){var student = cursor.next()print(student.name)printjson(student)}`</code></pre><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在任何的数据库之中，索引都是一种提升数据库检索性能的手段，这一点在MongoDB数据库之中同样是存在的，在MongoDB数据库里面依然会存在有两种的索引创建：是自动创建的，另外一种索引是手工创建的。</p><p>exp：重新准备一个新的简单集合</p><pre><code>db.students.drop()db.students.insert({&apos;name&apos;:&apos;张三&apos;,&apos;sex&apos;:&apos;男&apos;,&apos;age&apos;:19,&apos;score&apos;: 89,&apos;address&apos;: &apos;海淀区&apos;})db.students.insert({&apos;name&apos;:&apos;李四&apos;,&apos;sex&apos;:&apos;女&apos;,&apos;age&apos;:20,&apos;score&apos;: 100,&apos;address&apos;: &apos;朝阳区&apos;})db.students.insert({&apos;name&apos;:&apos;王五&apos;,&apos;sex&apos;:&apos;男&apos;,&apos;age&apos;:22,&apos;score&apos;: 50,&apos;address&apos;: &apos;西城区&apos;})</code></pre><p>  查询默认状态下的students集合的索引内容<br>  db.students.getIndexes()</p><p>  创建一个索引，在age字段上设置一个降序索引<br>  db.students.ensureIndex({‘age’:-1})<br>  此时并没有设置索引的名字，所以名字是自动命名的。命名规范：“字段名称_索引的排序模式”。</p><p>  针对于当前的age字段上的索引做一个分析<br>  db.students.find({‘age’:19}).explain()<br>  此时的查询使用了索引的技术</p><p>  针对于score字段上设置查询<br>  db.students.find({score:{$gt:60}}).explain()<br>  此时在score字段上并没有设置索引，所以当前的索引形式就变为了全集合扫描的模式.</p><p>  复合索引：<br>  db.students.ensureIndex({age:1,score:-1},{name:’age_1_score_1_index’})</p><p>  删除一个索引：<br>  db.students.dropIndex({age:1})</p><p>  删除全部索引：<br>  db.students.dropIndexes()</p><h2 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h2><p>唯一索引的主要目的是用在某一个字段上，使该字段的内容不重复.</p><p>创建唯一索引<br> db.students.ensureIndex({name:1},{unique:true})<br>此时若在name中添加重复数据，会报错。</p><h2 id="过期索引"><a href="#过期索引" class="headerlink" title="过期索引"></a>过期索引</h2><p>在一些程序站点会出现若干秒之后信息被删除的情况，例如：手机信息验证码，在MongoDB里面就可以轻松的实现过期索引，但是这个时间往往不怎么准确。必须要有时间，否则没法实现过期。</p><p>设置过期索引<br>db.phones.ensureIndex({time:1},{expireAfterSeconds:10})<br>如果要想实现过期索引，需要保存一个时间信息；<br>db.phones.insert({tel:110,code:110,time:new Date()})<br>db.phones.insert({tel:111,code:111,time:new Date()})</p><h2 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h2><p>在一些信息管理平台上经常需要进行信息模糊查询，最早的时候是利用了某个字段上实现的模糊查询，但是这个时候返回的信息并不会很准确，因为只能够查A字段或者是B字段，而在MongoDB里面实现了非常简单的全文检索。</p><p>定义一个新的集合<br>db.news.insert({‘title’:’gyh’,content:’sfq’})<br>db.news.insert({‘title’:’gyh’,content:’gry’})<br>db.news.insert({‘title’:’sfq’,content:’gry’})</p><p>设置全文检索<br>db.news.ensureIndex({title:’text’,content:’text’})</p><p>实现数据的模糊查询<br>如果要想表示出全文检索，则使用“$text”判断符，而要想进行数据的查询则使用“$search”运算符：</p><p>查询单个内容<br> db.news.find({$text:{$search:’gry’}})</p><p>包含有“gry”与“sfq”的信息<br> db.news.find({$text:{$search:’gry gyh’}})</p><p>同时包含有“mldn”与“lxh”的内容<br>db.news.find({$text:{$search:’\’mldn\’ \’lxh\’’}})</p><p>在进行全文检索操作的时候还可以使用相似度的打分来判断检索成果。<br> db.news.find({$text:{$search:’gyh’}},{‘score’:{$meta:’textScore’}})<br>db.news.find({$text:{$search:’gyh’}},{‘score’:{$meta:’textScore’}}).sort({‘score’:{$meta:’textScore’}})</p><p>但是在这里面还有一个小问题，如果一个集合的字段太多了，那么每一个字段都分别设置全文检索麻烦点，所以简单一些，可以为所有的字段设置全文检索。<br>为所有字段设置全文检索<br>db.news.ensureIndex({‘$**’:’text’})</p><h2 id="地理信息索引"><a href="#地理信息索引" class="headerlink" title="地理信息索引"></a>地理信息索引</h2><p>地理信息索引分为两类：2D平面索引，另外就是2DSphere球面索引。在2D索引里面基本上能够保存的信息都是坐标，而且坐标保存的就是经纬度坐标。</p><p>定义一个商铺的集合</p><pre><code>db.shop.insert({loc:[10,10]})db.shop.insert({loc:[11,10]})db.shop.insert({loc:[10,11]})</code></pre><p>为shop的集合定义2D索引<br>db.shop.ensureIndex({loc:’2d’})</p><p>这个时候shop集合就可以实现坐标位置的查询了，而要进行查询有两种查询方式：<br>·“$near”查询，查询距离某个点最近的坐标点；<br>·“$geoWithin”查询：查询某个形状内的点；</p><p>假设我的现在的坐标是：[11,11]<br>db.shop.find({loc:{$near:[11,11]}})</p><p>db.shop.find({loc:{$near:[11,11],$maxDistance:5}})</p><p>但是需要注意一点，在2D索引里面虽然支持最大距离，但是不支持最小距离。<br>但是也可以设置一个查询的范围，使用“$geoWithin”查询，而可以设置的范围：<br>·矩形范围（$box）：{“$box”:[[x1,y1],[x2,y2]]}；<br>·圆形范围（$center）：{“$center” : [[x1,y1],r]}；<br>·多边型（$polygon）：{“$polygon” :[[x1,y1],[x2,y2][x3,y3] , …]}</p><p>查询矩形<br>db.shop.find({loc:{$geoWithin:{$box:[[9,9],[12,12]]}}})</p><p>查询圆形<br> db.shop.find({loc:{$geoWithin:{$center:[[10,10],2]}}})</p><h1 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇博客根据船长原文件整理&lt;/p&gt;
&lt;h1 id=&quot;游标&quot;&gt;&lt;a href=&quot;#游标&quot; class=&quot;headerlink&quot; title=&quot;游标&quot;&gt;&lt;/a&gt;游标&lt;/h1&gt;&lt;p&gt;  所谓的游标就是指的数据可以一行行的进行操作，类似于关系型数据库处理。在MongoDB数据库里面
      
    
    </summary>
    
      <category term="数据" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Mongo" scheme="http://yoursite.com/tags/Mongo/"/>
    
  </entry>
  
</feed>
