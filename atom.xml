<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>思 见</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-26T07:59:22.274Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>sun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微服务框架选择</title>
    <link href="http://yoursite.com/2020/03/26/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6%E9%80%89%E6%8B%A9/"/>
    <id>http://yoursite.com/2020/03/26/微服务框架选择/</id>
    <published>2020-03-26T02:22:40.000Z</published>
    <updated>2020-03-26T07:59:22.274Z</updated>
    
    <content type="html"><![CDATA[<p>随着产品的设计的结束，如今进入架构设计阶段，需要选择一些基础的组件来完善系统。去年年初学习了微服务架构，包括杨波架构师对微服务的简单介绍以及陈皓老师对分布式系统的介绍，年中又接触了K8S，对其结构略懂一二。在这种背景下，来进行框架的选择。  </p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>微服务架构功能方面需要的功能包括：服务发现、负载均衡、熔断限流、流量分析、日志聚合、配置中心、调用链监控、性能监控、自动化部署等。可以将它们分成3层：网关层，主要做流量控制；服务层，主要对各服务提供支持；运维层，自动化部署。分别来选择。</p><h1 id="网关层"><a href="#网关层" class="headerlink" title="网关层"></a>网关层</h1><p>这一部分我把它定义为流量在系统与业务服务之间的阶段，入、出都算在其中。包括nginx，zuul中servlet的filter，K8S的ingress以及service。<br>在功能上，它包括：负载均衡、安全认证、熔断限流、流量日志等内容<br>在实现上，确实在向2个方向发展：1. 统一的网关，2. Service Mesh</p><h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><p><img src="./服务发现.jpg" alt="服务发现.jpg"><br><img src="./Eureka架构.png" alt="Eureka架构.png">  </p><p>Provider与Server：Eureka服务发现是服务的Provider通过注册到 Eureka Service中，并Keep Alive。这里的Eureka sever可能有多个，它们之间做数据的同步，保持一致性。<br>Consumer与Server：这里可能有多种方式，Server将数据同步到Eureka Client上，在杨波课程中，这里称作LB，也就是在这里确定选择哪个Provider进行通讯  </p><p>由此可见Eureka是做了Cosumer发现Provider，提供负载均衡的功能。这个在K8S中，service与pod之间的关系，就是做了这个事情，由于pod的短暂特性，ip会发生变化，通过service，不仅能提供统一的服务，也能流量在多个pod中均衡    </p><h2 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h2><p><img src="./zuul架构图.jpg" alt="zuul架构图.jpg"><br>Zuul是一个Servlet，里边有很多的filter，分成Pre routing filter，Routing filter，Post Routing filter等部分，Request Context在filter之间保存状态。除此之外，写的filter通过客户端的Filter Poller传递到服务的Filter Directory下，并最终由Filter Loader加载进Zuul中。  </p><p>那Zuul跟Servlet有什么区别呢？最主要的区别应该是，Servlet是在每个服务中起作用，而Zuul是一个统一的网关。这样看，将认证授权、流量分析等工作放在Zuul上就会比较适合。</p><h2 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h2><p><img src="./hystrix架构图.jpg" alt="hystrix架构图.jpg"><br> Hystrix为分布式系统提供了限流、熔断、降级的功能，<br> Hystrix对请求进行了封装。被调用方在Hystrix中被称为依赖项，利用HystrixCommand或HystrixObservableCommand封装对依赖项的请求。收到请求后，先查看是否有缓存，如果有就直接返回；然后查看Circle-breaker是否open，没有open，就直接进行降级处理；然后看线程池的状态，如果满也进行降级处理；没满的情况，正常执行，并对执行结果进行跟踪，如果执行失败或者超时，都进行降级处理。  这些失败的情况，会被汇总在一起，决定circuit-breaker是否open。<br>在这里可以看到，增加缓存以应对大流量是有效措施；有趣的是对circuit-breaker的控制上，有个反馈回路在在起作用；在判断系统是否满状态时，Hystrix参考了2个指标：线程池与调用结果。这对没有线程的情况如何控制呢？</p><p>以上3者是spring cloud中提供的组件，都是Java写的，可以提供做负载均衡、安全认证、流量分析、熔断限流等功能。在K8S，Eureka的价值就不高，Hystrix虽然有趣，但它对服务有浸入，对非Java应用的可用性有待查看。下边分析一下K8S中的网关  </p><h2 id="K8S的ingress"><a href="#K8S的ingress" class="headerlink" title="K8S的ingress"></a>K8S的ingress</h2><p>K8S的网关是Ingress，它提供了一个类似 ConfigMap 的接口功能 ，用户可以以 [ host - paths -&gt; services ] 的形式 , 在 Ingress 里建立一个个映射规则 , 然后启动一个 Ingress Controller（nginx为主） , Ingress Controller 将订阅 Ingress 里的配置规则并转化成 Nginx 的配置 , 然后对外部提供服务。在对外网暴露地址的时候, 只需要暴露 Ingress Controller 自身就行了, 所有服务可以被隔离在集群内部。 </p><h2 id="kong"><a href="#kong" class="headerlink" title="kong"></a>kong</h2><p><img src="./API网关示意图.png" alt="API网关示意图.png"><br><a href="https://www.jianshu.com/p/4dd5ed88468c" target="_blank" rel="noopener">链接</a><br>Kong主要有三个组件：<br>Kong Server ：基于nginx的服务器，用来接收API请求。<br>Apache Cassandra/PostgreSQL ：用来存储操作数据。<br>Kong dashboard：官方推荐UI管理工具   </p><p>Kong采用插件机制进行功能定制，插件集（可以是0或N个）在API请求响应循环的生命周期中被执行。插件使用Lua编写，目前已有几个基础功能：HTTP基本认证、密钥认证、CORS（Cross-Origin Resource Sharing，跨域资源共享）、TCP、UDP、文件日志、API请求限流、请求转发以及Nginx监控。</p><p>Kong在架构中的位置与Zuul类似，通过这种AOP的做法，在请求上做一些工作。Kong可以集成到K8S中，位置应该就是Ingress。<a href="https://qhh.me/2019/08/17/Kong-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3%E5%9C%A8-Kubernetes-%E7%9A%84%E5%AE%9E%E8%B7%B5/" target="_blank" rel="noopener">链接</a>  </p><p>ps：用Kong去访问权限数据库是否妥当？  </p><h2 id="Istio"><a href="#Istio" class="headerlink" title="Istio"></a><strong>Istio</strong></h2><p><img src="./Istio架构图.jpeg" alt="Istio架构图.jpeg"><br>Istio是ServiceMesh的一种设计，ServiceMesh可以分成2部分：控制平面与数据平面，Istio控制平面主要分为三大块，Pilot、Mixer、Istio-Auth, 数据平面是Envoy Proxy.</p><p>Pilot: 主要作为服务发现和路由规则，并且管理着所有Envoy，它对资源的消耗是非常大的。对应Eureka<br>Mixer: 主要负责策略请求和配额管理，还有Tracing，所有的请求都会上报到Mixer。对应Hystrix，它的限流与Hystrix不相同，是面向流量的一张限流方式，好处是不浸入服务。<br>Istio-Auth: 升级流量、身份验证等等功能。对应Zuul  </p><p>Hystrix可以被视为白盒监控工具，而Istio可以被视为黑盒监控工具，主要是因为Istio从外部监控系统并且不知道系统内部如何工作。每个服务中有Hystrix来获取所需的数据。Istio是通过Envoy Proxy 来实现熔断和限流机制的，Envoy 强制在网络层面配置熔断和限流策略，这样就不必为每个应用程序单独配置或重新编程。<br>Istio嵌入K8S利用了CRD（customResourceDefinition）。在k8s中，它是在Ingress后边，service之前的位置，自称Virtual  Service。 </p><p><a href="https://www.jianshu.com/p/bed143a1c886" target="_blank" rel="noopener">链接1</a><br><a href="https://jimmysong.io/istio-handbook/preface/service-mesh-the-microservices-in-post-kubernetes-era.html" target="_blank" rel="noopener">链接2</a>  </p><h1 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h1><h2 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a><strong>Consul</strong></h2><p><img src="./consul.png" alt="consul.png">  </p><p><a href="https://www.consul.io/docs/internals/architecture.html" target="_blank" rel="noopener">官网</a><br>Consul的介绍找到的几个都或多或少的存在问题，结合官网及这些资料，简单写一下。<br>Consul可以在多个数据中心中，在每一数据中心中，每个Consul的节点被成为Agent，Agent管理注册的服务信息，提供查询响应，运行检查等功能。Agent通过Gossip协议来做彼此之间的发现。一般配置3个或这5个Server，这些Server通过Raft算法产生唯一的Leader。注册到Client上的服务会被转发到Server做存储，Leader负责同步数据到所有端，并且负责与其他数据中心的Leader通信。  </p><p>从功能上看Consul功能包括：服务发现与配置中心<br>service discovery：consul通过DNS或者HTTP接口使服务注册和服务发现变的很容易，一些外部服务，例如saas提供的也可以一样注册。<br>health checking：健康检测使consul可以快速的告警在集群中的操作。和服务发现的集成，可以防止服务转发到故障的服务上面。<br>key/value storage：一个用来存储动态配置的系统。提供简单的HTTP接口，可以在任何地方操作。  </p><p>ps：consul的集群很有趣，值得研究。K8S中可以通过control感知到Pod的运行状态，也就做了Pod的健康监控，Consul更接近与服务的健康检查。另外还有配置中心的功能，在K8S中有ConfigMap功能与配置中心有重合的地方，比如说启动的端口，这种配置还是在ConfigMap中好一些，但比如说每个服务中用的业务配置，放在Consul里也会很舒服。另外Consul是用Go实现的。</p><h2 id="zipkin"><a href="#zipkin" class="headerlink" title="zipkin"></a><strong>zipkin</strong></h2><p><img src="./zipkin示意图.png" alt="zipkin示意图.png"><br><a href="https://www.jianshu.com/p/4cdba2fc62ad" target="_blank" rel="noopener">链接</a><br>调用链监控，有2个基本概念，trace与span，trace代表调用链，span代表它在每个调用节点。<br>从功能上除了对调用进行性能分析，  也可以看出服务间依赖，以此来排查依赖环的产生  </p><h2 id="Promethues"><a href="#Promethues" class="headerlink" title="Promethues"></a><strong>Promethues</strong></h2><p><img src="./promethues架构图.png" alt="promethues架构图.png"><br><a href="https://songjiayang.gitbooks.io/prometheus/content/introduction/what.html" target="_blank" rel="noopener">链接</a><br>Promethues是基于时序数据库的监控组件，通过server主动去抓取exporter上的数据，或者可以先将数据Push到PushGateway上，然后server再去PushGateway上去抓取数据。server将数据存在时序数据库（TSDB）上。 在输出上，可以通过alert将一些告警通知出去，也支持UI页面通过自定义的语句（PromQL）查看数据。 </p><h2 id="ELK"><a href="#ELK" class="headerlink" title="ELK"></a><strong>ELK</strong></h2><p>ELK是Elasticsearch、Logstash、Kibana，它本质上建立在NoSQL（document）上的搜索引擎，主要是Elasticsearch。拿来做日志聚合的事情正好，可以方便查看各种日志。<br>一度被一个问题困恼着：Promethues与ELK应该选哪个？Promethues 的数据是按一定时间采集的，注的更多是系统的运行瞬时状态以及趋势，即使有少量数据没有采集也能容忍，本质是一种监控；ELK对实时监控力有不逮，本质上是对日志的存取，比如去看一个故障，Promethues可能没有采集到这个数据，那只能从ELK上看。  所以它俩确实有些重合，但2者可以兼得。</p><h1 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h1><h2 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a><strong>Jenkins</strong></h2><p><a href="https://www.kancloud.cn/huyipow/kubernetes/716441" target="_blank" rel="noopener">链接</a><br>Jenkins是一个可扩展的持续集成引擎，当程序员提交代码，从代码Repository处得到通知，然后做 Build -&gt; Test -&gt; Package -&gt; Deploy 等工作<br>通过pipeline可以完成 clone代码 =&gt; test代码 =&gt; build镜像 =&gt; push镜像 =&gt; 修改k8s的yml =&gt; apply yml的过程</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:center">位置</th><th style="text-align:center">用途</th><th style="text-align:right">语言</th><th style="text-align:right">是否需要</th><th style="text-align:center">优先级</th></tr></thead><tbody><tr><td style="text-align:left">Zuul</td><td style="text-align:center">网关</td><td style="text-align:center">安全认证、流量日志</td><td style="text-align:right">Java</td><td style="text-align:right">No</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">Kong</td><td style="text-align:center">网关</td><td style="text-align:center">负载均衡、安全认证、熔断限流、流量日志</td><td style="text-align:right">Lua</td><td style="text-align:right">No</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">Hystrix</td><td style="text-align:center">网关</td><td style="text-align:center">熔断限流</td><td style="text-align:right">Java</td><td style="text-align:right">No</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">Istio</td><td style="text-align:center">网关</td><td style="text-align:center">负载均衡、安全认证、流量日志、熔断限流</td><td style="text-align:right">Go</td><td style="text-align:right">Yes</td><td style="text-align:center">5</td></tr><tr><td style="text-align:left">Eureka</td><td style="text-align:center">网关、服务</td><td style="text-align:center">服务发现、负载均衡</td><td style="text-align:right">Java</td><td style="text-align:right">No</td></tr><tr><td style="text-align:left">Consul</td><td style="text-align:center">服务</td><td style="text-align:center">服务发现</td><td style="text-align:right">Go</td><td style="text-align:right">Yes</td><td style="text-align:center">3</td></tr><tr><td style="text-align:left">Zipkin</td><td style="text-align:center">服务</td><td style="text-align:center">调用链监控</td><td style="text-align:right">Java</td><td style="text-align:right">Yes</td><td style="text-align:center">4</td></tr><tr><td style="text-align:left">Prometheus</td><td style="text-align:center">服务</td><td style="text-align:center">监控</td><td style="text-align:right">Go</td><td style="text-align:right">Yes</td><td style="text-align:center">5</td></tr><tr><td style="text-align:left">ELK</td><td style="text-align:center">服务</td><td style="text-align:center">Java</td><td style="text-align:right">日志</td><td style="text-align:right">Yes</td><td style="text-align:center">4</td></tr><tr><td style="text-align:left">Jenkins</td><td style="text-align:center">运维</td><td style="text-align:center"></td><td style="text-align:right">Java</td><td style="text-align:right">Yes</td><td style="text-align:center">5</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着产品的设计的结束，如今进入架构设计阶段，需要选择一些基础的组件来完善系统。去年年初学习了微服务架构，包括杨波架构师对微服务的简单介绍以及陈皓老师对分布式系统的介绍，年中又接触了K8S，对其结构略懂一二。在这种背景下，来进行框架的选择。  &lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>spring-boot使用学习二</title>
    <link href="http://yoursite.com/2020/02/20/spring-boot%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0%E4%BA%8C/"/>
    <id>http://yoursite.com/2020/02/20/spring-boot使用学习二/</id>
    <published>2020-02-20T02:39:45.000Z</published>
    <updated>2020-02-27T06:04:35.552Z</updated>
    
    <content type="html"><![CDATA[<p>本文为第二篇<br>主要是中间件与部署方面的内容  </p><p>主要参考：<br><a href="https://github.com/ityouknow/spring-boot-leaning" target="_blank" rel="noopener">spring-boot-learning</a></p><a id="more"></a><h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Spring Boot 提供了对 Redis 集成的组件包：spring-boot-starter-data-redis，它依赖于 spring-data-redis 和 lettuce。Spring Boot 1.0 默认使用的是 Jedis 客户端，2.0 替换成了 Lettuce</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lettuce → Spring Data Redis → Spring Data → spring-boot-starter-data-redis</span><br></pre></td></tr></table></figure><ol><li>Lettuce：是一个可伸缩线程安全的 Redis 客户端，多个线程可以共享同一个 RedisConnection，它利用优秀 Netty NIO 框架来高效地管理多个连接</li><li>Spring Data Redis：是 Spring Data 项目中的一个主要模块，实现了对 Redis 客户端 API 的高度封装，使对 Redis 的操作更加便捷。</li><li>Spring Data：是 Spring 框架中的一个主要项目，目的是为了简化构建基于 Spring 框架应用的数据访问，包括非关系数据库、Map-Reduce 框架、云数据服务等，另外也包含对关系数据库的访问支持。</li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>与postgres的安装相同，在docker-compse.yml中添加:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis:</span></span><br><span class="line"><span class="attr">  image:</span> <span class="attr">redis:4.0.13</span></span><br><span class="line"><span class="attr">  container_name:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">  restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">  command:</span> <span class="bullet">--appendonly</span> <span class="literal">yes</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="number">6379</span><span class="string">:6379</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">./redis_data:/data</span></span><br></pre></td></tr></table></figure><p>然后docker-compose up -d 等待即可</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li><p>依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引入 commons-pool 2 是因为 Lettuce 需要使用 commons-pool 2 创建 Redis 连接池。</p></li><li><p>配置</p><p>配置文件application.properties：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Redis 数据库索引（默认为 0）</span><br><span class="line">spring.redis.database=0</span><br><span class="line"># Redis 服务器地址</span><br><span class="line">spring.redis.host=localhost</span><br><span class="line"># Redis 服务器连接端口</span><br><span class="line">spring.redis.port=6379  </span><br><span class="line"># Redis 服务器连接密码（默认为空）</span><br><span class="line">spring.redis.password=</span><br><span class="line"># 连接池最大连接数（使用负值表示没有限制） 默认 8</span><br><span class="line">spring.redis.lettuce.pool.max-active=8</span><br><span class="line"># 连接池最大阻塞等待时间（使用负值表示没有限制） 默认 -1</span><br><span class="line">spring.redis.lettuce.pool.max-wait=-1</span><br><span class="line"># 连接池中的最大空闲连接 默认 8</span><br><span class="line">spring.redis.lettuce.pool.max-idle=8</span><br><span class="line"># 连接池中的最小空闲连接 默认 0</span><br><span class="line">spring.redis.lettuce.pool.min-idle=0</span><br></pre></td></tr></table></figure><p>配置类RedisConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> <span class="keyword">extends</span> <span class="title">CachingConfigurerSupport</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KeyGenerator <span class="title">keyGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KeyGenerator() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">generate</span><span class="params">(Object target, Method method, Object... params)</span> </span>&#123;</span><br><span class="line">                StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                sb.append(target.getClass().getName());</span><br><span class="line">                sb.append(method.getName());</span><br><span class="line">                <span class="keyword">for</span> (Object obj : params) &#123;</span><br><span class="line">                    sb.append(obj.toString());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sb.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上配置了主键生成的策略，如不配置会默认使用参数名作为主键，这里添加了类名+函数名+参数名</p></li><li><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRedisTemplate</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testString</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">      redisTemplate.opsForValue().set(<span class="string">"neo"</span>, <span class="string">"ityouknow"</span>);</span><br><span class="line">      Assert.isTrue(<span class="string">"ityouknow"</span>.equals(redisTemplate.opsForValue().get(<span class="string">"neo"</span>)), <span class="string">"测试出错"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="session"><a href="#session" class="headerlink" title="session"></a>session</h1><ul><li><p>简介<br>使用redis来存储http的sessionId信息，这个spring boot对这块都进行了封装。封装到牙齿的感觉。  </p></li><li><p>依赖  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置  </p><p>application.properties:<br>这里的配置就是redis的配置即可  </p><p>配置类：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableRedisHttpSession</span>(maxInactiveIntervalInSeconds = <span class="number">86400</span>*<span class="number">30</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>maxInactiveIntervalInSeconds: 设置 Session 失效时间</p></li><li><p>使用  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(value = <span class="string">"/login"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">login</span> <span class="params">(HttpServletRequest request,String userName,String password)</span></span>&#123;</span><br><span class="line">      String msg=<span class="string">"logon failure!"</span>;</span><br><span class="line">      User user= userRepository.getByUserName(userName);</span><br><span class="line">      <span class="keyword">if</span> (user!=<span class="keyword">null</span> &amp;&amp; user.getPassword().equals(password))&#123;</span><br><span class="line">          request.getSession().setAttribute(<span class="string">"user"</span>,user);</span><br><span class="line">          msg=<span class="string">"login successful!"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> msg;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping</span>(value = <span class="string">"/logout"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">logout</span> <span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line">      request.getSession().removeAttribute(<span class="string">"user"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"loginout successful!"</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>问题  </p><p>这里，如果有登录的要求，需要在每个路由中都去判断是否登录，这样在写的时候会比较费劲，适合使用spring切片的方式来进行登录与否的验证  </p></li></ul><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>  这里的缓存，是将从关系型数据库中读取数据，变成先从缓存中读取，若没有则从关系型数据库中读取，这里用的缓存，也是用的redis。spring对这些操作也进行了封装，只需要用几个注解，就可以完成  </p><p>  @Cacheable是读取完之后，再次读取时候会做缓存，主要用在Get上<br>  @CachePut，这个是数据发生变化之后，将更新变化数据，主要用在Put上<br>  @CacheEvict，这个是数据删除之后，同时清除缓存  </p><p>  他们共有的属性：value：缓存的名称；key：缓存的key值(redis的hash结构)；condition：在什么条件上做缓存<br>  CacheEvict，还有两个属性，allEntries：这个是true清除缓存的所有内容，不是删hash的key，而是删这个整个对象，默认是false；beforeInvocation：这个是值true指在执行Delele前，清除缓存，false是之后清除，默认是false；</p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><ul><li><p>@Cacheable：读取数据之后，缓存数据 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"user/&#123;id&#125;"</span>)</span><br><span class="line"><span class="meta">@Cacheable</span>(value=<span class="string">"user"</span>, key=<span class="string">"#id"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getId</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>&#123;</span><br><span class="line">    User user = <span class="keyword">this</span>.userRepository.getById(id);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@CachePut：数据修改之后，更新缓存数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation</span>(value =<span class="string">"修改用户信息"</span>, notes =<span class="string">"根据传参修改用户"</span>)</span><br><span class="line">  <span class="meta">@PutMapping</span>(value = <span class="string">"user"</span>)</span><br><span class="line">  <span class="meta">@CachePut</span>(value=<span class="string">"user"</span>,key=<span class="string">"#id"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">modify</span><span class="params">(String nickName, Long id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> r = <span class="keyword">this</span>.userRepository.upateNickNameById(nickName, id);</span><br><span class="line">      <span class="keyword">if</span> (r &lt; <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      User u = <span class="keyword">this</span>.userRepository.getById(id);</span><br><span class="line">      <span class="keyword">return</span> u;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>@CacheEvict：数据删除之后，删除缓存数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeleteMapping</span>(value = <span class="string">"user/&#123;id&#125;"</span>)</span><br><span class="line">  <span class="meta">@CacheEvict</span>(value=<span class="string">"user"</span>, key=<span class="string">"#id"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> BaseResult&lt;String&gt; <span class="title">Delete</span> <span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.userRepository.deleteById(id);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> BaseResult.success();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p><a href="https://zhuanlan.zhihu.com/p/103642773" target="_blank" rel="noopener">借鉴</a></p><ul><li><p>说RabbitMQ,要先介绍AMQP<br>AMQP（Advanced Message Queuing Protocol，高级消息队列协议）是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。<br>RabbitMQ 是一个开源的 AMQP 实现，服务器端用 Erlang 语言编写，支持多种客户端</p></li><li><p>基本概念<br>通常我们谈到队列服务，会有三个概念：<strong>生产者(Producer)、队列(Queue)、消费者(Consumer)</strong>。RabbitMQ 在这个基本概念之上，多做了一层抽象，在发消息者和队列之间加入了<strong>交换机（Exchange）</strong>。这样发消息者和队列就没有直接联系，转而变成发消息者把消息给交换器，交换器根据调度策略再把消息再给队列。<br><img src="./rabbitmq流转图.png" alt="rabbitmq流转图.png"></p><ol><li>生产者发送消息的时候指定RoutingKey，然后消息被发送到Exchange</li><li>Exchange根据一些列规则(BindingKey)将消息路由到指定的队列中</li><li>消费者从队列中消费消息</li></ol></li><li><p>交换机<br>交换机有4种类型：Direct Exchange(默认)、Topic Exchange、Headers Exchange、Fanout Exchange<br>前3种都是消息队列，虽然交换机与队列之间的映射机制不同（路由方式），但对于一条消息，只有一个生产者与消费者。Fanout是广播，对于一条消息可以有多个消费者。<br>Direct Exchange把消息路由到BindingKey和RoutingKey完全匹配的队列中<br>Topic Exchange把消息路由到BindingKey可以模糊匹配的队列中，Binding Key可以认为是消息名称，Binding Key是一种模糊匹配，代表一类消息，其中”*”表示一个单词,”#”表示多个单词（包括0,1）<br>Fanout Exchange把消息发送与该交换机绑定的所有队列上,不光BindingKey,用来广播  </p></li></ul><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li><p>安装  </p><p>docker-compose.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rabbitmq:</span></span><br><span class="line"><span class="attr">  image:</span> <span class="attr">rabbitmq:3-management</span></span><br><span class="line"><span class="attr">  container_name:</span> <span class="string">rabbitmq</span></span><br><span class="line"><span class="attr">  restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">  environment:</span></span><br><span class="line"><span class="attr">    RABBITMQ_DEFAULT_USER:</span> <span class="string">"rabbitmq"</span></span><br><span class="line"><span class="attr">    RABBITMQ_DEFAULT_PASS:</span> <span class="string">"rabbitmq"</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="number">15672</span><span class="string">:15672</span></span><br><span class="line"><span class="bullet">    -</span> <span class="number">5672</span><span class="string">:5672</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">./rabbitmq_data:/var/lib/rabbitmq</span></span><br></pre></td></tr></table></figure></li><li><p>依赖  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置  </p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.rabbitmq.host=192.168.0.1</span></span><br><span class="line"><span class="string">spring.rabbitmq.port=5672</span></span><br><span class="line"><span class="string">spring.rabbitmq.username=rabbitmq</span></span><br><span class="line"><span class="string">spring.rabbitmq.password=rabbitmq</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h2><ul><li><p>Direct Exchange<br>spring boot默认使用时，应该自己封装了exchange，只需定义routeKey即可<br>可以发送对象，二进制发送，需要实现Serializable</p><ol><li><p>定义Queue  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">Queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><ol start="2"><li><p>定义生产者  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String context = <span class="string">"hello "</span> + <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(<span class="string">"Sender : "</span> + context);</span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate.convertAndSend(<span class="string">"hello"</span>, context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义接收者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String hello)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Receiver  : "</span> + hello);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>topic exchange<br>需要定义queue、exchange，并且binding queue与exchange</p><p>1.定义queue、exchange  </p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicRabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> String message = <span class="string">"topic.message"</span>;    <span class="comment">// queue名</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> String messages = <span class="string">"topic.messages"</span>;  <span class="comment">// queue名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(TopicRabbitConfig.message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueMessages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(TopicRabbitConfig.messages);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">TopicExchange <span class="title">exchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(<span class="string">"exchange"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将队列和交换机绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">bindingExchangeMessage</span><span class="params">(Queue queueMessage, TopicExchange exchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueMessage).to(exchange).with(<span class="string">"topic.message"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">bindingExchangeMessages</span><span class="params">(Queue queueMessages, TopicExchange exchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueMessages).to(exchange).with(<span class="string">"topic.#"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  注意定义queue时使用，只是queue名，在接收者时用来指定某个queue使用。<br>  后边binding时候使用with才是bindingKey</p><ol start="2"><li><p>发送者  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String context = <span class="string">"hi, i am message 1"</span>;</span><br><span class="line">    System.out.println(<span class="string">"Sender : "</span> + context);</span><br><span class="line">    <span class="keyword">this</span>.rabbitTemplate.convertAndSend(<span class="string">"exchange"</span>, <span class="string">"topic.message"</span>, context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String context = <span class="string">"hi, i am messages 2"</span>;</span><br><span class="line">    System.out.println(<span class="string">"Sender : "</span> + context);</span><br><span class="line">    <span class="keyword">this</span>.rabbitTemplate.convertAndSend(<span class="string">"exchange"</span>, <span class="string">"topic.messages"</span>, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这个“exchange”是指明交换机，topic.message与top.messages是routeKey</p><ol start="3"><li>接收者  </li></ol><p>接收者同上，没有改变。 </p></li><li><p>fanout<br>fanout与topic类似，定义部分稍有不同，生产者与消费者使用相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutRabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">AMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"fanout.A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">BMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"fanout.B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">FanoutExchange <span class="title">fanoutExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(<span class="string">"fanoutExchange"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分部进行绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">bindingExchangeA</span><span class="params">(Queue AMessage,FanoutExchange fanoutExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(AMessage).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">bindingExchangeB</span><span class="params">(Queue BMessage, FanoutExchange fanoutExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(BMessage).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h1><h2 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h2><p>elasticsearch也借鉴了一篇文章，可惜是微信的，链接有signature，访问会受限，这里没法给出原链接了。</p><ul><li><p>是什么<br>Elasticsearch 是一个 <strong>real-time</strong>, <strong>distributed storage</strong>, <strong>search engine</strong>  </p></li><li><p>特性<br>Elasticsearch是专门做搜索的,我们在用搜狗、google时候，输入关键字没那么匹配都可以搜索的出来，用elaticsearch就可以做到：</p><ol><li>Elasticsearch对模糊搜索非常擅长（模糊查询）</li><li>没有那么准确的关键字也能搜出相关的结果（相关性查询）</li><li>从Elasticsearch搜索到的数据可以根据评分过滤掉大部分的，只要返回评分高的给用户就好了（原生就支持排序）</li></ol></li><li><p>简单介绍原理<br>分词： 写入到Elasticsearch的数据会进行分词<br>存储：<br>  <img src="./elasticsearch数据结构.png" alt="elasticsearch数据结构.png"><br>  从右往左看：position是记录所在的位置，term dictionary是分词字典， term index是为了快速查找分词所做的索引  </p></li><li><p>基本术语  </p></li></ul><table><thead><tr><th style="text-align:center">关系型数据库</th><th style="text-align:center">Elasticsearch</th></tr></thead><tbody><tr><td style="text-align:center">Table</td><td style="text-align:center">Index(Type)</td></tr><tr><td style="text-align:center">Row</td><td style="text-align:center">Document</td></tr><tr><td style="text-align:center">Column</td><td style="text-align:center">Filed</td></tr><tr><td style="text-align:center">Schema</td><td style="text-align:center">Mapping</td></tr><tr><td style="text-align:center">SQL</td><td style="text-align:center">DSL</td></tr></tbody></table><p>  这个术语与mongo的术语基本相同，mongo中与Table对应的概念是Collection。所以在分布式存储这块，elasticsearch应该用的NoSQL，至于与mongo的关系还需要探索一下  </p><h2 id="准备-1"><a href="#准备-1" class="headerlink" title="准备"></a>准备</h2><ul><li><p>安装<br><a href="https://www.cnblogs.com/zz0412/p/10572828.html" target="_blank" rel="noopener">借鉴1</a><br><a href="https://blog.csdn.net/qq_36835255/article/details/89314248" target="_blank" rel="noopener">借鉴2</a>  </p><p>docker-compose.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  es1:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch:6.8.6</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">es1</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">node.name=es01</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">cluster.name=es-cluster</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"ES_JAVA_OPTS=-Xms1024m -Xmx1024m"</span></span><br><span class="line"><span class="attr">    ulimits:</span></span><br><span class="line"><span class="attr">      nproc:</span> <span class="number">65535</span></span><br><span class="line"><span class="attr">      memlock:</span></span><br><span class="line"><span class="attr">        soft:</span> <span class="bullet">-1</span></span><br><span class="line"><span class="attr">        hard:</span> <span class="bullet">-1</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./elasticsearch_data/es1_data:/usr/share/elasticsearch/data</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">9200</span><span class="string">:9200</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">9300</span><span class="string">:9300</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">esnet</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  es2:</span></span><br><span class="line"><span class="attr">  image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch:6.8.6</span></span><br><span class="line"><span class="attr">  container_name:</span> <span class="string">es2</span></span><br><span class="line"><span class="attr">  environment:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">node.name=es02</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">cluster.name=es-cluster</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"ES_JAVA_OPTS=-Xms1024m -Xmx1024m"</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"discovery.zen.ping.unicast.hosts=es1"</span></span><br><span class="line"><span class="attr">  ulimits:</span></span><br><span class="line"><span class="attr">    nproc:</span> <span class="number">65535</span></span><br><span class="line"><span class="attr">    memlock:</span></span><br><span class="line"><span class="attr">      soft:</span> <span class="bullet">-1</span></span><br><span class="line"><span class="attr">      hard:</span> <span class="bullet">-1</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">./elasticsearch_data/es2_data:/usr/share/elasticsearch/data</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="number">9201</span><span class="string">:9200</span></span><br><span class="line"><span class="bullet">    -</span> <span class="number">9301</span><span class="string">:9300</span></span><br><span class="line"><span class="attr">  networks:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">esnet</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  kibana:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">docker.elastic.co/kibana/kibana:6.8.6</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">kibana</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      SERVER_NAME:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">      ELASTICSEARCH_URL:</span> <span class="attr">http://es1:9200</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">5601</span><span class="string">:5601</span></span><br><span class="line"><span class="attr">    ulimits:</span></span><br><span class="line"><span class="attr">      nproc:</span> <span class="number">65535</span></span><br><span class="line"><span class="attr">      memlock:</span></span><br><span class="line"><span class="attr">        soft:</span> <span class="bullet">-1</span></span><br><span class="line"><span class="attr">        hard:</span> <span class="bullet">-1</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">esnet</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">  esnet:</span></span><br></pre></td></tr></table></figure><p>这里ulimits是对资源的限制，nproc是线程的个数,memlock<br>浏览器打开<code>http://localhost:5601</code>即可监控集群状态  </p><p>在启动过程中出现了<code>max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</code>意思是最大的虚拟内存太小了，要求扩容，解决方案：<br>修改本机的 /etc/sysctl.conf，在文件末尾增加：<code>vm.max_map_count=262144</code><br>sysctl -p生效  </p><p>由于本机的内存限制，使用过程中，将es2节点删去之后进行的实验  </p></li><li><p>依赖  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置  </p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.data.elasticsearch.cluster-name=es-cluster</span></span><br><span class="line"><span class="comment"># 集群节点地址列表，用逗号分隔</span></span><br><span class="line"><span class="string">spring.data.elasticsearch.cluster-nodes=localhost:9300</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h2><p>spring-boot下使用elasticsearch与JPA很相似，因为它们都是在从相同的父类下继承而来  </p><ul><li><p>定义对象  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Document</span>(indexName = <span class="string">"customer"</span>, type = <span class="string">"customer"</span>, shards = <span class="number">1</span>, replicas = <span class="number">0</span>, refreshInterval = <span class="string">"-1"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//省略部分 getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Document 注解会对实体中的所有属性建立索引<br>indexName = “customer” 表示创建一个名称为 “customer” 的索引<br>type = “customer” 表示在索引中创建一个名为 “customer” 的 type<br>shards = 1 表示只使用一个分片<br>replicas = 0 表示不使用复制<br>refreshInterval = “-1” 表示禁用索引刷新</p></li><li><p>repository</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomerRepository</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">Customer</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Customer&gt; <span class="title">findByAddress</span><span class="params">(String address)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Customer <span class="title">findByUserName</span><span class="params">(String userName)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>  <span class="title">deleteByUserName</span><span class="params">(String userName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerRepositoryTest</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> CustomerRepository repository;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveCustomers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      repository.save(<span class="keyword">new</span> Customer(<span class="string">"Alice"</span>, <span class="string">"北京"</span>,<span class="number">13</span>));</span><br><span class="line">      repository.save(<span class="keyword">new</span> Customer(<span class="string">"Bob"</span>, <span class="string">"北京"</span>,<span class="number">23</span>));</span><br><span class="line">      repository.save(<span class="keyword">new</span> Customer(<span class="string">"Hibe"</span>, <span class="string">"上海"</span>,<span class="number">30</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fetchAllCustomers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (Customer customer : repository.findAll()) &#123;</span><br><span class="line">          System.out.println(customer);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteCustomers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      repository.deleteByUserName(<span class="string">"Hibe"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateCustomers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Customer customer= repository.findByUserName(<span class="string">"Bob"</span>);</span><br><span class="line">      customer.setAddress(<span class="string">"北京市海淀区"</span>);</span><br><span class="line">      repository.save(customer);</span><br><span class="line">      Customer xcustomer=repository.findByUserName(<span class="string">"Bob"</span>);</span><br><span class="line">      System.out.println(xcustomer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fetchIndividualCustomers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (Customer customer : repository.findByAddress(<span class="string">"北京"</span>)) &#123;</span><br><span class="line">          System.out.println(customer);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="Quartz"><a href="#Quartz" class="headerlink" title="Quartz"></a>Quartz</h1><h2 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h2><p>  Quartz其实就是linux的cron，能够定时执行某些任务，spring boot内部也集成了一个简单的定时任务调度。说怎么实现原理的话，可能有2种，一种的用定时器来实现，另一种封装系统的cron来实现，在内核层都应该是软中断。  </p><h2 id="spring-boot自带"><a href="#spring-boot自带" class="headerlink" title="spring boot自带"></a>spring boot自带</h2><ol><li><p>application上增加@EnableScheduling  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Spring</span> BootApplication</span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对应函数上增加配置@Scheduled(),cron与fixedRate都可以  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SchedulerTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron=<span class="string">"*/6 * * * * ?"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is scheduler task runing  "</span>+(count++));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled</span>(fixedRate = <span class="number">6000</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reportCurrentTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"现在时间："</span> + dateFormat.format(<span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cron：秒、时、分，日、月、星期、年； *表示每， /表示步长，也就是间隔， ？表示不确定（因为周与日是不会共存的，所以选择一种，另外一个就用？来表示）</p></li></ol><h2 id="Quartz-1"><a href="#Quartz-1" class="headerlink" title="Quartz"></a>Quartz</h2><ul><li><p>4个基本概念  </p><p>Job: 一个接口，表示要执行的任务<br>JobDetail: Job的实例<br>Trigger: 什么情况下触发，类似cron或者fixedRate<br>Scheduler: 调度器，包含这Job与Trigger</p></li><li><p>依赖  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-quartz<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用  </p><ol><li><p>定义job，需要实现Job接口  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"schedule job1 is running ..."</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用  </p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleJob</span><span class="params">(Scheduler scheduler)</span> <span class="keyword">throws</span> SchedulerException</span>&#123;</span><br><span class="line">    <span class="comment">// 这里生成JobDetail</span></span><br><span class="line">    JobDetail jobDetail = JobBuilder.newJob(ScheduledJob.class) .withIdentity(<span class="string">"job"</span>, <span class="string">"group1"</span>).build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里生成Trigger</span></span><br><span class="line">    CronScheduleBuilder scheduleBuilder = CronScheduleBuilder.cronSchedule(<span class="string">"0/6 * * * * ?"</span>);</span><br><span class="line">    CronTrigger cronTrigger = TriggerBuilder.newTrigger().withIdentity(<span class="string">"trigger"</span>, <span class="string">"group"</span>) .withSchedule(scheduleBuilder).build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用Scheduler，注册JobDetail与Trigger</span></span><br><span class="line">    scheduler.scheduleJob(jobDetail,cronTrigger);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>调用  </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleJobs</span><span class="params">()</span> <span class="keyword">throws</span> SchedulerException </span>&#123;</span><br><span class="line">  Scheduler scheduler = schedulerFactoryBean.getScheduler();</span><br><span class="line">  scheduleJob(scheduler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>启动时开始运行  </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStartupRunner</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> CronSchedulerJob scheduleJobs;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        scheduleJobs.scheduleJobs();</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;定时任务开始执行&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="邮件系统"><a href="#邮件系统" class="headerlink" title="邮件系统"></a>邮件系统</h1><ul><li><p>简介  </p><p><img src="./sendmail.png" alt="sendmail.png"><br>发送的时候使用SMTP协议，服务器推送时候使用POP3或者IMAP协议  </p></li><li><p>依赖  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置  </p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.mail.host=smtp.163.com</span> <span class="string">//邮箱服务器地址</span></span><br><span class="line"><span class="string">spring.mail.username=xxx@oo.com</span> <span class="string">//用户名</span></span><br><span class="line"><span class="string">spring.mail.password=xxyyooo</span>    <span class="string">//密码</span></span><br><span class="line"><span class="string">spring.mail.default-encoding=UTF-8</span></span><br><span class="line"></span><br><span class="line"><span class="string">//超时时间，可选</span></span><br><span class="line"><span class="string">spring.mail.properties.mail.smtp.connectiontimeout=5000</span>  </span><br><span class="line"><span class="string">spring.mail.properties.mail.smtp.timeout=3000</span></span><br><span class="line"><span class="string">spring.mail.properties.mail.smtp.writetimeout=5000</span></span><br></pre></td></tr></table></figure><p>这里的密码需要注意，并不是邮箱的密码，而是开启POP3的客户端授权码  </p></li><li><p>使用  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JavaMailSender mailSender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.mail.username&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendSimpleMail</span><span class="params">(String to, String subject, String content)</span> </span>&#123;</span><br><span class="line">        SimpleMailMessage message = <span class="keyword">new</span> SimpleMailMessage();</span><br><span class="line">        message.setFrom(from);</span><br><span class="line">        message.setTo(to);</span><br><span class="line">        message.setSubject(subject);</span><br><span class="line">        message.setText(content);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mailSender.send(message);</span><br><span class="line">            logger.info(<span class="string">"简单邮件已经发送。"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"发送简单邮件时发生异常！"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><ul><li><p>简介<br>Spring Security，是封装401与403的模块。401是未登录问题，这个感觉还不错；403是无权限问题，这个对复杂的，感觉还差一点  </p></li><li><p>依赖  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>加上这个依赖，默认所有的路由，都需要登录认证  </p></li><li><p>登录认证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">"/"</span>, <span class="string">"/home"</span>).permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">                <span class="comment">// .loginPage("/login")</span></span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">            .logout()</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">            .csrf()</span><br><span class="line">                .ignoringAntMatchers(<span class="string">"/logout"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是统一配置，哪些路由需要登录才能访问，哪个可以直接访问<br><code>antMatchers(&quot;/&quot;, &quot;/home&quot;).permitAll()</code>，这个意思是”/“,”/home”可以直接访问<br><code>anyRequest().authenticated()</code>，这个是其他的都需要登录认证<br>后边的几个是对登录与退出说的，对于Restful，可以省略  </p></li><li><p>权限认证<br>权限认证，首先要告诉spring boot有哪些角色、与成员，然后可以在config中确定哪些路由需要什么样的角色、权限，或者可以直接在函数上注解权限或角色。  </p><ol><li><p>配置角色</p><p>在SecurityConfig中增加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureGlobal</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    auth.inMemoryAuthentication()</span><br><span class="line">            .passwordEncoder(<span class="keyword">new</span> BCryptPasswordEncoder())</span><br><span class="line">            .withUser(<span class="string">"user"</span>)</span><br><span class="line">                .password(<span class="keyword">new</span> BCryptPasswordEncoder()</span><br><span class="line">                    .encode(<span class="string">"123456"</span>)).roles(<span class="string">"USER"</span>)</span><br><span class="line">            .and()</span><br><span class="line">            .withUser(<span class="string">"admin"</span>)</span><br><span class="line">                .password(<span class="keyword">new</span> BCryptPasswordEncoder()</span><br><span class="line">                    .encode(<span class="string">"admin"</span>)).roles(<span class="string">"ADMIN"</span>, <span class="string">"USER"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是直接通过代码写进去的，没有借鉴意义，只作演示用途  </p></li><li><p>统一配置路由方式  </p></li></ol><p>同登录认证，在SecurityConfig中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            .antMatchers(<span class="string">"/resources/**"</span>, <span class="string">"/"</span>).permitAll()</span><br><span class="line">            .antMatchers(<span class="string">"/admin/**"</span>).hasRole(<span class="string">"ADMIN"</span>)</span><br><span class="line">            .antMatchers(<span class="string">"/content/**"</span>).access(<span class="string">"hasRole('ADMIN') or hasRole('USER')"</span>)</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">            .and()</span><br><span class="line">        .formLogin()</span><br><span class="line"><span class="comment">//                .loginPage("/login")</span></span><br><span class="line">            .permitAll()</span><br><span class="line">            .and()</span><br><span class="line">        .logout()</span><br><span class="line">            .permitAll()</span><br><span class="line">            .and()</span><br><span class="line">        .csrf()</span><br><span class="line">            .ignoringAntMatchers(<span class="string">"/logout"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>antMatchers(&quot;/admin/**&quot;).hasRole(&quot;ADMIN&quot;)</code>，/admin路由，需要有’ADMIN’角色才可以访问，<br><code>antMatchers(&quot;/content/**&quot;).access(&quot;hasRole(&#39;ADMIN&#39;) or hasRole(&#39;USER&#39;)&quot;)</code>，/content路由，’ADMIN’,’USER’角色都可以访问</p><ol start="2"><li><p>在函数注解方式  </p><p>使用PreAuthorize()来配置，使用之前，需要先打开PreAuthorize的开关，否则不起作用<br>在SecurityConfig上，增加<code>@EnableGlobalMethodSecurity(prePostEnabled = true)</code> 注解即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize</span>(<span class="string">"hasAuthority('ADMIN')"</span>)</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/admin"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">admin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"admin"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关于权限认证  </p></li></ol><p>权限认证，是可以通过角色，也可以通过权限。如果角色固定，且较少的话，通过角色会好一些；如果角色不定，用权限来做会更佳一些。</p></li></ul><h1 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h1><h2 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h2><p>  对应用的监控，spring boot给出的方案是Actuator，它的监控分成两类：原生端点和用户自定义端点。自定义端点主要是指扩展性，用户可以根据自己的实际应用，定义一些比较关心的指标，在运行期进行监控。<br>  原生端点又可以分成三类：<br>  应用配置类，可以查看应用在运行期的静态信息，例如自动配置信息、加载的 springbean 信息、yml 文件配置信息、环境信息、请求映射信息；<br>  度量指标类，主要是运行期的动态信息，如堆栈、请求连、一些健康指标、metrics 信息等；<br>  操作控制类，主要是指 shutdown，用户可以发送一个请求将应用的监控功能关闭。  </p><p>  Actuator的提供了很多接口常用的：  </p><table><thead><tr><th>接口</th><th>路径</th><th>描述</th></tr></thead><tbody><tr><td>health</td><td>/health</td><td>报告应用程序的健康指标</td></tr><tr><td>info</td><td>/info</td><td>获取应用程序的定制信息，这些信息由 info 打头的属性提供</td></tr><tr><td>env</td><td>/env</td><td>获取全部环境属性</td></tr><tr><td>metrics</td><td>/metrics</td><td>报告各种应用程序度量信息，比如内存用量和 HTTP 请求计数</td></tr><tr><td>heapdump</td><td>/heapdump</td><td>dump 一份应用的 JVM 堆信息</td></tr><tr><td>threaddump</td><td>/threaddump</td><td>获取线程活动的快照</td></tr><tr><td>httptrace</td><td>/httptrace</td><td>显示 HTTP 足迹，最近 100 个 HTTP request/repspons(未成功)</td></tr><tr><td>sessions</td><td>/sessions</td><td>如果我们使用了 Spring Session 展示应用中的 HTTP Sessions 信息</td></tr><tr><td>logfile</td><td>/logfile</td><td>返回 log file 中的内容（如果 logging.file 或者 logging.path 被设置）</td></tr></tbody></table><p>  另外，在Actuator基础上，构建了分布式的Admin，来收集各应用的Actuator信息，进行汇总显示  </p><h2 id="Actuator"><a href="#Actuator" class="headerlink" title="Actuator"></a>Actuator</h2><ul><li><p>依赖  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置  </p><p>开启哪些监控，可以进行配置<br><code>management.endpoints.web.exposure.include=*</code>，默认开启health与info，通过这个设置，开启所有<br><code>management.endpoints.web.base-path=/manage</code>， 默认base路径是/actuator/*，这个可以进行配置<br><code>management.endpoint.health.show-details=always</code>，对health监控显示的内容进行配置</p></li></ul><h2 id="Admin"><a href="#Admin" class="headerlink" title="Admin"></a>Admin</h2><ul><li><p>server依赖  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>sever配置  </p><p><code>server.port=8000</code> 修改启动的端口  </p></li><li><p>client依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>spring-boot-admin-starter-client 会自动添加 Actuator 相关依赖</p></li><li><p>client配置  </p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.application.name=Admin</span> <span class="string">Client</span></span><br><span class="line"><span class="comment"># 配置sever的地址</span></span><br><span class="line"><span class="string">spring.boot.admin.client.url=http://localhost:8000</span>  </span><br><span class="line"><span class="comment"># 打开所有监控</span></span><br><span class="line"><span class="string">management.endpoints.web.exposure.include=*</span></span><br></pre></td></tr></table></figure></li><li><p>访问<br>通过<code>http://localhost:8000</code>访问页面，就可以查看指标了</p></li></ul><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><h2 id="普通部署"><a href="#普通部署" class="headerlink" title="普通部署"></a>普通部署</h2><ul><li><p>打包配置<br>可以打包成jar包，也可以打成war包，这里只介绍jar包<br>配置文件中设置打包方式：  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>打包命令<br>cd到项目根目录下，执行<br><code>mvn clean package -Dmaven.test.skip=true</code><br>mvn clean 是清除项目target目录下的文件<br>mvn package 是打包，可以跟clean一起执行，类似于管道。默认情况下，打包时候会自动运行test下的测试，如果失败打包就结束，可以通过<code>-Dmaven.test.skip=true</code>来禁用此测试。  </p><p>打包成功后，在target目录下，就会生成jar文件  </p></li><li><p>运行  </p><p><code>java -jar  target/spring-boot-package-1.0.0.jar</code><br><code>nohup java -jar spring-boot-package-1.0.0.jar &amp;</code>  </p></li><li><p>多配置文件  </p><ol><li><p>pom.xml修改</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">env</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">env</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">env</span>&gt;</span>test<span class="tag">&lt;/<span class="name">env</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>pro<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">env</span>&gt;</span>pro<span class="tag">&lt;/<span class="name">env</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置文件修改<br>在 Spring Boot 中多环境配置文件名需要满足 application-{profile}.properties 的格式<br>在 resources 目录下<strong>增加</strong>以下三个文件。<br>application-dev.properties：开发环境<br>application-test.properties：测试环境<br>application-prod.properties：生产环境  </p><p>将原来的application.properties修改为<code>spring.profiles.active=dev</code>，这样默认时候的是dev配置文件  </p></li><li><p>运行<br>打包完成之后，可以通过<code>java -jar  target/spring-boot-package-1.0.0.jar --spring.profiles.active=dev</code> 的方式来运行</p></li></ol></li><li><p>Jenkins简介<br>Jenkins，批量部署时候，它是目前CI领域使用最广泛的工具之一，它是一个独立的开源自动化服务器，可用于自动化各种任务，如构建、测试和部署软件。Jenkins 可以通过本机系统包以 Docker 的方式部署项目。</p><p>使用 Jenkin 之后，部署项目的步骤如下：<br>push 代码到 Github（或者 SVN） 触发 WebHook<br>Jenkins 从仓库拉去代码<br>Maven 构建项目、单元测试<br>备份项目，停止正在运行的项目<br>启动应用<br>查看启动日志  </p></li></ul><h2 id="docker部署"><a href="#docker部署" class="headerlink" title="docker部署"></a>docker部署</h2><ul><li><p>配置<br>在pom.xml中，增加  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--镜像前缀--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">docker.image.prefix</span>&gt;</span>friday<span class="tag">&lt;/<span class="name">docker.image.prefix</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 中间省略 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- Docker maven plugin --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spotify<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>docker-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">imageName</span>&gt;</span>$&#123;docker.image.prefix&#125;/$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">imageName</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">dockerDirectory</span>&gt;</span>src/main/docker<span class="tag">&lt;/<span class="name">dockerDirectory</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>/<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.build.directory&#125;<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">include</span>&gt;</span>$&#123;project.build.finalName&#125;.jar<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- Docker maven plugin --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>${project.build.directory}</code>，构建目录，缺省为 target<br><code>${project.build.finalName}</code>，产出物名称，缺省为 <code>${project.artifactId}-${project.version}</code></p></li><li><p>Dockerfile</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:8-jdk-alpine</span><br><span class="line">ADD account-0.1.0.jar app.jar</span><br><span class="line">ENTRYPOINT [<span class="string">"java"</span>,<span class="string">"-jar"</span>,<span class="string">"/app.jar"</span>]</span><br></pre></td></tr></table></figure><p>account-0.1.0.jar是打的jar包</p></li><li><p>打包部署  </p><ol start="0"><li><p>pro的配置文件<br>application-pro.properties中的localhost需要修改成对应的docker，如</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.datasource.url:</span> <span class="attr">jdbc:postgresql://postgresql:5432/account</span>  </span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">spring.redis.host=redis</span></span><br></pre></td></tr></table></figure></li><li><p>打包<br><code>mvn clean package -Dmaven.test.skip=true</code></p></li><li><p>启动<br><code>java -jar target/account-0.1.0.jar --spring.profiles.active=pro</code><br>运行正常，若启动失败，需要调试到正常  </p></li><li><p>打镜像<br><code>mvn docker:build</code> </p></li><li><p>docker-compose.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">account:</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">friday/account:latest</span></span><br><span class="line"><span class="attr">container_name:</span> <span class="string">account</span></span><br><span class="line"><span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line"><span class="attr">environment:</span></span><br><span class="line">  <span class="string">spring.profiles.active:</span> <span class="string">pro</span></span><br><span class="line"><span class="attr">ports:</span> </span><br><span class="line"><span class="bullet">  -</span> <span class="number">8080</span><span class="string">:8080</span></span><br><span class="line"><span class="attr">links:</span> </span><br><span class="line"><span class="bullet">  -</span> <span class="string">postgresql</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">redis</span></span><br></pre></td></tr></table></figure></li><li><p>启动<br>docker-compose up -d  </p></li></ol></li></ul><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>spring boot使用学习到此结束，嚼别人嚼过的馒头，虽速度不慢，但真不香。如果想深入的学习应该去看看spring boot的实现，Druid的实现，Elasticsearch的实现，RabbitMQ的原理等内容。这些全看，太费时，还有更重要的内容要去学习；不看，浅尝辄止，对于自己没有多少提高。那就综合一下，对spring boot的实现进行一下探索。  </p><p>这里有关于学习有些话想说，使用级别的学习，也是最肤浅的学习，就如同小孩子学会用水杯喝水，我称它为器；对原理与实现的学习，是第二阶段的学习，这就像学习如何制造水杯，我称它为术法；在众多术法以及术法演化中，涌现出了一些共性的东西，我称它为道，道不再局于某个领域，经济、组织、控制、生态、心智无不包含其中。吾辈学习，应以器学术，以术悟道。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为第二篇&lt;br&gt;主要是中间件与部署方面的内容  &lt;/p&gt;
&lt;p&gt;主要参考：&lt;br&gt;&lt;a href=&quot;https://github.com/ityouknow/spring-boot-leaning&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;spring-boot-learning&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>spring-boot使用学习一</title>
    <link href="http://yoursite.com/2020/02/06/spring-boot%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0%E4%B8%80/"/>
    <id>http://yoursite.com/2020/02/06/spring-boot使用学习一/</id>
    <published>2020-02-06T06:16:45.000Z</published>
    <updated>2020-02-27T06:04:35.552Z</updated>
    
    <content type="html"><![CDATA[<p>最近窝在家里，准备对微服务学习再深入一步，这样就跨不过spring cloud这个坎了，那咱就从spring boot开始学习，然后转到spring cloud，并对spring cloud中的相关组件分别进行学习。<br>本文为第一篇  </p><p>主要参考：</p><p><a href="https://github.com/ityouknow/spring-boot-leaning" target="_blank" rel="noopener">spring-boot-learning</a> </p><a id="more"></a><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><ul><li><p>JDK<br>oracle官方下载JDK1.8，解压，添加环境变量<br><a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">jdk8下载</a>  </p></li><li><p>Maven<br>官网下载，解压，添加环境变量<br><a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">maven下载</a>  </p></li><li><p>IDE：VS<br>几个个插件：Java Extension Pack；Spring Initializr Java Support; Spring Boot Tools; Spring Boot Dashborad;<br><a href="https://code.visualstudio.com/docs/java/java-spring-boot" target="_blank" rel="noopener">指导</a>  </p></li><li><p>docker<br>另外，需要用到数据库（postgresql），redis，RabbitMQ等基础设施，用docker安装比较省事，本机已经安装了docker与docker-compose  </p></li></ul><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p>在 spring vs中有引导生成的方法： </p><ul><li>Ctrl + Shift + P</li><li>选择spring initializr maven</li><li>包名</li><li>依赖</li><li>生成位置</li><li>用VS打开  </li><li>F5执行  </li></ul><h1 id="Spring-Web"><a href="#Spring-Web" class="headerlink" title="Spring Web"></a>Spring Web</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li><p>@SpringBootApplication</p><p>每个应用都有一个application类，用@SpringBootApplication来注解  </p></li><li><p>@RestController与@RequestMapping</p><p>Contoller层用@RestController来注解，里边每个路由用@RequestMapping来注解</p></li><li><p>注入<br>将被注入的service用@Service(“xxx”)来注解<br>注入时，使用@Autowired来进行注入即可  </p></li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul><li><p>@SpringBootTest与@Test<br>原课程中使用被@Before注解的setUp()来创建基础环境，但在的版本中，没有@Before只用 @BeforeAll，且使用之后，就无法运行下边的测试了，所以这里改为通过声明时直接初始化的方法来创建mockMvc<br>测试的使用VS会在测试类与测试方法上，自动添加Run Test、Debug Test，点击即可运行  </p></li><li><p>@Before与@BeforeAll<br>搜索了一下@BeforeAll，它是在Junit5才出现的，用来对静态方法的注解。@Before是Junit4中的注解，与Junit5中的@BeforeEach等价</p></li><li><p>注入<br>在测试中，如果像之前一样用MockMvcBuilders.standaloneSetup(new WebController()).build();来创建mockMvc会发现，service无法注入到controller中，但直接运行是没问题的。<br>mockMvc需要用MockMvcBuilders.webAppContextSetup(this.wac).build();来定义，这个this.wac是@AutoWired的WebApplicationContext对象。</p></li></ul><h2 id="swagger"><a href="#swagger" class="headerlink" title="swagger"></a>swagger</h2><ul><li><p>依赖<br>  pom.xml中增加</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置<br>这里的配置，使用配置类的方式来配置  </p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger</span>2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">api</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                <span class="comment">// 自行修改为自己的包路径</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">"com.sun.account.controller"</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                .title(<span class="string">"用户管理"</span>)</span><br><span class="line">                .description(<span class="string">"用户管理操作文档"</span>)</span><br><span class="line">                .version(<span class="string">"1.0"</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用<br>在controller上用@Api(description=”xxx”)来装饰<br>在controller每个方法上用@ApiOperation(value=”xx”, notes=”xxxx”)来装饰<br>另外有@ApiImplicitParams，用来对入参进行解释；@ApiResponse，用来对返回进行解释；不过我感觉这2个用处不大，入参命名恰当，完全可以自注释。出参本身有用处，@ApiResponse返回的是对状态码的解释，如果状态码约定好了，并不需要每个都注释。</p><p>在返回数据的class上，用@ApiModel(description=”xxx”)来注解<br>class中的成员变量，用@ApiModelProperty(value=”xx”, name=”xxx”)来注解</p><p>这里例子中给出的class BaseResult<t>{}不错</t></p></li></ul><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="Postgresl安装"><a href="#Postgresl安装" class="headerlink" title="Postgresl安装"></a>Postgresl安装</h2><p>这里说安装是值得容器化的过程，看了一下之前的容器化，将每个数据库都创建一个镜像，这种做法是费力的，正确的做法是一个镜像，可以运行多个实例，在run的时候，通过配置将环境变量注入进去。  </p><ul><li><p>安装docker-compose<br>pip install upgrade pip<br>pip install docker-compose</p></li><li><p>docker-compose.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.4'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  postgresql:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">postgres:10.5</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">unless-stopped</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      POSTGRES_DB:</span> <span class="string">account</span></span><br><span class="line"><span class="attr">      POSTGRES_USER:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">      POSTGRES_PASSWORD:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./data:/var/lib/postgresql/data</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"5432:5432"</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><ul><li><p>依赖  </p><p>需要在pom.xml中增加2个依赖  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.postgresql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>postgresql<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一个是jdbc另外一个是postgres的驱动</p></li><li><p>配置</p><p>在application.properties中增加：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.datasource.url:</span> <span class="attr">jdbc:postgresql://localhost:5432/account</span></span><br><span class="line"><span class="string">spring.datasource.username:</span> <span class="string">root</span></span><br><span class="line"><span class="string">spring.datasource.password:</span> <span class="number">123456</span></span><br><span class="line"><span class="string">spring.datasource.driverClassName:</span> <span class="string">org.postgresql.Driver</span></span><br></pre></td></tr></table></figure></li><li><p>使用</p><p>在Repository的Impl类中，自动注入JdbcTemplate对象，通过此对象操作数据库。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryImpl</span> <span class="keyword">implements</span> <span class="title">UserRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">save</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.update(<span class="string">"INSERT INTO users(name, password, age) values(?, ?, ?)"</span>,</span><br><span class="line">            user.getName(), user.getPassword(), user.getAge());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> jdbcTemplate.update(<span class="string">"UPDATE users set name=?, password=?, age=? WHERE id=?"</span>,</span><br><span class="line">          user.getName(), user.getPassword(), user.getAge(), user.getId());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(<span class="keyword">long</span> id)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> jdbcTemplate.update(<span class="string">"DELETE FROM users WHERE id = ?"</span>,id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">findById</span><span class="params">(<span class="keyword">long</span> id)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> jdbcTemplate.queryForObject(<span class="string">"SELECT * from users WHERE id = ?"</span>, <span class="keyword">new</span> Object[] &#123; id &#125;, <span class="keyword">new</span> BeanPropertyRowMapper&lt;User&gt;(User.class));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Spring-Boot-JPA"><a href="#Spring-Boot-JPA" class="headerlink" title="Spring Boot JPA"></a>Spring Boot JPA</h2><p>同样的3个步骤</p><h3 id="前奏"><a href="#前奏" class="headerlink" title="前奏"></a>前奏</h3><ul><li><p>依赖</p><p>将jdbc改为data-jpa即可  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.postgresql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>postgresql<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置</p><p>除了postgres数据库的配置，增加了jpa的配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.datasource.url:</span> <span class="attr">jdbc:postgresql://localhost:5432/account</span></span><br><span class="line"><span class="string">spring.datasource.username:</span> <span class="string">root</span></span><br><span class="line"><span class="string">spring.datasource.password:</span> <span class="number">123456</span></span><br><span class="line"><span class="string">spring.datasource.driverClassName:</span> <span class="string">org.postgresql.Driver</span></span><br><span class="line"><span class="comment"># 可以用create\update\validate</span></span><br><span class="line"><span class="string">spring.jpa.properties.hibernate.hbm2ddl.auto=update</span></span><br><span class="line"><span class="string">spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect</span></span><br><span class="line"><span class="string">spring.jpa.show-sql=true</span></span><br><span class="line"><span class="string">spring.jpa.properties.hibernate.format_sql=true</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li><p>entity</p><p>entity上用@Entity来注解，如果表名与类名不同，可以增加@Table(name=”表名”)来注解表名  </p><p>主键：@Id @GeneratedValue来注解  </p><p>不同列：@Column(nullable=false, unqiue=true)来注解  </p><p>使用postgres来创建User对象时，这里有个小坑，因为postgres中默认有一个user表，会与User类重复，导致创建失败，这时候用@Table注解来重新命名表名即可  </p></li><li><p>JpaRepository</p><p>reppository是与JDBC不同最大的，在JDBC中，我们创建了一个interface+impl class来做的repository。而在jpa中，我们只需要一个interface，而有spring自动帮助我们实现。</p><ul><li><p>自动实现<br>Spring Data JPA 可以根据接口方法名来实现数据库操作，主要的语法是 findXXBy、readAXXBy、queryXXBy、countXXBy、getXXBy 后面跟属性名称，利用这个功能仅需要在定义的 Repository 中添加对应的方法名即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">User <span class="title">findByUserName</span><span class="params">(String userName)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>自定义查询<br>在自己本地，只实现了HQL的版本，原生的并没有实现  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query</span>(<span class="string">"select u from User u where u.nickName = ?1"</span>)</span><br><span class="line"><span class="function">User <span class="title">findUserByNickName</span><span class="params">(String nickName)</span></span>;</span><br></pre></td></tr></table></figure><p>在实践过程中发现：如果一个自定义函数有问题，会影响其他函数的生成与执行  </p></li></ul></li><li><p>分页查询  </p><p>分页有2种形式：Page与Slice，Page继承自Slice，并且多一个总数的属性  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query</span>(<span class="string">"select u from User u"</span>)</span><br><span class="line"><span class="function">Page&lt;User&gt; <span class="title">getAll</span><span class="params">(Pageable pageable)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Slice&lt;User&gt; <span class="title">getByNickName</span><span class="params">(String nickName, Pageable pageable)</span></span>;</span><br></pre></td></tr></table></figure><p>定义时候比较简单，复杂的是使用，这个Pageable的生成比较复杂。<br>Pageable的生成通过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Pageable pageable = PageRequest.of(page, size, sort);</span><br><span class="line">``</span><br><span class="line">来生成，前两个参数是<span class="keyword">int</span>类型，page表示第几页，size表示页的大小，sort是Sort对象，可以在这里传入order的参数。sort可以不填写。</span><br><span class="line">我经常的写法是将order写入语句中，比起这里将sort放到查询时候加入，没有这个通用性好。</span><br><span class="line"></span><br><span class="line">sort对象通过：  </span><br><span class="line">```java</span><br><span class="line"> Sort sort = Sort.by(Sort.Direction.DESC, <span class="string">"id"</span>);</span><br></pre></td></tr></table></figure><p>来生成  </p><p>整个过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAll</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> page=<span class="number">0</span>, size=<span class="number">2</span>;</span><br><span class="line">      Sort sort = Sort.by(Sort.Direction.DESC, <span class="string">"id"</span>);</span><br><span class="line"></span><br><span class="line">      Pageable pageable = PageRequest.of(page, size, sort);</span><br><span class="line">      Page&lt;User&gt; allUser = userRepository.getAll(pageable);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (User user : allUser) &#123;</span><br><span class="line">          System.out.print(user);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Page是Slice的子类，Slice是Iterable的孙类，故可以遍历访问  </p></li><li><p>top查询  </p><p>top查询将spring中约定大于配置的理念发挥得淋漓尽致，spring自动生成了TopN的查询：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">findTop2ByNickName</span><span class="params">(String nickName, Sort pageable)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><p>  只需要在repository的interface中增加此接口，就可以进行top2的查询了，t如果是top可以直接用User来当返回参数</p><ul><li><p>联表查询  </p><p>多表查询就是有外键的情况，在接口注解的时候，以HQL的形式注解即可<br>需要注意的是返回值，这里不像node,返回值需要访问，需要自定义访问接口，有getter即可。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query</span>(<span class="string">"select u.id as id, u.userName as userName, u.phone as phone, i.realName as realName, i.hobby as hobby from User u join UserInfo i on u.id=i.userId  where  u.id = ?1 "</span>)</span><br><span class="line"><span class="function">UserDetail <span class="title">getUserDetail</span><span class="params">(Long id)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDetail</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getUserName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getPhone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getRealName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getHobby</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>疑问  </li></ul><p>spring data JPA 是从Hibernate借鉴过来的，而Hibernate是有@OneToMany等关系的注解的，这里没找到例子，后边使用的时候再研究一下使用。</p><h2 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h2><ul><li>简介  </li></ul><p>Druid 首先是一个数据库连接池，但它不仅仅是一个数据库连接池，还包含了一个 ProxyDriver，一系列内置的 JDBC 组件库，一个 SQL Parser。</p><ol><li>替换其他 Java 连接池，Druid 提供了一个高效、功能强大、可扩展性好的数据库连接池。</li><li>可以监控数据库访问性能，Druid 内置提供了一个功能强大的 StatFilter 插件，能够详细统计 SQL 的执行性能，这对于线上分析数据库访问性能有很大帮助。</li><li>SQL 执行日志，Druid 提供了不同的 LogFilter，能够支持 Common-Logging、Log4j 和 JdkLog，可以按需要选择相应的 LogFilter，监控应用的数据库访问情况。</li></ol><ul><li><p>依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化大小、最小、最大链接数</span></span><br><span class="line"><span class="string">spring.datasource.druid.initial-size=3</span></span><br><span class="line"><span class="string">spring.datasource.druid.min-idle=3</span></span><br><span class="line"><span class="string">spring.datasource.druid.max-active=10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置获取连接等待超时的时间</span></span><br><span class="line"><span class="string">spring.datasource.druid.max-wait=60000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  StatViewServlet 配置</span></span><br><span class="line"><span class="string">spring.datasource.druid.stat-view-servlet.login-username=admin</span></span><br><span class="line"><span class="string">spring.datasource.druid.stat-view-servlet.login-password=admin</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 StatFilter</span></span><br><span class="line"><span class="string">spring.datasource.druid.filter.stat.log-slow-sql=true</span></span><br><span class="line"><span class="string">spring.datasource.druid.filter.stat.slow-sql-millis=2000</span></span><br></pre></td></tr></table></figure><p>另外有个<code>spring.datasource.type: com.alibaba.druid.pool.DruidDataSource</code>配置，放在jdbc连接配置之上</p></li><li><p>使用</p><p> <code>http://localhost:8080/druid</code>访问即可，登录的用户名用户密码都是admin，每次有数据库访问时，都可以监控到</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近窝在家里，准备对微服务学习再深入一步，这样就跨不过spring cloud这个坎了，那咱就从spring boot开始学习，然后转到spring cloud，并对spring cloud中的相关组件分别进行学习。&lt;br&gt;本文为第一篇  &lt;/p&gt;
&lt;p&gt;主要参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ityouknow/spring-boot-leaning&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;spring-boot-learning&lt;/a&gt; &lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>k8s基础</title>
    <link href="http://yoursite.com/2019/12/11/k8s%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/12/11/k8s基础/</id>
    <published>2019-12-11T07:33:04.000Z</published>
    <updated>2020-03-23T02:42:57.753Z</updated>
    
    <content type="html"><![CDATA[<p>本文是学习ali云的云原生课程的记录，目的是对基础概念的理解<br><a href="https://edu.aliyun.com/roadmap/cloudnative" target="_blank" rel="noopener">原课程</a>  </p><a id="more"></a><h1 id="K8S核心概念"><a href="#K8S核心概念" class="headerlink" title="K8S核心概念"></a>K8S核心概念</h1><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ul><li><p>K8S的架构是CS架构：<br><img src="架构-1.png" alt="架构-1.png">  </p></li><li><p>master的结构如下：<br><img src="master结构.png" alt="master结构.png">  </p><ul><li>Api Server不仅是外部访问k8s的入口，也是k8s各组件内部的枢纽  </li><li>Scheduler用于调度deployment的pod在哪个node节点运行  </li><li>Controller用于控制状态，做一些检测，确定集群运行正常，当有节点宕机，将其上的pod运行到其他节点上。  </li><li>etcd是一个分布式数据库  </li></ul></li><li><p>node的结构如下：<br><img src="node.png" alt="master结构.png">  </p><ul><li>pod翻译是豆荚，是k8s对容器的一种封装  </li><li>kubelet，是node下的控制，接收自master的命令，运行pod  </li><li>Container Runtime，容器运行环境，是容器实际运行的地方  </li><li>storage plugin，存储插件，是云计算厂商实现的存储接口  </li><li>network plugin，网络插件，同样也是云计算厂商实现  </li><li>kube-proxy，是位置k8s内部service集群的代理  </li></ul></li><li><p>示例<br><img src="一个例子.png" alt="一个例子.png">  </p><p>这个例子是有一个pod要运行，先与api server进行交互，api server进行存储，然后交给scheduler进行调度，scheduler根据目前集群的状态，计算该pod运行的位置，并经过api server进行存储，下发给node上的kubelet，kubelet再在container Runtime下运行起相应的pod（容器）  </p></li></ul><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul><li><p>Pod</p><p><img src="pod.png" alt="pod.png">  </p><ul><li>k8s最小的调度及资源单元  </li><li>由一个或多个容器组成  </li><li>为这些容器，提供共享的资源（网络、进程空间）</li></ul></li><li><p>Volume  </p><ul><li>声明再Pod中的容器可访问的文件目录  </li><li>支持多种后端存储的抽象：本地存储、分布式存储、云存储  </li></ul></li><li><p>Deployment  </p><ul><li>部署的概念，定义一组pod的副本数、版本等。意思是告诉k8s，我想要这种状态。  </li><li>k8s通过scheduler调度pod运行的节点  </li><li>通过Controller维持想要的这种状态，包括自愈，版本控制  </li></ul></li><li><p>service  </p><p><img src="service.png" alt="service.png">  </p><p>既然服务可以运行多个容器，这些容器对外提供服务就需要用稳定的访问地址，service就是为多个pod而建立稳定的虚拟ip。  </p></li><li><p>Namespaces  </p><p><img src="namespace.png" alt="namespace.png"><br>集群内部的逻辑隔离机制，每个资源都属于一个Namespace<br>上述的概念都可认为是一种资源，namesapce为一套K8S运行多个产品做好了铺垫  </p></li></ul><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>  <img src="api基础.png" alt="api基础.png">  </p><h1 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h1><h2 id="Pod概念"><a href="#Pod概念" class="headerlink" title="Pod概念"></a>Pod概念</h2><ul><li><p>容器<br>容器是一个试图被隔离、资源受限的<strong>进程（linux线程）</strong><br>容器里PID = 1的进程就是应用本身<br>容器是单进程模型  </p></li><li><p>k8s<br>k8s是对容器的编排，等价于<strong>操作系统</strong></p></li><li><p>pod<br>pod中的容器共享一些资源，可以任务是<strong>进程组(linux进程)</strong></p><p>两个docker应该运行在以pod上时，应该有超亲密关系：</p><ul><li>会发生直接的文件操作</li><li>通过localhost进行本地同喜</li><li>非常频繁的rpc调用</li></ul></li></ul><h2 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h2><p><img src="共享网络.png" alt="共享网络.png"></p><p>通过Infra Container的方式来共享一个Network Namespace，将网络放到Infa Contanier中，也使得一个pod只有一个ip地址，整个pod的生命中期与infra container一致。</p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><ul><li><p>InitContainer<br>pod中的InitContainer按用户定义的顺序依次启动，其他容器并发启动，并且InitContainer运行完成后自动退出。<br>用InitContainer来执行一些配置、预先准备资源的任务。</p></li><li><p>SideCar<br>用边车来执行一些辅助且通用的工作，如：</p><ul><li><p>日志收集<br><img src="日志收集.png" alt="日志收集.png">  </p></li><li><p>应用监控<br><img src="应用监控.png" alt="应用监控.png"></p></li></ul></li></ul><h1 id="应用编排"><a href="#应用编排" class="headerlink" title="应用编排"></a>应用编排</h1><h2 id="控制的核心"><a href="#控制的核心" class="headerlink" title="控制的核心"></a>控制的核心</h2><h3 id="资源对象"><a href="#资源对象" class="headerlink" title="资源对象"></a>资源对象</h3><ul><li>spec：期望的状态</li><li>status: 观测到的状态</li><li><p>metadata</p><ul><li><p>Lables<br>key-value形式的标签，用于筛选资源，<br>Selector: Tie=front  </p><p>Selector:<br>Env in (test, gray)<br>Tie notin (front, back)  </p></li><li><p>Annotations<br>存储资源的非标识性信息，可以包含特殊字符  </p></li><li><p>OwnerReference<br>资源创建者对象，如pod一般的所有者是replicas</p></li></ul></li></ul><h3 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h3><ul><li><p>控制循环<br><img src="控制循环.png" alt="控制循环.png"><br>主要是2部分：sensor、controller，不断使status趋近spec</p></li><li><p>sensor部分<br><img src="sensor部分.png" alt="sensor部分.png"><br>通过不断的list &amp; watch来获取变化，通过informer通知给controller部分来处理</p></li><li><p>controller部分<br><img src="controller.png" alt="controller.png"><br>hander发出指令，woker进行操作。  </p></li><li><p>示例：<br><img src="控制示例-1.png" alt="控制示例-1.png"><br><img src="控制示例-2.png" alt="控制示例-2.png"><br><img src="控制示例-3.png" alt="控制示例-3.png"></p></li></ul><h2 id="deployment"><a href="#deployment" class="headerlink" title="deployment"></a>deployment</h2><p>本节应该算是运维重点  </p><ul><li><p>用处<br>定义一组pod的spec数量，controller会维持status与spec一致<br>配置pod的发布方式，controller会暗中给定策略更新pod，保证发布过程可用<br>如有发布问题，支持一键回滚  </p></li><li><p>基础<br><img src="deployment语法.png" alt="deployment语法.png"><br>replicas: 期望的数量；<br>template: pod模板</p><p>deployment只负责管理不同版本的replicaSet，由ReplicaSet管理Pod副本数。每个ReplicaSet对应 deployment的一个版本，每个ReplicaSet下的pod都是相同的版本<br><img src="replicaSet与pod.png" alt="replicaSet与pod.png">  </p></li><li><p>发布<br><img src="deployment扩容.png" alt="deployment扩容.png">  </p></li><li><p>扩容<br><img src="发布模拟.png" alt="发布模拟.png">  </p></li><li><p>快速回滚<br>kubectl rollout undo deployment/nginx-deployment   // 回滚到上一版本   </p><p>kebectl rollout undo deployment.v1.apps/nginx-deployment –to-revision=2    // 回滚到固定版本  </p><p><img src="回滚模拟.png" alt="回滚模拟.png">  </p></li><li><p>控制字段  </p><ul><li>revisionHistroyLimit:保留历史resion(ReplicaSet)的数量，默认10</li><li>paused: 标志Deployment只做数量维持，不做新的发布  </li><li>progressDeadlineSeconds: 判断deloyment失败的最大时间  </li><li>MaxUnavailable: 发布过程中最多的pod不可用数目</li><li>MaxSurge: 发布过程中最多存在多少个Pod超过期望replicas数量</li></ul></li></ul><h2 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h2><ul><li><p>普通job</p><p>Job可以看做是直接运行的任务进程，执行某种计算，完成之后就停止。  </p><p><img src="Job示例.png" alt="Job示例.png"><br>用pod执行一个计算pi的任务  </p><p>在spec中指明</p><ul><li>completions： 代表这个job执行的总次数</li><li>parallelism:  代表并发的个数 </li></ul><p>kubectl get jobs  </p></li><li><p>cronJob</p><p>定时运行的job，与linux的cron相似<br><img src="cronJob.png" alt="cronJob.png">  </p></li></ul><h2 id="daemonSet"><a href="#daemonSet" class="headerlink" title="daemonSet"></a>daemonSet</h2><ul><li><p>用处<br>如同守护进程类似，可以用来：  </p><ul><li>保证集群每一个(或一些)节点都运行一组相同的Pod</li><li>跟踪集群节点状态，保证新加入的节点自动创建对应的pod</li><li>跟踪集群节点状态，保证移除的节点删除对应的pod</li><li>跟踪pod状态，保证每个节点pod处于运行状态</li></ul></li><li><p>示例</p></li></ul><p><img src="deamonSet.png" alt="deamonSet.png">  </p><h1 id="应用配置"><a href="#应用配置" class="headerlink" title="应用配置"></a>应用配置</h1><h2 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h2><p>主要管理容器运行所需的配置文件，环境便利，命令行参数等可变配置。用于解耦镜像和可变配置，从而保证pod的可移植性。</p><ul><li><p>yml  </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span> </span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span> </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">example-configmap</span> </span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="comment"># Configuration values can be set as key-value properties</span></span><br><span class="line"><span class="attr">  database:</span> <span class="string">mongodb</span></span><br><span class="line"><span class="attr">  database_uri:</span> <span class="attr">mongodb://localhost:27017</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># Or set as complete file contents (even JSON!)</span></span><br><span class="line"><span class="attr">  keys:</span>  </span><br><span class="line">    <span class="string">image.public.key=771</span> </span><br><span class="line">    <span class="string">rsa.public.key=42</span></span><br></pre></td></tr></table></figure></li><li><p>创建<br>kubectl apply -f config-map.ymal </p></li><li><p>使用  </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span> </span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span> </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">pod-env-var</span> </span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">env-var-configmap</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">k8s.gcr.io/busybox</span></span><br><span class="line"><span class="attr">      command:</span> <span class="string">["/bin/sh",</span> <span class="string">"-c"</span><span class="string">,</span> <span class="string">"env"</span><span class="string">]</span></span><br><span class="line"><span class="attr">      envFrom:</span></span><br><span class="line"><span class="attr">        - configMapRef:</span></span><br><span class="line"><span class="attr">            name:</span> <span class="string">example-configmap</span></span><br></pre></td></tr></table></figure></li><li><p>说明  </p><ol><li>ConfigMap文件大小限制：1MB(ETCD限制)</li><li>Pod只能引用同Namespace中的ConfigMap</li></ol></li></ul><h2 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h2><p>Secret是用在集群中用于存储密码，token等敏感信息的资源对象，使用base-64编码  </p><ul><li><p>yml<br><img src="secret.png" alt="secret.png">  </p></li><li><p>创建<br>kubectl apply -f ~/kube/hello/registry-secret.yaml  </p></li><li><p>使用<br><img src="secret使用.png" alt="secret使用.png"><br>secret使用一般通过volume挂载到指定容器目录，供容器中业务使用。 </p></li></ul><h2 id="ServiceAccount"><a href="#ServiceAccount" class="headerlink" title="ServiceAccount"></a>ServiceAccount</h2><p>secviceAccount主要用于解决Pod在集群中的身份认证问题。认证使用的授权信息，利用Secret</p><ul><li><p>yml<br><img src="serviceAccount.png" alt="serviceAccount.png">  </p></li><li><p>示例：私有镜像仓库<br><img src="私有镜像仓库.png" alt="私有镜像仓库.png">  </p></li></ul><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>主要是pod中配置所需要的cpu、memory、外存等</p><ul><li><p>yml<br><img src="resource.png" alt="resource.png">  </p></li><li><p>说明<br><img src="resource2.png" alt="resource2.png"></p></li></ul><h1 id="应用存储"><a href="#应用存储" class="headerlink" title="应用存储"></a>应用存储</h1><p>存储与容器的隔离，pod的生命周期与volume的生命周期解耦</p><h2 id="核心知识"><a href="#核心知识" class="headerlink" title="核心知识"></a>核心知识</h2><ul><li><p>概念  </p><p>static volume provisioning:  pv是静态的，当用户提交pvc，从静态中匹配合适的pv，这种容易找不到合适的pv  <img src="staticVolumeProvisioning.png" alt="staticVolumeProvisioning.png">  </p><p>dynamic volume provisioning: 通过storage class分配pv的模板，K8s根据pvc与sc自动创建pv<br><img src="dynamicVolumeProvisioning.png" alt="dynamicVolumeProvisioning.png">  </p></li><li><p>示例1<br>pod中的多个容器共享一个volume  </p><p><img src="pv示例1.png" alt="pv示例1.png">  </p><ul><li>spec.volumes声明pod的volume</li><li>spec.containers.volumeMounts声明container如何使用volume</li><li>多个container共享volume时，可以使用spec.containers.volumeMounts.subPath隔离不同容器上数据存储的路径  </li></ul></li><li><p>示例2<br>static volume provisoning  </p><p><img src="pv示例2.png" alt="pv示例2.png">  </p><p><img src="pv示例2-2.png" alt="pv示例2-2.png">  </p><p><img src="pv示例2-3.png" alt="pv示例2-3.png">  </p></li><li><p>示例3<br>dynamic volume provisioning  </p><p>系统员创建sc<br><img src="pv示例3-1.png" alt="pv示例3-1.png">  </p><p><img src="pv示例3-2.png" alt="pv示例3-2.png"></p><p><img src="pv示例3-3.png" alt="pv示例3-3.png">  </p></li><li><p>字段  </p><p>AccessModes：PV访问策略控制，必须同PVC的访问策略控制匹配才能绑定  </p><pre><code>ReadWriteOnce:只允许单node访问ReadOnlyMany：允许多node只读访问ReadWriteOnly：允许多node读写访问</code></pre><p>PersistentVolumeReclaimPolicy: PV被release之后再回收策略</p><pre><code>Delete：删除Retain：默认策略，保留</code></pre><p>StorageClassName：动态时，可以通过对应的storageClass动态生成新pv对象<br>NodeAffinity: 限制可以访问该volume的node，影响使用该volume的pod调度</p></li><li><p>pv状态机<br><img src="pv状态机.png" alt="pv状态机.png"><br>pv状态release后，无法再通过Reclaim Policy回收，而再次绑定新的PVC。原文给出2种方式，我觉得后一种比较靠谱一些：<br>直接从PVC对象服用，即不unbound PVC和PV。statefulSet处理存储状态的原理。</p></li><li><p>pvc与node流程分析<br><img src="pvc-node流程-1.png" alt="pvc-node流程-1.png"><br><img src="pvc-node流程-2.png" alt="pvc-node流程-2.png">  </p></li></ul><h2 id="存储快照"><a href="#存储快照" class="headerlink" title="存储快照"></a>存储快照</h2><p>存储快照主要是数据的恢复与数据复制迁移场景  </p><ul><li><p>基本概念<br><img src="存储快照基本概念.png" alt="存储快照基本概念.png">  </p></li><li><p>示例<br><img src="存储快照示例.png" alt="存储快照示例.png"></p></li><li><p>流程<br><img src="存储快照流程.png" alt="存储快照流程.png">  </p></li></ul><h2 id="拓扑调度"><a href="#拓扑调度" class="headerlink" title="拓扑调度"></a>拓扑调度</h2><p>拓扑调度应用场景是对volume的调度  </p><ul><li><p>定义<br>拓扑是针对k8s中node位置关系的一种人为划分，通过再node的labels中设置，以标志自己属于具体的拓扑域.3种拓扑域：  </p><ul><li>kubernetes.io/hostname =&gt;  node范围 </li><li>failure-domain.beta.kubernetes.io/region =&gt; Region范围</li><li>failure-domain.beta.kubernetes.io/zone =&gt; Zone范围  </li></ul></li><li><p>背景<br>k8s通过pvc与pv讲存储与计算分离，但有的存储有位置的限制，只能在特定的node上才能访问pv，这就需要拓扑域，来对node运行进行调度。如loval PV只能在制定的Node上被pod使用  </p></li><li><p>本质<br>pv在binding或dynamic provision时，并不知道它会被哪些node所使用，而pv本身是有node限制的  </p><p>这样将binding或者dynamic provision pv的操作延迟到pod调度结果确定之后。再pod调度时，会根据pvc的要求，选择合适的node，然后再去做pv与pvc的binding或者pv的dynamic provision</p></li><li><p>local PV示例<br><img src="localpv示例.png" alt="localpv示例.png">  </p></li><li><p>dynamic provision pv示例<br><img src="dynamicProvisionPv示例.png" alt="dynamicProvisionPv示例.png">  </p></li></ul><h1 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h1><h2 id="基本约束"><a href="#基本约束" class="headerlink" title="基本约束"></a>基本约束</h2><p>  k8s对Pod间的网络没有多少限制，但需要满足3个基本条件：  </p><ul><li>所有Pod可以与其他Pod直接通信，无需显示使用NAT</li><li>所有Node可以与所有Pod直接通信，无需显示使用NAT</li><li><p>Pod课间的IP地址确为其他Pod与其通信时所用，无需显示转换  </p><p>这就有4个方面：</p></li><li>容器与容器间通信  </li><li>Pod与Pod间通信</li><li>Pod与Service间通信</li><li>外部与Service的通信  </li></ul><h2 id="Netns"><a href="#Netns" class="headerlink" title="Netns"></a>Netns</h2><ul><li><p>本质<br><img src="netns.png" alt="netns.png">  </p></li><li><p>pod与netns的关系<br>每个Pod拥有独立的Nets空间，Pod内的Container共享该空间。宿主机本身有一个Root Netns</p><p><img src="pod与netns.png" alt="pod与netns.png">  </p></li><li><p>典型的容器网络实现方案<br><img src="容器网络方案.png" alt="容器网络方案.png">  </p></li></ul><h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><ul><li><p>k8s 服务发现  </p><p>由于pod生命周期短暂，IP地址随时变化，而deployment时pod组需要统一访问入口和负载均衡，所有需要Service  </p><p><img src="service服务发现与负载均衡.png" alt="service服务发现与负载均衡.png">  </p></li><li><p>示例  </p><p><img src="service-1.png" alt="service-1.png"><br><img src="service-2.png" alt="service-2.png"><br><img src="service-3.png" alt="service-3.png"></p></li><li><p>集群外暴露Service<br><img src="向集群外暴露Service.png" alt="向集群外暴露Service.png">  </p></li></ul><h1 id="可观测性"><a href="#可观测性" class="headerlink" title="可观测性"></a>可观测性</h1><h2 id="探测"><a href="#探测" class="headerlink" title="探测"></a>探测</h2><ul><li><p>背景<br>k8s如何知道应用运行是否正常？  </p></li><li><p>liveness与readness<br>通过liveness探测确定应用是否存活；<br>通过readness探测确定应用是否就绪</p><p>探测方式：<br>httpGet、Exec脚本、tcpSocket  </p></li><li><p>probe示例<br><img src="探测示例.png" alt="探测示例.png">  </p></li><li><p>故障排查<br><img src="故障排查.png" alt="故障排查.png">  </p></li></ul><h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><ul><li><p>类型  </p><p>资源监控：CPU、内存、网络等资源类的指标<br>性能监控：通过Hook的机制在虚拟机层、字节码执行层隐式回调，或者在应用层显示注入，用来调优<br>安全监控<br>事件监控</p></li><li><p>k8s监控接口标准  </p><p>k8s提供了3种不同的metrics接口标准：<br><img src="监控接口标准.png" alt="监控接口标准.png">  </p><p>注意这里k8s提供的是标准，而不是实现。<br>Prometheus：开源社区的监控标准  </p></li></ul><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><ul><li><p>类型<br>主机内核的日志<br>容器docker的日志<br>k8s核心组件的日志<br>部署应用的日志  </p><p>他们可以是宿主机文件，也可能是容器内文件，或者容器标准/错误输出的文件<br>可以通过边车模式，用logging-agent-pod来读取文件</p></li><li><p>Fluentd日志采集方案<br><img src="日志采集方案.png" alt="日志采集方案.png">  </p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是学习ali云的云原生课程的记录，目的是对基础概念的理解&lt;br&gt;&lt;a href=&quot;https://edu.aliyun.com/roadmap/cloudnative&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原课程&lt;/a&gt;  &lt;/p&gt;
    
    </summary>
    
    
      <category term="k8s" scheme="http://yoursite.com/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>node.js基础</title>
    <link href="http://yoursite.com/2019/12/07/node-js%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/12/07/node-js基础/</id>
    <published>2019-12-07T02:50:49.000Z</published>
    <updated>2019-12-13T00:56:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>调整一下学习的顺序，从先看libuv，再看node.js。</p><ul><li>v8引擎  </li><li>libuv  </li><li>node.js  &lt;=  </li></ul><p>本文是本系列最后一篇，先来看看node.js的一些api，然后稍介绍一下node.js的源码。  </p><p>主要参考：<a href="https://nodejs.org/dist/latest-v12.x/docs/api/" target="_blank" rel="noopener">官网</a>  </p><a id="more"></a><h1 id="node-js的api"><a href="#node-js的api" class="headerlink" title="node.js的api"></a>node.js的api</h1><p><img src="node-class-diagram.png"></p><p>这张图的node版本是v0.8.12，当下最新的版本是v13.3.0，增加了很多新的类，但核心EventEmitter、stream、net.Server、net.Socket、dgram.Socket、http系列的已经在图中了。这里只对主要的几个类进行简单的介绍。  </p><h2 id="EventEmitter"><a href="#EventEmitter" class="headerlink" title="EventEmitter"></a>EventEmitter</h2><p>EventEmitter是大部分node类的父类，也体现了node的异步理念。  </p><p><a href="https://nodejs.org/dist/latest-v12.x/docs/api/events.html" target="_blank" rel="noopener">api地址</a>  </p><p>最主要的接口是： </p><ul><li><p>on(eventName, listener)<br>将listener添加到event的listener最后，如果第一个可以任务是注册。</p></li><li><p>emit(eventName[, …args])<br>异步调用eventName的每一个listeners</p></li><li><p>eventNames()<br>返回注册的所有event</p></li><li><p>listeners(eventName)<br>返回eventName的全部listeners</p></li></ul><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>stream再libuv中也已经介绍过，是node.js的第二大概念。将很多稳定的数据当做流来处理，如基于tcp的网络数据以及fs等。<br>包括：只读流readable、只写流writable、双向流duplex等内容,duplex = readble + writable  </p><p>stream与Buffer往往是连用的，本质是读取的数据都是二进制流，只不过可以转换成string或者object</p><p><a href="https://nodejs.org/dist/latest-v12.x/docs/api/stream.html" target="_blank" rel="noopener">api地址</a></p><ul><li><p>readable  </p><p>2个event: readable vs data<br>1个function:   read([size])</p><ul><li><p>readable vs data  </p><p>在api中并没有说明这两个事件的差异，stackoverflow中有比较好的解释：  </p><p>The ‘data’ example calls your function with a chunk, and you have no choice but to handle it, or else it will be lost forever. In the ‘readable’ example, the function tells you that data is available, but you can read it at any time. This allows the underlying system to know whether or not you have dealt with the data yet so it is very simple to support a concept called backpressure.</p><p>For example, in a networked stream, if a client is sending data over a TCP connection to a server and the server is super busy, it will receive readable events, but it could choose to wait to read the data until it actually has the resources to deal with the data. By not reading the data, the stream will buffer it and as that buffer approaches a maximum size, the stream will stop reading packets from the operating system to avoid taking up too much RAM. Then the operating system will start dropping packets, and since the packets were dropped, the client that is sending the data will reduce the speed at which it is sending data to try to make fewer packets drop.</p><p>这也解释了官方说的：data是将一chunck数据的控制权交给用户。</p></li><li><p>read([size])<br>如果size不写，在内部缓存中的数据会全部返回</p></li></ul></li><li><p>writable  </p><ul><li>drain 事件　与　write()函数<br>写失败后，当可以再次写入的时候，会发送drain事件，通知写端继续write</li></ul></li></ul><h2 id="net"><a href="#net" class="headerlink" title="net"></a>net</h2><h3 id="net-Server"><a href="#net-Server" class="headerlink" title="net.Server"></a>net.Server</h3><p><a href="https://nodejs.org/dist/latest-v12.x/docs/api/net.html" target="_blank" rel="noopener">api地址</a>  </p><p>net.Server是从EventEmitter派生  </p><p>主要的接口  </p><ul><li><p>listening事件<br>该事件可以认为是server开张的事件</p></li><li><p>connect事件<br>当有新连接创建时，该事件就触发了。对比开张事件，这是接到客的事件  </p></li><li><p>net.createServer()函数<br>创建server的函数  </p></li><li><p>server.listen()函数<br>server.listen([port[, host[, backlog]]][, callback])</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server.listen(&#123;</span><br><span class="line">  host: <span class="string">'localhost'</span>,</span><br><span class="line">  port: <span class="number">80</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="net-Socket"><a href="#net-Socket" class="headerlink" title="net.Socket"></a>net.Socket</h3><p>socket与server连用，socket是server接到的客，它是从Duplex stream派生而来，也就继承了stream的data事件与drain事件，write()、read()函数，另外主要的事件还应该包括  </p><ul><li><p>connect事件<br>代表连接的成功建立</p></li><li><p>close事件<br>连接的断开  </p></li><li><p>connect()函数<br>socket.connect(port[, host][, connectListener])<br>这里的的connectListener回调，可以看做是connect事件的listener  </p></li><li><p>end()函数<br>socket.end([data[, encoding]][, callback])<br>半关闭socket，如果传递的data，可以认为是先write()data，然后再end()</p></li></ul><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><h3 id="http-Server"><a href="#http-Server" class="headerlink" title="http.Server"></a>http.Server</h3><p>http.server 从 net.Server派生  </p><ul><li><p>request事件<br>与tcp的connect事件不同，这里“来客”的事件是:request  </p></li><li><p>upgrade事件<br>比如，http升级成websocket的使用</p></li><li><p>clientError事件  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.end();</span><br><span class="line">&#125;);</span><br><span class="line">server.on(<span class="string">'clientError'</span>, (err, socket) =&gt; &#123;</span><br><span class="line">  socket.end(<span class="string">'HTTP/1.1 400 Bad Request\r\n\r\n'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">8000</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="http-ClientRequest"><a href="#http-ClientRequest" class="headerlink" title="http.ClientRequest"></a>http.ClientRequest</h3><p><a href="https://nodejs.org/dist/latest-v12.x/docs/api/http.html#http_class_http_clientrequest" target="_blank" rel="noopener">示例</a>  </p><p>ClientRequest是一个http的客户端，它包含了Socket，另外也包含了http协议的Header等内容。  </p><ul><li><p>http.request() 进行创建</p></li><li><p>connect事件<br>与server连接成功之后，会emit该事件</p></li><li><p>request.setHeader() 与 request.getHeader()  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">request.setHeader(<span class="string">'content-type'</span>, <span class="string">'text/html'</span>);</span><br><span class="line">request.setHeader(<span class="string">'Content-Length'</span>, Buffer.byteLength(body));</span><br><span class="line">request.setHeader(<span class="string">'Cookie'</span>, [<span class="string">'type=ninja'</span>,<span class="string">'language=javascript'</span>]);</span><br><span class="line"><span class="keyword">const</span> contentType = request.getHeader(<span class="string">'Content-Type'</span>);</span><br><span class="line"><span class="comment">// 'contentType' is 'text/html'</span></span><br><span class="line"><span class="keyword">const</span> contentLength = request.getHeader(<span class="string">'Content-Length'</span>);</span><br><span class="line"><span class="comment">// 'contentLength' is of type number</span></span><br><span class="line"><span class="keyword">const</span> cookie = request.getHeader(<span class="string">'Cookie'</span>);</span><br><span class="line"><span class="comment">// 'cookie' is of type string[]</span></span><br></pre></td></tr></table></figure></li><li><p>request.Socket()<br>虽然是socket，但这里的socket是http协议下的socket，不会发送‘readable’事件。</p></li><li><p>request.write()<br>写数据</p></li><li><p>示例：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; URL &#125; = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create an HTTP tunneling proxy</span></span><br><span class="line"><span class="keyword">const</span> proxy = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123; <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span> &#125;);</span><br><span class="line">  res.end(<span class="string">'okay'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">proxy.on(<span class="string">'connect'</span>, (req, cltSocket, head) =&gt; &#123;</span><br><span class="line">  <span class="comment">// Connect to an origin server</span></span><br><span class="line">  <span class="keyword">const</span> &#123; port, hostname &#125; = <span class="keyword">new</span> URL(<span class="string">`http://<span class="subst">$&#123;req.url&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">const</span> srvSocket = net.connect(port || <span class="number">80</span>, hostname, () =&gt; &#123;</span><br><span class="line">    cltSocket.write(<span class="string">'HTTP/1.1 200 Connection Established\r\n'</span> +</span><br><span class="line">                    <span class="string">'Proxy-agent: Node.js-Proxy\r\n'</span> +</span><br><span class="line">                    <span class="string">'\r\n'</span>);</span><br><span class="line">    srvSocket.write(head);</span><br><span class="line">    srvSocket.pipe(cltSocket);</span><br><span class="line">    cltSocket.pipe(srvSocket);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now that proxy is running</span></span><br><span class="line">proxy.listen(<span class="number">1337</span>, <span class="string">'127.0.0.1'</span>, () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make a request to a tunneling proxy</span></span><br><span class="line">  <span class="keyword">const</span> options = &#123;</span><br><span class="line">    port: <span class="number">1337</span>,</span><br><span class="line">    host: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    method: <span class="string">'CONNECT'</span>,</span><br><span class="line">    path: <span class="string">'www.google.com:80'</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> req = http.request(options);</span><br><span class="line">  req.end();</span><br><span class="line"></span><br><span class="line">  req.on(<span class="string">'connect'</span>, (res, socket, head) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'got connected!'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make a request over an HTTP tunnel</span></span><br><span class="line">    socket.write(<span class="string">'GET / HTTP/1.1\r\n'</span> +</span><br><span class="line">                 <span class="string">'Host: www.google.com:80\r\n'</span> +</span><br><span class="line">                 <span class="string">'Connection: close\r\n'</span> +</span><br><span class="line">                 <span class="string">'\r\n'</span>);</span><br><span class="line">    socket.on(<span class="string">'data'</span>, (chunk) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(chunk.toString());</span><br><span class="line">    &#125;);</span><br><span class="line">    socket.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">      proxy.close();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>  创建了一个http代理，用req与代理连接，然后发送数据</p><h3 id="http-ServerResponse"><a href="#http-ServerResponse" class="headerlink" title="http.ServerResponse"></a>http.ServerResponse</h3><p>由server创建的对象，在request事件的监听回调中，作为第二个参数。<br>这是用来与requestClient进行通信用的。  </p><ul><li>response.setHeader(name, value)</li><li>response.getHeader(name)</li><li>response.write(chunk[, encoding][, callback])</li><li>response.end([data[, encoding]][, callback])</li></ul><h3 id="http-IncomingMessage"><a href="#http-IncomingMessage" class="headerlink" title="http.IncomingMessage"></a>http.IncomingMessage</h3><p>这个server接到的客，属性包括：  </p><ul><li>message.headers</li><li>message.httpVersion</li><li>message.method</li><li><p>message.rawHeaders<br>原始的头，并不是键值对形式的，而是在一个list中的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Prints something like:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// [ 'user-agent',</span></span><br><span class="line"><span class="comment">//   'this is invalid because there can be only one',</span></span><br><span class="line"><span class="comment">//   'User-Agent',</span></span><br><span class="line"><span class="comment">//   'curl/7.22.0',</span></span><br><span class="line"><span class="comment">//   'Host',</span></span><br><span class="line"><span class="comment">//   '127.0.0.1:8000',</span></span><br><span class="line"><span class="comment">//   'ACCEPT',</span></span><br><span class="line"><span class="comment">//   '*/*' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(request.rawHeaders);</span><br></pre></td></tr></table></figure></li></ul><h2 id="fs"><a href="#fs" class="headerlink" title="fs"></a>fs</h2><p><a href="https://nodejs.org/dist/latest-v12.x/docs/api/fs.html" target="_blank" rel="noopener">api地址</a>  </p><ul><li>fs.open(path[, flags[, mode]], callback)</li><li><p>fs.openSync(path[, flags, mode])</p></li><li><p>fs.opendir(path[, options], callback)</p></li><li><p>fs.opendirSync(path[, options])</p></li><li><p>fs.readdir(path[, options], callback)</p></li><li><p>fs.readdirSync(path[, options])</p></li><li><p>fs.readFile(path[, options], callback)</p></li><li><p>fs.readFileSync(path[, options])</p></li><li><p>fs.writeFile(file, data[, options], callback)</p></li><li><p>fs.writeFileSync(file, data[, options])</p></li><li><p>fs.close(fd, callback)</p></li><li>fs.closeSync(fd)</li></ul><h1 id="node-js源码节选赏析"><a href="#node-js源码节选赏析" class="headerlink" title="node.js源码节选赏析"></a>node.js源码节选赏析</h1><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p><img src="node启动.png" alt="node启动.png">  </p><h2 id="internal模块"><a href="#internal模块" class="headerlink" title="internal模块"></a>internal模块</h2><p>internal模块是在init过程将模块注册到V8的堆栈中:</p><p>每个internal模块都有一个Initialize()函数，通过Envirment::SetMethod()注册成V8的Funtion Template，用于js代码来调用。  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> Environment::SetMethod(v8::Local&lt;v8::Object&gt; that,</span><br><span class="line">                                   <span class="keyword">const</span> <span class="keyword">char</span>* name,</span><br><span class="line">                                   v8::FunctionCallback callback) &#123;</span><br><span class="line">  v8::Local&lt;v8::Context&gt; context = isolate()-&gt;GetCurrentContext();</span><br><span class="line">  v8::Local&lt;v8::Function&gt; function =</span><br><span class="line">      NewFunctionTemplate(callback, v8::Local&lt;v8::Signature&gt;(),</span><br><span class="line">                          v8::ConstructorBehavior::kThrow,</span><br><span class="line">                          v8::SideEffectType::kHasSideEffect)</span><br><span class="line">          -&gt;GetFunction(context)</span><br><span class="line">          .ToLocalChecked();</span><br><span class="line">  <span class="comment">// kInternalized strings are created in the old space.</span></span><br><span class="line">  <span class="keyword">const</span> v8::NewStringType type = v8::NewStringType::kInternalized;</span><br><span class="line">  v8::Local&lt;v8::String&gt; name_string =</span><br><span class="line">      v8::String::NewFromUtf8(isolate(), name, type).ToLocalChecked();</span><br><span class="line">  that-&gt;Set(context, name_string, function).Check();</span><br><span class="line">  function-&gt;SetName(name_string);  <span class="comment">// NODE_SET_METHOD() compatibility.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个模块的最后都有<code>NODE_MODULE_CONTEXT_AWARE_INTERNAL(&lt;模块名&gt;, 模块的Initialize函数)</code>，<br>这个宏定义是再node_binding中定义的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NODE_MODULE_CONTEXT_AWARE_INTERNAL(modname, regfunc)                   \</span></span><br><span class="line">  NODE_MODULE_CONTEXT_AWARE_CPP(modname, regfunc, <span class="literal">nullptr</span>, NM_F_INTERNAL)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NODE_MODULE_CONTEXT_AWARE_CPP(modname, regfunc, priv, flags)           \</span></span><br><span class="line">  <span class="keyword">static</span> node::node_module _module = &#123;                                         \</span><br><span class="line">      NODE_MODULE_VERSION,                                                     \</span><br><span class="line">      flags,                                                                   \</span><br><span class="line">      <span class="literal">nullptr</span>,                                                                 \</span><br><span class="line">      __FILE__,                                                                \</span><br><span class="line">      <span class="literal">nullptr</span>,                                                                 \</span><br><span class="line">      (node::addon_context_register_func)(regfunc),                            \</span><br><span class="line">      NODE_STRINGIFY(modname),                                                 \</span><br><span class="line">      priv,                                                                    \</span><br><span class="line">      <span class="literal">nullptr</span>&#125;;                                                                \</span><br><span class="line">  <span class="keyword">void</span> _register_#<span class="meta">#modname() &#123; node_module_register(&amp;_module); &#125;</span></span><br></pre></td></tr></table></figure><p>通过宏定义，将创建了一个NM_F_INTERNAL类型的模块，声明了<em>register</em>&lt;模块名&gt; 的注册函数，先来看看这个注册函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> node_module* modlist_internal;</span><br><span class="line"><span class="keyword">static</span> node_module* modlist_linked;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">thread_local</span> node_module* thread_local_modpending;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is set by node::Init() which is used by embedders</span></span><br><span class="line"><span class="keyword">bool</span> node_is_initialized = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">node_module_register</span><span class="params">(<span class="keyword">void</span>* m)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node_module</span>* <span class="title">mp</span> = <span class="title">reinterpret_cast</span>&lt;struct node_module*&gt;(<span class="title">m</span>);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mp-&gt;nm_flags &amp; NM_F_INTERNAL) &#123;</span><br><span class="line">    mp-&gt;nm_link = modlist_internal;</span><br><span class="line">    modlist_internal = mp;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!node_is_initialized) &#123;</span><br><span class="line">    <span class="comment">// "Linked" modules are included as part of the node project.</span></span><br><span class="line">    <span class="comment">// Like builtins they are registered *before* node::Init runs.</span></span><br><span class="line">    mp-&gt;nm_flags = NM_F_LINKED;</span><br><span class="line">    mp-&gt;nm_link = modlist_linked;</span><br><span class="line">    modlist_linked = mp;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    thread_local_modpending = mp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">这个在不同的node版本中，node模块的类型有些不同。它将internal 模块放到 modlist_internal链表中，通过nm_link指向下一个模块。再来看看这些<span class="keyword">register</span>函数是如何被调用的。</span><br><span class="line"></span><br><span class="line">这些函数的调用正是再init时候的`RegisterBuiltinModules()`执行的：</span><br><span class="line"></span><br><span class="line">```C</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RegisterBuiltinModules</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> V(modname) _register_##modname();</span></span><br><span class="line">  NODE_BUILTIN_MODULES(V)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> V</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NODE_BUILTIN_MODULES(V)                                                \</span></span><br><span class="line">  NODE_BUILTIN_STANDARD_MODULES(V)                                             \</span><br><span class="line">  NODE_BUILTIN_OPENSSL_MODULES(V)                                              \</span><br><span class="line">  NODE_BUILTIN_ICU_MODULES(V)                                                  \</span><br><span class="line">  NODE_BUILTIN_REPORT_MODULES(V)                                               \</span><br><span class="line">  NODE_BUILTIN_PROFILER_MODULES(V)                                             \</span><br><span class="line">  NODE_BUILTIN_DTRACE_MODULES(V)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NODE_BUILTIN_STANDARD_MODULES(V)                                       \</span></span><br><span class="line">  V(async_wrap)                                                                \</span><br><span class="line">  V(buffer)                                                                    \</span><br><span class="line">  V(cares_wrap)                                                                \</span><br><span class="line">  V(config)                                                                    \</span><br><span class="line">  V(contextify)                                                                \</span><br><span class="line">  V(credentials)                                                               \</span><br><span class="line">  V(domain)                                                                    \</span><br><span class="line">  V(errors)                                                                    \</span><br><span class="line">  V(fs)                                                                        \</span><br><span class="line">  V(fs_dir)                                                                    \</span><br><span class="line">  V(fs_event_wrap)                                                             \</span><br><span class="line">  V(heap_utils)                                                                \</span><br><span class="line">  V(http2)                                                                     \</span><br><span class="line">  V(http_parser)                                                               \</span><br><span class="line">  V(inspector)                                                                 \</span><br><span class="line">  V(js_stream)                                                                 \</span><br><span class="line">  V(messaging)                                                                 \</span><br><span class="line">  V(module_wrap)                                                               \</span><br><span class="line">  V(native_module)                                                             \</span><br><span class="line">  V(options)                                                                   \</span><br><span class="line">  V(os)                                                                        \</span><br><span class="line">  V(performance)                                                               \</span><br><span class="line">  V(pipe_wrap)                                                                 \</span><br><span class="line">  V(process_wrap)                                                              \</span><br><span class="line">  V(process_methods)                                                           \</span><br><span class="line">  V(serdes)                                                                    \</span><br><span class="line">  V(signal_wrap)                                                               \</span><br><span class="line">  V(spawn_sync)                                                                \</span><br><span class="line">  V(stream_pipe)                                                               \</span><br><span class="line">  V(stream_wrap)                                                               \</span><br><span class="line">  V(string_decoder)                                                            \</span><br><span class="line">  V(symbols)                                                                   \</span><br><span class="line">  V(task_queue)                                                                \</span><br><span class="line">  V(tcp_wrap)                                                                  \</span><br><span class="line">  V(timers)                                                                    \</span><br><span class="line">  V(trace_events)                                                              \</span><br><span class="line">  V(tty_wrap)                                                                  \</span><br><span class="line">  V(types)                                                                     \</span><br><span class="line">  V(udp_wrap)                                                                  \</span><br><span class="line">  V(url)                                                                       \</span><br><span class="line">  V(util)                                                                      \</span><br><span class="line">  V(uv)                                                                        \</span><br><span class="line">  V(v8)                                                                        \</span><br><span class="line">  V(wasi)                                                                      \</span><br><span class="line">  V(worker)                                                                    \</span><br><span class="line">  V(zlib)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;调整一下学习的顺序，从先看libuv，再看node.js。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;v8引擎  &lt;/li&gt;
&lt;li&gt;libuv  &lt;/li&gt;
&lt;li&gt;node.js  &amp;lt;=  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文是本系列最后一篇，先来看看node.js的一些api，然后稍介绍一下node.js的源码。  &lt;/p&gt;
&lt;p&gt;主要参考：&lt;a href=&quot;https://nodejs.org/dist/latest-v12.x/docs/api/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网&lt;/a&gt;  &lt;/p&gt;
    
    </summary>
    
    
      <category term="node.js" scheme="http://yoursite.com/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>libuv记录</title>
    <link href="http://yoursite.com/2019/11/24/libuv%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/11/24/libuv记录/</id>
    <published>2019-11-24T02:58:23.000Z</published>
    <updated>2019-12-13T08:44:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>调整一下学习的顺序，从先看libuv，再看node.js。</p><ul><li>v8引擎  </li><li>libuv     &lt;=  </li><li>node.js  </li></ul><p>主要参考：<a href="http://docs.libuv.org/en/v1.x" target="_blank" rel="noopener">官网</a><br><a id="more"></a></p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>libuv不仅仅是一个在不同I/O轮询机制之上的简单抽象，它为sockets提供更高层次的’handles’与’streams’抽象，跨平台的文件I/O，线程、进程等功能。如图：<br><img src="概览.png" alt="概览.png">  </p><ul><li><p>事件循环(event loop)<br><img src="事件循环.png" alt="事件循环.png">  </p><p>事件循环是libuv的核心，它与一个独立的线程绑定。所有的网络I/O都在非阻塞的socket上执行。作为循环迭代的一部分，等待socket上I/O活动时，循环会阻塞，回调函数会立即触发，并指示socket的状态（可读、可写等），这样handles可以执行读写操作。</p><ul><li>首先执行是到期的times  </li><li>其次执行的是被挂起的callbacks，这些callback在本次轮询的前面，为什么会再前面呢，因为它们是在一次轮询前，推迟到本次的。  </li><li>空闲的handles  </li><li>prepare handles、I/O轮询、check handles，这三个可以是轮询的前中后，AOP编程的思维，像是Nest框架中的Interceptors</li></ul><p>在事件驱动的编程中，应用向表示对特定事件的兴趣，当事件发生时进行相应。从操作系统收集事件，监视其他资源的工作由libuv来完成。用户可以注册回调，当事件触发时被调用。  </p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;uv.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uv_loop_t</span> *loop = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">uv_loop_t</span>));</span><br><span class="line">    uv_loop_init(loop);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Now quitting.\n"</span>);</span><br><span class="line">    uv_run(loop, UV_RUN_DEFAULT);</span><br><span class="line"></span><br><span class="line">    uv_loop_close(loop);</span><br><span class="line">    <span class="built_in">free</span>(loop);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>handles 与 requests </p><ul><li><p>定义<br>libuv提供两个抽象：handle与request，它们与event loop结合使用。<br>handles： 代表可执行某些操作的持久对象，例如tcp server handle，一有新连接到来，就会执行回调函数。<br>requests: 代表可以行某些操作的短期对象，即可以在handle里执行，也可以直接再event loop里执行。例如getaddrinfo request</p><p>前文讲到，需要向libuv表示对某些事件的兴趣，这个怎么表示呢？这通过创建一个相应的handle来完成，handle可以简单表示成：uv_TYPE_t.例如：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Handle types. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_stream_s</span> <span class="title">uv_stream_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_tcp_s</span> <span class="title">uv_tcp_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_udp_s</span> <span class="title">uv_udp_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_pipe_s</span> <span class="title">uv_pipe_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_tty_s</span> <span class="title">uv_tty_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_poll_s</span> <span class="title">uv_poll_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_timer_s</span> <span class="title">uv_timer_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_prepare_s</span> <span class="title">uv_prepare_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_check_s</span> <span class="title">uv_check_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_idle_s</span> <span class="title">uv_idle_t</span>;</span></span><br></pre></td></tr></table></figure></li><li><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;uv.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int64_t</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait_for_a_while</span><span class="params">(<span class="keyword">uv_idle_t</span>* handle)</span> </span>&#123;</span><br><span class="line">    counter++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (counter &gt;= <span class="number">10e6</span>)</span><br><span class="line">        uv_idle_stop(handle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uv_idle_t</span> idler;</span><br><span class="line"></span><br><span class="line">    uv_idle_init(uv_default_loop(), &amp;idler);</span><br><span class="line">    uv_idle_start(&amp;idler, wait_for_a_while);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Idling...\n"</span>);</span><br><span class="line">    uv_run(uv_default_loop(), UV_RUN_DEFAULT);</span><br><span class="line"></span><br><span class="line">    uv_loop_close(uv_default_loop());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Streams 与 Buffers</p><p>最基本的handle是stream(uv_stream_t),TCP socket、文件I/O的管道、IPC都是stream的子类。<br>初始化之后，stream的基本操作如下：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_read_start</span><span class="params">(<span class="keyword">uv_stream_t</span>*, uv_alloc_cb alloc_cb, uv_read_cb read_cb)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_read_stop</span><span class="params">(<span class="keyword">uv_stream_t</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_write</span><span class="params">(<span class="keyword">uv_write_t</span>* req, <span class="keyword">uv_stream_t</span>* handle,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> <span class="keyword">uv_buf_t</span> bufs[], <span class="keyword">unsigned</span> <span class="keyword">int</span> nbufs, uv_write_cb cb)</span></span>;</span><br></pre></td></tr></table></figure><p>当uv_read_start()调用后，libuv自动从stream中持续读取数据，直到uv_read_stop()调用。<br>每个单位的数据是buffer- uv_buf_t。两个基本属性：uv_buf_t.base，指向数据的指针；uv_buf_t.len，数据的长度。</p></li></ul><h1 id="Filesystem"><a href="#Filesystem" class="headerlink" title="Filesystem"></a>Filesystem</h1><p>在概览图中，文件I/O是建立再线程池基础之上的。Socket操作使用操作系统提供的非阻塞函数，而File操作内部使用是阻塞函数，通过线程池来触发该函数。  </p><ul><li><p>主要函数  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_fs_open</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop, <span class="keyword">uv_fs_t</span>* req, <span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">int</span> flags, <span class="keyword">int</span> mode, uv_fs_cb cb)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_fs_close</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop, <span class="keyword">uv_fs_t</span>* req, uv_file file, uv_fs_cb cb)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(<span class="keyword">uv_fs_t</span>* req)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_fs_read</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop, <span class="keyword">uv_fs_t</span>* req, uv_file file, <span class="keyword">const</span> <span class="keyword">uv_buf_t</span> bufs[], <span class="keyword">unsigned</span> <span class="keyword">int</span> nbufs, <span class="keyword">int64_t</span> offset,   uv_fs_cb cb)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_fs_write</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop, <span class="keyword">uv_fs_t</span>* req, uv_file file, <span class="keyword">const</span> <span class="keyword">uv_buf_t</span> bufs[], <span class="keyword">unsigned</span> <span class="keyword">int</span> nbufs, <span class="keyword">int64_t</span> offset,   uv_fs_cb cb)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>直接读取方式：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">on_open</span><span class="params">(<span class="keyword">uv_fs_t</span> *req)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The request passed to the callback is the same as the one the call setup</span></span><br><span class="line">    <span class="comment">// function was passed.</span></span><br><span class="line">    assert(req == &amp;open_req);</span><br><span class="line">    <span class="keyword">if</span> (req-&gt;result &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        iov = uv_buf_init(buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">        uv_fs_read(uv_default_loop(), &amp;read_req, req-&gt;result,</span><br><span class="line">                   &amp;iov, <span class="number">1</span>, <span class="number">-1</span>, on_read);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"error opening file: %s\n"</span>, uv_strerror((<span class="keyword">int</span>)req-&gt;result));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">on_read</span><span class="params">(<span class="keyword">uv_fs_t</span> *req)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (req-&gt;result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Read error: %s\n"</span>, uv_strerror(req-&gt;result));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (req-&gt;result == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">uv_fs_t</span> close_req;</span><br><span class="line">        <span class="comment">// synchronous</span></span><br><span class="line">        uv_fs_close(uv_default_loop(), &amp;close_req, open_req.result, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (req-&gt;result &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        iov.len = req-&gt;result;</span><br><span class="line">        uv_fs_write(uv_default_loop(), &amp;write_req, <span class="number">1</span>, &amp;iov, <span class="number">1</span>, <span class="number">-1</span>, on_write);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">on_write</span><span class="params">(<span class="keyword">uv_fs_t</span> *req)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (req-&gt;result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Write error: %s\n"</span>, uv_strerror((<span class="keyword">int</span>)req-&gt;result));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        uv_fs_read(uv_default_loop(), &amp;read_req, open_req.result, &amp;iov, <span class="number">1</span>, <span class="number">-1</span>, on_read);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    uv_fs_open(uv_default_loop(), &amp;open_req, argv[<span class="number">1</span>], O_RDONLY, <span class="number">0</span>, on_open);</span><br><span class="line">    uv_run(uv_default_loop(), UV_RUN_DEFAULT);</span><br><span class="line"></span><br><span class="line">    uv_fs_req_cleanup(&amp;open_req);</span><br><span class="line">    uv_fs_req_cleanup(&amp;read_req);</span><br><span class="line">    uv_fs_req_cleanup(&amp;write_req);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个边读边写的示例，再onCreate中，开始读一定的量，然后写到write_req中，再write_req的回调中，再触发读。<br>libuv对操作系统的api进行了完整的封装，详细内容查看libuv的api</p></li><li><p>stream方式</p><p>除了直接读取，还可以通过stream的方式来使用，通过将文件fd与pipe绑定来创建一个file pipe如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    loop = uv_default_loop();</span><br><span class="line"></span><br><span class="line">    uv_pipe_init(loop, &amp;stdin_pipe, <span class="number">0</span>);</span><br><span class="line">    uv_pipe_open(&amp;stdin_pipe, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    uv_pipe_init(loop, &amp;stdout_pipe, <span class="number">0</span>);</span><br><span class="line">    uv_pipe_open(&amp;stdout_pipe, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uv_fs_t</span> file_req;</span><br><span class="line">    <span class="keyword">int</span> fd = uv_fs_open(loop, &amp;file_req, argv[<span class="number">1</span>], O_CREAT | O_RDWR, <span class="number">0644</span>, <span class="literal">NULL</span>);</span><br><span class="line">    uv_pipe_init(loop, &amp;file_pipe, <span class="number">0</span>);</span><br><span class="line">    uv_pipe_open(&amp;file_pipe, fd);</span><br><span class="line"></span><br><span class="line">    uv_read_start((<span class="keyword">uv_stream_t</span>*)&amp;stdin_pipe, alloc_buffer, read_stdin);</span><br><span class="line"></span><br><span class="line">    uv_run(loop, UV_RUN_DEFAULT);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">alloc_buffer</span><span class="params">(<span class="keyword">uv_handle_t</span> *handle, <span class="keyword">size_t</span> suggested_size, <span class="keyword">uv_buf_t</span> *buf)</span> </span>&#123;</span><br><span class="line">    *buf = uv_buf_init((<span class="keyword">char</span>*) <span class="built_in">malloc</span>(suggested_size), suggested_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_stdin</span><span class="params">(<span class="keyword">uv_stream_t</span> *stream, <span class="keyword">ssize_t</span> nread, <span class="keyword">const</span> <span class="keyword">uv_buf_t</span> *buf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nread &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (nread == UV_EOF)&#123;</span><br><span class="line">            <span class="comment">// end of file</span></span><br><span class="line">            uv_close((<span class="keyword">uv_handle_t</span> *)&amp;stdin_pipe, <span class="literal">NULL</span>);</span><br><span class="line">            uv_close((<span class="keyword">uv_handle_t</span> *)&amp;stdout_pipe, <span class="literal">NULL</span>);</span><br><span class="line">            uv_close((<span class="keyword">uv_handle_t</span> *)&amp;file_pipe, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        write_data((<span class="keyword">uv_stream_t</span> *)&amp;stdout_pipe, nread, *buf, on_stdout_write);</span><br><span class="line">        write_data((<span class="keyword">uv_stream_t</span> *)&amp;file_pipe, nread, *buf, on_file_write);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// OK to free buffer as write_data copies it.</span></span><br><span class="line">    <span class="keyword">if</span> (buf-&gt;base)</span><br><span class="line">        <span class="built_in">free</span>(buf-&gt;base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="Networking"><a href="#Networking" class="headerlink" title="Networking"></a>Networking</h1><h2 id="tcp"><a href="#tcp" class="headerlink" title="tcp"></a>tcp</h2><p>这个过程与直接使用操作系统的过程类似</p><ul><li><p>server</p><p>服务器通过:init、bind、listen、accept来使用  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    loop = uv_default_loop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uv_tcp_t</span> server;</span><br><span class="line">    uv_tcp_init(loop, &amp;server);</span><br><span class="line"></span><br><span class="line">    uv_ip4_addr(<span class="string">"0.0.0.0"</span>, DEFAULT_PORT, &amp;addr);</span><br><span class="line"></span><br><span class="line">    uv_tcp_bind(&amp;server, (<span class="keyword">const</span> struct sockaddr*)&amp;addr, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> r = uv_listen((<span class="keyword">uv_stream_t</span>*) &amp;server, DEFAULT_BACKLOG, on_new_connection);</span><br><span class="line">    <span class="keyword">if</span> (r) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Listen error %s\n"</span>, uv_strerror(r));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uv_run(loop, UV_RUN_DEFAULT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">on_new_connection</span><span class="params">(<span class="keyword">uv_stream_t</span> *server, <span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"New connection error %s\n"</span>, uv_strerror(status));</span><br><span class="line">        <span class="comment">// error!</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uv_tcp_t</span> *client = (<span class="keyword">uv_tcp_t</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">uv_tcp_t</span>));</span><br><span class="line">    uv_tcp_init(loop, client);</span><br><span class="line">    <span class="keyword">if</span> (uv_accept(server, (<span class="keyword">uv_stream_t</span>*) client) == <span class="number">0</span>) &#123;</span><br><span class="line">        uv_read_start((<span class="keyword">uv_stream_t</span>*) client, alloc_buffer, echo_read);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>  注意这里read数据时，是使用stream来使用  </p><ul><li><p>client  </p><p>client端通过connect来使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uv_tcp_t</span>* socket = (<span class="keyword">uv_tcp_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">uv_tcp_t</span>));</span><br><span class="line">uv_tcp_init(loop, socket);</span><br><span class="line"></span><br><span class="line"><span class="keyword">uv_connect_t</span>* connect = (<span class="keyword">uv_connect_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">uv_connect_t</span>));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">dest</span>;</span></span><br><span class="line">uv_ip4_addr(<span class="string">"127.0.0.1"</span>, <span class="number">80</span>, &amp;dest);</span><br><span class="line"></span><br><span class="line">uv_tcp_connect(connect, socket, (<span class="keyword">const</span> struct sockaddr*)&amp;dest, on_connect);</span><br></pre></td></tr></table></figure></li></ul><h2 id="udp"><a href="#udp" class="headerlink" title="udp"></a>udp</h2><p>libuv并不为udp提供stream，使用非阻塞的uv_udp_t handle与 uv_udp_send_t request来使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uv_loop_t</span> *loop;</span><br><span class="line"><span class="keyword">uv_udp_t</span> send_socket;</span><br><span class="line"><span class="keyword">uv_udp_t</span> recv_socket;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    loop = uv_default_loop();</span><br><span class="line"></span><br><span class="line">    uv_udp_init(loop, &amp;recv_socket);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">recv_addr</span>;</span></span><br><span class="line">    uv_ip4_addr(<span class="string">"0.0.0.0"</span>, <span class="number">68</span>, &amp;recv_addr);</span><br><span class="line">    uv_udp_bind(&amp;recv_socket, (<span class="keyword">const</span> struct sockaddr *)&amp;recv_addr, UV_UDP_REUSEADDR);</span><br><span class="line">    uv_udp_recv_start(&amp;recv_socket, alloc_buffer, on_read);</span><br><span class="line"></span><br><span class="line">    uv_udp_init(loop, &amp;send_socket);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">broadcast_addr</span>;</span></span><br><span class="line">    uv_ip4_addr(<span class="string">"0.0.0.0"</span>, <span class="number">0</span>, &amp;broadcast_addr);</span><br><span class="line">    uv_udp_bind(&amp;send_socket, (<span class="keyword">const</span> struct sockaddr *)&amp;broadcast_addr, <span class="number">0</span>);</span><br><span class="line">    uv_udp_set_broadcast(&amp;send_socket, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uv_udp_send_t</span> send_req;</span><br><span class="line">    <span class="keyword">uv_buf_t</span> discover_msg = make_discover_msg();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">send_addr</span>;</span></span><br><span class="line">    uv_ip4_addr(<span class="string">"255.255.255.255"</span>, <span class="number">67</span>, &amp;send_addr);</span><br><span class="line">    uv_udp_send(&amp;send_req, &amp;send_socket, &amp;discover_msg, <span class="number">1</span>, (<span class="keyword">const</span> struct sockaddr *)&amp;send_addr, on_send);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> uv_run(loop, UV_RUN_DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">on_read</span><span class="params">(<span class="keyword">uv_udp_t</span> *req, <span class="keyword">ssize_t</span> nread, <span class="keyword">const</span> <span class="keyword">uv_buf_t</span> *buf, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">unsigned</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nread &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Read error %s\n"</span>, uv_err_name(nread));</span><br><span class="line">        uv_close((<span class="keyword">uv_handle_t</span>*) req, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">free</span>(buf-&gt;base);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> sender[<span class="number">17</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    uv_ip4_name((<span class="keyword">const</span> struct sockaddr_in*) addr, sender, <span class="number">16</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Recv from %s\n"</span>, sender);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... DHCP specific code</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> *as_integer = (<span class="keyword">unsigned</span> <span class="keyword">int</span>*)buf-&gt;base;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ipbin = ntohl(as_integer[<span class="number">4</span>]);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> ip[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        ip[i] = (ipbin &gt;&gt; i*<span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Offered IP %d.%d.%d.%d\n"</span>, ip[<span class="number">3</span>], ip[<span class="number">2</span>], ip[<span class="number">1</span>], ip[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(buf-&gt;base);</span><br><span class="line">    uv_udp_recv_stop(req);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>libuv中还对线程、进程、进程通信等进行了封装，我觉得这些不是libuv的核心，这里不做详细的介绍了。</p><ul><li><p>线程  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tracklen = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">uv_thread_t</span> hare_id;</span><br><span class="line">    <span class="keyword">uv_thread_t</span> tortoise_id;</span><br><span class="line">    uv_thread_create(&amp;hare_id, hare, &amp;tracklen);</span><br><span class="line">    uv_thread_create(&amp;tortoise_id, tortoise, &amp;tracklen);</span><br><span class="line"></span><br><span class="line">    uv_thread_join(&amp;hare_id);</span><br><span class="line">    uv_thread_join(&amp;tortoise_id);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进程  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uv_loop_t</span> *loop;</span><br><span class="line"><span class="keyword">uv_process_t</span> child_req;</span><br><span class="line"><span class="keyword">uv_process_options_t</span> options;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    loop = uv_default_loop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* args[<span class="number">3</span>];</span><br><span class="line">    args[<span class="number">0</span>] = <span class="string">"mkdir"</span>;</span><br><span class="line">    args[<span class="number">1</span>] = <span class="string">"test-dir"</span>;</span><br><span class="line">    args[<span class="number">2</span>] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    options.exit_cb = on_exit;</span><br><span class="line">    options.file = <span class="string">"mkdir"</span>;</span><br><span class="line">    options.args = args;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> ((r = uv_spawn(loop, &amp;child_req, &amp;options))) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, uv_strerror(r));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Launched process with ID %d\n"</span>, child_req.pid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> uv_run(loop, UV_RUN_DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><ul><li>event loop</li><li>handle 与 request</li><li>stream</li><li>file</li><li>tcp &amp;&amp; udp</li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li><p>为什么文件读取用的是线程池？</p></li><li><p>为什么tcp是一个stream，而udp不是一个stream？</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;调整一下学习的顺序，从先看libuv，再看node.js。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;v8引擎  &lt;/li&gt;
&lt;li&gt;libuv     &amp;lt;=  &lt;/li&gt;
&lt;li&gt;node.js  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主要参考：&lt;a href=&quot;http://docs.libuv.org/en/v1.x&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="libuv" scheme="http://yoursite.com/tags/libuv/"/>
    
  </entry>
  
  <entry>
    <title>v8引擎学习记录</title>
    <link href="http://yoursite.com/2019/10/21/v8%E5%BC%95%E6%93%8E%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/10/21/v8引擎记录/</id>
    <published>2019-10-21T13:41:28.000Z</published>
    <updated>2019-11-25T06:25:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用node.js也有一段时间了，一直没有深入的研究一下node，这次就对node.js相关的技术，进行从上层到底层的学习，内容包括：</p><ul><li>v8引擎     &lt;=</li><li>libuv  </li><li>node.js  </li></ul><p>libuv的避免不了unix环境编程的api，这一块与node.js有点距离，不放在这个系列中了。  </p><a id="more"></a><p>本文主要引用：<br><a href="https://zhuanlan.zhihu.com/p/27628685" target="_blank" rel="noopener">认识v8引擎</a><br><a href="https://v8.dev/docs" target="_blank" rel="noopener">v8 doc文档</a>  </p><h1 id="V8简介"><a href="#V8简介" class="headerlink" title="V8简介"></a>V8简介</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>v8的背景是webkit内核的浏览器，webkit的架构如下：<br><img src="webkit内核.png" alt="webkit内核.png">  </p><p>这里：  </p><ul><li>WebCore 是各个浏览器使用的共享部分，包括HTML解析器、CSS解析器、DOM和SVG等</li><li>JSCore是WebKit的默认引擎，在谷歌系列产品中被替换为V8引擎。Javascript的引擎，或者类比Java的虚拟机  </li><li>WebKit Eembedding API是平台差异的,不同的浏览器实现不同</li></ul><p>这样就很容易看出V8的定位，解析执行JavaScript语言，JavaScript是一种解释性语言，与C、c++编译型语言不同，以及Java的半编译半解释性语言不同，它需要一遍执行一遍解析。</p><p>编译型语言的一般过程： 源代码 –&gt; 抽象语法树 –&gt;  中间表示 –&gt; 机器码<br>V8的过程: 源代码 –&gt; 抽象语法树 –&gt; 字节码 –&gt; JIT –&gt; 机器码</p><p>源代码：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象语法树：<br><img src="js抽象语法树.png" alt="js抽象语法树.png">  </p><p>字节码:<br><img src="字节码.png" alt="字节码"></p><p>v8 在5.9版本之前，不生成字节码，直接由抽象语法树经JIT运行，在5.9版本增加了Ignition字节码编译器。这一部分内容参考<a href="https://zhuanlan.zhihu.com/p/28590489" target="_blank" rel="noopener">v8字节码</a>  </p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>JavaScript代码编译的过程大致为：  </p><ul><li>Script类调用Compiler类的Compile函数为其生成本地代码。 </li><li>Compile函数先使用Parser类生成AST(抽象语法树)    </li><li>FullCodeGenerator类来生成本地代码。本地代码与具体的硬件平台密切相关，FullCodeGenerator使用多个后端来生成与平台相匹配的本地汇编代码。  </li><li>AstVisitor用于遍历AST（访问者模式） </li></ul><p><img src="js代码编译过程.jpg" alt="js代码编译过程.jpg">  </p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><ul><li>Script表示JavaScript代码，即包含源代码，又包含编译之后生成的本地代码，即是编译入口，又是运行入口；</li><li>Execution：运行代码的辅组类，包含一些重要函数，如Call函数，它辅组进入和执行Script代码；</li><li>JSFunction：需要执行的JavaScript函数表示类；</li><li>Runtime：运行这些本地代码的辅组类，主要提供运行时所需的辅组函数，如：属性访问、类型转换、编译、算术、位操作、比较、正则表达式等；</li><li>Heap：运行本地代码需要使用的内存堆类；</li><li>MarkCompactCollector：垃圾回收机制的主要实现类，用来标记、清除和整理等基本的垃圾回收过程；</li><li>SweeperThread：负责垃圾回收的线程。</li></ul><p><img src="js代码执行过程.jpg" alt="js代码执行过程.jpg">  </p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p><a href="https://zhuanlan.zhihu.com/p/33816534" target="_blank" rel="noopener">v8内存</a>  </p><ul><li>构成  </li></ul><p>一个 V8 进程的内存通常由以下几个块构成：</p><ol><li>新生代内存区（new space）<br>大多数的对象都会被分配在这里，这个区域很小但是垃圾回收比较频繁；</li><li>老生代内存区（old space）<br>属于老生代，这里只保存原始数据对象，这些对象没有指向其他对象的指针；</li><li>大对象区（large object space）<br>这里存放体积超越其他区大小的对象，每个对象有自己的内存，垃圾回收其不会移动大对象区；</li><li>代码区（code space）<br>代码对象，会被分配在这里。唯一拥有执行权限的内存；</li><li>map 区（map space）<br>存放 Cell 和 Map，每个区域都是存放相同大小的元素，结构简单。</li></ol><ul><li>生命周期</li></ul><p>假设代码中有一个对象 jerry ，这个对象从创建到被销毁，刚好走完了整个生命周期，通常会是这样一个过程：</p><ol><li>这个对象被分配到了 new space；</li><li>随着程序的运行，new space 塞满了，gc 开始清理 new space 里的死对象，jerry 因为还处于活跃状态，所以没被清理出去；</li><li>gc 清理了两遍 new space，发现 jerry 依然还活跃着，就把 jerry 移动到了 old space；</li><li>随着程序的运行，old space 也塞满了，gc 开始清理 old space，这时候发现 jerry 已经没有被引用了，就把 jerry 给清理出去了。</li></ol><h1 id="嵌入v8"><a href="#嵌入v8" class="headerlink" title="嵌入v8"></a>嵌入v8</h1><p>为什么介绍嵌入v8呢，因为node.js就是嵌入v8的。  </p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>isolate： 有自己堆的VM实例  </li><li>handle: 指向一个对象的指针，所有的V8对象都可以通过handle来访问</li><li>handle scope: 存放handle的容器，当删除handle scoppe，会自动删除其中的handle,从而也会触发删除v8对象  </li><li>context: 可以独立运行JavaScript脚本的可执行环境，要想运行一个JavaScript脚本，必须明确指明其context</li></ul><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><ul><li><p>Handles </p><p>handle是一个指针，指向在heap中JavaScript对象的地址。当这些对象没有被handle指向时，垃圾收集器GC就会回收这些存储。前边提到过，对象在heap中的位置会被GC移动，移动后，GC会更新所有指向这个对象的handle。  </p><p>最常见的有2种handle：local handle与Persistent handle<br>local handle存储在一个stack上，这个stack可以认为是前边的handle scope。用Local<sometype>来定义<br>Persistent handle也是指向一个在heap上分配的JavaScript对象，但它不在stack上。用UniquePersistent<sometype>与 Persistent<sometype>来定义。</sometype></sometype></sometype></p><p><img src="handle图解.png" alt="handle图解.png"> </p></li></ul><ul><li><p>context  </p><p>context是一个独立的可执行环境，它其中就包括了JavaScript内置的函数与对象。既然每个context都包含这些内置的函数与对象，加载的过程就比较耗时，v8做了一些优化，第一次创建context时候，会解析创建内置对象的JS代码，并创建对象，以后再创建context就只创建对象，而不再解析JS代码了。并且为第一创建也提供了快照功能，也会加快解析。  </p><p>你也可以多次进入、退出一个context，也可进入多个context，但只有一个当前的context。<br><img src="context图解.png" alt="context图解.png">  </p></li><li><p>template  </p><p>模板可以将C++的函数或者数据结构封装进一个JavaScript对象，这样可以再JavaScript中去操作这些对象。 在一个context下，一个template只能有一个实例。  </p><p>JavaScript有强烈的函数、对象二元性。这也反应在template上。有2种类型的template：</p><ul><li><p>Function template<br>通过调用template的GetFunction方法，在context中创建一个template的实例。可以将一个C++的回调函数与function template连接，这样当Js实例调用时，触发相应的C++函数。</p></li><li><p>Object template<br>每一个function template都与一个object template相连。用作配置被function示例化的对象（这里function当做类使用）。可以讲2种c++回调与object template关联。<br>accessor: 当一个Js对象的指定属性被访问使，触发<br>interceptor: 当一个Js对象的任意属性被访问时，触发</p></li></ul></li><li><p>Security model  </p><p>同源策略禁止一个origin的script访问另外一个origin的script的属性（数据）。origin在此指的是域名(<a href="http://www.example.com)、协议(https)、端口的结合。这3个相同，才可以认为是同源。" target="_blank" rel="noopener">www.example.com)、协议(https)、端口的结合。这3个相同，才可以认为是同源。</a><br>在V8中，“origin”被定义为context。默认禁止从任何一个context中访问另外一个context。既然默认禁止，那就有不默认的方式来访问。如果要从一个context访问另外一个context，就需要使用security token。可以在创建context时通过setSecurityToken手动创建，或者v8自动生成一个。当然时，v8的安全系统会检查调用者的token与被调用者的token，如果匹配，就允许访问，反之，就进一个回调来判断是否允许。</p></li><li><p>Exception  </p><p>当一个脚本执行不成功，V8返回空句柄。所以在继续执行之前，必须检查返回值是否是空句柄。<br>想要捕获异常，使用TryCatch，例如：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TryCatch <span class="title">trycatch</span><span class="params">(isolate)</span></span>;</span><br><span class="line">Local&lt;Value&gt; v = script-&gt;Run();</span><br><span class="line"><span class="keyword">if</span> (v.IsEmpty()) &#123;</span><br><span class="line">  Local&lt;Value&gt; exception = trycatch.Exception();</span><br><span class="line">  String::<span class="function">Utf8Value <span class="title">exception_str</span><span class="params">(exception)</span></span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Exception: %s\n"</span>, *exception_str);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式有点像unix，通过返回值标识是否错误，通过主动get错误信息来打印。</p></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>  官方给出3个示例，这里给出process这里示例的地址:<br>  <a href="https://github.com/v8/v8/blob/master/samples/process.cc" target="_blank" rel="noopener">process.cc</a><br>  <a href="https://github.com/v8/v8/blob/master/samples/count-hosts.js" target="_blank" rel="noopener">js脚本</a>  </p><p>  这个示例实现的是，统计访问host的个数，progess函数通过js来实现，保存在全局对象中，通过以下代码讲Js的函数引用到C++ process_对象中</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Local&lt;String&gt; process_name =</span><br><span class="line">  String::NewFromUtf8(GetIsolate(), <span class="string">"Process"</span>, NewStringType::kNormal)</span><br><span class="line">      .ToLocalChecked();</span><br><span class="line">Local&lt;Value&gt; process_val;</span><br><span class="line"><span class="comment">// If there is no Process function, or if it is not a function,</span></span><br><span class="line"><span class="comment">// bail out</span></span><br><span class="line"><span class="keyword">if</span> (!context-&gt;Global()-&gt;Get(context, process_name).ToLocal(&amp;process_val) ||</span><br><span class="line">    !process_val-&gt;IsFunction()) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// It is a function; cast it to a Function</span></span><br><span class="line">Local&lt;Function&gt; process_fun = Local&lt;Function&gt;::Cast(process_val);</span><br><span class="line">  </span><br><span class="line"><span class="comment">// Store the function in a Global handle, since we also want</span></span><br><span class="line"><span class="comment">// that to remain after this call returns</span></span><br><span class="line">process_.Reset(GetIsolate(), process_fun);</span><br></pre></td></tr></table></figure><p>  然后，写了一个Process函数，来调用，这个Process函数有些像代理一样  </p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> argc = <span class="number">1</span>;</span><br><span class="line">Local&lt;Value&gt; argv[argc] = &#123;request_obj&#125;;</span><br><span class="line">v8::Local&lt;v8::Function&gt; process =</span><br><span class="line">    v8::Local&lt;v8::Function&gt;::New(GetIsolate(), process_);</span><br><span class="line">Local&lt;Value&gt; result;</span><br><span class="line"><span class="keyword">if</span> (!process-&gt;Call(context, context-&gt;Global(), argc, argv).ToLocal(&amp;result)) &#123;</span><br><span class="line">  String::Utf8Value error(GetIsolate(), try_catch.Exception());</span><br><span class="line">  Log(*error);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  以上可以认为是C++调用JavaScript的函数，另外还有JavaScript使用C++的数据对象。<br>  既然是计数，最好的方式就是map，这里C++的实现就是用的Map来实现。然后将Map封装到全局的template下，就可以在脚本中直接使用该对象了。(原代码封装了2个对象,opts与output) </p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">bool</span> JsHttpRequestProcessor::InstallMaps(<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;* opts,</span><br><span class="line">                                         <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;* output) &#123;</span><br><span class="line">  HandleScope handle_scope(GetIsolate());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Wrap the map object in a JavaScript wrapper</span></span><br><span class="line">  Local&lt;Object&gt; opts_obj = WrapMap(opts);</span><br><span class="line"></span><br><span class="line">  v8::Local&lt;v8::Context&gt; context =</span><br><span class="line">      v8::Local&lt;v8::Context&gt;::New(GetIsolate(), context_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set the options object as a property on the global object.</span></span><br><span class="line">  context-&gt;Global()</span><br><span class="line">      -&gt;Set(context,</span><br><span class="line">            String::NewFromUtf8(GetIsolate(), <span class="string">"options"</span>, NewStringType::kNormal)</span><br><span class="line">                .ToLocalChecked(),</span><br><span class="line">            opts_obj)</span><br><span class="line">      .FromJust();</span><br><span class="line"></span><br><span class="line">  Local&lt;Object&gt; output_obj = WrapMap(output);</span><br><span class="line">  context-&gt;Global()</span><br><span class="line">      -&gt;Set(context,</span><br><span class="line">            String::NewFromUtf8(GetIsolate(), <span class="string">"output"</span>, NewStringType::kNormal)</span><br><span class="line">                .ToLocalChecked(),</span><br><span class="line">            output_obj)</span><br><span class="line">      .FromJust();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Js中使用output<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Process</span>(<span class="params">request</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (options.verbose) &#123;</span><br><span class="line">    log(<span class="string">"Processing "</span> + request.host + request.path +</span><br><span class="line">        <span class="string">" from "</span> + request.referrer + <span class="string">"@"</span> + request.userAgent);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!output[request.host]) &#123;</span><br><span class="line">    output[request.host] = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    output[request.host]++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用node.js也有一段时间了，一直没有深入的研究一下node，这次就对node.js相关的技术，进行从上层到底层的学习，内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;v8引擎     &amp;lt;=&lt;/li&gt;
&lt;li&gt;libuv  &lt;/li&gt;
&lt;li&gt;node.js  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;libuv的避免不了unix环境编程的api，这一块与node.js有点距离，不放在这个系列中了。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="v8" scheme="http://yoursite.com/tags/v8/"/>
    
  </entry>
  
  <entry>
    <title>微积分-其他</title>
    <link href="http://yoursite.com/2019/10/13/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%85%B6%E4%BB%96/"/>
    <id>http://yoursite.com/2019/10/13/微积分-其他/</id>
    <published>2019-10-13T13:40:25.000Z</published>
    <updated>2019-11-07T09:35:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是微积分复习的最后一篇，教材使用《普林斯顿微积分读本》，涵盖第27章-第30章的内容。  </p><ul><li>函数与微分  </li><li>积分  </li><li>级数  </li><li>其他      &lt;=</li></ul><p>本文的内容覆盖4章，包括：参数方程和极坐标、复数、体积弧长和表面积、微分方程。在函数中引入中间变量，过度到了参数方程，极坐标可以看作特殊的参数方程; 复数即可以用笛卡尔坐标系来表示，也可以用极坐标系来表示（欧拉公式），这两章的内容较近。体积、弧长与表面积一章是用微积分代入空间几何，可以看作一种应用，在3D中有很好的应用场景; 微分方程应用场景更宽广一些，这里介绍了3种微分方程的解法。  </p><a id="more"></a><h1 id="参数方程和极坐标"><a href="#参数方程和极坐标" class="headerlink" title="参数方程和极坐标"></a>参数方程和极坐标</h1><h2 id="参数方程"><a href="#参数方程" class="headerlink" title="参数方程"></a>参数方程</h2><ul><li><p>示例<br>x和y都是另外一个变量t的函数，例如：<br>x = 3cos(t) 和 y = 3sin(t)<br>图像为: <img src="参数方程示例.png" alt="参数方程示例.png">  </p></li><li><p>参数方程的导数<br><img src="参数方程的导数.png" alt="参数方程的导数.png">  </p></li></ul><h2 id="极坐标"><a href="#极坐标" class="headerlink" title="极坐标"></a>极坐标</h2><ul><li><p>极坐标与笛卡尔坐标互换<br>极坐标到笛卡尔坐标：x = rcos(θ) 和 y = rsin(θ)<br><img src="坐标变化1.png" alt="坐标变化1.png">  </p><p>笛卡尔坐标到极坐标：r<sup>2</sup> = x<sup>2</sup> + y<sup>2</sup> 和 tan(θ) = y/x, x不等于0， 需要检查象限<br><img src="极坐标的示例.png" alt="极坐标的示例.png">  </p></li><li><p>极坐标中的曲线<br>极坐标中的函数 r=f(θ), θ在给定的范围内取值。一般先画出r=f(θ)在笛卡尔坐标系下的图像，然后再画在极坐标中的图像<br>如 r=3sin(θ)</p><p><img src="极坐标画图.png" alt="极坐标画图.png"><br><img src="极坐标画图2.png" alt="极坐标画图2.png">  </p><p><img src="一些漂亮的极坐标曲线.png" alt="一些漂亮的极坐标曲线.png">  </p></li><li><p>极坐标曲线的切线<br>我们有r = f(θ)， 并且有 x = rcos(θ)一级 y = rsin(θ)<br>于是 x = f(θ)cos(θ) 和 y = f(θ)sin(θ)  </p><p>这样依据参数方式的切线方法 dy/dx = dy/dθ  /  dx/dθ</p><p>示例： r = 1+2cos(θ)，求穿过极坐标为（2, π/3）点的切线方程。</p><p>x = rcos(θ) = (1+2cos(θ))cos(θ)<br>y = rsin(θ) = (1+2cos(θ))sin(θ)<br>求导:<br>dy/dθ = -2sin<sup>2</sup>(θ) + (1+2cos(θ))cos(θ)<br>dx/dθ = -sin(θ)(1+4cos(θ))</p></li></ul><p>所以 dy/dx = dy/dθ / dx/dθ  将 θ = π/3代入得：<img src="极坐标切线.png" alt="极坐标切线.png">  代入点x = 2cos(π/3)=1 和 y = 2 sin(π/3) = √3</p><ul><li><p>极坐标曲线的围成的面积<br><img src="极坐标的面积.png" alt="极坐标的面积.png"><br><img src="极坐标的面积2.png" alt="极坐标的面积2.png">  </p><p>这里有个很有趣的例子：r = 1+2cos(θ)围成的图形的面积。<br><img src="极坐标面积示例.png" alt="极坐标面积示例.png"><br>直接从[0,2π]进行积分求处的面积是<img src="极坐标面积示例2.png" alt="极坐标面积示例2.png">图形的，问题在于θ 位于 2π/3 和 4π/3 之间时 , r 为负。由于面积公式包含r<sup>2</sup>无法辨别正负面积。（这与笛卡儿坐标下的情况大不相同,在笛卡儿坐标系中,y轴以下都为负）。<br>正解是通过通过完全的面积减去2倍小圈中的面积.<br>小圈中的面积为：<img src="极坐标面积示例3.png" alt="极坐标面积示例3.png"></p></li></ul><h1 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>复数的加、减、乘、除法则比较简单，不进行介绍了，主要介绍复数的指数化e<sup>z</sup><br>复指数也满足指数的法则 e<sup>z</sup>e<sup>w</sup> = e<sup>z+w</sup><br>证明的过程可以借鉴指数的泰勒级数：<br><img src="复指数函数-1.png" alt="复指数函数-1.png"><br><img src="复指数函数-2.png" alt="复指数函数-2.png"></p><h2 id="欧拉公式"><a href="#欧拉公式" class="headerlink" title="欧拉公式"></a>欧拉公式</h2><p><img src="欧拉公式.png" alt="欧拉公式.png"><br>欧拉公式的证明可以通过泰勒级数展开的方式进行证明。<br>不管怎么看，它都太简单，太美丽了，完美的定义了复数的极坐标形式<br><img src="复平面.png" alt="复平面.png"><br><img src="复平面示例1.png" alt="复平面示例1.png">  </p><p><img src="欧拉公式证明1.png" alt="欧拉公式证明1.png"><br><img src="欧拉公式证明2.png" alt="欧拉公式证明2.png">  </p><h2 id="复数的高次幂"><a href="#复数的高次幂" class="headerlink" title="复数的高次幂"></a>复数的高次幂</h2><p>为什么要使用极坐标形式呢？一个原因是，极坐标形式比较容易进行乘法跟取幂运算。<br>如：<br><img src="复数的高次幂.png" alt="复数的高次幂.png">  </p><h2 id="解Zn-w"><a href="#解Zn-w" class="headerlink" title="解Zn = w"></a>解Z<sup>n</sup> = w</h2><p><img src="解复数的幂-1.png" alt="解复数的幂-1.png"><br><img src="解复数的幂-2.png" alt="解复数的幂-2.png"><br><img src="解复数的幂-3.png" alt="解复数的幂-3.png"></p><p>这里的 5θ = 5π/6 + 2πk</p><p>因为极坐标方式很容易求指数方式，所以，复数的次幂，都是转换成极坐标方式进行求解。</p><h2 id="解-ez-w"><a href="#解-ez-w" class="headerlink" title="解 ez = w"></a>解 e<sup>z</sup> = w</h2><p><img src="e的复数次幂-1.png" alt="e的复数次幂-1.png"><br>z = x + iy<br><img src="e的复数次幂-2.png" alt="e的复数次幂-2.png">  </p><p>与复数的次幂类似，也转换成极坐标的方式来进行求解。  </p><h1 id="体积、弧长和表面积"><a href="#体积、弧长和表面积" class="headerlink" title="体积、弧长和表面积"></a>体积、弧长和表面积</h1><p>本章是微积分在空间几何中的应用，主要是求体积与求表面积2大目标，弧长的求解是表面积求解的引子</p><h2 id="旋转体的体积"><a href="#旋转体的体积" class="headerlink" title="旋转体的体积"></a>旋转体的体积</h2><p><img src="圆盘法-1.png" alt="圆盘法-1.png">  </p><ul><li><p>圆盘法<br>圆盘法是黎曼和积分的扩展。<br>求此图形绕x轴旋转得到图形的体积  </p><p><img src="圆盘法-2.png" alt="圆盘法-2.png"><br><img src="圆盘法-3.png" alt="圆盘法-3.png"><br>将体积看作面积的积分。  </p></li><li><p>壳法<br>求此图形绕y轴旋转得到图形的体积</p><p><img src="壳法-1.png" alt="壳法-1.png"><br>壳法比圆盘法理解更新奇一点,这里想想此图形y轴方向截开，形成长方体的体积。<br><img src="壳法-2.png" alt="壳法-2.png"><br><img src="壳法-3.png" alt="壳法-3.png">  </p></li><li><p>总结  </p><ul><li>若每个小条的dx边平行于旋转轴，运用圆盘法  </li><li>若咩个小条的dx边垂直于旋转轴，运用壳法</li></ul></li></ul><h2 id="一般立方体体积"><a href="#一般立方体体积" class="headerlink" title="一般立方体体积"></a>一般立方体体积</h2><p>一般立方体的体积求法也是考虑体积是面积的积分。需要注意是面积的选择与积分区间的选择。<br>基本上,你的选择是:选择一个轴,所有的切片将垂直于这个轴.一旦选定了轴,后续的思路就清晰了:求得每个垂直于该轴的切片的横截面面积.不同的切片有不同的面积。</p><ul><li>选定一个轴  </li><li>求轴上点x处的横截面面积，称该面积为A(x)  </li><li><img src="一般体积求法.png" alt="一般体积求法.png">  </li></ul><p><img src="一般体积求法示意图.png" alt="一般体积求法示意图.png">  </p><p>这些面积的求解都依赖于原始的曲线方程，那如果生活中一个物体，要求其体积如何来做呢。大概可以考虑拟合出曲线来，然后用公式求解，更一般的也许就类似与草冲称象了。  </p><h2 id="弧长"><a href="#弧长" class="headerlink" title="弧长"></a>弧长</h2><p><img src="弧长公式图像.png" alt="弧长公式图像.png"><br><img src="弧长公式-1.png" alt="弧长公式-1.png"><br><img src="弧长公式-2.png" alt="弧长公式-2.png"><br>这里有一点很有趣的变化，就是将(dx)<sup>2</sup>提到的根号外边。原文称这个变化需要进行证明但证明超越原书范围。<br>弧长公式也有参数形式: <img src="弧长公式-3.png" alt="弧长公式-3.png">  </p><ul><li>示例：<br><img src="弧长公式示例1.png" alt="弧长公式示例1.png"><br>t在[3,5]之间</li></ul><p><img src="弧长公式示例2.png" alt="弧长公式示例2.png"><br>根号内化简得到：36(t + 2)<sup>2</sup>  </p><ul><li>物理中的应用<br>定义在时间 t 秒处的蚂蚁位置是(x(t), y(t)). 那么,蚂蚁在时间 t 的速率是多少?<br><img src="速率.png" alt="速率.png">  </li></ul><p>把速率进行积分，就是蚂蚁走过曲线的弧长  </p><h2 id="旋转体的表面积"><a href="#旋转体的表面积" class="headerlink" title="旋转体的表面积"></a>旋转体的表面积</h2><p><img src="表面积示意图.png" alt="表面积示意图.png"><br>表面积看作周长的积分</p><p><img src="表面积公式1.png" alt="表面积公式1.png"><br><img src="表面积公式2.png" alt="表面积公式2.png">  </p><h1 id="微分方程"><a href="#微分方程" class="headerlink" title="微分方程"></a>微分方程</h1><p>微分方程就是包含导数的方程，它对于描述现实世界中量的变化非常有用，比如了解种群增长快慢，或者还清贷款等，都可以有微分方程来建模。  </p><h2 id="可分离变量的一阶微分方程"><a href="#可分离变量的一阶微分方程" class="headerlink" title="可分离变量的一阶微分方程"></a>可分离变量的一阶微分方程</h2><p>可分离变量的一阶微分方程指的是所有关于y的部分(包括dy)放到一边，所有关于x的部分(包括dx)放到另外一边。<br>这种方程比较好求解，只需要两边求积分即可，这里只介绍一个简单的示例：  </p><p><img src="可分离变量-1.png" alt="可分离变量-1.png"><br><img src="可分离变量-2.png" alt="可分离变量-2.png"><br><img src="可分离变量-3.png" alt="可分离变量-3.png">  </p><h2 id="一阶线性微分方程"><a href="#一阶线性微分方程" class="headerlink" title="一阶线性微分方程"></a>一阶线性微分方程</h2><ul><li><p>定义：<br>一阶线性微分方程：<img src="一阶线性方程形式.png" alt="一阶线性方程形式.png">。dy/dx 与 y的幂次都是1  </p></li><li><p>解法：<br>这种方程的解法是使用配方法，将左侧进行变换，转换成可分离变量的形式。进行的变化可以借鉴乘法的导数法则。<br><img src="一阶线性微分方程.png" alt="一阶线性微分方程.png">  </p><p><img src="配方法解释-1.png" alt="配方法解释-1.png"><br><img src="配方法解释-2.png" alt="配方法解释-2.png">  </p><p>这是一种解法，也可以参考下一节的常系数微分方程的解法</p></li><li><p>示例：<br><img src="一阶线性微分方程1.png" alt="一阶线性微分方程1.png"><br>两边乘e<sup>2x<sup>3</sup></sup>得：<br><img src="一阶线性微分方程2.png" alt="一阶线性微分方程2.png"><br><img src="一阶线性微分方程3.png" alt="一阶线性微分方程3.png">  </p></li></ul><h2 id="常系数微分方程"><a href="#常系数微分方程" class="headerlink" title="常系数微分方程"></a>常系数微分方程</h2><ul><li><p>定义：<br><img src="常系数微分方程.png" alt="常系数微分方程.png"><br>a<sub>n</sub> 只是一些普通的常实数。  </p></li><li><p>解法：<br>解法一般显示解齐次(右侧为0)，然后再解非齐次的特解，然后再合并。有些像线代中的解法，这里只介绍1次与2次。  </p></li><li><p>一阶齐次解法：<br><img src="一阶齐次.png" alt="一阶齐次.png"><br>y = Ae<sup>-ax</sup>  </p></li><li><p>二阶齐次解法：<br><img src="二阶齐次方程.png" alt="二阶齐次方程.png"><br><img src="二阶齐次方程解法.png" alt="二阶齐次方程解法.png">  </p><p>那为什么这种解法适用？<img src="二阶齐次解法解释.png" alt="二阶齐次解法解释.png">  </p></li><li><p>二阶非齐次<br>求一个特解，非齐次的解= 一般解 + 特解<br>特解归纳如下：<br><img src="特解的求法归纳.png" alt="特解的求法归纳.png">  </p></li><li><p>示例<br><img src="常系数示例1.png" alt="常系数示例1.png"><br>先求齐次部分：<br>t<sup>2</sup> -4t + 4 = 0，只有一个解，t=2<br><img src="常系数示例2.png" alt="常系数示例2.png"><br>特解形式为： <img src="常系数示例3.png" alt="常系数示例3.png"><br>代入方程求解的：C=-4 D=-3.<br><img src="常系数示例4.png" alt="常系数示例4.png">  </p></li></ul><h2 id="微分方程建模"><a href="#微分方程建模" class="headerlink" title="微分方程建模"></a>微分方程建模</h2><p>微分方程以上都是工具，建模部分是核心，它告诉我们，微分方程能如何使用。可惜的是，这部分原书中示例很少，只有一个细菌培养的例子。  </p><p><img src="微分方程建模1.png" alt="微分方程建模1.png"><br><img src="微分方程建模2.png" alt="微分方程建模2.png"><br>这是一个一阶线性微分方程，套用上边解法即可  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是微积分复习的最后一篇，教材使用《普林斯顿微积分读本》，涵盖第27章-第30章的内容。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数与微分  &lt;/li&gt;
&lt;li&gt;积分  &lt;/li&gt;
&lt;li&gt;级数  &lt;/li&gt;
&lt;li&gt;其他      &amp;lt;=&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文的内容覆盖4章，包括：参数方程和极坐标、复数、体积弧长和表面积、微分方程。在函数中引入中间变量，过度到了参数方程，极坐标可以看作特殊的参数方程; 复数即可以用笛卡尔坐标系来表示，也可以用极坐标系来表示（欧拉公式），这两章的内容较近。体积、弧长与表面积一章是用微积分代入空间几何，可以看作一种应用，在3D中有很好的应用场景; 微分方程应用场景更宽广一些，这里介绍了3种微分方程的解法。  &lt;/p&gt;
    
    </summary>
    
      <category term="理论" scheme="http://yoursite.com/categories/%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="微积分" scheme="http://yoursite.com/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>微积分-级数</title>
    <link href="http://yoursite.com/2019/09/28/%E5%BE%AE%E7%A7%AF%E5%88%86-%E7%BA%A7%E6%95%B0/"/>
    <id>http://yoursite.com/2019/09/28/微积分-级数/</id>
    <published>2019-09-28T06:41:25.000Z</published>
    <updated>2019-11-07T09:35:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是微积分复习的第三篇，教材使用《普林斯顿微积分读本》，涵盖第22章-第26章的内容。  </p><ul><li>函数与微分  </li><li>积分      </li><li>级数      &lt;=</li><li>其他</li></ul><p>级数的进入是从数列开始的，首先是数列的收敛性，然后是级数的收敛性，然后过度到泰勒级数，最后是对泰勒级数的应用（估值问题）。<br>级数是积分概念在离散数列的延伸，正向理解，是对离散数据的求和，反向理解，是对函数的分解。就分解而言，在工程领域得到了充分的应用。</p><a id="more"></a><h1 id="级数的收敛性"><a href="#级数的收敛性" class="headerlink" title="级数的收敛性"></a>级数的收敛性</h1><h2 id="数列收敛性"><a href="#数列收敛性" class="headerlink" title="数列收敛性"></a>数列收敛性</h2><p>谈到收敛性，就离不开极限，而数列从函数那里继承了很多极限的性质：  </p><ul><li>数列继承了函数的极限性质  </li><li>三明治定理  </li><li>连续函数保持极限，lim g(x) -&gt; L 则lim f(g(x)) -&gt; f(L)</li></ul><h2 id="级数收敛性简介"><a href="#级数收敛性简介" class="headerlink" title="级数收敛性简介"></a>级数收敛性简介</h2><p>级数就是和，就是将数列a<sub>n</sub>的所有项都加起来;<br>级数对等的是积分，无穷级数的收敛性对等反常积分对无限的积分，这样对反常积分收敛性的4种判别方法，就可以应用到级数上，另外级数也有几种独有的级数。  </p><h2 id="反常积分的方法"><a href="#反常积分的方法" class="headerlink" title="反常积分的方法"></a>反常积分的方法</h2><ul><li><p>第n项判别法<br><img src="第n项判别法.png" alt="第n项判别法"><br>注意：第n项判别法不能用于级数收敛性的判别，即lim a<sub>n</sub> = 0未必收敛。 </p></li><li><p>极限比较判别法<br><img src="极限比较判别法.png" alt="极限比较判别法.png">   </p></li><li><p>p判别法<br><img src="p值判断法.png" alt="p值判断法.png">  </p></li><li><p>绝对收敛判别法<br><img src="绝对收敛判别法.png" alt="绝对收敛判别法.png">  </p></li></ul><h2 id="特有的方法"><a href="#特有的方法" class="headerlink" title="特有的方法"></a>特有的方法</h2><p>以上是从反常积分继承来的判别法，以下是级数特有的判别法，包括：比式判别法、根式判别法、积分判别法和交错级数判别法<br>比式判别法与根式判别法不之间判断源数列，而是构建一个新的数列，通过判断新数列的收敛性来判断级数的收敛性  </p><ul><li><p>比式判别法</p><p>构建一个新的数列b<sub>n</sub>，定义其为数列相邻两项之的绝对值, 若b<sub>n</sub>收敛于一个小于1的数，则原级数收敛;大于1的数，则原级数发散;等于1，则不应该用比式判别法。  </p><p><img src="比式判别法.png" alt="比式判别法.png"></p></li><li><p>根式判别法  </p><p>根式判别式构建的新数列为第n项绝对值的n次方根，若b<sub>n</sub>收敛于一个小于1的数，则原级数收敛;大于1的数，则原级数发散;等于1，则不应该用根式判别法。  </p><p><img src="根式判别法.png" alt="根式判别法.png"></p></li><li><p>积分判别法  </p><p><img src="积分判别法.png" alt="积分判别法.png">  </p><p>若函数的f(x)的积分<img src="积分判别法-2.png" alt="积分判别法-2.png">收敛，则对应级数也收敛  </p></li><li><p>交错级数判别法  </p><p>若级数是交错的，且各项的绝对值递减趋于0,则级数收敛<br>这里引出一个条件收敛的概念，若一个级数收敛二其绝对值发散，就称为条件收敛<br>示例：  <img src="交错级数.png" alt="交错级数.png">  </p></li></ul><h2 id="使用总结"><a href="#使用总结" class="headerlink" title="使用总结"></a>使用总结</h2><p><img src="判断法使用总结.png" alt="判断法使用总结.png">  </p><p>特有方法的使用优先级高于继承方法的优先级  </p><h1 id="泰勒级数与幂级数"><a href="#泰勒级数与幂级数" class="headerlink" title="泰勒级数与幂级数"></a>泰勒级数与幂级数</h1><h2 id="泰勒定理"><a href="#泰勒定理" class="headerlink" title="泰勒定理"></a>泰勒定理</h2><p><img src="泰勒近似定理.png" alt="泰勒近似定理.png">  </p><p><img src="泰勒定理.png" alt="泰勒定理.png">  </p><p>若想证明一个函数在某些x处等于它的泰勒级数，需要证明当N → ∞ 时 R<sub>N</sub>(x) → 0.<br><img src="一个极限.png" alt="一个极限.png"> 对所有x都成立。  </p><h2 id="幂级数与泰勒级数"><a href="#幂级数与泰勒级数" class="headerlink" title="幂级数与泰勒级数"></a>幂级数与泰勒级数</h2><p>幂级数是以a<sub>0</sub>+a<sub>1</sub>x + a<sub>2</sub>x<sup>2</sup> + a<sub>3</sub>x<sup>3</sup> + a<sub>4</sub>x<sup>4</sup> + …<br>也可以写成![幂级数一般形式.png])<br>在x=a处的幂级数：<img src="幂级数形式.png" alt="幂级数形式.png">  </p><p>从这个形式处，可以看出泰勒级数是一种特殊的幂级数: <img src="幂级数与泰勒级数.png" alt="幂级数与泰勒级数.png">  </p><p>这里有一个麦克劳林级数，它是泰勒级数的在x=0处的特例：<img src="麦克劳林级数.png" alt="麦克劳林级数.png">  </p><h1 id="求解估值问题"><a href="#求解估值问题" class="headerlink" title="求解估值问题"></a>求解估值问题</h1><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>用二阶泰勒多项式估算e<sup>1/3</sup>，并估算误差  </p><table><thead><tr><th>n</th><th>f<sup>(n)</sup>(x)</th><th>f<sup>(n)</sup>(0)</th></tr></thead><tbody><tr><td>0</td><td>e<sup>x</sup></td><td>1</td></tr><tr><td>1</td><td>e<sup>x</sup></td><td>1</td></tr><tr><td>2</td><td>e<sup>x</sup></td><td>1</td></tr><tr><td>3</td><td>e<sup>x</sup></td><td>1</td></tr></tbody></table><p><img src="估值示例1-1.png" alt="估值示例1-1.png"><br><img src="估值示例1-2.png" alt="估值示例1-2.png"><br><img src="估值示例1-3.png" alt="估值示例1-3.png">  </p><p><img src="估值示例1-4.png" alt="估值示例1-4.png"><br><img src="估值示例1-5.png" alt="估值示例1-5.png"></p><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>估算sqart(27)，误差不大于1/250    </p><p><img src="估值示例2-1.png" alt="估值示例2-1.png"><br><img src="估值示例2-2.png" alt="估值示例2-2.png"><br>求得N = 1即可。P<sub>1</sub>(27) = 5 + 1/10 *(27-25) = 26/5</p><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><p>用三阶泰勒级数估算 cos(π/3 − 0.01) 的值 ,<br><img src="估值示例3-1.png" alt="估值示例3-1.png"><br><img src="估值示例3-2.png" alt="估值示例3-2.png"><br>求得N=3<br><img src="估值示例3-3.png" alt="估值示例3-3.png">  </p><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><h2 id="幂级数收敛半径与收敛区间"><a href="#幂级数收敛半径与收敛区间" class="headerlink" title="幂级数收敛半径与收敛区间"></a>幂级数收敛半径与收敛区间</h2><p>幂级数的收敛性判断，大多数时间使用比值判别法，有时可以使用根式判别法。<br><img src="幂级数收敛半径.png" alt="幂级数收敛半径.png"><br><img src="幂级数收敛半径-1.png" alt="幂级数收敛半径-1.png"><br><img src="幂级数收敛半径-2.png" alt="幂级数收敛半径-2.png"><br>当|x|&lt; 1 时绝对收敛，当|x| &gt; 1时绝对发散。<br>再考虑 x = 1 与 x = -1情况：<br>当x = 1 时<img src="幂级数收敛半径-3.png" alt="幂级数收敛半径-3.png">它发散<br>当x = -1时 <img src="幂级数收敛半径-4.png" alt="幂级数收敛半径-4.png">条件收敛  </p><h2 id="利用现有泰勒级数求其他泰勒级数"><a href="#利用现有泰勒级数求其他泰勒级数" class="headerlink" title="利用现有泰勒级数求其他泰勒级数"></a>利用现有泰勒级数求其他泰勒级数</h2><p><img src="麦克劳林级数1.png" alt="麦克劳林级数1.png"><br><img src="麦克劳林级数2.png" alt="麦克劳林级数2.png">  </p><p>可以通过换元、求导、求积分的方式求其他级数  </p><ul><li><p>换元<br><img src="麦克劳林级数-换元.png" alt="麦克劳林级数-换元.png">  </p><p><img src="麦克劳林级数-换元2.png" alt="麦克劳林级数-换元2.png"><br><img src="麦克劳林级数-换元2-2.png" alt="麦克劳林级数-换元2-2.png">  </p></li><li><p>求导<br><img src="麦克劳林级数-求导.png" alt="麦克劳林级数-求导.png">  </p></li><li><p>求积分<br><img src="麦克劳林级数-求积分.png" alt="麦克劳林级数-求积分.png">  </p></li></ul><h2 id="利用麦克劳林求极限"><a href="#利用麦克劳林求极限" class="headerlink" title="利用麦克劳林求极限"></a>利用麦克劳林求极限</h2><p>利用麦克劳林级数求极限时，将所有的函数，换算成多项式，然后进行合并求解即可<br><img src="泰勒级数求极限.png" alt="泰勒级数求极限.png"><br><img src="泰勒级数求极限-2.png" alt="泰勒级数求极限-2.png"><br><img src="泰勒级数求极限-3.png" alt="泰勒级数求极限-3.png"><br><img src="泰勒级数求极限-4.png" alt="泰勒级数求极限-4.png"><br><img src="泰勒级数求极限-5.png" alt="泰勒级数求极限-5.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是微积分复习的第三篇，教材使用《普林斯顿微积分读本》，涵盖第22章-第26章的内容。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数与微分  &lt;/li&gt;
&lt;li&gt;积分      &lt;/li&gt;
&lt;li&gt;级数      &amp;lt;=&lt;/li&gt;
&lt;li&gt;其他&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;级数的进入是从数列开始的，首先是数列的收敛性，然后是级数的收敛性，然后过度到泰勒级数，最后是对泰勒级数的应用（估值问题）。&lt;br&gt;级数是积分概念在离散数列的延伸，正向理解，是对离散数据的求和，反向理解，是对函数的分解。就分解而言，在工程领域得到了充分的应用。&lt;/p&gt;
    
    </summary>
    
      <category term="理论" scheme="http://yoursite.com/categories/%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="微积分" scheme="http://yoursite.com/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>微积分-积分</title>
    <link href="http://yoursite.com/2019/09/06/%E5%BE%AE%E7%A7%AF%E5%88%86-%E7%A7%AF%E5%88%86/"/>
    <id>http://yoursite.com/2019/09/06/微积分-积分/</id>
    <published>2019-09-06T13:36:30.000Z</published>
    <updated>2019-10-18T00:59:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是微积分复习的第二篇，教材使用《普林斯顿微积分读本》，涵盖第15章-第21章的内容。  </p><ul><li>函数与微分  </li><li>积分       &lt;=</li><li>级数</li><li>其他</li></ul><a id="more"></a><h1 id="积分定义"><a href="#积分定义" class="headerlink" title="积分定义"></a>积分定义</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>积分是从级数求和引入的，比如第一例子：<br><img src="级数求和.png" alt="级数求和.png"><br>这种引入方式即暗示积分的求（有向）面积，求位移做铺垫，也为后边级数做准备。</p><h2 id="伸缩级数"><a href="#伸缩级数" class="headerlink" title="伸缩级数"></a>伸缩级数</h2><p>比较有趣的一个例子:<br><img src="伸缩级数.png" alt="伸缩级数.png"><br>书中用伸缩级数的方法，推导出了平方和级数的和公式：<br><img src="伸缩级数推动-1.png" alt="伸缩级数推动-1.png"><br>将等式左侧整理后得到<br><img src="伸缩级数推动-2.png" alt="伸缩级数推动-2.png"><br><img src="伸缩级数推动-3.png" alt="伸缩级数推动-3.png">  </p><h2 id="有向面积"><a href="#有向面积" class="headerlink" title="有向面积"></a>有向面积</h2><p>这一段主要从直观上看级数到积分的一个过度<br><img src="有向面积.png" alt="有向面积.png"><br><img src="有向面积-2.png" alt="有向面积-2.png">  </p><h1 id="定积分"><a href="#定积分" class="headerlink" title="定积分"></a>定积分</h1><h2 id="定积分定义（黎曼和）"><a href="#定积分定义（黎曼和）" class="headerlink" title="定积分定义（黎曼和）"></a>定积分定义（黎曼和）</h2><p>定积分是一种定义，是一种求某段[a,b]曲线y=f(x)，与X轴形成闭合图形的面积。可以看出，定积分面向的是一个具体的问题，然后再次抽象之后才出现了不定积分。  </p><p>这个图形面积的求法，就需要借鉴上一节有向面积。将上一节的公式区间长度趋向于0,就是这个图像的面积，也就是积分。<br><img src="黎曼和.png" alt="黎曼和.png"><br>上一节的求和部分，也别称作黎曼和。<br>积分的定义也离不开极限。这里发散一下，这个叫黎曼和，也就与黎曼有关，而黎曼是19世纪人物，微积分是17世纪创立的，也就是这个定义，是很久之后才确定的。</p><h2 id="定积分性质"><a href="#定积分性质" class="headerlink" title="定积分性质"></a>定积分性质</h2><p>有了定义，就有了几个简单的性质：  </p><ol><li><img src="定积分性质-1.png" alt="定积分性质-1.png">  </li><li><img src="定积分性质-2.png" alt="定积分性质-2.png"></li><li><img src="定积分性质-3.png" alt="定积分性质-3.png"></li><li><img src="定积分性质-4.png" alt="定积分性质-4.png"></li><li><img src="定积分性质-5.png" alt="定积分性质-5.png"></li></ol><p>对这几个性质只说一点：在矩阵中，我们说线性变换符合两个公式：<br>T(v+w) = T(v) + T(w); T(cv) = cT(v)。如果把f(x)看作v，g(x)看作w，那积分就可以看作成一种线性变换了。  </p><h2 id="估算积分"><a href="#估算积分" class="headerlink" title="估算积分"></a>估算积分</h2><p>积分既然可以看作成一种面积，面积就有大小之分<br><img src="积分的简单估算.png" alt="积分的简单估算.png"><br>这样就看出，积分是在[m(b-a), M(b-a)]之间</p><h2 id="积分中值定理"><a href="#积分中值定理" class="headerlink" title="积分中值定理"></a>积分中值定理</h2><p>有了最大值与最小值，也就想到平均值。<br><img src="积分中值定理.png" alt="积分中值定理.png"><br><img src="积分中值定理2.png" alt="积分中值定理2.png"><br>f(c)就可以看作是f(x)在区间[a,b]上的平均值。  </p><h1 id="微积分基本定理"><a href="#微积分基本定理" class="headerlink" title="微积分基本定理"></a>微积分基本定理</h1><p>注意，这里说的是微积分基本定理，将积分与微分联合到一起的定理。主要有2个基本定理，一个阐述积分与微分之间的关系，从这里引出了不定积分，另一是积分函数与被积函数的关系，从而引出了不定积分的计算方法。</p><h2 id="第一基本定理"><a href="#第一基本定理" class="headerlink" title="第一基本定理"></a>第一基本定理</h2><p><img src="微积分第一基本定理.png" alt="微积分第一基本定理.png"><br>这里看出，微积分基本定理是与定积分相关的定理，也就是包含积分的上下限，以后的很多文章都是在上下限中做的。  </p><p>其证明源自:<br><img src="微积分第一定理的证明.png" alt="微积分第一定理的证明.png"><br><img src="微积分第一定理的证明2.png" alt="微积分第一定理的证明2.png">  </p><p>对比不定积分与导数：<br><img src="不定积分.png" alt="不定积分.png">  </p><h2 id="第二基本定理"><a href="#第二基本定理" class="headerlink" title="第二基本定理"></a>第二基本定理</h2><p><img src="微积分第二基本定理.png" alt="微积分第二基本定理.png"><br>微积分第二基本定理的证明书中没有画图，画图的话会很简单，就是阴影部分面积的减法运算。  </p><p>证明:<br><img src="微积分第二定理证明.png" alt="微积分第二定理证明.png"><br>函数到a部分的面积是F(a)，函数到b部分的面积是F(b)，那[a,b]之间的面积自然就是F(b)-F(a)了。</p><h2 id="积分上下限是函数"><a href="#积分上下限是函数" class="headerlink" title="积分上下限是函数"></a>积分上下限是函数</h2><p>积分上限是函数：  </p><p>这句话说全了是这样：求积分式的导数，如果积分上限是函数。解题时，其实是将上限设成另外一个变量，然后再隐函数求导。如：</p><p><img src="积分上限是函数.png" alt="积分上限是函数.png"><br><img src="积分上限是函数2.png" alt="积分上限是函数2.png"><br>这里需要注意，dy/du中积出的函数变量是u，后边要用x替换掉。  </p><p>积分下限是函数与上限是函数相同，做一个相反数即可转换成，这里不做介绍</p><ul><li>积分与导数公式  </li></ul><p><img src="积分公式.png" alt="积分公式.png"></p><h1 id="微积分基本方法1"><a href="#微积分基本方法1" class="headerlink" title="微积分基本方法1"></a>微积分基本方法1</h1><h2 id="换元法"><a href="#换元法" class="headerlink" title="换元法"></a>换元法</h2><ul><li><p>示例1</p><p><img src="换元法示例1-1.png" alt="换元法示例1-1.png"><br>这里设t = x<sup>3</sup>，将t导入得<br> (1/3)sin(x<sup>3</sup>) + C</p></li><li><p>示例2<br><img src="换元法示例2.png" alt="换元法示例2.png"><br>这里设t = x<sup>3</sup> + 7x - 9<br>从示例2看出的公式是这样：<br><img src="换元法公式1.png" alt="换元法公式1.png">  </p></li><li><p>示例3<br><img src="换元法示例3.png" alt="换元法示例3.png">  </p></li><li><p>示例4<br><img src="换元法示例4.png" alt="换元法示例4.png"><br> 这里的t = e<sup>x</sup>  </p></li><li><p>示例5<br> <img src="换元法示例5-1.png" alt="换元法示例5-1.png"><br> 这个与上边的例子有很大不同，这个需要一次函数的根式形式，需要将t设置成这个根式。<br> <img src="换元法示例5-2.png" alt="换元法示例5-2.png">  </p></li><li><p>理论解释<br><img src="换元法理论解释.png" alt="换元法理论解释.png"><br>这个解释其实只解释了前4个示例，第5个示例并不在此之列</p></li></ul><h2 id="分部积分法"><a href="#分部积分法" class="headerlink" title="分部积分法"></a>分部积分法</h2><ul><li><p>公式<br><img src="分部积分法公式.png" alt="分部积分法公式.png">  </p><p>分部积分法跟贝叶斯公式有点相似</p></li><li><p>示例1<br><img src="分部积分法示例1.png" alt="分部积分法示例1.png">  </p><p>多项式与指数函数</p></li><li><p>示例2<br><img src="分部积分法示例2.png" alt="分部积分法示例2.png"><br> 然后以相同德办法处理等式右边第二项</p><p>多项式与三角函数</p></li><li><p>示例3<br><img src="分部积分法示例3.png" alt="分部积分法示例3.png"><br> 利用三角函数两次求解后便会原值的特点</p><p>三角函数与指数函数  </p></li><li><p>示例4<br>以上三种都是两种基本初等函数的组合方式，e<sup>x</sup> &gt; sin(x) &gt; x 这种顺序<br>以下这些则反之，可以认为它们比 x 还小  </p><p><img src="分部积分法示例4-1.png" alt="分部积分法示例4-1.png"><br><img src="分部积分法示例4-2.png" alt="分部积分法示例4-2.png">  </p></li></ul><h2 id="部分积分法"><a href="#部分积分法" class="headerlink" title="部分积分法"></a>部分积分法</h2><p>部分积分法是处理，有理函数(两个多项式函数的比值)的方法. 通过一些代数运算把它分解成几个更简单的有理函数和的形式, 然后再对真写简单的有理函数求积分.  </p><ul><li><p>步骤  </p><ol><li>要确保分母的次幂大于分子的次幂,否则,通过除法方式,转换成此形式</li><li>对分母做因式分解<br>对于二次函数,查看判别式,若大于0,则可以因式分解</li><li><p>分部<br>分部是将因式分解之后的乘积形式,变成和形式的过程<br><img src="分部积分法1.png" alt="分部积分法1.png"><br><img src="分部积分法2.png" alt="分部积分法2.png"><br>这有些像基向量的样子,在每个基向量的常数倍.</p></li><li><p>计算常量的值</p></li><li>求解分母为线性项次幂的积分</li><li>对分母是二次函数的被积函数求积分</li></ol></li><li><p>示例1:<br><img src="分部积分法3.png" alt="分部积分法3.png">  </p></li><li><p>示例2:<br><img src="部分积分法示例2.png" alt="部分积分法示例2.png"></p></li><li><p>示例3:<br><img src="部分积分法示例3.png" alt="部分积分法示例3.png"><br>再次将进行分部,第一部分用换元法, 第二部分借用<img src="部分积分公式.png" alt="部分积分公式.png">来计算<br><img src="部分积分法示例3-2.png" alt="部分积分法示例3-2.png">  </p></li></ul><h1 id="微积分基本方法2"><a href="#微积分基本方法2" class="headerlink" title="微积分基本方法2"></a>微积分基本方法2</h1><h2 id="三角恒等式的积分"><a href="#三角恒等式的积分" class="headerlink" title="三角恒等式的积分"></a>三角恒等式的积分</h2><p>通过几个三角恒等式进行变化,将不易求的积分转变成易求的积分.恒等式包括:</p><ol><li>倍角公式: <img src="倍角公式.png" alt="倍角公式.png">  </li><li>毕达哥拉斯恒等式: <img src="毕达哥拉斯恒等式.png" alt="毕达哥拉斯恒等式.png">  </li><li>和差公式: <img src="和差公式.png" alt="和差公式.png">  </li></ol><p>这一部分的示例太多了,而且没有统一的解法,只做几个示例:  </p><ul><li><p>示例1<br><img src="三角恒等式示例1-1.png" alt="三角恒等式示例1-1.png"><br>给sec(x)上次幂,转换成2次进行<br><img src="三角恒等式示例1-2.png" alt="三角恒等式示例1-2.png"><br><img src="三角恒等式示例1-3.png" alt="三角恒等式示例1-3.png">  </p></li><li><p>示例2<br><img src="三角恒等式示例2.png" alt="三角恒等式示例2.png">  </p></li></ul><h2 id="三角函数的幂积分"><a href="#三角函数的幂积分" class="headerlink" title="三角函数的幂积分"></a>三角函数的幂积分</h2><p>三角函数的幂积分,很繁琐.不同的三角函数,技巧不相同.</p><ul><li><p>sinx或者cosx<br>如果是奇数次幂,则可以将一个奇数取出,转变积分<br>如果是偶数次幂,则使用倍角公式,将次幂转变成倍角</p></li><li><p>tan(x)<br>1次幂的tan(x),转换成sinx / cosx 的形式来计算<br>偶次幂的tan(x)求导很有趣,使用tan(x)与secx之间的关系,能不断的降幂,每次将2幂来完成</p></li><li><p>sec(x)<br>1次幂的secx求导很有技巧,(sec(x) + tan(x))/(sex(x) + tan(x))相乘之后,一下便可求出<br>偶次幂的sec(x),与偶次幂的tan(x)求法类似,但更复杂一些,不管的降幂,直到求出.</p></li><li><p>其他<br>cot(x) 同 tan(x), csc(x) 同 sec(x)</p></li><li><p>示例1<br><img src="三角函数幂积分示例1.png" alt="三角函数幂积分示例1.png"><br>将cos(x),转变成sin(x),然后将单独的cosx 放进积分中即可.</p></li><li><p>示例2<br><img src="三角函数幂积分示例2.png" alt="三角函数幂积分示例2.png"><br>将等式右侧展看,多变成多项式形式,偶次幂继续升角,奇次幂利用换元法求解</p></li><li><p>示例3<br><img src="tanx的积分.png" alt="tanx的积分.png">  </p></li><li><p>示例4<br><img src="tanx的2次幂积分.png" alt="tanx的2次幂积分.png">  </p></li><li><p>示例5<br><img src="tanx的4次幂积分.png" alt="tanx的4次幂积分.png">  </p></li><li><p>示例6<br><img src="secx的积分.png" alt="secx的积分.png"><br>sec(x)的二次幂积分为tan(x)+c  </p></li><li><p>示例7<br><img src="secx的6次幂积分1.png" alt="secx的6次幂积分1.png"><br><img src="secx的6次幂积分2.png" alt="secx的6次幂积分2.png"><br><img src="secx的6次幂积分3.png" alt="secx的6次幂积分3.png"><br>这里采用了分部积分法,并且只用来降成4次幂. 4次幂的过程仍然要继续采用此方法.  </p></li><li><p>总结  </p></li></ul><p>tan(x)与sex(x)的偶次幂,都是采用了类似数学归纳法的方式,不断降维来求解</p><h2 id="三角换元法"><a href="#三角换元法" class="headerlink" title="三角换元法"></a>三角换元法</h2><p>三角换元法不再求解的是三角函数,而是利用三角函数的特点来求解根式的积分.  </p><p><img src="三角换元法.png" alt="三角换元法.png"><br>进行换元之后,脱离根式,然后进行求解.  </p><ul><li><p>示例1<br><img src="三角换元法示例1.png" alt="三角换元法示例1.png"><br>用x = 3sin(θ)来进行换元<br><img src="三角换元法示例2.png" alt="三角换元法示例2.png">  </p></li><li><p>示例2<br><img src="三角换元法示例3.png" alt="三角换元法示例3.png"><br><img src="三角换元法示例3-1.png" alt="三角换元法示例3-1.png">  </p></li></ul><h1 id="反常积分"><a href="#反常积分" class="headerlink" title="反常积分"></a>反常积分</h1><p>反常积分要么在函数定义域内存在垂直渐进线,要么区间趋向无穷的定积分.这两种积分都涉及用极限来求积分的基本方法.在这种基本方法之上,演化出了常用的3中通用判别方法:比较判别法,极限比较判别法,p判别法,一种不太通用的判别法:绝对值判别法.这些判别法用于判断反常积分是否存在,或者称收敛.<br>原文中以2章的在讲述反常积分,其中,一章讲理论,一章讲示例.这里仅用一章将理论,不在积分花费更多的时间了.  </p><h2 id="2个定义"><a href="#2个定义" class="headerlink" title="2个定义"></a>2个定义</h2><p><img src="反常积分定义1.png" alt="反常积分定义1.png"><br>这是在下界的定义,在上界的定义同理  </p><p><img src="反常积分定义2.png" alt="反常积分定义2.png"><br>区间无穷的定义</p><h2 id="比较判别法"><a href="#比较判别法" class="headerlink" title="比较判别法"></a>比较判别法</h2><p>比较判别法可以从积分的面积定义上找到源头.  </p><p><img src="比较判别法表达式.png" alt="比较判别法表达式.png"><br><img src="比较判别法图像.png" alt="比较判别法图像.png"><br>如图,如果g(x)在区间[a,b]上收敛,则f(x)也一定收敛. 反命题不成立<br>逆反命题是如果f(x)在区间[a,b]上发散,则g(x)也一定发散.  </p><h2 id="极限比较判别法"><a href="#极限比较判别法" class="headerlink" title="极限比较判别法"></a>极限比较判别法</h2><p><img src="极限比较判别法.png" alt="极限比较判别法.png"><br>这个有同样的意义应该理解为:有相同的收敛性. 同收敛,共发散.</p><p>如: 在x -&gt; 0时, tan(x) ~ x, sin(x) ~ x, e<sup>x</sup>-1 ~x</p><h2 id="p判别法"><a href="#p判别法" class="headerlink" title="p判别法"></a>p判别法</h2><p>p判别法,应该是最接近运用的判别法<br><img src="p判别法.png" alt="p判别法.png"><br><img src="p判别法图像.png" alt="p判别法图像.png">  </p><p>记忆的方法是,与y=x相比, 更接近x轴霍y轴的收敛,反之发散</p><h2 id="绝对值判别法"><a href="#绝对值判别法" class="headerlink" title="绝对值判别法"></a>绝对值判别法</h2><p><img src="绝对收敛判别法.png" alt="绝对收敛判别法.png"><br>其他的判别法即可判别发散,也可以判别收敛.绝对值判别法,只能用来判别收敛.<br>在应用上,比较适合使用在sin(x)的判别上,即sin(x) &lt;= |sin(x)| &lt;= 1</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是微积分复习的第二篇，教材使用《普林斯顿微积分读本》，涵盖第15章-第21章的内容。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数与微分  &lt;/li&gt;
&lt;li&gt;积分       &amp;lt;=&lt;/li&gt;
&lt;li&gt;级数&lt;/li&gt;
&lt;li&gt;其他&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="理论" scheme="http://yoursite.com/categories/%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="微积分" scheme="http://yoursite.com/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>微积分-函数与微分</title>
    <link href="http://yoursite.com/2019/08/08/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%87%BD%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/"/>
    <id>http://yoursite.com/2019/08/08/微积分-函数与微分/</id>
    <published>2019-08-08T13:11:43.000Z</published>
    <updated>2019-08-20T06:44:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是微积分复习的第一篇，教材使用《普林斯顿微积分读本》，涵盖第1章-第14章的内容。 </p><ul><li>函数与微分  &lt;=</li><li>积分</li><li>级数</li><li>其他</li></ul><a id="more"></a><h1 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>函数是将一个对象转化成另外一个对象的规则。起始的对象称为输入，来自称为定义域的集合。返回的对象称为输出，来自称为值域的集合。<br>一个函数必须给每一有效的输入制定唯一的输出。</p><h2 id="定义域"><a href="#定义域" class="headerlink" title="定义域"></a>定义域</h2><p>定义据包括实数集尽可能多的部分，几种常见的情况：</p><ol><li>分母不能为0</li><li>不能取一个负数的平方根</li><li>不能取一个负数或0的对数</li></ol><h2 id="反函数"><a href="#反函数" class="headerlink" title="反函数"></a>反函数</h2><p>数据中有很多对称，例如有了函数就有反函数。<br>给定一个实数 y, 那么在 f 定义域中的哪个x满足 f(x) = y ？<br>变换 f<sup>-1</sup> 就像是 f 的撤销按钮: 如果你从 x 出发,并通过函数 f 将它变换为 y, 那么你可以通过在 y 上的反函数 f<sup>-1</sup> 来撤销这个变换的效果,取回 x<br><img src="反函数图像.png" alt="反函数图像"><br>图像关于y=x对称</p><h2 id="奇偶性"><a href="#奇偶性" class="headerlink" title="奇偶性"></a>奇偶性</h2><p>偶函数：f(x) = f(-x)，图像关于y轴具有镜面对称性。<br>奇函数：f(x) = -f(-x)， 图像关于原点有对称性。</p><h2 id="常见函数的图像"><a href="#常见函数的图像" class="headerlink" title="常见函数的图像"></a>常见函数的图像</h2><ul><li><p>多项式  p(x) = a<sub>n</sub>x<sup>n</sup> + a<sub>n-1</sub>x<sup>n-1</sup> + a<sub>1</sub>x<sup>1</sup> + a<sub>0</sub></p><p><img src="多项式函数图像.png" alt="多项式函数图像"><br>一般多项式函数图像很难画，但其左右两段的走势倒是很容易判断。主要是由首项系数决定的。  </p><p><img src="多项式函数走向.png" alt="多项式函数走向"></p></li><li><p>有理函数  p(x) / q(x)<br><img src="有理函数图像.png" alt="有理函数图像"></p></li><li><p>指数函数图像<br><img src="指数函数图像.png" alt="指数函数图像">  </p></li><li><p>对数函数图像<br><img src="对数函数图像.png" alt="对数函数图像">  </p></li><li><p>其他<br>绝对值函数，正值不变，负值关于x周对称<br>开方函数，将多项式关于镜像对称  </p></li></ul><h1 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h1><h2 id="x-a处的极限"><a href="#x-a处的极限" class="headerlink" title="x=a处的极限"></a>x=a处的极限</h2><p>从函数图像上，从左侧往右接近a时，就得到左极限; 反之从右往左接近是，就得到右极限。<br>当左极限等于右极限时，就称为双侧极限; 极限一般是指的双侧极限  </p><p>f(x)在x = a处有一条垂直渐进线，则在a处的左极限和右极限，至少有一个是∞或−∞。</p><p>左右极限不存在的例子：f(x) = sin(1/x)，在x=0,不存在左右极限。</p><p><img src="左右极限不存在.png" alt="左右极限不存在"></p><h2 id="在∞与-∞处的极限"><a href="#在∞与-∞处的极限" class="headerlink" title="在∞与-∞处的极限"></a>在∞与-∞处的极限</h2><p>当x-&gt;∞ f(x)有固定值，则函数有水平渐进线。</p><p><img src="导数与sin的结合.png" alt="导数与sin的结合"></p><p>函数与其渐进线可能会相交。</p><h2 id="三明治定理"><a href="#三明治定理" class="headerlink" title="三明治定理"></a>三明治定理</h2><p><img src="三明治定理.png" alt="三明治定理"><br><img src="三明治定理示例.png" alt="三明治定理示例"></p><h2 id="求解多项式的极限问题"><a href="#求解多项式的极限问题" class="headerlink" title="求解多项式的极限问题"></a>求解多项式的极限问题</h2><ul><li>x-&gt; a 有理函数,有理函数求解注意通分</li><li>x-&gt; a 平方根函数，注意乘共轭表达式</li><li>x-&gt; ∞ 有理函数，取决于首项及其系数</li><li>x-&gt; -∞ 时，若有函数需要开方时，注意取负数</li></ul><h1 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h1><p>连续性, 直观上,连续函数的图像必须能一笔画成;<br>可导性, 直观上,在可导函数的图像中不会出现尖角。</p><h2 id="连续性"><a href="#连续性" class="headerlink" title="连续性"></a>连续性</h2><ul><li><p>定义<br>如果在x=a处的极限 = f(x), 则在x=a处连续。<br>这个定义中包括：在x=a处有双侧极限，并且在x=a处有定义，或者f(a)存在，他们相等。</p></li><li><p>区间连续定义<br>f(x)在[a,b]区间上连续，在区间每一点都连续，且两个端点的单侧极限存在。</p></li><li><p>介值定理<br>如果f(x) 在[a,b]上连续，并且f(a)f(b)&lt;0，则在区间(a,b)上至少有一点c，使得f(c) = 0存在。</p></li><li><p>最值定理<br>如果f(x) 在[a,b]上连续，则在[a,b]上至少有一个最大值和一个最小值。</p></li></ul><h2 id="可导性"><a href="#可导性" class="headerlink" title="可导性"></a>可导性</h2><ul><li><p>定义<br><img src="可导性-切线斜率.png" alt="可导性-切线斜率.png">  </p><p><img src="可导性-表达式.png" alt="可导性-表达式.png"></p><p><img src="导数微分.png" alt="导数微分.png">.<br>后来有dx表示x中十分微笑的彪悍，dy表示y中十分微笑的变化。dy就是微分。</p></li><li><p>不存在导数的情况<br>双侧的导数不相同，直观上，就是有尖角。</p></li><li><p>如果一个函数f在x上可导，则它在x上连续。</p></li></ul><h2 id="求导法则"><a href="#求导法则" class="headerlink" title="求导法则"></a>求导法则</h2><ul><li><p>乘法法则<br><img src="求导-乘法法则.png" alt="求导-乘法法则.png"></p><p><img src="乘法法则的直观展示.png" alt="乘法法则的直观展示.png"><br>两个变量相乘直观的展示是图中矩形的面积，长与宽都是x的函数，当x有一个小变化∆x,时，面积S如何变化。<br>∆S = ∆(uv) = v∆u + u∆v + (∆u)(∆v)。 其中(∆u)(∆v)是更高阶的无穷小，可以忽略。</p></li><li><p>除法法则<br><img src="求导-商法则.png" alt="求导-商法则.png"></p></li><li><p>链式法则<br><img src="链式求导法则.png" alt="链式求导法则.png"><br>以 y=f(u) u=g(x) 为例：<br>∆y = f’(u)∆u<br>∆u = g’(x)∆x</p><p>代入 ∆y = f’(u)g’(x)∆x<br>由此  ∆y/∆x = f’(u)g’(x)</p></li><li><p>常见应用<br>几何：切线<br>物理：加速度<br>代数：导数伪装的极限  </p><p><img src="通过导数求极限-1.png" alt="通过导数求极限-1.png"></p></li></ul><h1 id="函数的导数"><a href="#函数的导数" class="headerlink" title="函数的导数"></a>函数的导数</h1><h2 id="多项式函数"><a href="#多项式函数" class="headerlink" title="多项式函数"></a>多项式函数</h2><p><img src="多项式求导.png" alt="多项式求导.png"></p><h2 id="三角函数的极限与导数"><a href="#三角函数的极限与导数" class="headerlink" title="三角函数的极限与导数"></a>三角函数的极限与导数</h2><ul><li><p>极限<br><img src="sinx与x.png" alt="sinx与x.png">  </p><p><img src="sinx与x的极限.png" alt="sinx与x的极限.png"><br><img src="tanx的0极限.png" alt="tanx的0极限.png"></p><p>x可以换成其他函数代入与x<sup>2</sup> 、5x等</p><p><img src="x、sinx、tanx极限的直观解释.png" alt="x、sinx、tanx极限的直观解释.png"><br>扇形面积= x/2，内三角形面积= sin(x)/2, 外三角形面积= tan(x)/2， 当x趋近0时，它们相等。<br>变换：1 &gt; sin(x)/x &gt; cos(x)，利用三明治定理，可以得到结论。</p><p><img src="sinx除以x图像.png" alt="sinx除以x图像.png"><br><strong>小波函数</strong></p></li><li><p>导数  </p><p> sin’(x) = cos(x)<br> cos’(x) = -sin(x)  </p><p> tan’(x) = sec<sup>2</sup>(x)<br> cot’(x) = -csc<sup>2</sup>(x)  </p><p> sec’(x) = sec(x)tan(x)<br> csc’(x) = -csc(x)cot(x)</p><p> 记忆：正的导数都是正好，余的导数都是负数</p></li><li><p>一个有趣的函数</p><p>f(x) = x<sup>2</sup>sin(1/x)</p><p>根据求导公式，其在0处导数不存在</p><p><img src="导函数不连续.png" alt="导函数不连续.png"><br>这样改之后，用导数定义，发现其在0处f’(0) = 0，但它同样不连续。</p><p><img src="导函数不连续图像.png" alt="导函数不连续图像.png">  </p></li><li><p>小结<br>本节的sin(x)/x函数，是一个很漂亮的函数。貌似在小波中见过。<br>关于最后这个f(x) = x<sup>2</sup>sin(1/x)。导函数在0处存在，但却不连续。这种情况基本都出在sin(1/x)这种情况内，倒数使趋向无穷大变成了趋向无穷小。</p></li></ul><h2 id="指数函数与对数函数"><a href="#指数函数与对数函数" class="headerlink" title="指数函数与对数函数"></a>指数函数与对数函数</h2><ul><li><p>对数基础<br>log<sub>b</sub>(1) = 0  </p><p>log<sub>b</sub>(xy) = log<sub>b</sub>(x) + log<sub>b</sub>(y)<br>log是可以将乘法变成加法的运算。  </p><p>log<sub>b</sub>(x/y) = log<sub>b</sub>(x) - log<sub>b</sub>(y)  </p><p>log<sub>b</sub>(x<sup>y</sup>) = ylog<sub>b</sub>(x)<br>对数可以处理指数与对数都是函数的情况。  </p><p>log<sub>b</sub>(x) =   log<sub>c</sub>(x) /  log<sub>c</sub>(b)<br>这意味着，所有不同底数的对数，其实都互为常数倍。 log<sub>b</sub>(x) =  Klog<sub>c</sub>(x) K=1/log<sub>c</sub>(b)</p></li><li><p>e的定义<br>e一种由来，可以从计算复利而得来：当年利率一定，每年结算的的次数越多，最终的金额也就越多。当次数取向无穷时，其最终金额不会趋向无穷，而是一个常数。  </p><p><img src="e.png" alt="e.png"><br><img src="e2.png" alt="e2.png">  </p></li><li><p>导数<br>介绍e的定义，主要用于计算对数的导数。<br><img src="对数导数.png" alt="对数导数.png"><br><img src="自然对数导数.png" alt="自然对数导数.png">  </p><p>根据反函数求导<br><img src="指数函数导数.png" alt="指数函数导数.png"><br><img src="指数函数导数2.png" alt="指数函数导数2.png">  </p></li><li><p>极限<br><img src="指数与多项式极限.png" alt="指数与多项式极限.png"><br><img src="对数与多项式.png" alt="对数与多项式.png">  </p></li><li><p>取对数求导法<br>y = x<sup>sin(x)</sup><br>=&gt; ln(y) = sin(x)ln(x)<br>=&gt; <img src="取对求导-1.png" alt="取对求导-1.png"><br>=&gt; <img src="取对求导-2.png" alt="取对求导-2.png"><br>=&gt; <img src="取对求导-3.png" alt="取对求导-3.png">  </p></li><li><p>指数增长与指数衰减  </p><p><img src="微分方程.png" alt="微分方程.png"><br>y变化率取决于这个量的大小。当k是正数就是指数增长，负数就是指数衰减。  </p><p>指数增长就是指的： P(t) = P<sub>0</sub>e<sup>kt</sup><br>这时候, dP/dt = kP<br>常见例子是无限条件下，兔子的增长。  </p><p>指数衰减：P(t) = P<sub>0</sub>e<sup>-kt</sup><br>dP/dt = -kP<br>常见例子是放射性原子的衰减。</p></li><li><p>双曲函数<br>![双曲函数.png])(双曲函数.png)<br><img src="双曲函数图像.png" alt="双曲函数图像.png">  </p><p>双曲函数有些像三角函数：</p><ol><li>cosh<sup>2</sup> - sinh<sup>2</sup> = 1</li><li>d(sinh(x))/dx = cosh(x) 及 d(cosh(x))/dx = sinh(x)  </li></ol><p><a href="https://www.zhihu.com/question/21239693" target="_blank" rel="noopener">双曲函数产生</a>  </p></li><li><p>小结：<br>从对称性上，我们可以看到初等函数可以分成很多空间，多项式函数、三角函数、指对函数。他们在很多时候，都在自己空间内玩。比如求导运算，多项式求导之后还是多项式，三角函数求导也还是三角函数。但对数函数却打破了这种规律，它的求导变成了有理函数，这真有趣。  </p><p>另一个是e，从定义上，就可以看到e是多么神奇的一个数字。</p></li></ul><h2 id="隐函数导数"><a href="#隐函数导数" class="headerlink" title="隐函数导数"></a>隐函数导数</h2><p>隐函数求导，比较适合于求等式的导数。</p><ul><li><p>示例<br>x<sup>2</sup> + y<sup>2</sup> = 4  </p><p>2x + 2y dy/dx = 0<br>dy/dx = -x/y  </p></li></ul><p>等式求导，一般关注于特定点，在特定点时，可以将等式求导之后，立即代入点，然后整理。对于二阶导，要等到求导2次之后再代入。</p><p>应用场景：求某个时刻的变化率问题，思路：<br>1、列出等式<br>2、等式求导  </p><h2 id="反函数导数"><a href="#反函数导数" class="headerlink" title="反函数导数"></a>反函数导数</h2><ul><li><p>导数与反函数存在<br>在区间内单调则反函数存在，单调意味着: f’(x)&gt;=0,或者f’(x)&lt;=0,且等于0的点有限。</p></li><li><p>公式<br><img src="反函数求导.png" alt="反函数求导.png"><br><img src="反函数求导-2.png" alt="反函数求导-2.png"><br> 把反函数表示出来，然后再代入原函数的导数，并求其倒数</p></li><li><p>示例<br>h(x) = x<sup>3</sup><br>h’(x) = 3x<sup>2</sup><br>反函数： y=x <sup>1/3</sup>  </p><p>代入可得反函数的导数 1/(3x<sup>2/3</sup>) </p></li></ul><h1 id="导数与图像"><a href="#导数与图像" class="headerlink" title="导数与图像"></a>导数与图像</h1><ul><li><p>函数的极值<br>假设函数 f 定义在开区间 (a, b) 内,并且点 c 在 (a, b) 区间内.如果点 c 为函数的局部最大值或最小值,那么点 c 一定为该函数的临界点.也就是说,f’(c) = 0 或 f’(c) 不存在  </p><p>闭区间[a,b]的最值，求f’(x) = 0的点，再加两个端点进行比较。</p></li><li><p>罗尔定理<br>假设函数 f 在闭区间[a, b]内连续,在开区间(a, b)内可导.如果 f(a) = f(b），那么在开区间 (a, b) 内至少存在一点 c, 使得 f‘(c) = 0.</p><p>也就是一定有极值点。</p></li><li><p>中值定理<br>假设函数 f 在闭区间[a, b]内连续,在开区间(a, b)内可导,那么在开区间(a, b)内至少有一点 c 使得：<br><img src="中值定理.png" alt="中值定理.png"><br><img src="中值定理图像.png" alt="中值定理图像.png"><br>可以看出，罗尔定理是中值定理的特例。  </p></li><li><p>二阶导数  </p><p>二级导数&gt;0时，图像像是一个凹向上的，像是碗的一部分;二阶导书&lt;0时，图像是凹向下的，像是倒着的碗。<br>拐点：在c点两侧，二阶导符号相异，则为拐点。<br><img src="拐点图像.png" alt="拐点图像.png"><br>这个感激挺有趣，经常听房价拐点、经济拐点，感觉像是在说极值点。这里的拐点却不是。<br>拐点处f’’(c) = 0，但反过来并不成立，比如f(x) = x<sup>4</sup>  </p></li></ul><h1 id="导数的应用"><a href="#导数的应用" class="headerlink" title="导数的应用"></a>导数的应用</h1><p>最优化涉及找出各种可能情况中最好的一种；<br>线性化是一种对难以计算的量找出其估算值的有用技术</p><h2 id="最优化"><a href="#最优化" class="headerlink" title="最优化"></a>最优化</h2><ol><li>找到变量  </li><li>找出等式  </li><li>消元  </li><li>求最值，可能用到隐函数求导  </li></ol><p>书上给出3个实例，这里不多介绍了  </p><h2 id="线性化"><a href="#线性化" class="headerlink" title="线性化"></a>线性化</h2><p>线性化其实是用直线（一阶函数）来拟合原函数（曲线），以求解问题。<br>f(a+∆x) ≈ f(a) + f’(a)∆x.<br><img src="线性化图像.png" alt="线性化图像.png">  </p><p>微分： 其中量df = f’(a)∆x，称为f在 x=a 处的微分。<br>误差： r(x) = f(x) - L(x)<br>      r(x) = f‘’(c)(x − a)<sup>2</sup> , 其中 c 为在 x 和 a 之间的某个数  </p><p>示例：  </p><ol><li>估算 (6.01)<sup>2</sup><br>f’(x) = 2x<br>df = f’(a)∆x = f’(6)(0.01) = 12 × (0.01) = 0.12<br>(6.01)<sup>2</sup> ≈ 36.12</li></ol><h2 id="估算零点的牛顿法"><a href="#估算零点的牛顿法" class="headerlink" title="估算零点的牛顿法"></a>估算零点的牛顿法</h2><p>牛顿法求0值，是线性化的一个应用  </p><p>假设现在要解一个形为 f (x) = 0 的方程,但你死活都解不出来.所以你退而求其次,试着猜测该方程有一个解,并把它记为 a. </p><p><img src="牛顿法图像.png" alt="牛顿法图像.png"><br><img src="牛顿法.png" alt="牛顿法.png">  </p><p>失效的情况：  </p><ul><li><p>f‘(a) 的值接近于 0.<br> <img src="牛顿法失效-1.png" alt="牛顿法失效-1.png">  </p></li><li><p>近似可能越来越糟<br> f (x) = x<sup>1/3</sup>，唯一解是 0 ，<br> 代入公式：b = -2a，除非从0开始，否则越来越糟糕  </p></li><li><p>可能限于左右循环<br> <img src="牛顿法失效-3.png" alt="牛顿法失效-3.png">  </p></li></ul><h2 id="洛必答法则"><a href="#洛必答法则" class="headerlink" title="洛必答法则"></a>洛必答法则</h2><p>洛必答法则本身容易记住，重点是使用时的变形，要点是是对不定式使用<br>除法情况：<br><img src="洛必达法则-1.png" alt="洛必达法则-1.png">  </p><p>除法=乘法，只须将一种一个变成倒数即可  </p><p>减法情况，需要将减法进行通分，变成除法  </p><p>指数情况，需要进行取对数，将指数编程乘法</p><p>示例：<br><img src="洛必答法则示例-1.png" alt="洛必答法则示例-1.png"><br><img src="洛必答法则示例-2.png" alt="洛必答法则示例-2.png"><br><img src="洛必答法则示例-3.png" alt="洛必答法则示例-3.png"><br><img src="洛必答法则示例-4.png" alt="洛必答法则示例-4.png">  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是微积分复习的第一篇，教材使用《普林斯顿微积分读本》，涵盖第1章-第14章的内容。 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数与微分  &amp;lt;=&lt;/li&gt;
&lt;li&gt;积分&lt;/li&gt;
&lt;li&gt;级数&lt;/li&gt;
&lt;li&gt;其他&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="理论" scheme="http://yoursite.com/categories/%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="微积分" scheme="http://yoursite.com/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>typeorm使用总结</title>
    <link href="http://yoursite.com/2019/07/11/typeorm%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/07/11/typeorm使用总结/</id>
    <published>2019-07-11T14:23:08.000Z</published>
    <updated>2019-07-15T00:17:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>总结一下typeorm常用的使用方法  </p><a id="more"></a><h1 id="entity"><a href="#entity" class="headerlink" title="entity"></a>entity</h1><h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><p>typeorm中，每个entity必须有主键</p><ul><li><p>普通主键</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Entity()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">TunnelPart</span></span>&#123;</span><br><span class="line">  @PrimaryGeneratedColumn()</span><br><span class="line">  id: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>uuid主键  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Entity()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseFileEntity</span> </span>&#123;</span><br><span class="line">  @PrimaryGeneratedColumn(<span class="string">"uuid"</span>)</span><br><span class="line">  id: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的主键，就是uuid  </p></li><li><p>多列主键  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Entity()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">StructureTeam</span> </span>&#123;</span><br><span class="line">    @PrimaryColumn(&#123; <span class="attr">type</span>: <span class="string">'int'</span> &#125;)</span><br><span class="line">    teamId: number;</span><br><span class="line"></span><br><span class="line">    @PrimaryColumn(&#123; <span class="attr">type</span>: <span class="string">'int'</span> &#125;)</span><br><span class="line">    structureId: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，就形成了一个有多列形成的主键  </p></li></ul><h2 id="ManyToOne与oneToMany"><a href="#ManyToOne与oneToMany" class="headerlink" title="ManyToOne与oneToMany"></a>ManyToOne与oneToMany</h2><p>ManyToOne 与 oneToMany是最常用的关系，两者可同时使用，ManyToOne可以单独使用，基本操作，如：保存、查询、级联删除等，放到后边下边来写，这里只写关系的建立  </p><h2 id="只建立ManyToOne"><a href="#只建立ManyToOne" class="headerlink" title="只建立ManyToOne"></a>只建立ManyToOne</h2>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Entity()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">TunnelSection</span></span>&#123;</span><br><span class="line">    @PrimaryGeneratedColumn()</span><br><span class="line">    id: number;</span><br><span class="line"></span><br><span class="line">    @Column(<span class="string">'int'</span>)</span><br><span class="line">    length: number;</span><br><span class="line"></span><br><span class="line">    @ManyToOne(<span class="function"><span class="params">type</span>=&gt;</span>TunnelMethod)</span><br><span class="line">    method: TunnelMethod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在ManyToOne的创建中，只提用一个参数即可，这个参数是一个箭头函数，指向One所对应的表<br>  关系在建立的时候，可以指明一些参数，比如OnDetete,当用<code>CASCADE</code>时，可以用作级联删除。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@ManyToOne(<span class="function"><span class="params">type</span>=&gt;</span>TunnelMethod, &#123; <span class="attr">onDelete</span>: <span class="string">'CASCADE'</span> &#125;)</span><br><span class="line">    method: TunnelMethod;</span><br></pre></td></tr></table></figure><h2 id="同时建立ManyToOne-与-OneToMany"><a href="#同时建立ManyToOne-与-OneToMany" class="headerlink" title="同时建立ManyToOne 与 OneToMany"></a>同时建立ManyToOne 与 OneToMany</h2>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Entity()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">TunnelFixture</span></span>&#123;</span><br><span class="line">    @PrimaryGeneratedColumn()</span><br><span class="line">    id: number;</span><br><span class="line"></span><br><span class="line">    @Column(<span class="string">'varchar'</span>, &#123;<span class="attr">length</span>: <span class="number">128</span>&#125;)</span><br><span class="line">    name: string;</span><br><span class="line"></span><br><span class="line">    @OneToMany(<span class="function"><span class="params">type</span> =&gt;</span> TunnelProcedure, procedure =&gt; procedure.fixture)</span><br><span class="line">    procedures: TunnelProcedure[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Entity()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">TunnelProcedure</span></span>&#123;</span><br><span class="line">    @PrimaryGeneratedColumn()</span><br><span class="line">    id: number;</span><br><span class="line"></span><br><span class="line">    @Column(<span class="string">"varchar"</span>, &#123;<span class="attr">length</span>: <span class="number">128</span>&#125;)</span><br><span class="line">    name: string;</span><br><span class="line"></span><br><span class="line">    @ManyToOne(<span class="function"><span class="params">type</span> =&gt;</span> TunnelFixture, fixture =&gt; fixture.procedures)</span><br><span class="line">    fixture: TunnelFixture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在建立双向关系时，除了指明所在的entity，还要指明对方entity的属性</p><h1 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h1><h2 id="relation查询"><a href="#relation查询" class="headerlink" title="relation查询"></a>relation查询</h2><p>  创建ManyToOne与OneToMany的关系以后，可以通过repository来查询</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Entity()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Photo</span> </span>&#123;</span><br><span class="line">    @PrimaryGeneratedColumn()</span><br><span class="line">    id: number;</span><br><span class="line"></span><br><span class="line">    @Column()</span><br><span class="line">    url: string;</span><br><span class="line"></span><br><span class="line">    @ManyToOne(<span class="function"><span class="params">type</span> =&gt;</span> User, user =&gt; user.photos)</span><br><span class="line">    user: User;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Entity()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    @PrimaryGeneratedColumn()</span><br><span class="line">    id: number;</span><br><span class="line"></span><br><span class="line">    @Column()</span><br><span class="line">    name: string;</span><br><span class="line"></span><br><span class="line">    @OneToMany(<span class="function"><span class="params">type</span> =&gt;</span> Photo, photo =&gt; photo.user)</span><br><span class="line">    photos: Photo[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userRepository = connection.getRepository(User);</span><br><span class="line"><span class="keyword">const</span> users = <span class="keyword">await</span> userRepository.find(&#123; <span class="attr">relations</span>: [<span class="string">"photos"</span>] &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> photoRepository = connection.getRepository(Photo);</span><br><span class="line"><span class="keyword">const</span> photos = <span class="keyword">await</span> photoRepository.find(&#123; <span class="attr">relations</span>: [<span class="string">"user"</span>] &#125;);</span><br></pre></td></tr></table></figure><h2 id="也可以用createQueryBuilder形式"><a href="#也可以用createQueryBuilder形式" class="headerlink" title="也可以用createQueryBuilder形式"></a>也可以用createQueryBuilder形式</h2>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> users = <span class="keyword">await</span> connection</span><br><span class="line">  .getRepository(User)</span><br><span class="line">  .createQueryBuilder(<span class="string">"user"</span>)</span><br><span class="line">  .leftJoinAndSelect(<span class="string">"user.photos"</span>, <span class="string">"photo"</span>)</span><br><span class="line">  .getMany();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> photos = <span class="keyword">await</span> connection</span><br><span class="line">  .getRepository(Photo)</span><br><span class="line">  .createQueryBuilder(<span class="string">"photo"</span>)</span><br><span class="line">  .leftJoinAndSelect(<span class="string">"photo.user"</span>, <span class="string">"user"</span>)</span><br><span class="line">  .getMany();</span><br></pre></td></tr></table></figure><p>  一直觉得relations只在findOne中，可用，看了官网，发现都可以。<br>  有些情况下，都是自己创建id字段来连接另外一个表使用，这种情况下，只能使用createQueryBuilder，查询出来的是地卡尔乘积的结果，有些情况下，需要经过去重处理。<br>  这里要注意<code>leftJoinAndSelect</code>与<code>leftJoin</code>的区别。leftJoin不会查询出join表的字段</p><h2 id="Raw查询"><a href="#Raw查询" class="headerlink" title="Raw查询"></a>Raw查询</h2><p>  getRawMany()时，注意给列起别名，否则列名包括了表名。查询的数据不是entity时，采用raw方式查询。包括联表的自定义字段、SUM、COUNT等函数</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">async</span> getMaterialList(subprojId:number, type?:string):<span class="built_in">Promise</span>&lt;Material[]&gt;&#123;</span><br><span class="line">      <span class="keyword">let</span> param = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">      param.subprojId = subprojId;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> condition = <span class="string">"material.subprojId=:subprojId "</span></span><br><span class="line">      <span class="keyword">if</span>(!isNullOrUndefined(type))&#123;</span><br><span class="line">          param.type = type</span><br><span class="line">          condition += <span class="string">" and material.type=:type"</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.materialRepos.createQueryBuilder(<span class="string">"material"</span>)</span><br><span class="line">              .select(<span class="string">"material.id"</span>, <span class="string">"id"</span>)</span><br><span class="line">              .addSelect(<span class="string">"material.type"</span>, <span class="string">"type"</span>)</span><br><span class="line">              .addSelect(<span class="string">"material.name"</span>, <span class="string">"name"</span>)</span><br><span class="line">              .addSelect(<span class="string">"material.unit"</span>, <span class="string">"unit"</span>)</span><br><span class="line">              .addSelect(<span class="string">"material.metaQuantityId"</span>, <span class="string">"metaQuantityId"</span>)</span><br><span class="line">              .addSelect(<span class="string">"material.subprojId"</span>, <span class="string">"subprojId"</span>)</span><br><span class="line">              .addSelect(<span class="string">"material.createAt"</span>, <span class="string">"createAt"</span>)</span><br><span class="line">              .addSelect(<span class="string">'materialPrice.price'</span>, <span class="string">"price"</span>)</span><br><span class="line">              .leftJoin(<span class="string">"material.price"</span>, <span class="string">"materialPrice"</span>)</span><br><span class="line">              .where(condition, param)</span><br><span class="line">              .getRawMany();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  注意join都是迪卡尔积，会有重复。<br>  OneToOne关系比较适合，不会用重复</p><h1 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h1><h2 id="LessThan、MoreThan、Between"><a href="#LessThan、MoreThan、Between" class="headerlink" title="LessThan、MoreThan、Between"></a>LessThan、MoreThan、Between</h2><p>  这里在repository中查询时，使用了以上区间函数;<br>  同样可以使用createQueryBuilder的当时完成相同的操作。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">async</span> getMaterialPriceList(materialId:number, startDate?:string, endDate?:string)&#123;</span><br><span class="line">  <span class="keyword">let</span> condition = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  condition.materialId = materialId;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(startDate!=<span class="literal">null</span> &amp;&amp; endDate==<span class="literal">null</span>)&#123;</span><br><span class="line">      condition.createAt =  MoreThan(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.parse(startDate)));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(startDate==<span class="literal">null</span> &amp;&amp; endDate!=<span class="literal">null</span>)&#123;</span><br><span class="line">      condition.createAt =  LessThan(<span class="keyword">new</span> <span class="built_in">Date</span>(endDate));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(startDate!=<span class="literal">null</span> &amp;&amp; endDate!=<span class="literal">null</span>)&#123;</span><br><span class="line">      condition.createAt = Between(<span class="keyword">new</span> <span class="built_in">Date</span>(startDate), <span class="keyword">new</span> <span class="built_in">Date</span>(endDate));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.priceRepos.find(&#123;...condition&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用createQueryBuilder完成区间查询："><a href="#用createQueryBuilder完成区间查询：" class="headerlink" title="用createQueryBuilder完成区间查询："></a>用createQueryBuilder完成区间查询：</h2>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">async</span> getMaterialPriceList(materialId:number, startDate?:string, endDate?:string)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.priceRepos.createQueryBuilder(<span class="string">"materialPice"</span>)</span><br><span class="line">          .where(<span class="string">'materialPice.materialId = :materialId'</span>)</span><br><span class="line">          .andWhere(<span class="string">'materialPice.createAt &gt;= :startDate'</span>)</span><br><span class="line">          .andWhere(<span class="string">'materialPice.createAt &lt;= :endDate'</span>)</span><br><span class="line">          .setParameters(&#123;<span class="attr">materialId</span>:materialId, <span class="attr">startDate</span>:<span class="keyword">new</span> <span class="built_in">Date</span>(startDate),<span class="attr">endDate</span>:<span class="keyword">new</span> <span class="built_in">Date</span>(endDate)&#125;)</span><br><span class="line">          .getMany();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h1><p>同样是使用skip与take来完成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> users = <span class="keyword">await</span> getRepository(User)</span><br><span class="line">    .createQueryBuilder(<span class="string">"user"</span>)</span><br><span class="line">    .leftJoinAndSelect(<span class="string">"user.photos"</span>, <span class="string">"photo"</span>)</span><br><span class="line">    .skip(<span class="number">5</span>)</span><br><span class="line">    .take(<span class="number">10</span>)</span><br><span class="line">    .getMany();</span><br></pre></td></tr></table></figure><h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><p>子查询是两个查询的嵌套，通常发生在where与from中</p><h2 id="where中"><a href="#where中" class="headerlink" title="where中"></a>where中</h2>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> posts = <span class="keyword">await</span> connection.getRepository(Post)</span><br><span class="line">  .createQueryBuilder(<span class="string">"post"</span>)</span><br><span class="line">  .where(<span class="function"><span class="params">qb</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> subQuery = qb.subQuery()</span><br><span class="line">          .select(<span class="string">"user.name"</span>)</span><br><span class="line">          .from(User, <span class="string">"user"</span>)</span><br><span class="line">          .where(<span class="string">"user.registered = :registered"</span>)</span><br><span class="line">          .getQuery();</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"post.title IN "</span> + subQuery;</span><br><span class="line">  &#125;)</span><br><span class="line">  .setParameter(<span class="string">"registered"</span>, <span class="literal">true</span>)</span><br><span class="line">  .getMany();</span><br></pre></td></tr></table></figure><p>  或者写成</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userQb = <span class="keyword">await</span> connection.getRepository(User)</span><br><span class="line">  .createQueryBuilder(<span class="string">"user"</span>)</span><br><span class="line">  .select(<span class="string">"user.name"</span>)</span><br><span class="line">  .where(<span class="string">"user.registered = :registered"</span>, &#123; <span class="attr">registered</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> posts = <span class="keyword">await</span> connection.getRepository(Post)</span><br><span class="line">  .createQueryBuilder(<span class="string">"post"</span>)</span><br><span class="line">  .where(<span class="string">"post.title IN ("</span> + userQb.getQuery() + <span class="string">")"</span>)</span><br><span class="line">  .setParameters(userQb.getParameters())</span><br><span class="line">  .getMany();</span><br></pre></td></tr></table></figure><h2 id="from中"><a href="#from中" class="headerlink" title="from中"></a>from中</h2>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> posts = <span class="keyword">await</span> connection</span><br><span class="line">  .createQueryBuilder()</span><br><span class="line">  .select(<span class="string">"user.name"</span>, <span class="string">"name"</span>)</span><br><span class="line">  .from(<span class="function"><span class="params">subQuery</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> subQuery</span><br><span class="line">          .select(<span class="string">"user.name"</span>, <span class="string">"name"</span>)</span><br><span class="line">          .from(User, <span class="string">"user"</span>)</span><br><span class="line">          .where(<span class="string">"user.registered = :registered"</span>, &#123; <span class="attr">registered</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">  &#125;, <span class="string">"user"</span>)</span><br><span class="line">  .getRawMany();</span><br></pre></td></tr></table></figure><p>  from中的“user“是别名，或者写成</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userQb = <span class="keyword">await</span> connection.getRepository(User)</span><br><span class="line">  .createQueryBuilder(<span class="string">"user"</span>)</span><br><span class="line">  .select(<span class="string">"user.name"</span>, <span class="string">"name"</span>)</span><br><span class="line">  .where(<span class="string">"user.registered = :registered"</span>, &#123; <span class="attr">registered</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> posts = <span class="keyword">await</span> connection</span><br><span class="line">  .createQueryBuilder()</span><br><span class="line">  .select(<span class="string">"user.name"</span>, <span class="string">"name"</span>)</span><br><span class="line">  .from(<span class="string">"("</span> + userQb.getQuery() + <span class="string">")"</span>, <span class="string">"user"</span>)</span><br><span class="line">  .setParameters(userQb.getParameters())</span><br><span class="line">  .getRawMany();</span><br></pre></td></tr></table></figure><h1 id="全列查询"><a href="#全列查询" class="headerlink" title="全列查询"></a>全列查询</h1><p>全表查询指的是对全部字段进行模糊查询，网上找资料看到一些方式，通过引入插件，再用函数的方式来实现，这样的实现在typeorm中很难实现。  </p><ul><li><p>列少时，可以考虑多列的模糊</p><p><code>select * from t where phonenum=&#39;digoal&#39; or info ~ &#39;digoal&#39; or c1=&#39;digoal&#39;</code>  </p></li><li><p>将所有字段记录在1列中，从一列中查询</p></li><li><p>pgsql中使用::text<br><code>select * from structure where structure::text like %大河%</code></p></li></ul><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;getManager&#125; <span class="keyword">from</span> <span class="string">"typeorm"</span>;</span><br><span class="line"><span class="keyword">await</span> getManager().transaction(<span class="keyword">async</span> transactionalEntityManager =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> transactionalEntityManager.save(users);</span><br><span class="line">    <span class="keyword">await</span> transactionalEntityManager.save(photos);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>事物可以使用装饰器方式来书写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Transaction()</span><br><span class="line">save(@TransactionManager() manager: EntityManager, <span class="attr">user</span>: User) &#123;</span><br><span class="line">    <span class="keyword">return</span> manager.save(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Transaction()</span><br><span class="line">save(user: User, @TransactionRepository(User) userRepository: Repository&lt;User&gt;) &#123;</span><br><span class="line">    <span class="keyword">return</span> userRepository.save(user);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在事务中指明隔离级别</p><h1 id="migration"><a href="#migration" class="headerlink" title="migration"></a>migration</h1><ul><li>需要注意其ormconfig.json配置文件的书写</li><li>其原理是通过检测migration中的文件，来执行文件，并且在数据库中创建一个migrations的数据表，用来存储执行过的文件。在执行的时候，会对比文件夹中的文件与数据库执行过的文件，并选择new的进行执行。</li><li>这种方式需要看一个revert如果执行。</li><li>migration其实是一种命令模式。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结一下typeorm常用的使用方法  &lt;/p&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
      <category term="nest.js" scheme="http://yoursite.com/tags/nest-js/"/>
    
  </entry>
  
  <entry>
    <title>hexo迁移记录</title>
    <link href="http://yoursite.com/2019/06/22/hexo%E8%BF%81%E7%A7%BB%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/06/22/hexo迁移记录/</id>
    <published>2019-06-22T14:44:25.000Z</published>
    <updated>2019-09-28T04:00:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>本次在家里机器上迁移hexo成功，对这次迁移做一点记录。</p><a id="more"></a><p>hexo需要2个库，一个github page用来做网页，另一个库用来存md。网上一般的方式是建立一个github page库，用2个分支来存放，我自己的做法是将网站放在github page下，然后创建了一个gitlab库放md。</p><ul><li><p>配置ssh<br>详见ssh与git配置两篇博客<br>这里由于2个帐号，注意.ssh/config的配置</p></li><li><p>clone库<br>从gitlab下将库clone下来</p></li><li><p>安装hexo[3.9.0]<br>装机部分已经安装了git、node.js，这里只安装hexo即可。<br>参照：<a href="https://www.zhihu.com/question/21193762" target="_blank" rel="noopener">hexo换电脑更新</a><br>需要在blog下执行：  </p><ul><li>npm install hexo  </li><li>npm install  </li><li>npm install hexo-deployer-git  </li></ul><p>这样并不能直接使用hexo，我又在global范围内安装了一边hexo  </p><ul><li>npm install hexo -g  </li><li>npm install hexo-cli -g  </li><li>npm install hexo-deployer-git -g</li></ul><p>这样感觉多安装了一边，但确实可以了，只安装global范围内时，在blog下不能执行hexo g</p></li><li><p>_config.yml配置修改  </p><pre><code class="yml"><span class="attr">deploy:</span><span class="attr">  type:</span> <span class="string">git</span><span class="attr">  repo:</span> <span class="string">git@github.com:xxx/xxx.github.io.git</span><span class="attr">  branch:</span> <span class="string">master</span><span class="attr">  name:</span> <span class="string">xxxx</span><span class="attr">  email:</span> <span class="string">xxxx@xxx.xx</span></code></pre><p>这次修改其中的user =&gt; name</p></li><li><p>遗留<br>hexo d时，曾出现过HEAD不对应，但重新安装了global的hexo问题解决，github page的git同步并没有研究，但最终完成了同步，像是hexo内部自己做了封装。  </p></li><li><p>推荐<br>搜索过程中发现一篇比价全的hexo搭建博客<a href="https://thief.one/2017/03/03/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">Hexo搭建博客教程</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本次在家里机器上迁移hexo成功，对这次迁移做一点记录。&lt;/p&gt;
    
    </summary>
    
      <category term="工具与运维" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E4%B8%8E%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu装机后</title>
    <link href="http://yoursite.com/2019/06/16/%E8%A3%85%E6%9C%BA%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/06/16/装机记录/</id>
    <published>2019-06-16T13:18:04.000Z</published>
    <updated>2020-01-10T07:51:47.885Z</updated>
    
    <content type="html"><![CDATA[<p>本次装机，话费了大半天的时间，ubuntu装机出现几次启动问题，后边的软件安装也颇费功夫。写一下本次的装机记录，以后可以考虑写成脚本来自动完成装机。</p><a id="more"></a><h1 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h1><ul><li><p><a href="https://zhuanlan.zhihu.com/p/59393289" target="_blank" rel="noopener">UEFI+GPT 与 BIOS+MBR</a><br>启动方式是指如何主板上的固件在开机自检后如何找到引导程序，有Legacy模式（BIOS + MBR）和UEFI模式（UEFI _+ GPT）。大家注意这里的对应即可。 UEFI是15年之后才比较火的一种启动方式，电脑启动速度快是它的一大特点。所以15年后很多电脑都是采用这种方式。而之前的主板都是采用Lagacy的模式。需要硬件支持。</p></li><li><p><a href="https://blog.csdn.net/u014292358/article/details/70195932" target="_blank" rel="noopener">分区</a><br>由于本次重装，并没有手动分区，这个当选项了。</p></li></ul><h1 id="基础软件"><a href="#基础软件" class="headerlink" title="基础软件"></a>基础软件</h1><ul><li><p><a href="https://blog.csdn.net/happywho250/article/details/52506321" target="_blank" rel="noopener">换源</a>  </p></li><li><p><a href="https://jingyan.baidu.com/article/f79b7cb31a990d9144023ea2.html" target="_blank" rel="noopener">安装chrome</a><br>sudo apt-get install chromium-browser  </p></li><li><p><a href="https://blog.csdn.net/duxu24/article/details/52955785" target="_blank" rel="noopener">安装wps</a><br>sudo dpkg -i  </p></li><li><p><a href="https://zhuanlan.zhihu.com/p/37914770" target="_blank" rel="noopener">安装node</a><br><a href="https://nodejs.org/en/" target="_blank" rel="noopener">node下载</a><br>tar 之后 ln -s  </p></li><li><p><a href="https://code.visualstudio.com/Download" target="_blank" rel="noopener">安装vscode</a><br>sudo dpkg -i  </p></li><li><p>安装git<br>sudo apt-get install git  </p></li></ul><h1 id="gitlab"><a href="#gitlab" class="headerlink" title="gitlab"></a>gitlab</h1><ul><li><p><a href="https://sunyanfeng.cn/2019/01/09/ssh%E5%85%8D%E5%AF%86%E9%85%8D%E7%BD%AE/" target="_blank" rel="noopener">git免密</a>  </p></li><li><p>翻墙<br>从ubuntu软件中心中下载shadowsocks，下载snap的</p><p><a href="https://ea.36fy.com/clientarea.php" target="_blank" rel="noopener">加速度</a>  </p><p>chromium –proxy-server=”socks5://127.0.0.1:1080”</p></li></ul><h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install -y \</span><br><span class="line">         apt-transport-https \</span><br><span class="line">         ca-certificates \</span><br><span class="line">         curl \</span><br><span class="line">         software-properties-common</span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line">sudo add-apt-repository \</span><br><span class="line">         <span class="string">"deb [arch=amd64] https://download.docker.com/linux/ubuntu <span class="variable">$(lsb_release -cs)</span> stable"</span></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install -y docker-ce</span><br><span class="line">sudo usermod -a -G docker $(whoami)</span><br><span class="line">newgrp docker</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本次装机，话费了大半天的时间，ubuntu装机出现几次启动问题，后边的软件安装也颇费功夫。写一下本次的装机记录，以后可以考虑写成脚本来自动完成装机。&lt;/p&gt;
    
    </summary>
    
      <category term="工具与运维" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E4%B8%8E%E8%BF%90%E7%BB%B4/"/>
    
    
  </entry>
  
  <entry>
    <title>next.js弃坑总结</title>
    <link href="http://yoursite.com/2019/05/23/next%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/05/23/next实践总结/</id>
    <published>2019-05-23T02:30:00.000Z</published>
    <updated>2019-07-01T02:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>关键字：next.js</p><a id="more"></a><h1 id="next-js接触"><a href="#next-js接触" class="headerlink" title="next.js接触"></a>next.js接触</h1><p>接触next.js的过程在<a href>next.js记录</a>中已经说过了，主要是在自己搭建后台渲染过程中，使用了web-isomorphic-tools，而它官网中，推荐使用其进化版本universal-tools或者使用集成了universal-tools的next.js。而自己搭建的渲染，跳过了无数坑之后，渲染Materila-Ui组件时失败，况且不知道越过这坑后边是否还有坑，索性研究一下next.js.</p><p>next.js是一个后台渲染的MPA（多页面应用）</p><h1 id="next-js优点"><a href="#next-js优点" class="headerlink" title="next.js优点"></a>next.js优点</h1><ul><li><p>后台渲染做的不错<br>对Material-Ui支持不错</p></li><li><p>代码切割做的不错<br>本身是不过加载页面中不用的component，也可以手动进行动态加载，并支持prefetch(预取)的功能，提高加载的速度。</p></li><li><p>动态数据加载做的可以<br>由前端服务器向api server获取数据使用getInitPrepoty的方式不错</p></li></ul><h1 id="next-js缺点"><a href="#next-js缺点" class="headerlink" title="next.js缺点"></a>next.js缺点</h1><p>这里的缺点是针对我们应用的场景而言</p><ul><li><p>文件系统路由的方式不太适合<br>虽然它支持定制路由，但也仅是做了as，类似于一个别名，还需要服务侧做转换。<br>并且由于文件系统路由，使它内部仅支持用query方式(url?key=value)传参，若需要param方式(/:userId)，需要使用定制url。</p></li><li><p>对componet不太友好<br>在面临选择page还是componet时，next.js偏向与page。比如通过link导向一个page，然后在page进行一些操作之后，通过component切换的形式来做一些view的切换，这时候如果想再逆操作时，没法通过点击link的方式进行切换，只能自己控制。link发现地址没变，点击不会响应。  </p></li><li><p>传参问题<br>由于更多的页面，在传值问题上存在更多的挑战。使用react的component，可以愉快的使用向下流的传值，而页面只能在地址中增加一些id，然后在页面内部再次去获取数据，这样效率比较低一些。</p></li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>与同事讨论之后，我们觉得，next.js更适合向博客、新闻等使用场景，不太适合写数据交互多的场景，这样就准备弃用了。<br>如果非要用next.js来写的话，感觉可以将next.js做一个后端渲染的活，然后在next.js之上移植react-router，由MPA转换成SPA，这方面的资料在next.js github的issue中可以找到一点，有兴趣的朋友可以考虑一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关键字：next.js&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="next.js" scheme="http://yoursite.com/tags/next-js/"/>
    
  </entry>
  
  <entry>
    <title>同构SPA应用jwt实践</title>
    <link href="http://yoursite.com/2019/05/23/%E5%90%8C%E6%9E%84SPA%E5%BA%94%E7%94%A8jwt%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2019/05/23/同构SPA应用jwt实践/</id>
    <published>2019-05-23T01:30:00.000Z</published>
    <updated>2019-07-01T02:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>关键字：Isomorphic、SPA、Jwt</p><a id="more"></a><h1 id="Jwt简介"><a href="#Jwt简介" class="headerlink" title="Jwt简介"></a>Jwt简介</h1><p>先介绍一下Jwt:<a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener">Jwt简介</a></p><h1 id="3层过程"><a href="#3层过程" class="headerlink" title="3层过程"></a>3层过程</h1><ul><li>浏览器获取页面，前端服务器发现未登录，重定向到登录页面&lt;这个重定向由后端控制&gt;</li><li>录入用户、密码，发送给accout后端服务，验证信息，返回jwt给浏览器</li><li><p>登录成功，浏览器重定向到主页面，此时携带token&lt;这个重定向由浏览器控制&gt;</p></li><li><p>前端服务器接收到主页的请求，再次进行验证，发现已经登录，返回主页面</p></li><li>浏览器做前端渲染，向后台请求数据时，携带token。进行验证。</li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li><p>查资料说，token可以通过cookie来设置，也可以通过localStorage来设置<br>token通过Set-Cookie的方式发送给浏览器但一直没有设置成功，设置了domain、path、max-age<br><a href="http://bubkoo.com/2014/04/21/http-cookies-explained/" target="_blank" rel="noopener">cookie详解</a><br>后来通过浏览器调用document.cookie来进行设置</p></li><li><p>使用cookie设置的问题<br>token时间与cookie时间问题，token与cookie各有自己的过期时间，两个时间不一致会存在问题，不太喜欢2个源的东西。</p></li><li><p>使用localStorage的问题<br>存储在LocalStorag里的问题是，无法在向前端服务器请求页面的时候，自动携带这个token。</p></li><li><p>后端缓存token的问题<br>jwt本身设计就是stateless，如果加上缓存，就是一有状态的东西，与sessionId的使用一致。<br>需要用一些规则来包成token的安全</p></li></ul><h1 id="token安全规则"><a href="#token安全规则" class="headerlink" title="token安全规则"></a>token安全规则</h1><p>  <a href="https://stackoverflow.com/questions/30523238/best-practices-for-server-side-handling-of-jwt-tokens" target="_blank" rel="noopener">token最佳实践</a></p><h1 id="2层过程"><a href="#2层过程" class="headerlink" title="2层过程"></a>2层过程</h1><p>思维过程如下：<br>用cookie来传输jwt由于2个过期时间，所以弃用<br>=&gt; 选择localStorage来存储<br>=&gt; 无法给前端服务器携带<br>=&gt; 放弃前端服务器重定向<br>=&gt; 使用浏览器端的重定向</p><p>浏览器端的重定向通过判断localStorage中是否存在jwt来判断是否登录，判断时机是整个页面重渲染时，由于是Isomorphic的SPA，这个时机可以认为是在页面第一次从后端取之后，前端第一次渲染时做的判断。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关键字：Isomorphic、SPA、Jwt&lt;/p&gt;
    
    </summary>
    
    
      <category term="jwt" scheme="http://yoursite.com/tags/jwt/"/>
    
  </entry>
  
  <entry>
    <title>Matrix-图像压缩与伪逆</title>
    <link href="http://yoursite.com/2019/05/22/Matrix-%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9%E4%B8%8E%E4%BC%AA%E9%80%86/"/>
    <id>http://yoursite.com/2019/05/22/Matrix-图像压缩与伪逆/</id>
    <published>2019-05-21T22:32:16.000Z</published>
    <updated>2019-07-01T02:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>原课程Lessson31～Lesson32课，图像压缩是基于基变换，伪逆</p><a id="more"></a><h1 id="图像压缩"><a href="#图像压缩" class="headerlink" title="图像压缩"></a>图像压缩</h1><ul><li>图像的向量表示<br>对于一副512×512的的黑白图像，它有512<sup>2</sup>个像素，每个像素用8bit的信息来表达，<img src="图片的矩阵表示.png" alt="图片的矩阵表示"></li><li>压缩的必要性<br>如果采用标准基(I)，来表示每一张图片，每一张图片都需要512<sup>2</sup>bit的数据，那所用的带宽太高。如果根据JPEG的标准，换一种基来表达，那么可以更高效的表达、传输数据。<br>以黑板为例，如果是标准基，那每个图片，都需要那么多的数据，但如果用一种基，其中一个基向量代表亮度，那黑板图片，就可以压缩到很小。<br>下边整理一下常见的基.  </li></ul><h2 id="傅里叶基"><a href="#傅里叶基" class="headerlink" title="傅里叶基"></a>傅里叶基</h2><p><img src="傅里叶基.png" alt="傅里叶基"><br>在JPEG中，使用的是w<sup>jk</sup>的实部，也就是cos分量。<br>它将512<sup>2</sup>的向量，分裂成8×8的小块，然后进行压缩，然后剔除掉系数低于某阈值。<br><img src="傅里叶基的使用.png" alt="傅里叶基的使用"></p><h2 id="小波基"><a href="#小波基" class="headerlink" title="小波基"></a>小波基</h2><p><img src="小波基.png" alt="小波基"><br>JPEG2000中采用小波基从上图中可以看出，示例小波基中，每个向量的非零元素在折半递减。</p><h2 id="压缩与矩阵"><a href="#压缩与矩阵" class="headerlink" title="压缩与矩阵"></a>压缩与矩阵</h2><p>  线性代数用来计算从标准基到傅里叶基或者小波基的系数。<br>  <img src="图像基变换公式1.png" alt="图像基变换公式1"><br>  <img src="图像基变换公式2.png" alt="图像基变换公式2"><br>  故，可得c = W<sup>-1</sup>x.<br>  上式中，如果选择合适的基向量使W<sup>-1</sup> = W<sup>T</sup>，这样计算效率就会大大提高。</p><h1 id="基变换"><a href="#基变换" class="headerlink" title="基变换"></a>基变换</h1><p>对于一个在旧基的向量A，可以通过x=Wc关系，转换到新基体系中，转换后的向量是B。<br>A和B是相似的: B=M<sup>-1</sup>AM  </p><p>对于旧基，用v<sub>1</sub>,v<sub>2</sub>…v<sub>8</sub>来表示<br>A暂时用v来表示： <img src="v表示.png" alt="v表示"><br>转换之后表示为： T(v) = c<sub>1</sub>T(v<sub>1</sub>) + c<sub>2</sub>T(v<sub>2</sub>) + … +c<sub>8</sub>T(v<sub>8</sub>)</p><p>如果T(v<sub>i</sub>) = λ<sub>i</sub>x<sub>i</sub>，这样的变化效率是最高的，但计算一个图像的特征向量，是一件计算量很大的操作，所以不如用佛里叶变换或小波变换。  </p><h1 id="左逆"><a href="#左逆" class="headerlink" title="左逆"></a>左逆</h1><p>左逆是矩阵A：m×n rank(A) = n而言的，川型矩阵</p><p>(A<sup>T</sup>A)<sup>-1</sup>A<sup>T</sup>A = I 我们说：<br><img src="A的左逆.png" alt="A的左逆"> 是A 的左逆。</p><h1 id="右逆"><a href="#右逆" class="headerlink" title="右逆"></a>右逆</h1><p>同样的道理，来类比右逆，右逆是对A: m×n rank(A) = m而言，三型矩阵<br><img src="A的右逆.png" alt="A的右逆"> 是A的右逆。</p><h1 id="伪逆"><a href="#伪逆" class="headerlink" title="伪逆"></a>伪逆</h1><p>左右逆解决了长方形矩阵的逆的问题，但对于奇异矩阵，如何来找到最佳的逆呢？伪逆。<br>因为是奇异矩阵，Ax=0存在非0解，存在着null space，也就不可能有逆的存在。伪逆其实建立的是A的row space与column space之间对应关系。A中row space 中的向量与column space中的向量一一对应。证明略。<br>向量x在row space中 Ax转换到column space上，称之为Ax， 然后再通过A<sup>+</sup>，再转换回来。<img src="伪逆.png" alt="伪逆">  </p><p>A = UΣV<sup>T</sup>  =&gt;  A<sup>+</sup> = UΣ<sup>+</sup>V<sup>T</sup>.</p><p>Σ<sup>+</sup>:1/σ1, 1/σ2, …, 1/σ</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原课程Lessson31～Lesson32课，图像压缩是基于基变换，伪逆&lt;/p&gt;
    
    </summary>
    
      <category term="理论" scheme="http://yoursite.com/categories/%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="Matrix" scheme="http://yoursite.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>问题汇总</title>
    <link href="http://yoursite.com/2019/05/15/%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2019/05/15/问题汇总/</id>
    <published>2019-05-14T16:00:00.000Z</published>
    <updated>2019-07-01T02:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录踩的坑</p><a id="more"></a><h1 id="nest框架的坑"><a href="#nest框架的坑" class="headerlink" title="nest框架的坑"></a>nest框架的坑</h1><ul><li><p>搭建pms-account后，连接报502 bad gateway的错<br>描述：<br>pms-account运行后，报502的错  </p><p>解决：<br>报502的错问题很多，这一次是docker运行时候，暴露的端口是10001,而服务启动时候的端口是3000，修改后问题解决  </p></li><li><p>bcrypt的坑<br>描述1：<br>bcrypt在阿华电脑上启动是，报的是node module version的一个错</p><p>解决1：<br>怀疑是node版本造成的问题，对比后发现在build在主机上执行，node版本是10.0+的版本，而运行是在docker中，node版本是8.+版本。<br>删除node_module，在容器中重新编译，然后运行，问题解决。  </p><p>描述2：<br>在阿里云上install事，一直安装不了bcrypt  </p><p>解决2：<br>怀疑也是版本问题，但同样的解决方式虽然install成功了，但却不可运行，还在继续</p></li></ul><h1 id="node"><a href="#node" class="headerlink" title="node"></a>node</h1><ul><li><p>找不到package的坑<br>描述：<br>Couldn’t find package “package-name” on the “npm” registry  </p><p>解决：<br>npm源是官方源，换了一个淘宝源后，问题解决，这个有点真坑<br>查看：<code>npm get registry</code><br>修改：<code>npm config set registry https://registry.npm.taobao.org</code></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录踩的坑&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>next.js基础</title>
    <link href="http://yoursite.com/2019/05/12/next%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/05/12/next基础/</id>
    <published>2019-05-12T07:35:49.000Z</published>
    <updated>2019-07-01T02:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文为学习next.js而做的笔记，主要参照<a href="https://nextjs.org/docs" target="_blank" rel="noopener">官网</a> ，也会借鉴<a href="https://juejin.im/post/5b868b45e51d4538ae4db7ca" target="_blank" rel="noopener">Next.js踩坑</a>  </p><a id="more"></a><h1 id="起因与目的"><a href="#起因与目的" class="headerlink" title="起因与目的"></a>起因与目的</h1><p>最早接触next.js是在看webpack-isomorphic-tools的官网时候，其推荐新项目使用universal-tools，或者直接用next.js这样的框架。那时候基于create-react-app而搭建的同构已经走了大半，没有继续研究next.js。而搭建的系统遇到了stylus问题，一时间没有找到解决方案，就试着接触一下next.js，一方面想看一下next.js是如何解决这个问题的，另一方也看一下是否可以直接使用next.js。<br>看过之后，觉得next.js是不错的框架，值得去整理一下。</p><p>next.js是一个基于react的SSR框架，它有很多特性值得去应用，下边对这些特性进行整理  </p><p>对于SSR，首先它需要根据浏览器的路径，选择合适的页面、组件进行渲染；<br>其次，<code>&lt;head&gt;</code>中对静态文件的引用，页面中也会包含一些静态的文件，包括react、material的js，还有一些图片等；<br>接着，页面、组件加载时为了提升性能，就需要一些技术：代码切割、预取页面、动态导入等<br>然后，对于有些请求，需要从api sever中加载数据，然后再渲染到页面上；<br>再然后，对于登录，需要判断是否登录（头部判断），再进行路由的跳转；<br>最后，在同构的时候react-router有对history的使用，对于这一点有点疑问，浏览器显然是有自己的一块存储区域来存储历史，为什么在服务器也会看到history？<br>这期间还夹杂一些基础，如对css的支持、路由的参数等</p><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><h2 id="文件系统路由"><a href="#文件系统路由" class="headerlink" title="文件系统路由"></a>文件系统路由</h2><p>  next.js是一个文件系统路由，意思是，需要一个pages目录，这个目录对应’/‘路由；若存在’/home’路由，则需要page目录下有一个home目录。路由与目录结构对应。  </p><p>  这种方式跟最早接触的tomcat有些类似，也与http的静态文件形态时候形同。<br>  webship中维护一个路由与文件的映射；<br>  react-router常见的用法是SPA，只有一个页面，也就不太需要这种映射。</p><h2 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h2><p>  Next.js没有一个记录所有路由的清单，当前页面对其他页面一无所知。这样，浏览器中页面的组织、跳转是通过<code>Link</code>来完成的.与html的<code>&lt;a&gt;</code>标签很相似。  </p><p>  它有2个主要属性：<br>  <code>href</code>：a标签的href，包括路由+请求参数。<br>  <code>as</code>：在浏览器中展示的URL。这个听起来有点怪，需要多做一个说明。<code>next.js</code>本身只支持文件系统路由 与 query形式的参数传递，但为了支持制定方式，可以讲文件系统路由命名成其他的路由，展示在浏览器上。这个就是定制路由</p><p>  url参数：<br>  <code>/about?name=Zeit</code>，从根上，next只支持query形式的传参，对于param形式的传参，需要用<code>as</code></p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link href=&#123;&#123; pathname: '/about', query: &#123; name: 'Zeit' &#125; &#125;&#125;&gt;</span><br><span class="line">  &lt;a&gt;here&lt;/a&gt;</span><br><span class="line">&lt;/Link&gt;</span><br></pre></td></tr></table></figure><h2 id="定制路由"><a href="#定制路由" class="headerlink" title="定制路由"></a>定制路由</h2><ul><li>对于<code>/post/:slug</code>路由  </li><li><p>需要在<code>pages/post.js</code>  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Post</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">async</span> getInitialProps(&#123; query &#125;) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'SLUG'</span>, query.slug);</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>My blog post<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Post;</span><br></pre></td></tr></table></figure></li><li><p>在服务增加一个对<code>/post/:slug</code>路由的响应  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.get(<span class="string">'/post/:slug'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> app.render(req, res, <span class="string">'/post'</span>, &#123; <span class="attr">slug</span>: req.params.slug &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里需要将这个<code>/post/:slug</code>路由转换成内部的<code>/post</code>路由，参数通过query的方式传递。</p></li><li><p>在前端使用<code>next/link</code>  </p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link href=<span class="string">"/post?slug=something"</span> <span class="keyword">as</span>=<span class="string">"/post/something"</span>&gt;</span><br></pre></td></tr></table></figure></li></ul><h1 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h1><ul><li><p>static<br>next.js除了pages目录用于放页面，还有一个static目录用于存放静态文件，这个目录是设定死的，不能改变。路由上使用<code>/  static/</code>与之对应。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyImage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/static/my-image.png"</span> <span class="attr">alt</span>=<span class="string">"my image"</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">export default MyImage;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="加载性能"><a href="#加载性能" class="headerlink" title="加载性能"></a>加载性能</h1><h2 id="代码切割"><a href="#代码切割" class="headerlink" title="代码切割"></a>代码切割</h2><p>  代码切割不应该属于静态文件，指的是对于页面，仅会加载<code>import</code>到的组件，并不会加载其他组件。  </p><h2 id="预取页面"><a href="#预取页面" class="headerlink" title="预取页面"></a>预取页面</h2><p><code>prefetch</code>预取页面是<code>Link</code>的第三个属性，加上它，next.js会在后台自动加载这些页面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">'next/link'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;nav&gt;</span><br><span class="line">            &lt;Link prefetch href=<span class="string">"/"</span>&gt;</span><br><span class="line">                &lt;a&gt;Home&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>Link&gt;</span><br><span class="line">            &lt;Link prefetch href=<span class="string">"/about"</span>&gt;</span><br><span class="line">                &lt;a&gt;About&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>Link&gt;</span><br><span class="line">            &lt;Link prefetch href=<span class="string">"/contact"</span>&gt;</span><br><span class="line">                &lt;a&gt;Contact&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>Link&gt;</span><br><span class="line">        &lt;<span class="regexp">/nav&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default Header;</span></span><br></pre></td></tr></table></figure><h2 id="动态引用组件"><a href="#动态引用组件" class="headerlink" title="动态引用组件"></a>动态引用组件</h2><p>动态引用可以认为是另一种控制代码切割的方式。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// components/hello.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dynamic <span class="keyword">from</span> <span class="string">'next/dynamic'</span>;</span><br><span class="line"><span class="keyword">const</span> DynamicComponent = dynamic(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../components/hello'</span>));</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Header /&gt;</span><br><span class="line">      &lt;DynamicComponent /&gt;</span><br><span class="line">      &lt;p&gt;HOME PAGE is here!<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default Home;</span></span><br></pre></td></tr></table></figure><p>动态引入还支持对组件的引入不使用SSR。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dynamic <span class="keyword">from</span> <span class="string">'next/dynamic'</span>;</span><br><span class="line"><span class="keyword">const</span> DynamicComponentWithNoSSR = dynamic(</span><br><span class="line">  () =&gt; <span class="keyword">import</span>(<span class="string">'../components/hello3'</span>),</span><br><span class="line">  &#123;</span><br><span class="line">    ssr: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Header /&gt;</span><br><span class="line">      &lt;DynamicComponentWithNoSSR /&gt;</span><br><span class="line">      &lt;p&gt;HOME PAGE is here!<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Home;</span></span><br></pre></td></tr></table></figure><h1 id="动态数据加载"><a href="#动态数据加载" class="headerlink" title="动态数据加载"></a>动态数据加载</h1><p>当页面启动需要加载数据时，使用<code>getInitialProps</code>函数来完成，它可以异步获取数据，并解析成对象，并发送给<code>props</code>。注意，<code>getInitialProps</code> 仅可以在pages中使用，不能在components中使用。其仅用于渲染在页面路由中有参数，需要根据这些参数来获取数据并进行渲染的情况。对于动态的交互，还是需要ajax。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloUA</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">async</span> getInitialProps(&#123; req &#125;) &#123;</span><br><span class="line">    <span class="keyword">const</span> userAgent = req ? req.headers[<span class="string">'user-agent'</span>] : navigator.userAgent;</span><br><span class="line">    <span class="keyword">return</span> &#123; userAgent &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello World &#123;this.props.userAgent&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> HelloUA;</span><br></pre></td></tr></table></figure><h1 id="定制路由-1"><a href="#定制路由-1" class="headerlink" title="定制路由"></a>定制路由</h1><p>定制路由，next.js的文档写的有点没跟上，大体记录一下：</p><h2 id="路由修改"><a href="#路由修改" class="headerlink" title="路由修改"></a>路由修改</h2><p>  其实与link的as类似，在express中，对外展示一层，对内依然用文件系统路由。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">app.prepare().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"> createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">// Be sure to pass `true` as the second argument to `url.parse`.</span></span><br><span class="line">   <span class="comment">// This tells it to parse the query portion of the URL.</span></span><br><span class="line">   <span class="keyword">const</span> parsedUrl = parse(req.url, <span class="literal">true</span>);</span><br><span class="line">   <span class="keyword">const</span> &#123; pathname, query &#125; = parsedUrl;</span><br><span class="line">   <span class="keyword">if</span> (pathname === <span class="string">'/a'</span>) &#123;</span><br><span class="line">     app.render(req, res, <span class="string">'/b'</span>, query);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pathname === <span class="string">'/b'</span>) &#123;</span><br><span class="line">     app.render(req, res, <span class="string">'/a'</span>, query);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     handle(req, res, parsedUrl);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;).listen(<span class="number">3000</span>, err =&gt; &#123;</span><br><span class="line">   <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'&gt; Ready on http://localhost:3000'</span>);</span><br><span class="line"> &#125;);</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="后端禁用文件系统路由"><a href="#后端禁用文件系统路由" class="headerlink" title="后端禁用文件系统路由"></a>后端禁用文件系统路由</h2><p>  如果使用定制路由，文件系统路由的方式可能会导致从多个路由里边访问的内容是一样的情况，可以禁用掉文件系统路由。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// next.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  useFileSystemPublicRoutes: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  useFileSystemPublicRoutes属性会禁用掉SSR侧的文件名路由，CSR侧可能继续提供。对于CSR侧的需要<code>popstate</code></p><p>  以上是官方提供的文档，但并没有提供SSR侧禁用文件系统路由之后，服务端的渲染该如何处理的方案。</p><h2 id="前端拦截popstate"><a href="#前端拦截popstate" class="headerlink" title="前端拦截popstate"></a>前端拦截<code>popstate</code></h2><p>监听<code>popstate</code>，在router响应之前进行拦截，这样可以操作request，或者强制SSR刷新。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'next/router'</span>;</span><br><span class="line">Router.beforePopState(<span class="function">(<span class="params">&#123; url, <span class="keyword">as</span>, options &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// I only want to allow these two routes!</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">as</span> !== <span class="string">'/'</span> || <span class="keyword">as</span> !== <span class="string">'/other'</span>) &#123;</span><br><span class="line">    <span class="comment">// Have SSR render bad routes as a 404.</span></span><br><span class="line">    <span class="built_in">window</span>.location.href = <span class="keyword">as</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>返回false时，router不再处理<code>popstate</code></p><h2 id="router对象的使用"><a href="#router对象的使用" class="headerlink" title="router对象的使用"></a>router对象的使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'next/router'</span>;</span><br><span class="line"><span class="keyword">const</span> handler = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  Router.push(&#123;</span><br><span class="line">    pathname: <span class="string">'/about'</span>,</span><br><span class="line">    query: &#123; <span class="attr">name</span>: <span class="string">'Zeit'</span> &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReadMore</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      Click &lt;span onClick=&#123;handler&#125;&gt;here&lt;<span class="regexp">/span&gt; to read more</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ReadMore;</span><br></pre></td></tr></table></figure><p>这里的功能与<code>&lt;link&gt;</code>相同，但在router上可以监听很多时间，包括<code>routeChangeStart(url)</code>、<code>routeChangeComplete(url)</code>。<br>通过:  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Router.events.on(<span class="string">'routeChangeStart'</span>, handleRouteChange);</span><br></pre></td></tr></table></figure><h1 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h1><p>页面跳转其实是express的功能，只需要将res.redirect(301, ‘/new/link’)即可。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> next = <span class="built_in">require</span>(<span class="string">'next'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; join &#125; = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> dev = process.env.NODE_ENV !== <span class="string">'production'</span></span><br><span class="line"><span class="keyword">const</span> app = next(&#123; dev &#125;)</span><br><span class="line"><span class="keyword">const</span> handle = app.getRequestHandler()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> redirects = [</span><br><span class="line">  &#123; <span class="attr">from</span>: <span class="string">'/old-link-1'</span>, <span class="attr">to</span>: <span class="string">'/new-link-1'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">from</span>: <span class="string">'/old-link-2'</span>, <span class="attr">to</span>: <span class="string">'https://externalsite.com/new-link-2'</span> &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">app.prepare().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> server = express()</span><br><span class="line"></span><br><span class="line">  redirects.forEach(<span class="function">(<span class="params">&#123; <span class="keyword">from</span>, to, type = <span class="number">301</span>, method = <span class="string">'get'</span> &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    server[method](<span class="keyword">from</span>, (req, res) =&gt; &#123;</span><br><span class="line">      res.redirect(type, to)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  server.get(<span class="string">'*'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> handle(req, res)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  server.listen(<span class="number">3000</span>, err =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'&gt; Ready on http://localhost:3000'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>package.json:  </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"dev"</span>: <span class="string">"node server.js"</span>,</span><br><span class="line">  <span class="attr">"start"</span>: <span class="string">"NODE_ENV=production node server.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于登录，可以在’*’中，检查req来进行重定向</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="lt-App-gt"><a href="#lt-App-gt" class="headerlink" title="&lt;App&gt;"></a><code>&lt;App&gt;</code></h2><p>next利用App组件来初始化页面，我们可以重写它来控制页面的初始化，可以处理：</p><ul><li>在页面变换时，持久化布局  </li><li>在页面导航时，保存状态  </li><li>注入额外的数据</li><li>使用<code>componentDidCatch</code>来做定制的错误处理</li></ul><p>创建一个pages/_app.js，然后继承App来实现即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> App, &#123; Container &#125; <span class="keyword">from</span> <span class="string">'next/app'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">async</span> getInitialProps(&#123; Component, ctx &#125;) &#123;</span><br><span class="line">    <span class="keyword">let</span> pageProps = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (Component.getInitialProps) &#123;</span><br><span class="line">      pageProps = <span class="keyword">await</span> Component.getInitialProps(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; pageProps &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; Component, pageProps &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Container&gt;</span><br><span class="line">        &lt;Component &#123;...pageProps&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Container&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default MyApp;</span></span><br></pre></td></tr></table></figure><h2 id="lt-Document-gt"><a href="#lt-Document-gt" class="headerlink" title="&lt;Document&gt;"></a><code>&lt;Document&gt;</code></h2><p>用于改变初始化时候服务端渲染的document标记。处理与App类似<br>修改pages/_document.js，继承自Document</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为学习next.js而做的笔记，主要参照&lt;a href=&quot;https://nextjs.org/docs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网&lt;/a&gt; ，也会借鉴&lt;a href=&quot;https://juejin.im/post/5b868b45e51d4538ae4db7ca&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Next.js踩坑&lt;/a&gt;  &lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="next.js" scheme="http://yoursite.com/tags/next-js/"/>
    
  </entry>
  
  <entry>
    <title>阿里云使用</title>
    <link href="http://yoursite.com/2019/05/12/%E9%98%BF%E9%87%8C%E4%BA%91%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/05/12/阿里云使用/</id>
    <published>2019-05-11T16:00:00.000Z</published>
    <updated>2019-07-01T02:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>总结阿里云使用需要注意的问题</p><a id="more"></a><h1 id="阿里云新实例的坑"><a href="#阿里云新实例的坑" class="headerlink" title="阿里云新实例的坑"></a>阿里云新实例的坑</h1><ul><li><p>80端口不可用的坑<br>描述：<br>搭建起来之后运行core-nginx失败，log日志中什么都没用，80端口也没有被占用</p><p>解决：<br>每个esc都有自己的安全组，需要在阿里云控制台，需要开相应的端口<br>然后，连接后，ubunt预装了防火墙，需要放行80端口，与行<code>ufw allow http</code>即可<br><a href="https://help.aliyun.com/knowledge_detail/59367.html#ubuntu" target="_blank" rel="noopener">ubuntu</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结阿里云使用需要注意的问题&lt;/p&gt;
    
    </summary>
    
      <category term="工具与运维" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E4%B8%8E%E8%BF%90%E7%BB%B4/"/>
    
    
  </entry>
  
</feed>
