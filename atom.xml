<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>思 见</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-29T08:51:25.316Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>sun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>对js中{}的思考</title>
    <link href="http://yoursite.com/2018/11/29/%E5%AF%B9js%E4%B8%AD&#39;%7B%7D&#39;%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://yoursite.com/2018/11/29/对js中&#39;{}&#39;的思考/</id>
    <published>2018-11-29T08:31:47.000Z</published>
    <updated>2018-11-29T08:51:25.316Z</updated>
    
    <content type="html"><![CDATA[<p>这次在现场对于新给的工程量的解析与存储时，又发现对于js中”{}”的使用又存在着疑惑，这个疑惑在以前分析过，但记录确实找不到了，现对它再次进行分析。<br><a id="more"></a></p><h1 id="js中的”-”与C-中的map"><a href="#js中的”-”与C-中的map" class="headerlink" title="js中的”{}”与C++中的map"></a>js中的”{}”与C++中的map</h1><p>  c++中的map与js中的”{}”都是一种键值对的结构，键是唯一的，可以通过键快速的访问value。</p><p>  在c++的STL的map中，我们可以将一个类的对象作为键值放在key的位置，value的位置可以放任意数据，key位置的数据需要实现&lt;的比较运算即可，但”{}”的键值对是片面的键值对，因为其只能是字符串-值的。</p><p>  这里可以再引申一下js中的Map，这个Map号称是键值对，它也确实可以将对象存在key的位置上，但它是巨坑的实现，因为它的key位置的唯一不是按key对象的值来判断的，而是按地址来判断的。</p><h1 id="js中的”-”与C-中的struct"><a href="#js中的”-”与C-中的struct" class="headerlink" title="js中的”{}”与C++中的struct"></a>js中的”{}”与C++中的struct</h1><p>  前文说到”{}”其实是字符串-值的一种结构，它的名字叫对象，那它与静态语言中的对象有什么异同呢？ 拿c++的struct来与”{}”来做个对比</p><p>  struct与”{}”都可以仅放数据，也可以放数据与函数，在C++使用时一般沿用C的方式，将struct只放数据，而用class来当类来使用。</p><p>  比如在做一个Student对象时：<br>  C++中需要先声明一个Strudent的结构体：<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">  <span class="built_in">string</span> name;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  <span class="built_in">string</span> sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 然后用这个结构体来实例化对象：<br> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student s1 = &#123;<span class="string">"张三"</span>,<span class="number">13</span>,<span class="string">"男"</span>&#125;</span><br><span class="line">Student s2 = &#123;<span class="string">"李四"</span>，<span class="number">14</span>,<span class="string">"男"</span>&#125;</span><br></pre></td></tr></table></figure></p><p> 而在js中的”{}”需要：<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = &#123;<span class="string">"name"</span>:<span class="string">"张三"</span>, <span class="string">"age"</span>:<span class="number">13</span>, <span class="string">"sex"</span>:<span class="string">"男"</span>&#125;</span><br><span class="line"><span class="keyword">let</span> s2 = &#123;<span class="string">"name"</span>:<span class="string">"李四"</span>, <span class="string">"age"</span>:<span class="number">14</span>, <span class="string">"sex"</span>:<span class="string">"男"</span>&#125;</span><br></pre></td></tr></table></figure></p><p> 这样我们看到，js中的对象由于没有类型，所以需要把变量信息也包含在对象内部。数据效率相对低一些。<br> 访问时都是： s1.name</p><h1 id="对”-”的理解"><a href="#对”-”的理解" class="headerlink" title="对”{}”的理解"></a>对”{}”的理解</h1><p>前便说到”{}”中是变量信息放在了key的位置上，这句话需要再解释一下。<br>我们完全可以创建一个这样的对象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> zs = &#123;<span class="string">"张三"</span>:<span class="number">13</span>&#125;</span><br></pre></td></tr></table></figure></p><p>这样的结果是key的位置上，其实是一个之前的name，是一个信息，而不是简单的变量名的概念。访问时可以是zs.张三。（当然，也可以认为变量名是汉字，虽然一般人都不会这样玩，但C++的变量名确实也可以是汉字。） </p><p>综上： 对”{}”的理解最到位的就是 字符串-值结构的对象。</p><h1 id="js中的”-”与python中的”-”"><a href="#js中的”-”与python中的”-”" class="headerlink" title="js中的”{}”与python中的”{}”"></a>js中的”{}”与python中的”{}”</h1><p>“{}”在js与python中的差异性更不明显一些。”{}”在python中叫字典，在js中叫对象。</p><p>在使用上它们都可以如此使用：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">"a"</span>:<span class="number">1</span>&#125;</span><br><span class="line">a[<span class="string">"a"</span>]      // <span class="number">1</span></span><br><span class="line">a.get(<span class="string">"a"</span>)  // <span class="number">1</span></span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;<span class="string">"a"</span>:<span class="number">1</span>&#125;</span><br><span class="line">a[<span class="string">"a"</span>]   <span class="comment">// 1</span></span><br><span class="line">a.a      <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>但他们在深层次上是不同的，python中的””更像是动态语言中的map，因为它不能包括函数，而是当作一种数据结构来使用。而js中的”{}”更接近与动态语言中的struct，因为它不仅可以包含函数，更可以通过”.”来访问数据。<br>如在js中<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.fun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">111</span>)&#125;</span><br><span class="line">a.fun()</span><br></pre></td></tr></table></figure></p><p>但在python中则不能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次在现场对于新给的工程量的解析与存储时，又发现对于js中”{}”的使用又存在着疑惑，这个疑惑在以前分析过，但记录确实找不到了，现对它再次进行分析。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>android开发记录</title>
    <link href="http://yoursite.com/2018/11/28/android%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2018/11/28/android开发记录/</id>
    <published>2018-11-28T10:25:37.000Z</published>
    <updated>2018-11-28T10:31:03.716Z</updated>
    
    <content type="html"><![CDATA[<p> 随着开发深入，又要开始用Java来开发android了，上次没有总结出一篇像样的android博客出来，这次补上，随着开发陆续完善。</p><a id="more"></a><h1 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h1><h2 id="对于android与react开发的对比"><a href="#对于android与react开发的对比" class="headerlink" title="对于android与react开发的对比"></a>对于android与react开发的对比</h2><ul><li><p>相同：<br>android在开发时，最基础的过程是布局、activity、view，其中布局用于确定一个页面中有哪些组件以及他们之间的位置关系; activity通过findViewById得到布局中的view(组件)，来进行控制，包括获取数据已经控制显示数据; 对于view的事件（如button的点击），可以在布局中去指定，也可以在activity中去指定响应函数。 </p><p>对比react中的开发，布局对应着app.js中对不同组件组合以及css中布局的控制; activity中内容像是组件中的控制，包括document.getElementById()来获取元素，以及onClick（）响应等，包括组件之间的通信，以及与后端的通信，都可以在activity中去实现（不过大多都将module层抽象出来）; android中的view跟标签有些类似，当然可以自建view 对应着fragment，对应着react中的component(组建)</p></li><li><p>区别：<br>react的数据流是自上而下的流动， 而android中数据流可以自由流动;<br>react中大的封装用页面，且页面之间基本无法通信， 页面之间的封装用component; 在android中教为自由，毕竟大家都在一个进程中，数据是共享的，封装用布局来完成，页面控制由activity来完成。<br>react中component封装了view与对view的控制，而且本身也当作view来使用，是一种组合模式; 在android中将显示由基本的view与布局来完成，控制由activity来完成。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 随着开发深入，又要开始用Java来开发android了，上次没有总结出一篇像样的android博客出来，这次补上，随着开发陆续完善。&lt;/p&gt;
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>前端问题汇总</title>
    <link href="http://yoursite.com/2018/11/28/css%E6%A0%B7%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/11/28/css样式总结/</id>
    <published>2018-11-28T08:00:00.000Z</published>
    <updated>2018-11-29T08:33:19.291Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要汇总开发中前端布局，遇到的小问题以及对小问题的研究</p><a id="more"></a><h1 id="框模型：元素本身大小的控制"><a href="#框模型：元素本身大小的控制" class="headerlink" title="框模型：元素本身大小的控制"></a>框模型：元素本身大小的控制</h1><h2 id="关于width-heigh-padding-border-margin的关系"><a href="#关于width-heigh-padding-border-margin的关系" class="headerlink" title="关于width,heigh,padding,border,margin的关系"></a>关于width,heigh,padding,border,margin的关系</h2><p>  <img src="框模型.png" alt=""></p><p>  对于框模型已经较为熟悉了，但有一点height与width属性都是内容部分的属性，而不是整个元素的属性。元素的宽度 = width + 2<em>padding + 2</em>border + 2*margin<br>  <img src="框模型宽度计算.png" alt=""></p><ul><li><p>100%的设置尺寸问题<br>子元素继承父元素的width是content，子元素尺寸100%的设置时，不能再设置padding、border、magin等宽度，否则就会超出限制</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="selector-class">.child</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">50px</span> solid green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的child元素的尺寸会超出父元素parent，因为child元素的尺寸已经是100%父元素的内容了，父元素没有设置border，而子元素增加border的宽度，这样就会超出了100px。</p></li><li><p>居中的一种实现：<br>.center-me { margin: 0 auto; }</p></li></ul><h2 id="子元素与父元素尺寸（width，-height）关系"><a href="#子元素与父元素尺寸（width，-height）关系" class="headerlink" title="子元素与父元素尺寸（width， height）关系"></a>子元素与父元素尺寸（width， height）关系</h2><p>若父元素与子元素都设置了尺寸，则各自按照自己的设置进行。</p><p>height展现了一种自下向上的尺寸影响路线：子元素设置的height,会决定父元素的height；父元素的height不会影响子元素的height。</p><p>width展示了从上而下的影响路线：父元素设置的width，会决定子元素的width；子元素的width设置不会影响父元素的width。</p><h1 id="position-元素位置的控制"><a href="#position-元素位置的控制" class="headerlink" title="position: 元素位置的控制"></a>position: 元素位置的控制</h1><h2 id="关于position-top-right-bottom-left的使用"><a href="#关于position-top-right-bottom-left的使用" class="headerlink" title="关于position,top,right,bottom,left的使用"></a>关于position,top,right,bottom,left的使用</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">position: relative/absolute/fixed </span><br><span class="line"><span class="selector-tag">top</span>: 10<span class="selector-tag">px</span></span><br><span class="line"><span class="selector-tag">right</span>: 10<span class="selector-tag">px</span></span><br><span class="line"><span class="selector-tag">bottom</span>: 10<span class="selector-tag">px</span></span><br><span class="line"><span class="selector-tag">left</span>: 10<span class="selector-tag">px</span></span><br></pre></td></tr></table></figure><h2 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h2><p>将窗体自上而下分成一行行, 并在每行中按从左至右的顺序排放元素,即为文档流。<br>只有三种情况会使得元素脱离文档流，分别是：浮动、相对定位和固定定位。</p><ul><li><p>静态定位<br>static，无特殊定位，它是html元素默认的定位方式，即我们不设定元素的position属性时默认的position值就是static，它遵循正常的文档流对象，对象占用文档空间，该定位方式下，top、right、bottom、left、z-index等属性是无效的。</p></li><li><p>相对定位相对的是它在文档流中的位置而进行偏移，且不脱离文档流</p></li><li><p>绝对定位：absolute</p><p>使用absoult定位的元素脱离文档流后，就只能根据祖先类元素(父类以上)进行定位，而这个祖先类还必须是以postion非static方式定位的</p><p>relative和static方式在最外层时是以<body>标签为定位原点的，而absoulte方式在无父级是position非static定位时是以<html>作为原点定位。<html>和<body>元素相差9px左右</body></html></html></body></p><p>absoulte定位要加 top:0; left:0。因为我们如果使用absoulte或fixed定位的话，必须指定 left、right、 top、 bottom 属性中的至少一个，否则left/right/top/bottom属性会使用它们的默认值 auto，简单讲就是都变成relative。</p><p>少了left/right/top/bottom属性不行，那如果我们多设了呢？例如，我们同时设置了top和bottom的属性值，那元素又该往哪偏移好呢？记住下面的规则：<br>如果top和bottom一同存在的话，那么只有top生效。<br>如果left和right一同存在的话，那么只有left生效。</p><p>absoulte是根据祖先类的border进行的定位</p></li><li><p>固定定位：fixed</p><p>fixed定位，又称为固定定位，它和absoult定位一样，都脱离了文档流，并且能够根据top、right、left、bottom属性进行定位，但不同的是fixed是根据窗口为原点进行偏移定位的，也就是说它不会根据滚动条的滚动而进行偏移。</p></li><li><p>z-index属性</p><p>z-index，又称为对象的层叠顺序，它用一个整数来定义堆叠的层次，整数值越大，则被层叠在越上面，当然这是指同级元素间的堆叠，如果两个对象的此属性具有同样的值，那么将依据它们在HTML文档中流的顺序层叠，写在后面的将会覆盖前面的。需要注意的是，父子关系是无法用z-index来设定上下关系的，一定是子级在上父级在下。</p><p>使用static 定位z-index属性是无效的</p></li></ul><h1 id="flex-浮动"><a href="#flex-浮动" class="headerlink" title="flex: 浮动"></a>flex: 浮动</h1><p>  display: flex<br>  待整理…<br>  <a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">阮一峰：Flex 布局教程</a></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul><li><p>屏幕适应<br>待整理</p></li><li><p>css文档流与DOM树<br>待整理<br>css是按DOM树的叶子节点还是根节点进行样式的刷新的。<br>屏幕宽度与文档宽度的差异</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要汇总开发中前端布局，遇到的小问题以及对小问题的研究&lt;/p&gt;
    
    </summary>
    
      <category term="汇总" scheme="http://yoursite.com/categories/%E6%B1%87%E6%80%BB/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>后端问题汇总</title>
    <link href="http://yoursite.com/2018/11/28/%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2018/11/28/问题汇总/</id>
    <published>2018-11-28T02:00:00.000Z</published>
    <updated>2018-11-29T08:33:01.479Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要汇总开发中后端、语言，遇到的小问题以及对小问题的研究</p><a id="more"></a><h1 id="import-与-require背后的故事"><a href="#import-与-require背后的故事" class="headerlink" title="import 与 require背后的故事"></a>import 与 require背后的故事</h1><h2 id="require"><a href="#require" class="headerlink" title="require"></a>require</h2><p>   node使js可以运行于后台，于是就有了对模块的需要。<br>   require的解决方式是将模块中的所有对象（变量、函数、类）都成为一个对象module.exports对象的子对象，然后在其他模块中直接通过require模块名来引用导出的molule.exports对象，来直接访问。<br>   使用：</p><p>   test.js<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123; </span><br><span class="line">    a : function()&#123;&#125;,</span><br><span class="line">    b : &apos;test&apos;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var t = require(&apos;./test&apos;);</span><br><span class="line">t.a();</span><br></pre></td></tr></table></figure><h2 id="AMD与CMD"><a href="#AMD与CMD" class="headerlink" title="AMD与CMD"></a>AMD与CMD</h2><p>  require在服务端优势明显，因为加载的模块在服务器硬盘上，而在浏览器端确需要等待网络传输，加载完成后才可以使用模块中的对象，这种同步方式不符合js异步的理念，于是就有了AMD与CMD两种异步加载方式。<br>  AMD: Asynchronous Module Definition<br>  CMD: Common Module Definition<br>  AMD是将对依赖加载模块部分都放到异步函数中完成</p><p>  math.js<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define([&apos;Lib&apos;], function(Lib)&#123;</span><br><span class="line">　　　　function foo()&#123;</span><br><span class="line">　　　　　　Lib.doSomething();</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　return &#123;</span><br><span class="line">　　　　　　foo : foo</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require([&apos;math&apos;], function (math) &#123;</span><br><span class="line">　      math.add(2, 3);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="ES6的modules"><a href="#ES6的modules" class="headerlink" title="ES6的modules"></a>ES6的modules</h2><p>  ES6应该也是一种异步加载方式，具体原理没有深入了解<br>  它是通过解构的方式来导入、到处，这样就可以不用引用所有对象。另外有一个default语法糖，每个模块都有只一个default，这样在import时可以不写解构的过程。<br>  与default语法糖相关的是as关键字，像是SQL的as，起一个别名，default就是这个别名。<br>  export还是的到处可以放在每个对象上定义，而不是放在一个exports对象里。</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export &#123; name1, name2, …, nameN &#125;;</span><br><span class="line">export &#123; variable1 as name1, variable2 as name2, …, nameN &#125;;</span><br><span class="line">export default expression;</span><br><span class="line"></span><br><span class="line">import &#123; member &#125; from &quot;module-name&quot;;</span><br><span class="line">import &#123; member as alias &#125; from &quot;module-name&quot;;</span><br><span class="line">import defaultMember from &quot;module-name&quot;</span><br></pre></td></tr></table></figure></code></pre><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://www.cnblogs.com/libin-1/p/7127481.html" target="_blank" rel="noopener">彻底搞清楚javascript中的require、import和export</a></p><p><a href="http://imweb.io/topic/582293894067ce9726778be9" target="_blank" rel="noopener">Node中没搞明白require和import，你会被坑的很惨</a></p><h1 id="javascript中this的理解"><a href="#javascript中this的理解" class="headerlink" title="javascript中this的理解"></a>javascript中this的理解</h1><h2 id="一句话"><a href="#一句话" class="headerlink" title="一句话"></a>一句话</h2><p> 一句话： this是函数的运行时环境<br> 解释： 谁调用的函数，this就是谁</p><p> 例如：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> var a = 1</span><br><span class="line"></span><br><span class="line"> function test() &#123;</span><br><span class="line">   console.log(this.a)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;&#125;</span><br><span class="line">obj.a = 2</span><br><span class="line">obj.t = test</span><br><span class="line"></span><br><span class="line">obj.t()           // 2</span><br><span class="line">t()               // 1</span><br></pre></td></tr></table></figure></p><h2 id="两个注意"><a href="#两个注意" class="headerlink" title="两个注意"></a>两个注意</h2><h3 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h3><p>函数的this可以通过bind来绑定，使其不受调用者的影响</p><p>function test (){}<br>test.bind(this)</p><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数() =&gt; {}，this始终指向定义者，而不受调用者的影响。</p><h2 id="内存解释"><a href="#内存解释" class="headerlink" title="内存解释"></a>内存解释</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; foo:  5 &#125;;</span><br></pre></td></tr></table></figure><p>它在内存中先创建一个 {foo:5} 对象，然后再将这个对象的地址用obj来表示</p><p><img src="变量-2.png" alt=""></p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;foo: funciton()&#123;&#125;&#125;</span><br></pre></td></tr></table></figure><p>函数与变量捎有不同，它先将函数独立存储在内存中（应该在代码段里），然后再将函数的地址赋值给foo属性的value值，也就是说foo那里存储的是函数的地址。</p><p><img src="函数.png" alt=""></p><h2 id="引用-1"><a href="#引用-1" class="headerlink" title="引用"></a>引用</h2><p><a href="http://www.ruanyifeng.com/blog/2018/06/javascript-this.html" target="_blank" rel="noopener">阮一峰： JavaScript的this原理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要汇总开发中后端、语言，遇到的小问题以及对小问题的研究&lt;/p&gt;
    
    </summary>
    
      <category term="问题" scheme="http://yoursite.com/categories/%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>React基础</title>
    <link href="http://yoursite.com/2018/11/08/React%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/11/08/React基础/</id>
    <published>2018-11-08T05:00:35.000Z</published>
    <updated>2018-11-09T01:29:03.029Z</updated>
    
    <content type="html"><![CDATA[<p>主要介绍React基础：包括React元素、React组件、React数据流、表单、列表等内容<br> <a href="https://react.docschina.org/docs/introducing-jsx.html" target="_blank" rel="noopener">React官方文档</a><br><a id="more"></a></p><h1 id="React基础"><a href="#React基础" class="headerlink" title="React基础"></a>React基础</h1><h2 id="React元素"><a href="#React元素" class="headerlink" title="React元素"></a>React元素</h2><h3 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">&lt;h1 className=<span class="string">"greeting"</span>&gt;</span><br><span class="line">   Hello, world</span><br><span class="line">)</span><br><span class="line">&lt;<span class="regexp">/h1&gt;</span></span><br></pre></td></tr></table></figure><p>Babel转译器把JSX转换成:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = React.createElement(</span><br><span class="line"><span class="string">"h1"</span>,</span><br><span class="line"> &#123;<span class="attr">className</span>:<span class="string">"greeting"</span>&#125;,</span><br><span class="line"> <span class="string">"Hello, world!"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>createElement会返回一个类似于下面的对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line"> type: <span class="string">'h1'</span>,</span><br><span class="line"> props: &#123;</span><br><span class="line">   className: <span class="string">'greeting'</span>,</span><br><span class="line">   children: <span class="string">'Hello, world'</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将React元素渲染到根DOM节点中,通常使用ReactDOM.render()<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &lt;h1&gt;Hello, world&lt;/h1&gt;</span><br><span class="line">ReactDOM.render(element, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>))</span><br></pre></td></tr></table></figure></p><p>ReactDOM的渲染只会更新渲染文本节点中发生变化的内容.</p><h3 id="JSX-和-HTML-的区别"><a href="#JSX-和-HTML-的区别" class="headerlink" title="JSX 和 HTML 的区别"></a>JSX 和 HTML 的区别</h3><ul><li><p>class<br>在JSX中不能使用class，因为是ES6的关键字，而使用className</p></li><li><p>style 属性<br> style属性接受一个对象，而不是分号分割的字符串。CSS使用驼峰命名发</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> styles = &#123;</span><br><span class="line">  fontSize = <span class="string">'2em'</span>,</span><br><span class="line">  lineHeight: <span class="string">'1.6'</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> em = &lt;em style=&#123;styles&#125;&gt;</span><br></pre></td></tr></table></figure></li><li><p>JSX 中所有标签都需要闭合</p></li><li><p>用驼峰明明属性，像onClick<br>所有以data-与aria-开头的属性例外</p></li></ul><h3 id="子代"><a href="#子代" class="headerlink" title="子代"></a>子代</h3><p>在包含开始和结束标签的JSX表达式中，标记之间的内容作为特殊的参数传递：props:children。</p><ul><li><p>字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent&gt;Hello world!&lt;/MyComponent&gt;</span><br></pre></td></tr></table></figure><p>props.children就是字符串</p></li><li><p>JSX<br>你可以通过子代嵌入更多的 JSX 元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyContainer&gt;</span><br><span class="line"> &lt;MyFirstComponent /&gt;</span><br><span class="line"> &lt;MySecondComponent /&gt;</span><br><span class="line">&lt;<span class="regexp">/MyContainer&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>javascript表达式</p></li><li>函数</li></ul><h2 id="React组件"><a href="#React组件" class="headerlink" title="React组件"></a>React组件</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>组件可以将UI切分成一些独立的、可复用的部件，它可以接受任意的输入值(称之为”props”)，并返回一个在页面上显示的React元素</p><p>函数定义<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>类定义<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">   render() &#123;</span><br><span class="line">     <span class="keyword">return</span> &lt;h1&gt; Hello, &#123;this.props.name&#125;&lt;/h1&gt;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>React元素，除了是DOM标签，也可以是用户自定义的组件<br>const element = <welcom name="Sara"><br>而且一个组件可以包含其他组建作为React元素<br>由此可见，我们React其实是一种组合模式，组件与组件的组合是一致对待的。<br>而且定义组件像是定义一个类，而组为React元组时，就是实例化的过程（CreateElement）</welcom></p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="react生命周期.png" alt=""></p><h3 id="props与state"><a href="#props与state" class="headerlink" title="props与state"></a>props与state</h3><p>组件内部绝不能修改它自己的的props。props保存了由父元素传递进来的数据，这些数据不可以在props中进行修改。</p><p>state可以根据用户操作、网络响应、或其他状态变化，使组件动态的响应并改变组件的输出。<br>state其实就是保存组件内部的数据变化，在使用中，可以通过生命成员变量的方式来使用。</p><p>内部的状态一般就是通过用户的操作（action），以及网络请求来触发状态的变化。action操作时，需要注意响应函数的this问题，一般用箭头函数来避免直接bind。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this is:'</span>， <span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;button onClick = &#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">  Click me</span><br><span class="line">&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">handleClick()&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this is:'</span>,<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;button onClick = &#123;(e) =&gt; <span class="keyword">this</span>.handleClick(e)&#125;&gt;</span><br><span class="line">  Click Me</span><br><span class="line">&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><h2 id="React组件间数据流"><a href="#React组件间数据流" class="headerlink" title="React组件间数据流"></a>React组件间数据流</h2><h3 id="自顶向下数据流"><a href="#自顶向下数据流" class="headerlink" title="自顶向下数据流"></a>自顶向下数据流</h3><p>React是一种自顶向下的数据传输,从父组件传递数据到子组件，因为从父组件传递给子组件的数据存放在props中，不能修改。</p><h3 id="反向数据流"><a href="#反向数据流" class="headerlink" title="反向数据流"></a>反向数据流</h3><p>但为什么还有反向数据流呢？ 因为可以从父组件传递回调函数进去，子组件通过回调函数，将数据作为参数传递，而达到反向数据传输的目的。这样其实需要把数据的存储从子组件提升到父组件中去。这在React中称谓状态提升（因为react喜欢把数据放在state中）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TemperatureInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.props.onTemperatureChange(e.target.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> temperature = <span class="keyword">this</span>.props.temperature;</span><br><span class="line">    <span class="keyword">const</span> scale = <span class="keyword">this</span>.props.scale;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;fieldset&gt;</span><br><span class="line">        &lt;legend&gt;在&#123;scaleNames[scale]&#125;:中输入温度数值&lt;<span class="regexp">/legend&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input value=&#123;temperature&#125;</span></span><br><span class="line"><span class="regexp">               onChange=&#123;this.handleChange&#125; /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/fieldset&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h2><ul><li><p>map<br>用来遍历数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> listItems = numbers.map(<span class="function">(<span class="params">number</span>) =&gt;</span></span><br><span class="line">  &lt;li&gt;&#123;number&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  &lt;ul&gt;&#123;listItems&#125;&lt;/u</span>l&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>&amp;&amp;<br>false、null、undefined 和 true 都是有效的子代，但它们不会直接被渲染。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Mailbox</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> unreadMessages = props.unreadMessages;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello!&lt;/h1&gt;</span><br><span class="line">      &#123;unreadMessages.length &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        &lt;h2&gt;</span><br><span class="line">          You have &#123;unreadMessages.length&#125; unread messages.</span><br><span class="line">        &lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>三目运算符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line"> <span class="keyword">const</span> isLoggedIn = <span class="keyword">this</span>.state.isLoggedIn;</span><br><span class="line"> <span class="keyword">return</span> (</span><br><span class="line">   &lt;div&gt;</span><br><span class="line">     &#123;isLoggedIn ? (</span><br><span class="line">       &lt;LogoutButton onClick=&#123;<span class="keyword">this</span>.handleLogoutClick&#125; /&gt;</span><br><span class="line">     ) : (</span><br><span class="line">       &lt;LoginButton onClick=&#123;<span class="keyword">this</span>.handleLoginClick&#125; /&gt;</span><br><span class="line">     )&#125;</span><br><span class="line">   &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"> );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p> 列表的key属性，在DOM中的某些元素增加或删除的时候帮助React识别哪些元素发生了变化，因此应当给数组中的每一元素赋予一个确定的标识。<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> listItems = numbers.map(<span class="function">(<span class="params">n</span>) =&gt;</span> </span><br><span class="line"> &lt;li key=&#123;n.toString()&#125;&gt;</span><br><span class="line">   n</span><br><span class="line"> &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure></p><p>  元素的key只有在它和它的兄弟节点对比时才有意义,而且应该唯一。 比如上例中，将<li>封装到一个组件ListItem中，那么key就不能放到li中了，而是放在ListItem下<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ListItem key=&#123;n.toString()&#125; value=&#123;n&#125; /&gt;</span><br></pre></td></tr></table></figure></li></p><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><h3 id="受控组件与非受控组件"><a href="#受控组件与非受控组件" class="headerlink" title="受控组件与非受控组件"></a>受控组件与非受控组件</h3><p>在HTML中，像<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>和<code>&lt;select&gt;</code>这类的表单元素会自己维持自身的状态，并根据用户输入自动进行刷新，这在React中被称谓非受控组件。<br>但在React中，可变的状态通常都保存在足组件的state中，并只能通过setState()方法控制其更新。这就称谓受控组建。</p><ul><li><p>受控组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameForm</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">value</span>: <span class="string">''</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.handleSubmit = <span class="keyword">this</span>.handleSubmit.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(event) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: event.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    alert(<span class="string">'A name was submitted: '</span> + <span class="keyword">this</span>.state.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          Name:</span><br><span class="line">          &lt;input type=<span class="string">"text"</span> value=&#123;<span class="keyword">this</span>.state.value&#125; onChange=&#123;<span class="keyword">this</span>.handleChange&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input type="submit" value="Submit" /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>由于 value 属性是在我们的表单元素上设置的，因此显示的值将始终为 React数据源上this.state.value 的值。由于每次按键都会触发 handleChange 来更新当前React的state，所展示的值也会随着不同用户的输入而更新。<br>它可以对每次的输入进行检验,需要设置value属性来完成，并在每次的点击时使用onChange（）来进行处理，并在onChange()通过setState（）进行重新渲染。</p></li><li><p>非受控组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">NameForm</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">   <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleSubmit = <span class="keyword">this</span>.handleSubmit.bind(<span class="keyword">this</span>);</span><br><span class="line">   </span><br><span class="line">   handleSubmit(event) &#123;</span><br><span class="line">    alert(<span class="string">'A name was submitted: '</span> + <span class="keyword">this</span>.input.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">   </span><br><span class="line">   render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          Name:</span><br><span class="line">          &lt;input type=<span class="string">"text"</span> ref=&#123;(input) =&gt; <span class="keyword">this</span>.input = input&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input type="submit" value="Submit" /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">   </span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>在 React 的生命周期中，表单元素上的 value 属性将会覆盖 DOM 中的值。使用非受控组件时，通常你希望 React 可以为其指定初始值，但不再控制后续更新。要解决这个问题，你可以指定一个 defaultValue 属性而不是 value。value值总是与文本框的最新内容保持一</p></li></ul><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p> Refs 提供了一种方式，用于访问在 render 方法中创建的 DOM 节点或 React 元素。<br> 通过ref将render中DOM节点或React元素进行指向。<br> 当一个 ref 属性被传递给一个 render 函数中的元素时，可以使用 ref 中的 current 属性对节点的引用进行访问。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomTextInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">   <span class="keyword">super</span>(props);</span><br><span class="line">   <span class="comment">// 创建 ref 存储 textInput DOM 元素</span></span><br><span class="line">   <span class="keyword">this</span>.textInput = React.createRef();</span><br><span class="line">   <span class="keyword">this</span>.focusTextInput = <span class="keyword">this</span>.focusTextInput.bind(<span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> focusTextInput() &#123;</span><br><span class="line">   <span class="comment">// 直接使用原生 API 使 text 输入框获得焦点</span></span><br><span class="line">   <span class="comment">// 注意：通过 "current" 取得 DOM 节点</span></span><br><span class="line">   <span class="keyword">this</span>.textInput.current.focus();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> render() &#123;</span><br><span class="line">   <span class="comment">// 告诉 React 我们想把 &lt;input&gt; ref 关联到构造器里创建的 `textInput` 上</span></span><br><span class="line">   <span class="keyword">return</span> (</span><br><span class="line">     &lt;div&gt;</span><br><span class="line">       &lt;input</span><br><span class="line">         type=<span class="string">"text"</span></span><br><span class="line">         ref=&#123;<span class="keyword">this</span>.textInput&#125; /&gt;</span><br><span class="line"></span><br><span class="line">         </span><br><span class="line">       &lt;input</span><br><span class="line">         type=<span class="string">"button"</span></span><br><span class="line">         value=<span class="string">"Focus the text input"</span></span><br><span class="line">         onClick=&#123;<span class="keyword">this</span>.focusTextInput&#125;</span><br><span class="line">       /&gt;</span><br><span class="line">     &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">   );</span></span><br><span class="line"><span class="regexp"> &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p> 回调Refs：<br> 不同于传递 createRef() 创建的 ref 属性，你会传递一个函数。这个函数接受 React 组件的实例或 HTML DOM 元素作为参数，以存储它们并使它们能被其他地方访问。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">CustomTextInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.textInput = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.setTextInputRef = <span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.textInput = element;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.focusTextInput = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 直接使用原生 API 使 text 输入框获得焦点</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.textInput) <span class="keyword">this</span>.textInput.focus();</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// 渲染后文本框自动获得焦点</span></span><br><span class="line">    <span class="keyword">this</span>.focusTextInput();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 使用 `ref` 的回调将 text 输入框的 DOM 节点存储到 React</span></span><br><span class="line">    <span class="comment">// 实例上（比如 this.textInput）</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"text"</span></span><br><span class="line">          ref=&#123;<span class="keyword">this</span>.setTextInputRef&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"button"</span></span><br><span class="line">          value=<span class="string">"Focus the text input"</span></span><br><span class="line">          onClick=&#123;<span class="keyword">this</span>.focusTextInput&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="React理念"><a href="#React理念" class="headerlink" title="React理念"></a>React理念</h2><ul><li>把UI划分出组件层级</li><li>用React创建一个静态版本</li><li>定义UI状态的最小且完整表示</li><li>确定State应该位于哪里</li><li>添加反向数据流</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要介绍React基础：包括React元素、React组件、React数据流、表单、列表等内容&lt;br&gt; &lt;a href=&quot;https://react.docschina.org/docs/introducing-jsx.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;React官方文档&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://yoursite.com/2018/10/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/10/24/设计模式/</id>
    <published>2018-10-24T01:00:00.000Z</published>
    <updated>2018-10-24T01:37:26.700Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍12种的设计模式，包括策略模式、装饰器模式、适配器模式、外观模式、模板模式、代理模式; 观察者模式、命令模式; 工厂模式、组合模式；状态模式、迭代器模式。<br>本文是学习《Head First设计模式》整理的博客。<br><a id="more"></a></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="OO基础"><a href="#OO基础" class="headerlink" title="OO基础"></a>OO基础</h2><ul><li>封装</li><li>继承</li><li>多态<h2 id="OO原则"><a href="#OO原则" class="headerlink" title="OO原则"></a>OO原则</h2></li><li><p>封装变化<br>找出应用中可能需要变化之处，把它们独立出来，不要和那不需要变化的代码混在一起</p></li><li><p>针对接口编程，不针对实现编程</p></li><li><p>多用组合，少用继承<br>继承是一种Is-A行为，而组合是一种Has-A行为<br>is-A比Has-A有更强的关系<br>has-A可以通过has接口，来实现has具体内容的多态，比is有更好的灵活性</p></li><li><p>类应该对扩展开发，对修改关闭<br>允许类容易扩展，在不修改现有代码的情况下，就可搭配新的行为<br>遵循开发-关闭原则，通常会引入新的抽象层次，增加代码复杂度。需要把注意力集中在设计中，最有可能改变的地方，然后应用，而不是每个部分都这样设计。</p></li></ul><h2 id="UML规定"><a href="#UML规定" class="headerlink" title="UML规定"></a>UML规定</h2><ul><li><p>继承： 实线空箭头</p></li><li><p>实现： 虚线空箭头</p></li><li><p>组合： 实线实箭头</p></li></ul><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>鸭子的故事：<br>绿头鸭：会飞行， 叫起来呱呱叫<br>红头鸭：会飞行, 叫起来吱吱叫<br>普通鸭：不会飞行，叫起来呱呱叫<br>橡皮鸭：不会飞行，叫起来唧唧叫<br>…</p><p>首先看到了鸭子，以及不同种类的鸭子<br>其次是看到了鸭子的2种行为，飞行与叫;<br>具体的飞行与叫声并不一一对应，不同的鸭子可能有相同的飞行行为与叫的行为</p><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="策略模式.png" alt=""></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>策略模式本质本质上是对动作、函数、算法等变化时的一种封装，将算法封装成算法族，一方面使之可以相互替换，另一方面增加了复用。<br>这里看到了一种n-m的情况，将n抽象,将m也抽象，然后前者组合后者。<br>也可降维使用，只有1-m的情况</p><h1 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h1><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><h2 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h2><p><img src="装饰器模式-1.png" alt=""></p><p><img src="装饰器模式-2.png" alt=""></p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><ul><li><p>装饰器(Decorator)在使用上有2个抽象维度，1个分类维度看作主维度（横向维度），另一个是次维度（纵向维度），在第二个维度上的各个量，是修饰第一个维度上的各个量，并且第二个维度上的各个量之间，没有先后次序，且可以累加使用。第二个维度上也应该是多个量，如果是单个量，也没必要如此使用</p></li><li><p>装饰器(Decorator)与代理有一些相似之处：</p><ul><li><p>相同之处：<br>首先对于装饰类与代理类都从一个父类来继承，拥有相同的接口，<br>而且都持有被装饰类与被代理类的引用。在调用接口时分不清代理与被代理或者装饰器与被装饰器。</p></li><li><p>不同之处：<br>装饰器模式，装饰类与被装饰类都有多个，是多对多的关系，而代理被代理一般是一对一的使用。<br>装饰器可以累加的使用，且没有先后关系的限制； 代理是在一个代理类中完成访问控制，至于控制的先后顺序，应该有关。</p></li></ul></li><li><p>应用：<br>感觉在预处理模块中，也可以使用，但需要写死被装饰的顺序，这点有些耦合过高。</p></li></ul><h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><p>适配器模式示例现实生活中有很多，比如前几天买的手机USB接口与PC的USB接口的转换器;或者head first中的不同插座之间的适配器。<br><img src="适配器模式-1.png" alt=""></p><h2 id="类图-2"><a href="#类图-2" class="headerlink" title="类图"></a>类图</h2><p><img src="适配器模式-2.png" alt=""></p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>适配器模式将一个类的接口，转换成客户期望的另一接口。让原本不兼容的类可以兼容。<br>适配器就涉及3个对象，被适配者、适配器、使用方，正对应于图1的三个部分。<br>系统出了新的接口，并面先行的接口编程，但为了兼容老的接口，便生成adapter，来转换老的接口。</p><h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><p>外观模式head first给出的实例是家庭影院，买了很多的设备，为了设置家庭影院，需要调灯光、调音箱，调投影仪，爆米花，关闭的时候还需要进行相反的关闭操作。</p><h2 id="类图-3"><a href="#类图-3" class="headerlink" title="类图"></a>类图</h2><p><img src="外观模式.png" alt=""></p><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>外观模式就是增加一个外观类，来完成对这些对象的调用配置，其实就是一个封装。</p><p>提出了与适配器模式不同的对比：<br>适配器模式中，只做接口的转换，而外观模式是封装对多个对象的调用，为客户提供统一的接口而已。</p><p>还提出一个原则：<br>最少知识原则：即，只和你的密友交谈。对于用户，涉及的对象越少越好。</p><h1 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h1><h2 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h2><p>head first给出了例子是煮咖啡与沏茶的例子：他俩的的过程相同，需要烧水，冲泡，倒到杯子里，加调料。他们的不同之处是冲泡的内容不同，添加的提案不同。<br>这样就设计了一个抽象类，用于将算法的逻辑写好，然后实现烧水、倒到杯子，将冲泡与加调料设置为抽象方法，而咖啡与茶只要去实现冲泡与加调料，就可以完成整个过程。</p><h2 id="类图-4"><a href="#类图-4" class="headerlink" title="类图"></a>类图</h2><p><img src="模板模式.png" alt=""></p><p>模板模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的步骤。</p><h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>从类图上看，模板模式很简单，就是一个继承结构，它的思想却挺有趣，首先一个算法是分几个步骤（函数）来实现的，在父类中将这个步骤的调用过程固定下来，并将需要子类实现的步骤定义为abstract类型，子类只需实现这些接口，就可以完成真个算法。</p><p>这样存在一个问题，即所有的步骤调用太固定，若有差异不够灵活，后来有了一些变易，它可以提前准备一些hook函数，子类通过实现不同的hook，来使整个算法的逻辑发生一点改变。</p><p>在应用上，像是sort函数需要传入compareaTo，就是这种思想的一种体现。</p><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><p>好莱坞原则：高层对待低层组建的方式，别调用我们，我们调用你。<br><img src="好莱坞原则.png" alt=""></p><p>我们在抽象工厂模式中，见过这种高层与低层组建关系的原则：依赖颠倒原则，即分离高层与低层的组件，让他们都以来接口。那时候的高层是工厂类，而低层是产品类接口。</p><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><h2 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h2><p>代理模式中，head first给出了3种：远程代理、虚拟代理、保护代理<br>远程代理： 远程代理指的是用一个电脑上的类、代理另外一台电脑上的一个类。例子是想统计想统计在经历的机器上来显示其他电脑上各糖果机器的情况。</p><p>虚拟代理： 就是缓存代理，对于大的对象，在对象时候的时候再去创建它。例子是从网络加载图像，通过虚拟代理，创建一个新的线程来加载图像，在没有加载完成一直使用虚拟带来应答，加载完成后，将请求再交给真实对象。</p><p>保护代理： 也就是动态代理，这里是把Java的动态代理讲的最明白的。动态代理意思是在运行时，才生成的代理对象。</p><h2 id="类图-5"><a href="#类图-5" class="headerlink" title="类图"></a>类图</h2><p><img src="代理模式-1.png" alt=""></p><p>代理模式为另一个对象提供一个替身或者占位符以控制对这个对象的访问。使用代理模式创建代表对象，让代表对象控制某对象的访问，被代理的对象可以是远程的对象、创建开销大的对象或需要安全控制的对象。</p><h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><ul><li><p>远程代理<br><img src="代理模式-远程代理.png" alt=""><br>Java提供远程代理的实现，由Java的命令（工具）自动实现客户辅助对象与服务辅助对象的创建，也就封装了代理对象（客户对象）与被代理对象（服务对象）之间的通讯。但还需要程序员去实现代理对象与被代理对象。<br>Java用的比较少一些，对于远程代理没用用过，而且现在的使用场合也不太确定，如果是BS或者CS之间的通信，用http、tcp/ip就可以完成通信；如果是S与S之间的通信，可以通过数据库+数据总线的方式来实现。</p></li><li><p>动态代理<br><img src="代理模式-动态代理.png" alt=""><br>这里是我觉得对Java的动态代理讲的最清楚的地方。它将代理包含在两个类中：Proxy以及InvocationHandler中，其中Proxy提供访问被代理类的接口，InvocationHandler真正访问被代理类，控制对被代理类的访问。<br>在使用上，先创建InvocationHandler类，并传入被代理的对象，在实现的Invoke接口中进行控制，通过控制的调用被代理对象的方法，在使用是，通过new Proxy对象（Proxy的创建会传入被代理类的接口，即他俩接口相同），并将InvocationHandler类来传入来实现真正的控制访问。</p></li></ul><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h2><h2 id="类图-6"><a href="#类图-6" class="headerlink" title="类图"></a>类图</h2><p><img src="观察者模式-2.png" alt=""></p><h2 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h2><p>  <img src="观察者模式-1.png" alt=""></p><ul><li><p>观察者模式是一方对多方单方发送数据的模型。<br>首先它是一方对多方，其中一的一方是Subject(或者Observable)，多的一方是Observer.<br>Subject中有一个Observer的列表， 当数据发生变化时，调用Observer的接口函数，将数据发送给列表中的各个Observer</p><p>其次它是单方发送据的，Observer只负责接收数据。<br>这里隐含一个变化，如果一个Observer要把数据发送给其他的Observer，是可以再调用Suject的set数据的函数，来完成数据分发的。</p></li><li><p>应用：<br>一个是flux中的pub与sub<br>另一个是android里的与后端通信，获取数据，然后使用数据的情况。</p></li></ul><h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><h2 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h2><p>Head First给出的示例是多功能遥控器<br>遥控器有一个插槽，可以插不同的遥控器，比如电视的、电灯的、风扇的等，最多有7种。<br>对于这些遥控器，预留出7对按钮，分别控制on与off</p><h2 id="类图-7"><a href="#类图-7" class="headerlink" title="类图"></a>类图</h2><p><img src="命令模式.png" alt=""></p><h2 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h2><ul><li><p>解析<br>命令模式中，由4种角色组成，命令执行者（命令接收者 receiver）、命令(commond)、命令的创建者、命令调用者(invoker)<br>命令本身封装了命令执行者，以及较固定的函数（exec()、undo()等）<br>命令的创建者创建命令以及执行者，并将执行者set进命令的地方。创建者是一个隐含的地方，可以是一个函数，并一定是类。<br>命令调用者负责调用命令的执行（exec）函数。</p><p>命令模式真正是通过对命令与命令执行者的封装，完成了命令创建者与命令调用者的解耦， 其实也完成了调用者与执行者的解耦。<br>在命令模式的例子中，执行者是电视、电灯，创建者是在main函数中，调用者是遥控器</p><p>这样，命令的调用者既可以用单个命令变量来存放命令，也可以用一个数组来存放多个命令，然后在执行时，便利去执行。在这种情况下涉及到一个问题，如果一个问题的处理需要一连串的命令，按顺序执行来完成，后一个命令的执行依赖于前一个命令执行的数据，这种情况下，是否适合使用命令模式？</p></li><li><p>应用<br>队列请求：<br>创建者将命令创建后，放如一个队列中，执行者在多个线程中快速并行调用这行命令。</p><p>重做日志：<br>命令模式还用于数据库的重做日志，将命令实现序列化的方法，store/load等接口进行持久化，然后在发生故障时，load命令进行执行，即可。</p></li><li><p>对比<br>其实有些像观察者模式，与观察者模式最大的不同在于，观察者模式中发布与订阅是一个一对多的关系，而在命令中，命令的创建者与调用者是一对一的关系。<br>另一个不同是，观察者模式中发送的只是一个小对象，比如一个字符串，或者一个bean。而在命令模式中，确是封装了执行者的命令。</p></li></ul><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><h2 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h2><p>批萨店做批萨;<br>不同地区的批萨店，对于同款产品，区域特点不一样;<br>同一批萨店，对于同款产品，有不同风味的做饭，采用的原料有一些差异</p><h2 id="类图-8"><a href="#类图-8" class="headerlink" title="类图"></a>类图</h2><ul><li><p>工厂模式<br><img src="工厂模式.png" alt=""><br>工厂模式：定义一个创建对象的接口，但由子类决定要实例化的类是哪一个，把类的实例化推迟到子类。</p></li><li><p>抽象工厂模式<br><img src="抽象工厂模式.png" alt=""><br>抽象工厂模式： 提用一个接口，用于创建相关或者以来对象的家族，而不需要指定具体类</p><h2 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h2><p>以前看的应该是抽象工厂模式，工厂模式较之类图结构更简单一些<br>工厂模式是抽象出了2个层级： 第一是创建者或者工厂，第二是产品类，由工厂来创建产品。产品类全部都继承自产品类本身，这样其实是把隐含的系列给隐掉了。</p></li></ul><p>抽象工厂也是有2个层级：创建者与产品。 创建者的层级与工厂模式类似，不同的是产品层级，产品层级细分，细分基本是依据创建者来分开的（具体情况下，不同工厂也会用相同的产品）。 其实在各个原料上，如Dough、Sauce、Cheese它们可以抽象成Ingredient（原料）类。这样以来，就会看出跟工厂模式更多的相似之处。创建者与产品之间的关系也必须是具体的，或者写死的。</p><p>另外一个不同可以看到，它将工厂变成的接口，是一个大的接口，必须包含所有的创建者的行为，即使在某个工厂中不需要这种行为，也得实现。</p><h2 id="原则-1"><a href="#原则-1" class="headerlink" title="原则"></a>原则</h2><p>依赖倒置原则：要依赖抽象，不要以来具体类。不能让高层组件依赖具体的低层组件，高层与低层组件，两者都应该依赖于抽象。</p><ul><li><p>变量不可以持有具体类的引用。<br>使用new事，就会持有具体的引用，可以使用工厂来避开这种做法</p></li><li><p>不要让类派生自具体的类。<br>如果派生自具体类，就会以来具体类，应该派生自一个接口</p></li><li><p>尽量不要覆盖基类中已实现的方法<br>基类中已实现的方法，应该由所有的子类共有。</p></li></ul><p>PS： 应该在有封装变化的时候，尽量靠近这些原则，而不是随时都要使用这些原则<br>    如一个不会改变的类，就可以在代码中直接实例化。</p><h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><h2 id="示例-9"><a href="#示例-9" class="headerlink" title="示例"></a>示例</h2><p>组合模式的实例也是与菜单相关，除了上边提到的3餐的菜单，餐厅想提供一份单独的甜点菜单，比如加到晚餐里。<br>这样菜单的结构发生了改变，它使得咖啡厅的晚餐菜单包括一个子菜单<br><img src="组合模式-1.png" alt=""></p><h2 id="类图-9"><a href="#类图-9" class="headerlink" title="类图"></a>类图</h2><p><img src="组合模式-2.png" alt=""></p><p><img src="组合模式-3.png" alt=""></p><p>组合模式允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。</p><h2 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h2><p>组合模式可以认为是将树在类中去实现。使用者对是组合还是单个对象而透明。</p><h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><h2 id="示例-10"><a href="#示例-10" class="headerlink" title="示例"></a>示例</h2><p>糖果售货机，投入硬币，摇动把手，出货;<br>若没有货，也会提示没货，然后退出硬币;<br>投入硬币后也可以直接退回硬币</p><p>这样有这样几种状态：无货， 未投币， 已投币， 出货<br><img src="状态模式-1.png" alt=""></p><h2 id="类图-10"><a href="#类图-10" class="headerlink" title="类图"></a>类图</h2><p><img src="状态模式-2.png" alt=""></p><p>状态模式允许对象在内部状态发生改变时，改变它的行为，对象看起来好像修改了它的类。</p><h2 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h2><p><img src="状态模式-3.png" alt=""></p><p><img src="状态模式-4.png" alt=""><br>在实现上，Context类中有所有的状态类（这里有4个），还有一个当前状态变量。State接口包括着所有可以执行的操作（引起状态变化的动作），具体状态实现所有的接口，然后在自己状态对应的操作里实现功能代码，并在这个操作里调用Context的设置状态函数，设置下一个状态。</p><p>这样状态转换的逻辑是放在状态中去掌握的，其实可以放在Context中去把握，我感觉更好一些。因为如果有别的Contex时，可以复用这些状态，而他们的状态转换逻辑可以放在自己的代码中。</p><h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><h2 id="示例-11"><a href="#示例-11" class="headerlink" title="示例"></a>示例</h2><p>不同餐厅的菜单用不同的数据结构来实现的，早点摊位用的是数组，午餐食堂用的是List，晚餐咖啡厅用的是HashMap。<br>现在有一个服务员，需要根据这些不同的菜单提供服务，非迭代器方式下，服务员需要对这些不同的菜单定义不同的遍历方法。而迭代器模式会使用使遍历使用相同的接口。</p><h2 id="类图-11"><a href="#类图-11" class="headerlink" title="类图"></a>类图</h2><p><img src="迭代器模式.png" alt=""></p><p>迭代器模式提供一种方法，能够顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。</p><h2 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h2><p>从类图上看，迭代器模式有些像工厂模式，毕竟每一个具体的Aggregate对象都对应唯一的Iterator对象。为不同的数据结构提供了统一的遍历接口。</p><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>一个类应该只有一个引起变化的原因。<br>类的每个职责都有改变的潜在区域。超过一个责任，意味着超过一个改变的区域。<br>内聚：当一个模块或者类被设计成只支持一组相关的功能时，我们说它具有高内聚，单一职责的原则的类，很容易就有高内聚，比低内聚的更容易维护。</p><p>可看作成封装的粒度建议。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍12种的设计模式，包括策略模式、装饰器模式、适配器模式、外观模式、模板模式、代理模式; 观察者模式、命令模式; 工厂模式、组合模式；状态模式、迭代器模式。&lt;br&gt;本文是学习《Head First设计模式》整理的博客。&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>CSS基础</title>
    <link href="http://yoursite.com/2018/08/30/css/"/>
    <id>http://yoursite.com/2018/08/30/css/</id>
    <published>2018-08-30T03:29:35.000Z</published>
    <updated>2018-10-22T10:33:48.092Z</updated>
    
    <content type="html"><![CDATA[<p>主要介绍css与css3<br><a id="more"></a></p><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;<span class="attribute">color</span>:black;&#125;</span><br><span class="line"><span class="selector-tag">h1</span> &#123;<span class="attribute">color</span>:blue;&#125;</span><br><span class="line"><span class="selector-tag">h2</span> &#123;<span class="attribute">color</span>:silver;&#125;</span><br><span class="line"><span class="selector-tag">body</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">p</span>, <span class="selector-tag">table</span>, <span class="selector-tag">th</span>, <span class="selector-tag">td</span>, <span class="selector-tag">pre</span>, <span class="selector-tag">strong</span>, <span class="selector-tag">em</span> &#123;<span class="attribute">color</span>:gray;&#125;</span><br></pre></td></tr></table></figure><h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器 ."></a>类选择器 .</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.important</span> &#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.important</span> &#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure><h3 id="ID选择器"><a href="#ID选择器" class="headerlink" title="ID选择器"></a>ID选择器</h3><p><code>#intro {font-weight:bold;}</code></p><h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器 []"></a>属性选择器 []</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href]</span> &#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line"><span class="selector-tag">img</span><span class="selector-attr">[alt]</span> &#123;<span class="attribute">border</span>: <span class="number">5px</span> solid red;&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href="http://www.w3school.com.cn/about_us.asp"]</span> &#123;<span class="attribute">color</span>: red;&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[class~="important"]</span> &#123;<span class="attribute">color</span>: red;&#125;</span><br></pre></td></tr></table></figure><h3 id="后代选择器-空格"><a href="#后代选择器-空格" class="headerlink" title="后代选择器 空格"></a>后代选择器 空格</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h1 em &#123;color:red;&#125;</span><br></pre></td></tr></table></figure><h3 id="子元素选择器-gt"><a href="#子元素选择器-gt" class="headerlink" title="子元素选择器 &gt;"></a>子元素选择器 &gt;</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h1 &gt; strong &#123;color:red;&#125;</span><br><span class="line">table.company td &gt; p</span><br></pre></td></tr></table></figure><p>上面的选择器会选择作为 td 元素子元素的所有 p 元素，这个 td 元素本身从 table 元素继承，该 table 元素有一个包含 company 的 class 属性。</p><h3 id="兄弟选择器"><a href="#兄弟选择器" class="headerlink" title="兄弟选择器 +"></a>兄弟选择器 +</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h1 + p &#123;margin-top:50px;&#125;</span><br></pre></td></tr></table></figure><p>选择紧接在 h1 元素后出现的段落，h1 和 p 元素拥有共同的父元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">html &gt; body table + ul &#123;margin-top:20px;&#125;</span><br></pre></td></tr></table></figure><p>这个选择器解释为：选择紧接在 table 元素后出现的所有兄弟 ul 元素，该 table 元素包含在一个 body 元素中，body 元素本身是 html 元素的子元素。</p><h3 id="伪类"><a href="#伪类" class="headerlink" title="伪类 :"></a>伪类 :</h3><p>语法selector : pseudo-class {property: value}<br>锚伪类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a:link &#123;color: #FF0000&#125;/* 未访问的链接 */</span><br><span class="line"></span><br><span class="line">a:visited &#123;color: #00FF00&#125;/* 已访问的链接 */</span><br><span class="line"></span><br><span class="line">a:hover &#123;color: #FF00FF&#125;/* 鼠标移动到链接上 */</span><br><span class="line"></span><br><span class="line">a:active &#123;color: #0000FF&#125;/* 选定的链接 */</span><br><span class="line"></span><br><span class="line">:first-child 伪类</span><br><span class="line">p:first-child &#123;font-weight: bold;&#125;</span><br><span class="line"></span><br><span class="line">:lang 伪类</span><br><span class="line">:lang 伪类使你有能力为不同的语言定义特殊的规则。在下面的例子中，:lang 类为属性值为 no 的 q 元素定义引号的类型：</span><br></pre></td></tr></table></figure><h3 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素  :"></a>伪元素  :</h3><p>selector.class:pseudo-element {property:value;}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">:first-line 伪元素</span><br><span class="line">  p:first-line</span><br><span class="line">  &#123;</span><br><span class="line">  color:#ff0000;</span><br><span class="line">  font-variant:small-caps;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">:first-letter 伪元素</span><br><span class="line">  p:first-letter</span><br><span class="line">  &#123;</span><br><span class="line">  color:#ff0000;</span><br><span class="line">  font-size:xx-large;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>:before 伪元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">:before&quot; 伪元素可以在元素的内容前面插入新内容。</span><br><span class="line">  h1:before</span><br><span class="line">  &#123;</span><br><span class="line">  content:url(logo.gif);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">:after 伪元素</span><br><span class="line">  h1:after</span><br><span class="line">  &#123;</span><br><span class="line">  content:url(logo.gif);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li><p>background-color 背景色</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">background-color</span>: gray;&#125;</span><br></pre></td></tr></table></figure></li><li><p>background-image 背景图 </p><p>background:url();</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;<span class="attribute">background-image</span>: <span class="built_in">url</span>(/i/eg_bg_04.gif);&#125;</span><br></pre></td></tr></table></figure><p>css3中支持多重背景：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="attribute">background-image</span>:<span class="built_in">url</span>(bg_flower.gif),<span class="built_in">url</span>(bg_flower_2.gif);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>background-repeat 背景重复，与背景图结合使用</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span></span><br><span class="line">&#123; </span><br><span class="line"> <span class="attribute">background-image</span>: <span class="built_in">url</span>(/i/eg_bg_03.gif);</span><br><span class="line"> <span class="attribute">background-repeat</span>: repeat-y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>background-position 背景定位</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span></span><br><span class="line">&#123; </span><br><span class="line">  <span class="attribute">background-image</span>:<span class="built_in">url</span>(<span class="string">'/i/eg_bg_03.gif'</span>);</span><br><span class="line">  <span class="attribute">background-repeat</span>:no-repeat;</span><br><span class="line">  <span class="attribute">background-position</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 属性值包括：center，top，right，bottom，left；百分比；具体数值等。</p></li><li><p>background-attachment 背景关联<br>  如果文档比较长，那么当文档向下滚动时，背景图像也会随之滚动。当文档滚动到超过图像的位置时，图像就会消失。<br>  background-attachment:fixed</p></li><li><p>background-size CSS3中增加背景大小属性<br>%,px,em,ex等。</p></li><li><p>background-origin属性<br>值为context-box,padding-box,border-box等</p></li></ul><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><ul><li><p>font-family字体系列属性</p><p>CSS定义了五种通用字体系列：</p><p>Serif字体</p><p>Sans-serif字体</p><p>Monospace字体</p><p>Cursive字体</p><p>Fantasy字体</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;<span class="attribute">font-family</span>: sans-serif;&#125;</span><br></pre></td></tr></table></figure></li><li><p>font-style字体风格</p><p>该属性有三个值：</p><p>normal - 文本正常显示</p><p>italic - 文本斜体显示</p><p>oblique - 文本倾斜显示</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.normal</span> &#123;<span class="attribute">font-style</span>:normal;&#125;</span><br></pre></td></tr></table></figure></li><li><p>font-weight字体加粗属性</p><p>100 ~ 900 为字体指定了 9 级加粗度。100 对应最细的字体变形，900 对应最粗的字体变形。数字 400 等价于 normal，而 700 等价于 bold。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.thick</span> &#123;<span class="attribute">font-weight</span>:bold;&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.thicker</span> &#123;<span class="attribute">font-weight</span>:<span class="number">900</span>;&#125;</span><br></pre></td></tr></table></figure></li><li><p>font-size字体大小属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;<span class="attribute">font-size</span>:<span class="number">60px</span>;&#125;</span><br><span class="line"><span class="selector-tag">h2</span> &#123;<span class="attribute">font-size</span>:<span class="number">40px</span>;&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">font-size</span>:<span class="number">14px</span>;&#125;</span><br></pre></td></tr></table></figure></li><li><p>CSS3 @font-face 规则</p><p>通过 CSS3，web 设计师可以使用他们喜欢的任意字体。</p><p>当您您找到或购买到希望使用的字体时，可将该字体文件存放到 web 服务器上，它会在需要时被自动下载到用户的计算机上。</p><p>您“自己的”的字体是在 CSS3 @font-face 规则中定义的。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt; </span><br><span class="line">@<span class="keyword">font-face</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">font-family</span>: myFirstFont;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">'Sansation_Light.ttf'</span>),</span><br><span class="line">    <span class="built_in">url</span>(<span class="string">'Sansation_Light.eot'</span>); <span class="comment">/* IE9+ */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">font-family</span>:myFirstFont;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><ul><li><p>text-indent首行缩进<br>p {text-indent: 5em;}</p></li><li><p>text-align水平对齐<br>left\right\center</p></li><li><p>word-spacing字间距<br>p.spread {word-spacing: 30px;}</p></li><li><p>letter-spacing 字母间距<br>h4 {letter-spacing: 20px}</p></li><li><p>text-transform 字符转换<br>uppercase<br>lowercase<br>capitalize：首字母大写</p></li><li><p>text-decoration字体装饰<br>underline<br>overline<br>line-through<br>blink</p></li><li><p>direction 文本放下<br>影响块级元素中文本的书写方向、表中列布局的方向、内容水平填充其元素框的方向、以及两端对齐元素中最后一行的位置。</p></li><li><p>text-shadow css3中支持文本阴影：与box-shadow类似</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="attribute">text-shadow</span>: <span class="number">5px</span> <span class="number">5px</span> <span class="number">5px</span> <span class="number">#FF0000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>word-wrap分词CSS3属性</p></li><li><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">word-wrap</span>:break-word;&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>针对以下四种状态设置颜色、背景、字体修饰等等</p><p>  a:link - 普通的、未被访问的链接</p><p>  a:visited - 用户已访问的链接</p><p>  a:hover - 鼠标指针位于链接的上方</p><p>  a:active - 链接被点击的时刻</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ul><li><p>list-style-type列表类型</p><p>square</p></li><li><p>list-style-image列表图像</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span> &#123;<span class="attribute">list-style-image </span>: <span class="built_in">url</span>(xxx.gif)&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><ul><li><p>border<br>设置表格边框</p><ul><li><p>边框</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">table</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">border-collapse</span>:collapse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">table</span>,<span class="selector-tag">th</span>, <span class="selector-tag">td</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有boder-collapse,table的边框与th、td的边框会分离，成为2层</p></li><li><p>其他属性</p><p>表格的宽度与高度属性：width，height;<br>表格文本对齐属性:text-align<br>背景颜色<br>内边距等等</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">table</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">th</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>:green;</span><br><span class="line">  <span class="attribute">color</span>:white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">td</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">text-align</span>:right;</span><br><span class="line">  <span class="attribute">padding</span>:<span class="number">15px</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>轮廓outline</p><ul><li>outline是在border外了一层框</li><li>outline-color</li><li>outline-style</li><li>outline-width</li></ul></li></ul></li></ul><h2 id="框模型"><a href="#框模型" class="headerlink" title="框模型"></a>框模型</h2><ul><li><p>模型</p><p>从内至外：元素element、内边距padding、边框border、外边距margin</p><p><img src="框模型.png" alt="框模型"></p></li><li><p>padding</p><p>可以按照上、右、下、左的顺序分别设置各边的内边距<br><code>h1 {padding: 10px 0.25em 2ex 20%;}</code><br>等价于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">h1 &#123;</span><br><span class="line">  padding-top: 10px;</span><br><span class="line">  padding-right: 0.25em;</span><br><span class="line">  padding-bottom: 2ex;</span><br><span class="line">  padding-left: 20%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>border</p><p>border有3个属性：类型style，颜色color，宽度width<br>每一种属性都可以从top\right\bottom\left的角度来设置。<br><code>p {border:solid red 1px}</code></p></li><li><p>border-radius</p><p>css3中新增属性，用于圆角矩形<br><code>border-radius:25px;</code></p></li><li><p>box-shadow<br>增加边框的阴影效果<br><code>box-shadow: 10px 10px 5px #888888;</code><br>边框的相对位置，虚化，颜色</p></li><li><p>margin<br>与padding类似<br><code>h1 {margin : 10px 0px 15px 5px;}</code></p></li></ul><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><h3 id="display"><a href="#display" class="headerlink" title="display"></a>display</h3><p>div、h1 或 p 元素常常被称为块级元素。这意味着这些元素显示为一块内容，即“块框”。与之相反，span 和 strong 等元素称为“行内元素”，这是因为它们的内容显示在行中，即“行内框”。</p><p>您可以使用 display 属性改变生成的框的类型。这意味着，通过将 display 属性设置为 block，可以让行内元素（比如 <code>&lt;a&gt;</code> 元素）表现得像块级元素一样。还可以通过把 display 设置为 none，让生成的元素根本没有框。这样的话，该框及其所有内容就不再显示，不占用文档中的空间。</p><h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><ul><li><p>相对定位：移动后原位置保留</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#box_relative</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="相对定位.png" alt="相对定位"></p><p>在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框</p></li><li><p>绝对定位：移动后原位置不保留</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#box_relative</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="绝对定位.png" alt="绝对定位"></p><p>相对定位是“相对于”元素在文档中的初始位置,而绝对定位是“相对于”最近的已定位祖先元素，如果不存在已定位的祖先元素，那么“相对于”最初的包含块。</p></li></ul><h3 id="float"><a href="#float" class="headerlink" title="float"></a>float</h3><ul><li><p>简介</p><p>浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。</p></li><li><p>浮动</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.news</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.news</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clear</span> &#123;</span><br><span class="line"><span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三个框都向左移动，那么框 1 向左浮动直到碰到包含框，另外两个框向左浮动直到碰到前一个浮动框。</p><p><img src="浮动框并列.png" alt="浮动框并列"></p><p>如果包含框太窄，无法容纳水平排列的三个浮动元素，那么其它浮动块向下移动，直到有足够的空间</p><p><img src="浮动框下沉.png" alt="浮动框下沉"></p></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h3><h4 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h4><ul><li><p>如何水平对齐块级元素<br>块级元素指的是占据占据全部可用宽度的元素，并在其前后都会换行。<br><code>&lt;h1&gt;</code><br><code>&lt;p&gt;</code><br><code>&lt;div&gt;</code></p></li><li><p>使用margin来水平对齐<br>可通过将左和右外边距设置为 “auto”，来对齐块元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.center</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="attribute">margin</span>:auto;</span><br><span class="line"> <span class="attribute">width</span>:<span class="number">70%</span>;</span><br><span class="line"> <span class="attribute">background-color</span>:<span class="number">#b0e0e6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用position来进行左右对齐<br>当像这样对齐元素时，对 <body> 元素的外边距和内边距进行预定义是一个好主意。这样可以避免在不同的浏览器中出现可见的差异。</body></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line"> <span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="attribute">position</span>:absolute;</span><br><span class="line"> <span class="attribute">right</span>:<span class="number">0px</span>;</span><br><span class="line"> <span class="attribute">width</span>:<span class="number">300px</span>;</span><br><span class="line"> <span class="attribute">background-color</span>:<span class="number">#b0e0e6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用float属性来对齐</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.right</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="attribute">float</span>:right;</span><br><span class="line"> <span class="attribute">width</span>:<span class="number">300px</span>;</span><br><span class="line"> <span class="attribute">background-color</span>:<span class="number">#b0e0e6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h4><ul><li><p>height:元素的高度</p></li><li><p>width：元素的宽度</p></li><li><p>line-height:行高</p></li><li><p>max-height:最大高度</p></li><li>min-height</li><li>max-width：最大宽度</li><li>min-width</li></ul><h4 id="图片浮动"><a href="#图片浮动" class="headerlink" title="图片浮动"></a>图片浮动</h4>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">float</span>:right;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">120px</span>;</span><br><span class="line"><span class="attribute">margin</span>:<span class="number">0</span> <span class="number">0</span> <span class="number">15px</span> <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">padding</span>:<span class="number">15px</span>;</span><br><span class="line"><span class="attribute">border</span>:<span class="number">1px</span> solid black;</span><br><span class="line"><span class="attribute">text-align</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/i/eg_cute.gif"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">CSS is fun!</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="首字母"><a href="#首字母" class="headerlink" title="首字母"></a>首字母</h4>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">span</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">float</span>:left;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">0.7em</span>;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">400%</span>;</span><br><span class="line"><span class="attribute">font-family</span>:algerian,courier;</span><br><span class="line"><span class="attribute">line-height</span>:<span class="number">80%</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;span&gt;T&lt;/span&gt;his is some text.</span><br></pre></td></tr></table></figure><h4 id="无表格首页"><a href="#无表格首页" class="headerlink" title="无表格首页"></a>无表格首页</h4>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type="text/css"&gt;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.container</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">border</span>:<span class="number">1px</span> solid gray;</span><br><span class="line">  <span class="attribute">line-height</span>:<span class="number">150%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.header</span>,<span class="selector-tag">div</span><span class="selector-class">.footer</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">padding</span>:<span class="number">0.5em</span>;</span><br><span class="line">  <span class="attribute">color</span>:white;</span><br><span class="line">  <span class="attribute">background-color</span>:gray;</span><br><span class="line">  <span class="attribute">clear</span>:left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-class">.header</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.left</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">float</span>:left;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">160px</span>;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>:<span class="number">1em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.content</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">margin-left</span>:<span class="number">190px</span>;</span><br><span class="line">  <span class="attribute">border-left</span>:<span class="number">1px</span> solid gray;</span><br><span class="line">  <span class="attribute">padding</span>:<span class="number">1em</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="图片库"><a href="#图片库" class="headerlink" title="图片库"></a>图片库</h3><h4 id="图片库-1"><a href="#图片库-1" class="headerlink" title="图片库"></a>图片库</h4>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.img</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">3px</span>;</span><br><span class="line">  <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#bebebe</span>;</span><br><span class="line">  <span class="attribute">height</span>:auto;</span><br><span class="line">  <span class="attribute">width</span>:auto;</span><br><span class="line">  <span class="attribute">float</span>:left;</span><br><span class="line">  <span class="attribute">text-align</span>:center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.img</span> <span class="selector-tag">img</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="attribute">display</span>:inline;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">3px</span>;</span><br><span class="line">  <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#bebebe</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.img</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">img</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#333333</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.desc</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="attribute">text-align</span>:center;</span><br><span class="line">  <span class="attribute">font-weight</span>:normal;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>:<span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">10px</span> <span class="number">5px</span> <span class="number">10px</span> <span class="number">5px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">href</span>=<span class="string">"/i/tulip_ballade.jpg"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/i/tulip_ballade_s.jpg"</span> <span class="attr">alt</span>=<span class="string">"Ballade"</span> <span class="attr">width</span>=<span class="string">"160"</span> <span class="attr">height</span>=<span class="string">"160"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"desc"</span>&gt;</span>在此处添加对图像的描述<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>div的类为class包括链接与desc说明，其中链接是以图片为链接src的。<br>最值得注意的是，将a中的img设置为inline，而不是a</p><h4 id="图片透明度"><a href="#图片透明度" class="headerlink" title="图片透明度"></a>图片透明度</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">IMG</span> <span class="selector-pseudo">:HOVER</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">OPACITY</span>:<span class="number">0.4</span>;</span><br><span class="line"><span class="attribute">FILTER</span>:<span class="built_in">ALPHA</span>(OPACITY=40); <span class="comment">/* 针对 IE8 以及更早的版本 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="透明框中的文本"><a href="#透明框中的文本" class="headerlink" title="透明框中的文本"></a>透明框中的文本</h5>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.background</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">266px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">'/i/tulip_peach_blossom_w.jpg'</span>) no-repeat;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.transbox</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">338px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">204px</span>;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">  <span class="comment">/* for IE */</span></span><br><span class="line">  <span class="attribute">filter</span>:<span class="built_in">alpha</span>(opacity=60);</span><br><span class="line">  <span class="comment">/* CSS3 standard */</span></span><br><span class="line">  <span class="attribute">opacity</span>:<span class="number">0.6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.transbox</span> <span class="selector-tag">p</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">30px</span> <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"background"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"transbox"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  This is some text that is placed in the transparent box.</span><br><span class="line">  This is some text that is placed in the transparent box.</span><br><span class="line">  This is some text that is placed in the transparent box.</span><br><span class="line">  This is some text that is placed in the transparent box.</span><br><span class="line">  This is some text that is placed in the transparent box.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对backgroud设置背景图片与大小，然后在其中设置文本框，包括边距、透明度、背景颜色为白色很重要。透明度也是在白色背景基础上完成的。</p><h3 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h3><p>导航栏 = 链接列表</p><h4 id="水平菜单"><a href="#水平菜单" class="headerlink" title="水平菜单"></a>水平菜单</h4>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">float</span>:left;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line"><span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line"><span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line"><span class="attribute">list-style-type</span>:none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">float</span>:left;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">7em</span>;</span><br><span class="line"><span class="attribute">text-decoration</span>:none;</span><br><span class="line"><span class="attribute">color</span>:white;</span><br><span class="line"><span class="attribute">background-color</span>:purple;</span><br><span class="line"><span class="attribute">padding</span>:<span class="number">0.2em</span> <span class="number">0.6em</span>;</span><br><span class="line"><span class="attribute">border-right</span>:<span class="number">1px</span> solid white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Link one<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Link two<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Link three<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Link four<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="垂直菜单"><a href="#垂直菜单" class="headerlink" title="垂直菜单"></a>垂直菜单</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line"><span class="selector-tag">ul</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">list-style-type</span>:none;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">display</span>:block;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>:<span class="number">#dddddd</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h4 id="水平菜单-1"><a href="#水平菜单-1" class="headerlink" title="水平菜单"></a>水平菜单</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line"><span class="selector-tag">ul</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">list-style-type</span>:none;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">overflow</span>:hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">float</span>:left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">display</span>:block;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>:<span class="number">#dddddd</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h1 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h1><h2 id="2D转换transform"><a href="#2D转换transform" class="headerlink" title="2D转换transform"></a>2D转换transform</h2><ul><li><p>translate()移动</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(50px,100px);</span><br><span class="line">  <span class="attribute">-ms-transform</span>: <span class="built_in">translate</span>(50px,100px);<span class="comment">/* IE 9 */</span></span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">translate</span>(50px,100px);<span class="comment">/* Safari and Chrome */</span></span><br><span class="line">  <span class="attribute">-o-transform</span>: <span class="built_in">translate</span>(50px,100px);<span class="comment">/* Opera */</span></span><br><span class="line">  <span class="attribute">-moz-transform</span>: <span class="built_in">translate</span>(50px,100px);<span class="comment">/* Firefox */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>rotate()旋转</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="attribute">transform</span>: <span class="built_in">rotate</span>(30deg);</span><br><span class="line"> <span class="attribute">-ms-transform</span>: <span class="built_in">rotate</span>(30deg);<span class="comment">/* IE 9 */</span></span><br><span class="line"> <span class="attribute">-webkit-transform</span>: <span class="built_in">rotate</span>(30deg);<span class="comment">/* Safari and Chrome */</span></span><br><span class="line"> <span class="attribute">-o-transform</span>: <span class="built_in">rotate</span>(30deg);<span class="comment">/* Opera */</span></span><br><span class="line"> <span class="attribute">-moz-transform</span>: <span class="built_in">rotate</span>(30deg);<span class="comment">/* Firefox */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>scale()拉伸</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="attribute">transform</span>: <span class="built_in">scale</span>(2,4);</span><br><span class="line"> <span class="attribute">-ms-transform</span>: <span class="built_in">scale</span>(2,4);<span class="comment">/* IE 9 */</span></span><br><span class="line"> <span class="attribute">-webkit-transform</span>: <span class="built_in">scale</span>(2,4);<span class="comment">/* Safari 和 Chrome */</span></span><br><span class="line"> <span class="attribute">-o-transform</span>: <span class="built_in">scale</span>(2,4);<span class="comment">/* Opera */</span></span><br><span class="line"> <span class="attribute">-moz-transform</span>: <span class="built_in">scale</span>(2,4);<span class="comment">/* Firefox */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>skew()倾斜</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="attribute">transform</span>: <span class="built_in">skew</span>(30deg,20deg);</span><br><span class="line"> <span class="attribute">-ms-transform</span>: <span class="built_in">skew</span>(30deg,20deg);<span class="comment">/* IE 9 */</span></span><br><span class="line"> <span class="attribute">-webkit-transform</span>: <span class="built_in">skew</span>(30deg,20deg);<span class="comment">/* Safari and Chrome */</span></span><br><span class="line"> <span class="attribute">-o-transform</span>: <span class="built_in">skew</span>(30deg,20deg);<span class="comment">/* Opera */</span></span><br><span class="line"> <span class="attribute">-moz-transform</span>: <span class="built_in">skew</span>(30deg,20deg);<span class="comment">/* Firefox */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>matrix():</p><p>需要六个参数，包含数学函数，允许您：旋转、缩放、移动以及倾斜元素。</p></li></ul><h2 id="3D转换"><a href="#3D转换" class="headerlink" title="3D转换"></a>3D转换</h2><p>就是2D转换后加X、Y、Z、3D等表示在那个轴进行</p><p>如translate3d(x,y,z),translateX(x),translateY(y),translateZ(z)</p><h2 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h2><p>CSS3 过渡是元素从一种样式逐渐改变为另一种的效果。</p><p>  要实现这一点，必须规定两项内容：</p><p>  规定您希望把效果添加到哪个 CSS 属性上</p><p>  规定效果的时长</p><h3 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h3>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt; </span><br><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>:yellow;</span><br><span class="line">  <span class="attribute">transition</span>:width <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">-moz-transition</span>:width <span class="number">2s</span>; <span class="comment">/* Firefox 4 */</span></span><br><span class="line">  <span class="attribute">-webkit-transition</span>:width <span class="number">2s</span>; <span class="comment">/* Safari and Chrome */</span></span><br><span class="line">  <span class="attribute">-o-transition</span>:width <span class="number">2s</span>; <span class="comment">/* Opera */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt; </span><br><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>:yellow;</span><br><span class="line">  <span class="attribute">transition</span>:width <span class="number">2s</span>, height <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">-moz-transition</span>:width <span class="number">2s</span>, height <span class="number">2s</span>, -moz-transform <span class="number">2s</span>; <span class="comment">/* Firefox 4 */</span></span><br><span class="line">  <span class="attribute">-webkit-transition</span>:width <span class="number">2s</span>, height <span class="number">2s</span>, -webkit-transform <span class="number">2s</span>; <span class="comment">/* Safari and Chrome */</span></span><br><span class="line">  <span class="attribute">-o-transition</span>:width <span class="number">2s</span>, height <span class="number">2s</span>, -o-transform <span class="number">2s</span>; <span class="comment">/* Opera */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">transform</span>:<span class="built_in">rotate</span>(180deg);</span><br><span class="line">  <span class="attribute">-moz-transform</span>:<span class="built_in">rotate</span>(180deg); <span class="comment">/* Firefox 4 */</span></span><br><span class="line">  <span class="attribute">-webkit-transform</span>:<span class="built_in">rotate</span>(180deg); <span class="comment">/* Safari and Chrome */</span></span><br><span class="line">  <span class="attribute">-o-transform</span>:<span class="built_in">rotate</span>(180deg); <span class="comment">/* Opera */</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h2 id="动画-keyframes及animation"><a href="#动画-keyframes及animation" class="headerlink" title="动画@keyframes及animation"></a>动画@keyframes及animation</h2><p>如需在 CSS3 中创建动画，您需要学习 @keyframes 规则。</p><p>@keyframes 规则用于创建动画。在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果。</p><p>先用@keyframes创建动画，然后用animation绑定到div元素上。动画其实是上述过渡的更进一步。需要对各个浏览器进行匹配。</p><h3 id="背景色"><a href="#背景色" class="headerlink" title="背景色"></a>背景色</h3>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt; </span><br><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line"><span class="attribute">background</span>:red;</span><br><span class="line"><span class="attribute">animation</span>:myfirst <span class="number">5s</span>;</span><br><span class="line"><span class="attribute">-moz-animation</span>:myfirst <span class="number">5s</span>; <span class="comment">/* Firefox */</span></span><br><span class="line"><span class="attribute">-webkit-animation</span>:myfirst <span class="number">5s</span>; <span class="comment">/* Safari and Chrome */</span></span><br><span class="line"><span class="attribute">-o-animation</span>:myfirst <span class="number">5s</span>; <span class="comment">/* Opera */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">keyframes</span> myfirst</span><br><span class="line">&#123;</span><br><span class="line">0%   &#123;<span class="attribute">background</span>:red;&#125;</span><br><span class="line">25%  &#123;<span class="attribute">background</span>:yellow;&#125;</span><br><span class="line">50%  &#123;<span class="attribute">background</span>:blue;&#125;</span><br><span class="line">100% &#123;<span class="attribute">background</span>:green;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-<span class="keyword">moz</span>-<span class="keyword">keyframes</span> myfirst /* Firefox */</span><br><span class="line">&#123;</span><br><span class="line">0%   &#123;<span class="attribute">background</span>:red;&#125;</span><br><span class="line">25%  &#123;<span class="attribute">background</span>:yellow;&#125;</span><br><span class="line">50%  &#123;<span class="attribute">background</span>:blue;&#125;</span><br><span class="line">100% &#123;<span class="attribute">background</span>:green;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-<span class="keyword">webkit</span>-<span class="keyword">keyframes</span> myfirst /* Safari and Chrome */</span><br><span class="line">&#123;</span><br><span class="line">0%   &#123;<span class="attribute">background</span>:red;&#125;</span><br><span class="line">25%  &#123;<span class="attribute">background</span>:yellow;&#125;</span><br><span class="line">50%  &#123;<span class="attribute">background</span>:blue;&#125;</span><br><span class="line">100% &#123;<span class="attribute">background</span>:green;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-<span class="keyword">o</span>-<span class="keyword">keyframes</span> myfirst /* Opera */</span><br><span class="line">&#123;</span><br><span class="line">0%   &#123;<span class="attribute">background</span>:red;&#125;</span><br><span class="line">25%  &#123;<span class="attribute">background</span>:yellow;&#125;</span><br><span class="line">50%  &#123;<span class="attribute">background</span>:blue;&#125;</span><br><span class="line">100% &#123;<span class="attribute">background</span>:green;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h3>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">animation</span>: myfirst <span class="number">5s</span> linear <span class="number">2s</span> infinite alternate;</span><br><span class="line"><span class="comment">/* Firefox: */</span></span><br><span class="line"><span class="attribute">-moz-animation</span>: myfirst <span class="number">5s</span> linear <span class="number">2s</span> infinite alternate;</span><br><span class="line"><span class="comment">/* Safari 和 Chrome: */</span></span><br><span class="line"><span class="attribute">-webkit-animation</span>: myfirst <span class="number">5s</span> linear <span class="number">2s</span> infinite alternate;</span><br><span class="line"><span class="comment">/* Opera: */</span></span><br><span class="line"><span class="attribute">-o-animation</span>: myfirst <span class="number">5s</span> linear <span class="number">2s</span> infinite alternate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多列"><a href="#多列" class="headerlink" title="多列"></a>多列</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>通过 CSS3，您能够创建多个列来对文本进行布局 - 就像报纸那样！</p><p>多列属性：</p><p>column-count</p><p>column-gap</p><p>column-rule </p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt; </span><br><span class="line"><span class="selector-class">.newspaper</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">-moz-column-count</span>:<span class="number">3</span>; <span class="comment">/* Firefox */</span></span><br><span class="line"><span class="attribute">-webkit-column-count</span>:<span class="number">3</span>; <span class="comment">/* Safari and Chrome */</span></span><br><span class="line"><span class="attribute">column-count</span>:<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">-moz-column-gap</span>:<span class="number">30px</span>; <span class="comment">/* Firefox */</span></span><br><span class="line"><span class="attribute">-webkit-column-gap</span>:<span class="number">30px</span>; <span class="comment">/* Safari and Chrome */</span></span><br><span class="line"><span class="attribute">column-gap</span>:<span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要介绍css与css3&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>HTML基础</title>
    <link href="http://yoursite.com/2018/08/30/html/"/>
    <id>http://yoursite.com/2018/08/30/html/</id>
    <published>2018-08-30T03:28:35.000Z</published>
    <updated>2018-10-22T08:31:23.368Z</updated>
    
    <content type="html"><![CDATA[<p>主要整理了html，html5</p><a id="more"></a><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><ul><li>HTML意思为超文本文档，首先是“文档”，类比word文档，有标题<code>&lt;h1&gt;-&lt;h6&gt;</code>，有段落<code>&lt;p&gt;</code>，有表格<code>&lt;table&gt;</code>，有图片<code>&lt;img&gt;</code>。其次是“超文本”，会有更多的元素，包括超链接<code>&lt;a href=&quot;&quot;&gt;</code>，视频，音频等等。所有这些元素各有各的属性、内容，用于对不同元素进行充实。</li><li>元素由三部分组成：标签、属性、内容。标签用于说明元素的类型，属性用来如何展示内容，内容是显示元素。</li></ul><h2 id="头部head"><a href="#头部head" class="headerlink" title="头部head"></a>头部head</h2><ul><li>title:标题，添加到收藏夹时显示的标题，</li><li>base定义页面上所有链接的默认地址。</li><li>link本文档与外部资源『文档』的关系</li><li>style：定义文档的样式信息。</li><li>script:客户端脚本</li><li>meta：关于HTML文档的元数据，包括作者，版权，描述，关键字，可用作搜素</li></ul><h2 id="js脚本"><a href="#js脚本" class="headerlink" title="js脚本"></a>js脚本</h2><ul><li><p><code>&lt;script&gt;</code>元素type=”text/javascript”，document.write来写入</p></li><li><p>位置</p><p>可以包含在header中，这样只有等js加载完成网页才能显示</p><p>js思想中推荐放在<code>&lt;body&gt;</code>最后，这样可以加速加载，具体使用看情况</p></li></ul><h2 id="文本元素"><a href="#文本元素" class="headerlink" title="文本元素"></a>文本元素</h2><p>包括align(对齐)、bgcolor（背景色）、color（字体颜色）等，都用style(样式)来替代。样式的好处可以直接添加到HTML元素，并将可以将样式在css文件中实现。</p><ul><li>对齐 style=”text-align:center”</li><li>字体 style=”font-family:verdana;color:red;font-size:20px;”</li><li><p>背景色 style=”background-color:red”</p></li><li><p>字体修改（b粗体、i斜体、big/small大小体、del删除、ins下划线、sub/sup上下标等各式）；</p></li><li>计算机输出（编程代码：code代码,var变量，kbd输入，samp代码样本，pre预各式）；</li><li>引用和属术语定义(abbr定义缩写，acronym首字母缩写，title属性显示完全内容，address定义地址)。</li></ul><h2 id="超文本元素"><a href="#超文本元素" class="headerlink" title="超文本元素"></a>超文本元素</h2><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><ul><li>链接有2种方式：href超链接，指向另一个文档的链接；另一个指向由name元素创建的文档内的书签。</li><li>超链接可以是文本，也可以是图像。</li><li>target=”_blank”，属性可以用来在新的文档中打开。</li></ul><h3 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h3><ul><li><code>&lt;img src=&quot;boat.gif&quot; alt=&quot;Big Boat&quot;&gt;</code></li><li>属性align=”bottom” “top” “middle” “left” “right”</li><li>属性width,height </li><li><p>map area</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">map</span> <span class="attr">name</span>=<span class="string">"planetmap"</span> <span class="attr">id</span>=<span class="string">"planetmap"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">area</span></span></span><br><span class="line"><span class="tag">  <span class="attr">shape</span>=<span class="string">"circle"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">coords</span>=<span class="string">"180,139,14"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">href</span>=<span class="string">"/example/html/venus.html"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">target</span>=<span class="string">"_blank"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">alt</span>=<span class="string">"Venus"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">area</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><ul><li><code>&lt;table&gt;&lt;/table&gt;</code> :border bgcolor background frame=”above” “box” “hsizes”</li><li>tr(table row)</li><li>td(table data) &amp;nbsp</li><li>th(table head)</li><li>caption</li><li>cellpadding</li><li>cellspacing</li></ul><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ul><li>无序列表<code>&lt;ul&gt;:&lt;li&gt;</code> 属性type=”circle” “square” “disc”</li><li>有序列表<code>&lt;ol&gt;</code>属性type=”A” “a” “I” “i”</li><li>定义列表dl,<code>&lt;dt&gt;</code>定义项目<code>&lt;dd&gt;</code>定义描述。</li></ul><h2 id="块与布局"><a href="#块与布局" class="headerlink" title="块与布局"></a>块与布局</h2><h3 id="块"><a href="#块" class="headerlink" title="块"></a>块</h3><ul><li>通过<code>&lt;div&gt;</code>与<code>&lt;span&gt;</code>将HTML元素组合起来。</li><li><p>块元素其实是模块化思想的结果。同CSS一起使用,<code>&lt;div&gt;</code>元素可以用于对大的内容块设置样式属性。另一个常见的用途是文档布局，它取代了使用表格定义布局的老式方法。 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"color:#00ff00"</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>&lt;span&gt;</code>更多的是对行内的进行修改。如注：这种情况。</p></li></ul><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul><li>对块进行分类，使我们能为元素的类定义CSS样式。</li><li>div标签的class = “cities”属性</li></ul><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><ul><li><code>&lt;div&gt;</code>元素用作布局，并能轻松通过CSS对其进行定位。</li><li>在head元素中的<code>&lt;style&gt;</code>元素来定义各个类的颜色、位置等信息。</li><li>在body元素中使用定义的类来显示内容。</li><li>header,footer,nav,section</li></ul><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><h3 id="响应式设计RWD"><a href="#响应式设计RWD" class="headerlink" title="响应式设计RWD"></a>响应式设计RWD</h3><ul><li>RWD能够以可变尺寸传递网页，对于平板和移动设备是必须的。</li><li>使用现成的CSS框架，Bootstrap。</li><li>meta charset=”utf-8”</li><li><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;http://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css&quot;&gt;</code></li><li>link之后可以在div中使用类”container”,”jumbotron”,”row”,”col-md-4”等属性来控制样式。</li></ul><h3 id="frame"><a href="#frame" class="headerlink" title="frame"></a>frame</h3><ul><li>所谓框架，就是在一个页面中，使用一定的布局来显示多个html文档</li><li>frameset标签</li><li>rows/columns属性，规定了每行或者每列的占屏比例。</li><li><code>&lt;frame src=&quot;frame_a.html&quot; noresize=&quot;noresize&quot;&gt;</code></li></ul><h3 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h3><p>可以在body元素中使用，并可通过name属性命名，可通过target=””来选择内联框架使用。类似于”_blank”</p><h2 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h2><ul><li>类似于C语言中的\作用，转义：<ul><li>空格   &amp;nbsp</li><li><code>&lt;</code>   &amp;lt</li><li><code>&gt;</code>   &amp;gt</li><li><code>&amp;</code>   &amp;amp</li><li><code>&quot;</code>   &amp;quot</li><li><code>*</code>   &amp;times</li><li><code>/</code>  &amp;divides</li></ul></li></ul><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><h3 id="form"><a href="#form" class="headerlink" title="form"></a>form</h3><p>  <code>&lt;form&gt;</code>表单用于收集用户的输入</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">.</span><br><span class="line">表单元素</span><br><span class="line">.</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  表单元素指的是不同类型的输入元素、复选框、单选按钮、提交按钮等等。</p><h3 id="input"><a href="#input" class="headerlink" title="input"></a>input</h3><ul><li><p>type</p><p>| 类型      | 描述              |<br>| -        | -:                |<br>| text     | 定义常规文本输入     |<br>| radio    | 单选按钮            |<br>| checkbox | 复选框             |<br>| button   | 按钮，响应onclick   |<br>| submit   | 提交按钮           |<br>| password | 字符会被做掩码处理  |<br>| file     | 上传文档          |<br>| image    | 上传图片          |<br>| email    | html5增加，检查@   |<br>| number   | html5增加，检查数字 |<br>| range    | html5增加，滑动块   |<br>| date     | html5增加，日期     |<br>| datetime | html5增加，日期时间 |<br>| color    | html5增加，颜色 |<br>| url      | html5增加，url |</p></li></ul><pre><code><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">name</span>=<span class="string">"points"</span> <span class="attr">min</span>=<span class="string">"0"</span> <span class="attr">max</span>=<span class="string">"10"</span> <span class="attr">step</span>=<span class="string">"3"</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"male"</span> <span class="attr">checked</span>&gt;</span>Male</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"female"</span>&gt;</span>Female</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"alert('Hello World!')"</span> <span class="attr">value</span>=<span class="string">"Click Me!"</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">Birthday:</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"date"</span> <span class="attr">name</span>=<span class="string">"bday"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></code></pre><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>  下拉框</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"cars"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"volvo"</span>&gt;</span>Volvo<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"saab"</span>&gt;</span>Saab<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"fiat"</span>&gt;</span>Fiat<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"audi"</span>&gt;</span>Audi<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="textarea"><a href="#textarea" class="headerlink" title="textarea"></a>textarea</h3><p>  多行输入</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">"message"</span> <span class="attr">rows</span>=<span class="string">"10"</span> <span class="attr">cols</span>=<span class="string">"30"</span>&gt;</span></span><br><span class="line">The cat was playing in the garden.</span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="datalist"><a href="#datalist" class="headerlink" title="datalist"></a>datalist</h3><p>  datalist也是下拉框，但可以输入数据，可以看到预设的option</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"action_page.php"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">list</span>=<span class="string">"browsers"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">"browsers"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Internet Explorer"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Firefox"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Chrome"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li><p>autocomplete</p><p>表单的记忆功能，对input与form都有效，与private类似，父标签声明对子标签有用，子标签的声明大于的声明。</p></li><li><p>autofocus</p><p>自定义焦点，对于input可能会更有用一些。</p></li><li><p>表单的form属性</p><p>实现了在form外声明表单的可能。</p></li><li><p>formaction属性</p><p>为submit标签，提供了，重载action的方法。</p></li><li><p>list属性</p><ul><li>规定输入域的datalist（选项列表） </li><li>list=”url_list”</li><li><code>&lt;datalist id=&quot;url_list&quot;&gt;</code></li></ul></li><li><p>multiple属性</p><ul><li>规定输入框中可以选择多个值</li><li><code>&lt;input type=&quot;file&quot; name=&quot;img&quot; multiple=&quot;multiple&quot; /&gt;</code></li></ul></li><li><p>novalidate属性</p><ul><li>novalidate属性规定在提交表单时不应该验证form或input域</li><li><code>&lt;form action=&quot;demo_form.asp&quot; method=&quot;get&quot; novalidate=&quot;true&quot;&gt;</code></li><li>在这种情况下，type=”email”时就不再验证@</li></ul></li><li><p>pattern属性</p><ul><li>用于验证ipnut域的模式，正则表达式</li><li><code>&lt;input type=&quot;text&quot; name=&quot;country_code&quot; pattern=&quot;[A-Z]{3}&quot; title=&quot;three letter country code&quot; /&gt;</code></li></ul></li><li><p>placeholder</p><ul><li>属性提供一种提示，描述输入域所期待的值</li><li><code>&lt;input type=&quot;search&quot; name=&quot;user_search&quot; placeholder=&quot;Search W3School&quot; /&gt;</code></li></ul></li><li><p>required</p><ul><li>required属性规定必须在提交之前写输入域（不能为空）</li><li><code>&lt;input type=&quot;text&quot; name=&quot;usr_name&quot; required=&quot;required&quot; /&gt;</code></li></ul></li></ul><h1 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li>RIA技术</li><li>服务器、浏览器的交互历史：文本、图片、声音、动画、可交互游戏、游戏</li><li>flex、sliverlight、flash、html5</li></ul><h3 id="发展简史"><a href="#发展简史" class="headerlink" title="发展简史"></a>发展简史</h3><ul><li>html1.0 (1993) </li><li>html 2.0 (1994) </li><li>html4.0(1999),使用最多。</li><li>w3c组织–&gt; xhtml –&gt; xhtml2.0 (xml标准)这个版本被主流浏览器公司有意见</li><li>主流浏览器厂商组织WHATGW，2004年提出html5.0草案 –&gt; 合并成一个2008年提出html5.0</li></ul><h3 id="HTML5-约等于-HTML-CSS3-Javascript-APIs"><a href="#HTML5-约等于-HTML-CSS3-Javascript-APIs" class="headerlink" title="HTML5 约等于 HTML+CSS3+Javascript APIs"></a>HTML5 约等于 HTML+CSS3+Javascript APIs</h3><ul><li><p>HTML5支持了Css3的强大的选择器和动画等功能， 再加上支持了Javascript的新的函数API，所以就很强大了。</p></li><li><p>chrome、firefox、opera；UC、QQ、百度等</p></li></ul><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li><p>增加了<code>&lt;header&gt;&lt;footer&gt;</code>标签，做到内容与结构分离，我们很多网页都有头和尾</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span>网页的头部<span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">hell,world</span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span>网页的尾部<span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>增加了<code>&lt;canvas&gt;</code>标签，画布标签，程序员可以在这里绘制图形，在一定程度上可替代flash</p></li><li><p>增加了<code>&lt;video&gt;</code> 和 <code>&lt;audio&gt;</code>标签，用于音频和视频的嵌入功能<br>使视频与音频的嵌入变得简单<br>1、这里的video支持ogg格式与mp4格式<br>2、如果把这个html5_2.html放在apache下，就可以看这个视频。</p></li><li><p>增加离线存储功能</p></li></ul><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">width</span>=<span class="string">"320"</span> <span class="attr">height</span>=<span class="string">"240"</span> <span class="attr">controls</span>=<span class="string">"controls"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"/i/movie.ogg"</span> <span class="attr">type</span>=<span class="string">"video/ogg"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>video的属性包括</p><ul><li>autoplay </li><li>controls</li><li>height/width</li><li>loop</li><li>preload</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span>=<span class="string">"controls"</span> <span class="attr">autoplay</span>=<span class="string">"autoplay"</span> <span class="attr">loop</span>=<span class="string">"loop"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>video + dom 进行控制</p><ul><li><p><code>&lt;video&gt;</code>元素同样拥有方法、属性和事件。<br>方法用于播放、暂停以及加载等。<br>属性（时长、音量等）可以被读取或设置<br>其中的DOM事件能够通知您，如<code>&lt;video&gt;</code>元素开始播放、已暂停、已停止等。</p></li><li><p>示例：<br>先用<code>&lt;div&gt;</code>画出<code>&lt;button&gt;</code>与<code>&lt;video&gt;</code>，在<code>&lt;button&gt;</code>中指定槽函数<br>然后用<code>&lt;script&gt;</code>脚本，来获取到<code>&lt;video&gt;</code>元素，在槽函数的实现中，完成对<code>&lt;video&gt;</code>的控制如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"playPause()"</span>&gt;</span>播放/暂停<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"makeBigger"</span>&gt;</span>大<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"makeSmaller"</span>&gt;</span>小<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">video</span> <span class="attr">id</span>=<span class="string">"v1"</span> <span class="attr">controls</span>=<span class="string">"controls"</span> <span class="attr">width</span>=<span class="string">"400"</span> <span class="attr">heigh</span>=<span class="string">"400"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"/example/html5/move.bbb.mp4"</span> <span class="attr">type</span>=<span class="string">"video/mp4"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> testVedio = <span class="built_in">document</span>.getElementById(<span class="string">"v1"</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">playPause</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="undefined">  &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span>(testVedio.paused)</span></span><br><span class="line"><span class="undefined">    testVedio.play();</span></span><br><span class="line"><span class="javascript">  <span class="keyword">else</span></span></span><br><span class="line"><span class="undefined">    testVedio.pause();</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">makeBigger</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="undefined">  &#123;</span></span><br><span class="line"><span class="undefined">    testVedio.width += 20;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">makeSmaller</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="undefined">  &#123;</span></span><br><span class="line"><span class="undefined">    testVedio.width -= 20;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">scipt</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>总结：先用<code>&lt;div&gt;</code>将控件、视频等画出，在通过<code>&lt;script&gt;</code>将使用的函数实现。类似于C的全局实现</p></li><li><p>方法、属性以及事件<br>方法：play()、pause()、load()<br>  属性：paused、height、width、muted、volume、ended；可以通过对属性的控制来实现方法的控制。可以都认为是public<br>  事件：play/pause/ended等等。</p></li></ul></li></ul><h3 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h3><ul><li><p>示例1</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">"song.ogg"</span> <span class="attr">controls</span>=<span class="string">"controls"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>示例2</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>=<span class="string">"controls"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"song.ogg"</span> <span class="attr">type</span>=<span class="string">"audio/ogg"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"song.mp3"</span> <span class="attr">type</span>=<span class="string">"audio/mp3"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;audio&gt;</code>元素允许有多个source。source元素可以链接不同的音频文件。浏览器将使用第一个可视频的格式。</p></li><li><p>标签属性</p><p>与视频相同属性包括：controls/autoplay/loop/preload<br>还包括一种src</p></li></ul><h3 id="画布"><a href="#画布" class="headerlink" title="画布"></a>画布</h3><p> <code>&lt;canvas&gt;</code>使用JavaScript在网页上绘制图像。画图是一个矩形区域，您可以控制其每一个像素。canvas拥有每种绘制路径、矩形、圆形、字符以及添加图像的方法。</p><ul><li><p>基本运用</p><ul><li><p>创建Canvas元素 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"myCanvas"</span> <span class="attr">width</span>=<span class="string">"200"</span> <span class="attr">height</span>=<span class="string">"100"</span> <span class="attr">style</span>=<span class="string">"border:1px solid #c3c3c3;"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>通过JavaScript来绘制</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javacript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> c=<span class="built_in">document</span>.getElementById(<span class="string">"myCanvas"</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> cxt=c.getContext(<span class="string">"2d"</span>);</span></span><br><span class="line"><span class="javascript">cxt.fillStyle = <span class="string">"#FF0000"</span>;</span></span><br><span class="line"><span class="undefined">cxt.fillRect(0,0,150,75);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Javascript的绘制函数</p><ul><li><p>直线</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cxt.moveTo(10,10);   //移动到起始位置</span><br><span class="line">cxt.lineTo(150,50);  //画线到（150，50）</span><br><span class="line">cxt.lineTo(10,50);   //从(150,10),画到(10,50)</span><br><span class="line">cxt.stroke();</span><br></pre></td></tr></table></figure></li><li><p>画圆</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cxt.fillStyle="#FF0000";</span><br><span class="line">cxt.beginPath();</span><br><span class="line">cxt.arc(70,18,15,0,Math.PI*2,true);  // 圆心（70，18）半径15</span><br><span class="line">cxt.closePath();</span><br><span class="line">cxt.fill();    // 与stroke()等类似</span><br></pre></td></tr></table></figure></li><li><p>渐变色</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var grd=cxt.createLinearGradient(0,0,175,50);  //创建线性梯度/斜率</span><br><span class="line">grd.addColorStop(0, "#FF0000");  </span><br><span class="line">grd.addColorStop(1, "#00FF00");  // 从红色到绿色的渐进</span><br><span class="line">cxt.fillStyle=grd;</span><br><span class="line">cxt.fillRect(0,0,170,50);</span><br></pre></td></tr></table></figure></li><li><p>图像</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var img=new Image();</span><br><span class="line">img.src="flower.png";</span><br><span class="line">cxt.drawImage(img,0,0);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h3><ul><li><p>基本概念</p><ul><li>SVG可伸缩矢量图形(Scalable Vector Graphics)</li><li>用于定义网络的基于矢量的图形</li><li>使用XML格式定义图形</li><li>图像在放大或者缩小时，图形质量不会有损失</li></ul></li><li><p>优势</p><ul><li>可通过文本编辑器来创建和修改</li><li>在任何分辨率下被高质量的打印，在图像质量不下降的情况下放大。</li></ul></li><li><p>实例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/2000/svg"</span> <span class="attr">version</span>=<span class="string">"1.1"</span> <span class="attr">height</span>=<span class="string">"190"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">polygon</span> <span class="attr">points</span>=<span class="string">"100,40 40,180 190,60 10,60 160,180"</span> </span></span><br><span class="line"><span class="tag">               <span class="attr">style</span>=<span class="string">"fill:red;stroke:blue;stroke-width:3;fill-rule:evenodd;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>说明<br>// 画多边形，从一个点到另一个点</p><p>// 动词fill为填充，stroke为线</p></li><li><p>SVG VS 画布</p><ul><li><p>Canvas</p><ul><li>依赖分辨率</li><li>不支持事件处理器</li><li>弱的文本渲染能力</li><li>最适合图像密集型游戏，其中的许多对象会被频繁重绘</li></ul></li><li><p>SVG</p><ul><li>不依赖分辨率</li><li>支持事件处理器</li><li>最适合带有大型渲染区域的应用（谷歌地图）</li><li>复杂度高会减慢渲染速度</li><li>不适合游戏应用，（由于复杂度高，频繁重绘效率低下）</li></ul></li></ul></li></ul><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="地理定位"><a href="#地理定位" class="headerlink" title="地理定位"></a>地理定位</h3><ul><li><p>简介</p><p>地理定位使用navigator.geolocation.getCurrentPosition();函数来实现</p><p>航海家.地理位置.获取当前坐标。可以传递函数作为参数。</p></li><li><p>实例</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span>点击这个按钮，获得您的坐标：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"getLocation()"</span>&gt;</span>试一下<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> x=<span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">getLocation</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="undefined">&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">if</span> (navigator.geolocation)</span></span><br><span class="line"><span class="undefined">    &#123;</span></span><br><span class="line"><span class="undefined">    navigator.geolocation.getCurrentPosition(showPosition,showError);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">else</span>&#123;x.innerHTML=<span class="string">"Geolocation is not supported by this browser."</span>;&#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">showPosition</span>(<span class="params">position</span>)</span></span></span><br><span class="line"><span class="undefined">&#123;</span></span><br><span class="line"><span class="javascript">  x.innerHTML=<span class="string">"Latitude: "</span> + position.coords.latitude + </span></span><br><span class="line"><span class="javascript">  <span class="string">"&lt;br /&gt;Longitude: "</span> + position.coords.longitude;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">showError</span>(<span class="params">error</span>)</span></span></span><br><span class="line"><span class="undefined">&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">switch</span>(error.code) </span></span><br><span class="line"><span class="undefined">    &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">case</span> error.PERMISSION_DENIED:</span></span><br><span class="line"><span class="javascript">      x.innerHTML=<span class="string">"User denied the request for Geolocation."</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">case</span> error.POSITION_UNAVAILABLE:</span></span><br><span class="line"><span class="javascript">      x.innerHTML=<span class="string">"Location information is unavailable."</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">case</span> error.TIMEOUT:</span></span><br><span class="line"><span class="javascript">      x.innerHTML=<span class="string">"The request to get user location timed out."</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">case</span> error.UNKNOWN_ERROR:</span></span><br><span class="line"><span class="javascript">      x.innerHTML=<span class="string">"An unknown error occurred."</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">break</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>getCurrentPosition()方法</p><p>若成功是重返回纬度(latitude)经度(longitude)以及(accuracy)</p><p>  coords.latitude（纬度）</p><p>  coords.longitude（经度）</p><p>  coords.accuracy（经纬的精度）</p><p>  coords.altitude（海拔）</p><p>  coords.altitudeAccuracy(海拔精度)</p><p>  coords.heading（方向）</p><p>  coords.speed(速度）</p><p>  timestamp:时间戳</p></li></ul><h3 id="Web存储"><a href="#Web存储" class="headerlink" title="Web存储"></a>Web存储</h3><ul><li><p>简介</p><ul><li><p>HTML5提供两种客户端存储数据的方法：</p><p>localStorage：永久的存储</p><p>sessionStorage：基于会话的存储</p></li><li><p>对于不同网站，数据存储于不同区域，一个网站只能访问其自身的数据</p></li><li><p>HTML5使用Javascript来存储和访问数据。</p></li></ul></li><li><p>localStorage</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span>(localStorage.pagecount)</span></span><br><span class="line"><span class="undefined">&#123;</span></span><br><span class="line"><span class="javascript">    localStorage.pagecount = <span class="built_in">Number</span>(localStorage.pagecount)+<span class="number">1</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">else</span></span></span><br><span class="line"><span class="undefined">&#123;</span></span><br><span class="line"><span class="undefined">    localStorage.pagecount = 1;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="javascript">documents.write(<span class="string">"visits:"</span> + localStorage.pagecount + <span class="string">"times."</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>sessionStorage</p><p>sessionStorage与lacalStorage类似用法，只不过在关闭网页后，数据清空</p></li></ul><h3 id="应用存储"><a href="#应用存储" class="headerlink" title="应用存储"></a>应用存储</h3><ul><li><p>简介</p><ul><li><p>HTML5引入了应用程序缓存，应用可以从服务端缓存数据，在没有网络连接时，也可进行访问。</p></li><li><p>优势：</p><p>离线浏览</p><p>速度更快</p><p>减少服务器负载，浏览器只从服务器下载更新过的资源即可。</p></li></ul></li><li><p>实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html manifest=&quot;demo.appache&quot;&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p>Cache Manifest基础</p><ul><li>如需启动应用缓存，在<code>&lt;html&gt;</code>标签中包含manifest属性，并指定manifest文件，扩展 名为 .appache</li><li>浏览器根据manifest文件，对内容进行缓存</li></ul></li><li><p>Manifest文件</p><p>三部分：</p><p>  CACHE MANIFEST:首次打开后进行缓存</p><p>  NETWORK:必须联网，不缓存</p><p>  FALLBACK:断网时的回退界面</p></li><li><p>实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line"># 注释2012-02-21 v1.0.0</span><br><span class="line">/theme.css</span><br><span class="line">/logo.gif</span><br><span class="line">/main.js</span><br><span class="line"></span><br><span class="line">NETWORK:</span><br><span class="line">login.asp</span><br><span class="line"></span><br><span class="line">FALLBACK:</span><br><span class="line">/html5/ /404.html</span><br></pre></td></tr></table></figure></li></ul><h3 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h3><ul><li><p>简介</p><ul><li>当在HTML执行脚本是，页面的状态是堵塞的，知道脚本执行完成</li><li>web worker 是运行在后台的JavaScript，独立与其他脚本，不堵塞（多线程）</li></ul></li><li><p>实例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>计数：<span class="tag">&lt;<span class="name">output</span> <span class="attr">id</span>=<span class="string">"result"</span>&gt;</span><span class="tag">&lt;/<span class="name">output</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"startWorker()"</span>&gt;</span>开始Worker<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"stopWorker()"</span>&gt;</span>开始Worker<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> w;  <span class="comment">// 在此处直接定义会是定时技术延迟3个500ms</span></span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">startWorker</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="undefined">    &#123;</span></span><br><span class="line"><span class="undefined">      # 注意是否支持Woker</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span>(<span class="keyword">typeof</span>(Worker)!=<span class="string">"undefined"</span>)</span></span><br><span class="line"><span class="undefined">      &#123;</span></span><br><span class="line"><span class="undefined">      # 判断变量是否定义</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(<span class="keyword">typeof</span>(w)==<span class="string">"undefined"</span>)</span></span><br><span class="line"><span class="undefined">        &#123;</span></span><br><span class="line"><span class="undefined">          # 创建worker</span></span><br><span class="line"><span class="javascript">          w=<span class="keyword">new</span> Worker(<span class="string">"/example/html5/demo_workers.js"</span>);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        # 相应消息，注意function的写法</span></span><br><span class="line"><span class="javascript">        w.onMessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span></span></span><br><span class="line"><span class="undefined">        &#123;</span></span><br><span class="line"><span class="undefined">          # 注意内容的展示</span></span><br><span class="line"><span class="javascript">          <span class="built_in">document</span>.getElementeById(<span class="string">"result"</span>).innerHTML=event.data;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">"result"</span>).innerHTML=<span class="string">"您的浏览器不支持Worker"</span></span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">stopWorker</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="undefined">    &#123;</span></span><br><span class="line"><span class="undefined">      # 停止worker</span></span><br><span class="line"><span class="undefined">      w.terminate();</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>demo_workers.js的内容如下</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeCount</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  i=i+<span class="number">1</span>;</span><br><span class="line">  # 注意消息的发送</span><br><span class="line">  postMessage(i);</span><br><span class="line">  setTimeOut(<span class="string">"timeCount()"</span>, <span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line">timeCount();</span><br></pre></td></tr></table></figure></li><li><p>注意</p><p>由于worker存在与外部文件中，它无法访问一下的javascript对象</p><p>window对象</p><p>  document对象</p><p>  parent对象</p></li></ul><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><ul><li><p>简介</p><p>Server-Sent事件-单向消息传递</p><p>Server-Sent事件指的是网页自动获取来自服务器的更新。</p><p>  之前的做法是网页轮询是否有更新。但通过服务器发送事件，更新能自动到达</p></li><li><p>实例</p><ul><li><p>客户端</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;h1&gt;获取服务器更新&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">  &lt;div id="result"&gt;&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span>(EventSource)!==<span class="string">"undefined"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">var</span> source = <span class="keyword">new</span> EventSource(<span class="string">"/example/html5/demo_sse.php"</span>);</span><br><span class="line">      source.onmessage=<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">"result"</span>).innerHTML=event.data + <span class="string">"&lt;br /&gt;"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">"result"</span>).innerHTML=<span class="string">"您的浏览器不支持server-sent"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>服务端</p></li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">header(<span class="string">'Content-Type: text/event-stream'</span>);</span><br><span class="line">header(<span class="string">'Cache-Control: no-cache'</span>);</span><br><span class="line"></span><br><span class="line">$time = date(<span class="string">'r'</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"data: The server time is: &#123;$time&#125;\n\n"</span>;</span><br><span class="line">flush();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>疑问</p><p>在EventSource中已经定义了服务器脚本的存在，那岂不是在客户端自己这就可以产生此技术？</p><p>服务器的运行时怎样实现的？</p></li></ul></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>【控件】HTML的学习类似与Qt的学习，首先需要学习的是各个控件的使用，包括：按钮/输出/音频/视频/画布/SVG、地理定位/客户端存储/应用缓存/worker，还要学习各种表单的使用、表格/输入类型：下拉框/输入框，输入框的属性：自动完成、自动foucus、 属性提示、唯一性提示、多属性、不检查有效性等等。</li><li>【布局】除了部件的学习，还有布局的学习，布局大约使用CSS，可以等到CSS时深入学习</li><li>【操作】学习用JavaScript来实现槽函数的控制</li><li>【方式】对于前端、后端结构的理解</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要整理了html，html5&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>docker基础</title>
    <link href="http://yoursite.com/2018/08/28/docker%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/08/28/docker基础/</id>
    <published>2018-08-28T07:56:35.000Z</published>
    <updated>2018-10-22T08:31:41.768Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.docker.com/get-started/" target="_blank" rel="noopener"></a><br>本文内容从docker官方文档摘抄，仅介绍基础概念，将与swarm相关的service、stack都没载入<br><a id="more"></a></p><h1 id="Docker基础"><a href="#Docker基础" class="headerlink" title="Docker基础"></a>Docker基础</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><p>image 与 container<br>A container is launched by running an image. An image is an executable package that includes everything needed to run an application–the code, a runtime, libraries, environment variables, and configuration files.<br>容器就是跑镜像的，镜像包括了程序运行的所有资源,包括代码，运行时，lib，环境变量，配置文件等</p></li><li><p>container 与 docker<br><img src="docker结构.png" alt="docker结构"><br>容器跑在docker上，每个容器之间相互独立。docker运行在host os之上</p><p><img src="纵观docker.png" alt="纵观docker"></p><p><img src="docker工作流程.png" alt="docker工作流程"></p></li></ul><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li><p>docker帮助<br>docker<br>docker COMMAND –help<br>docker container –help</p></li><li><p>docker版本<br>docker –version</p></li><li><p>docker的信息<br>docker info<br>列出docker的基本信息，包括Container状态，image个数等</p></li><li><p>运行image<br>docker run hello-world</p></li><li><p>列出image<br>docker image ls</p></li><li><p>列出container<br>docker container ls        # running<br>docker container ls –all  # all<br>docker container ls -aq    # all in quiet mode</p></li><li><p>列出云节点[对于swarms]<br>docker node ls</p></li><li><p>列出所有服务[对于swarms]<br>docker service ls</p></li><li><p>查看某个服务具体信息[对于swarms]<br> docker service ps 服务id</p></li></ul><h2 id="containers"><a href="#containers" class="headerlink" title="containers"></a>containers</h2><ul><li><p>层级结构<br>Container(底层)<br>Services: 定义container的行为[defines how containers behave in production]<br>Stack:  定义service的相互作用[defines the interacions of all the services]</p></li><li><p>Dockerfile</p><ol><li>映射容器内的资源与容器外的，如端口，磁盘等</li><li>指明需要从外部环境中copy到容器的文件</li></ol><p>创建一空目录，然后在里边创建一Dockerfile格式如下：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 引用一个官方的python镜像 Use an official Python runtime as a parent image</span><br><span class="line">FROM python:2.7-slim</span><br><span class="line"></span><br><span class="line"># 设置工作目录</span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"># 将当前目录copy到容器的/app下</span><br><span class="line">ADD . /app</span><br><span class="line"></span><br><span class="line"># 在容器内安装需要的包 Install any needed packages specified in requirements.txt</span><br><span class="line">RUN pip install --trusted-host pypi.python.org -r requirements.txt</span><br><span class="line"></span><br><span class="line"># 容器内暴露的虚拟端口80 </span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line"># 环境变量 </span><br><span class="line">ENV NAME World</span><br><span class="line"></span><br><span class="line"># 启动容器时运行命令 </span><br><span class="line">CMD [&quot;python&quot;, &quot;app.py&quot;]</span><br></pre></td></tr></table></figure><ul><li><p>app<br>在Dockerfile同级目录下创建2个文件，requirements.txt以及app.py.<br>其中requirements.txt是依赖包，而app.py可以拓展为应用代码<br>这样在Dockerfile被创建为image时，requirements.txt，以及app.py都会被copy到容器内部，由于ADD . /app命令，同时，也可以用80来访问了。<br>pip  install -r requirements.txt只是为python安装了Flask与Redis库，redis本身并没有运行。</p><p>requirements.txt  #依赖包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Flask </span><br><span class="line">Redis</span><br></pre></td></tr></table></figure><p>app.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">from redis import Redis, RedisError</span><br><span class="line">import os</span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line"># Connect to Redis</span><br><span class="line">redis = Redis(host=&quot;redis&quot;, db=0, socket_connect_timeout=2, socket_timeout=2)</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&quot;/&quot;)</span><br><span class="line">def hello():</span><br><span class="line">    try:</span><br><span class="line">        visits = redis.incr(&quot;counter&quot;)</span><br><span class="line">    except RedisError:</span><br><span class="line">        visits = &quot;&lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;&quot;</span><br><span class="line"></span><br><span class="line">    html = &quot;&lt;h3&gt;Hello &#123;name&#125;!&lt;/h3&gt;&quot; \</span><br><span class="line">           &quot;&lt;b&gt;Hostname:&lt;/b&gt; &#123;hostname&#125;&lt;br/&gt;&quot; \</span><br><span class="line">           &quot;&lt;b&gt;Visits:&lt;/b&gt; &#123;visits&#125;&quot;</span><br><span class="line">    return html.format(name=os.getenv(&quot;NAME&quot;, &quot;world&quot;), hostname=socket.gethostname(), visits=visits)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    app.run(host=&apos;0.0.0.0&apos;, port=80)</span><br></pre></td></tr></table></figure></li><li><p>构建app镜像<br>在同目录下执行：<br>docker build -t firendlshello </p></li><li><p>查看镜像<br>docker image ls</p></li><li><p>运行镜像<br>docker run -p 4000:80 friendlyhello<br>这样在外部需要用4000来访问，<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></p></li><li><p>查看运行中的container<br>docker container ls</p></li><li><p>停止container<br>docker container stop “CONTATINER ID”</p></li><li><p>分享镜像[暂时略过]<br>类似于github，有个dockerhub，可以通过docker push 来上传镜像</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://docs.docker.com/get-started/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;/a&gt;&lt;br&gt;本文内容从docker官方文档摘抄，仅介绍基础概念，将与swarm相关的service、stack都没载入&lt;br&gt;
    
    </summary>
    
      <category term="容器" scheme="http://yoursite.com/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>git配置</title>
    <link href="http://yoursite.com/2018/08/28/git%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/08/28/git配置/</id>
    <published>2018-08-28T04:02:35.000Z</published>
    <updated>2018-11-28T01:59:38.676Z</updated>
    
    <content type="html"><![CDATA[<p>主要就是git的配置，包括代理、多个git账户使用配置。</p><a id="more"></a><h1 id="git代理"><a href="#git代理" class="headerlink" title="git代理"></a>git代理</h1><h2 id="启动代理"><a href="#启动代理" class="headerlink" title="启动代理"></a>启动代理</h2><h2 id="http方式设置"><a href="#http方式设置" class="headerlink" title="http方式设置"></a>http方式设置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global https.proxy http://127.0.0.1:1080</span><br><span class="line">git config --global https.proxy https://127.0.0.1:1080</span><br></pre></td></tr></table></figure><p>其他设置（待验证）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy socks5://127.0.0.1:1080</span><br><span class="line">git config --global https.proxy socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure></p><h2 id="取消http设置"><a href="#取消http设置" class="headerlink" title="取消http设置"></a>取消http设置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure><h2 id="ssh方式设置"><a href="#ssh方式设置" class="headerlink" title="ssh方式设置"></a>ssh方式设置</h2><p>使用 <a href="mailto:git@xxoo.com" target="_blank" rel="noopener">git@xxoo.com</a> 这种方式，是用的 SSH 协议。需要在 ~/.ssh/config 目录下配置<br>Host xxoo.com(改成你的站点)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ProxyCommand connect -H 127.0.0.1:1080 %h %p</span><br></pre></td></tr></table></figure></p><h1 id="多个git账户使用"><a href="#多个git账户使用" class="headerlink" title="多个git账户使用"></a>多个git账户使用</h1><h2 id="生成新的ssh"><a href="#生成新的ssh" class="headerlink" title="生成新的ssh"></a>生成新的ssh</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"for duoda"</span></span><br></pre></td></tr></table></figure><h2 id="执行ssh-agent让ssh识别新的私钥"><a href="#执行ssh-agent让ssh识别新的私钥" class="headerlink" title="执行ssh-agent让ssh识别新的私钥"></a>执行ssh-agent让ssh识别新的私钥</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-agent bash</span><br><span class="line">ssh-add ~/.ssh/id_rsa_duoda</span><br></pre></td></tr></table></figure><h2 id="将新的ssh-pub放到gitlab的ssh下"><a href="#将新的ssh-pub放到gitlab的ssh下" class="headerlink" title="将新的ssh-pub放到gitlab的ssh下"></a>将新的ssh-pub放到gitlab的ssh下</h2><h2 id="配置-ssh-config"><a href="#配置-ssh-config" class="headerlink" title="配置.ssh/config"></a>配置.ssh/config</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Host jiangjunyouling.gitlab.com</span><br><span class="line">HostName gitlab.com</span><br><span class="line">User jiangyunyouling</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line"></span><br><span class="line"><span class="comment"># second </span></span><br><span class="line">Host duodasunyanfeng.gitlab.com</span><br><span class="line">HostName gitlab.com</span><br><span class="line">User duodasunyanfeng</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_duoda</span><br></pre></td></tr></table></figure><p>这一步花费了很多功夫，现解释一下：</p><p>Host类似与一个key值，用来代表其下的内容<br>HostName 这里需要写仓库的地址，gitlab.com才可，使用账号名是不好使的<br>User有人写的是git，这里我写的都是账号名，经过测试，并不影响结果<br>IndentityFile是私钥的位置</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>使用时可以先用ssh -T 进行测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@jiangjunyouling.gitlab.com</span><br><span class="line">ssh -T git@duodasunyanfeng.gitlab.com</span><br></pre></td></tr></table></figure><p>这里需要注意2点：</p><ul><li>要使用git@的形式才可，直接使用git -T jiangjunyouling.gitlab.com不可以</li><li>git@后面的值为Host的值，也就是key值，若Host为 duodasunyanfeng 则 ssh -T git@duodasunyanfeng 即可</li></ul><h2 id="clone代码库"><a href="#clone代码库" class="headerlink" title="clone代码库"></a>clone代码库</h2><p>在clone时，原来的地址：<a href="mailto:git@gitlab.com" target="_blank" rel="noopener">git@gitlab.com</a>:duobang/xxxx.git<br>要修改为：<a href="mailto:git@duodasunyanfeng.gitlab.com" target="_blank" rel="noopener">git@duodasunyanfeng.gitlab.com</a>:duobang/xxxx.git来指明使用那个进行clone</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要就是git的配置，包括代理、多个git账户使用配置。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>git使用</title>
    <link href="http://yoursite.com/2018/08/28/git%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/08/28/git使用/</id>
    <published>2018-08-28T03:02:35.000Z</published>
    <updated>2018-11-28T01:31:59.896Z</updated>
    
    <content type="html"><![CDATA[<p>主要就是git仓库概念与分支概念，git比较多，链接几篇博文。<br><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">git仓库概念与基础命令</a><br><a href="https://www.jianshu.com/p/7d0026305569" target="_blank" rel="noopener">git分支管理</a><br><a href="https://www.jianshu.com/p/f7451177476a" target="_blank" rel="noopener">git回滚</a><br><a href="https://www.jianshu.com/p/cc740394faf5" target="_blank" rel="noopener">git分支重命名</a></p><p>以下内容从这几篇文章中摘抄了git仓库<br><a id="more"></a></p><h1 id="git仓库"><a href="#git仓库" class="headerlink" title="git仓库"></a>git仓库</h1><p><img src="git仓库.png" alt="git仓库概念"></p><p> Workspace：工作区<br> Index / Stage：暂存区<br> Repository：仓库区（或本地仓库）<br> Remote：远程仓库</p><h1 id="git分支"><a href="#git分支" class="headerlink" title="git分支"></a>git分支</h1><h2 id="master分支"><a href="#master分支" class="headerlink" title="master分支"></a>master分支</h2><p> 在我们没有创建分支时，git会默认给我们创建一个master分支。刚才讲的HEAD是指向分支的，即当前分支，在这就是指向master分支，而master才是指向提交的。<br> <img src="git的master分支.png" alt="git的master分支"></p><p> 每次提交，master分支都会向前进一步。<br> <img src="master分支移动.png" alt="master分支移动"></p><h2 id="dev分支"><a href="#dev分支" class="headerlink" title="dev分支"></a>dev分支</h2><p> 当我们创建一个分支dev时，Git会创建一个新的指针dev，dev指针会指向master相同的提交版本节点，而HEAD也会指向 dev分支上，即当前版本是dev上的当前最新版本。</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git branch dev       //创建分支</span><br><span class="line">git checkout dev   // 切换分支</span><br><span class="line">或</span><br><span class="line">git checkout -b dev //创建并切换分支</span><br></pre></td></tr></table></figure><p><img src="创建dev分支.png" alt="创建dev分支"></p><p>当我们创建分支并切换到该分支后，Git会将HEAD指向所创建的分支dev上，从而我们以后再提交时，master分支的指针将不会改变，而dev分支的指针会向前移动。<br><img src="dev指针移动.png" alt="dev指针移动"></p><h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><p>有创建就会有合并， 在dev上的工作做完后，就可以把dev分支和master分支合并，合并也非常简单，只需要将master指向dev的当前提交即可。合并之后，HEAD会指向master分支。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge dev //快速模式合并，直接将当前所处分支指针指向dev的当前提交版本。</span><br></pre></td></tr></table></figure></p><p><img src="合并dev分支.png" alt="合并dev分支"></p><p>合并冲突<br>在现实情况下，多多少少还是会出现在merge的时候出现冲突的，即同一个文件在两个分支中都被修改了，在合并时使用快速合并模式*就会产生冲突。<br><img src="分支冲突.png" alt="合并冲突"></p><h2 id="重命名分支"><a href="#重命名分支" class="headerlink" title="重命名分支"></a>重命名分支</h2><ul><li>重命名本地</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m oldName newName</span><br></pre></td></tr></table></figure><ul><li>重命名远程分支</li></ul><p>先重命名本地分支，然后删除远程分支，再把本地分支推动送到远程（创建远程分支），最后与远程分支与本地分支关联</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git branch -m oldName newName</span><br><span class="line"></span><br><span class="line">git push --delete origin oldName</span><br><span class="line"></span><br><span class="line">git push origin newName</span><br><span class="line"></span><br><span class="line">git branch --set-upstream-to origin/newName</span><br></pre></td></tr></table></figure><h2 id="工作区隐藏与分支"><a href="#工作区隐藏与分支" class="headerlink" title="工作区隐藏与分支"></a>工作区隐藏与分支</h2><p>在实际的开发过程中，我们需要去修复一个bug时，我们一般都会去创创建一个issue分支去修复这个bug，所以我们会把当前的工作现场存储起来。</p><p>将当前工作现场隐藏<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure></p><p>bug处理完成，删除issue分支</p><p>查看stash内的工作区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure></p><p>工作区恢复<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git stash apply stash@&#123;0&#125; //恢复现场</span><br><span class="line">git stash drop stash@&#123;0&#125; //删除stash内的stash@&#123;0&#125;工作区</span><br><span class="line">或</span><br><span class="line">git stash pop stash@&#123;0&#125; //恢复现场并删除stash@&#123;0&#125;工作区</span><br></pre></td></tr></table></figure></p><h1 id="git回滚相关"><a href="#git回滚相关" class="headerlink" title="git回滚相关"></a>git回滚相关</h1><h2 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h2><p>reset 为 重置到这次提交，将内容重置到指定的版本。git reset 命令后面是需要加2种参数的：–-hard 和 –-soft。这条命令默认情况下是 -–soft。</p><p>执行上述命令时，这该条commit号之 后（时间作为参考点）的所有commit的修改都会退回到git缓冲区中。使用git status 命令可以在缓冲区中看到这些修改。而如果加上-–hard参数，则缓冲区中不会存储这些修改，git会直接丢弃这部分内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft commit_id</span><br><span class="line">git reset --hard commit_id</span><br></pre></td></tr></table></figure><h2 id="反回滚"><a href="#反回滚" class="headerlink" title="反回滚"></a>反回滚</h2><p>你回滚之后，又后悔了，想恢复到新的版本怎么办？</p><p>用git reflog打印你记录你的每一次操作记录,然后再次执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br><span class="line">git reset --hard commit_id</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要就是git仓库概念与分支概念，git比较多，链接几篇博文。&lt;br&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;git仓库概念与基础命令&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.jianshu.com/p/7d0026305569&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;git分支管理&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.jianshu.com/p/f7451177476a&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;git回滚&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.jianshu.com/p/cc740394faf5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;git分支重命名&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以下内容从这几篇文章中摘抄了git仓库&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>mongo使用总结</title>
    <link href="http://yoursite.com/2018/08/25/mongo%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/08/25/mongo使用总结/</id>
    <published>2018-08-25T11:36:49.000Z</published>
    <updated>2018-11-28T11:44:43.362Z</updated>
    
    <content type="html"><![CDATA[<p>总结在8月份开发过程中对mongo使用经验</p><a id="more"></a><h1 id="mongo的基本操作"><a href="#mongo的基本操作" class="headerlink" title="mongo的基本操作"></a>mongo的基本操作</h1><p>数组中元素的修改都是基于这按元素查询$elemMatch而来，然后通过$来选择哪一个</p><h2 id="数组的元素查询"><a href="#数组的元素查询" class="headerlink" title="数组的元素查询"></a>数组的元素查询</h2><ul><li>实例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> this.db.collection(&quot;tunnelWorkSection&quot;).findOne(</span><br><span class="line">  &#123;</span><br><span class="line">       tunnelID:tunnelID,</span><br><span class="line">       workSectionList:&#123;$elemMatch:&#123;workSectionName: workSection&#125;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">       _id:0, &quot;workSectionList.$&quot;:1</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这样的结果竟然只查询了一个结果，即若workSectionName有多个匹配结果会只查出一个,即使使用find也是如此。</p><ul><li>倒不如用unwind方法来进行查询</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.tunnelWorkSection.aggregate([&#123;$match:&#123;tunnelID:tunnelID&#125;&#125;,&#123;$unwind:&quot;$workSectionList&quot;&#125;, &#123;$match:&#123;&quot;workSectionList.workSectionName&quot;: workSection&#125;&#125;])</span><br></pre></td></tr></table></figure><p>  如此查询的结果就是查询到了所有的，但是拍平的结果。</p><h2 id="数组中元素的修改"><a href="#数组中元素的修改" class="headerlink" title="数组中元素的修改"></a>数组中元素的修改</h2><ul><li>实例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">await this.db.collection(&quot;tunnelWorkSection&quot;).updateOne(</span><br><span class="line">  &#123;</span><br><span class="line">     tunnelID: tunnelID, </span><br><span class="line">     workSectionList:&#123;$elemMatch:&#123;workSectionName: workSection&#125;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;$inc: &#123;&apos;workSectionList.$.finishLength&apos;: finishLength &#125; &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="数组中元素的删除"><a href="#数组中元素的删除" class="headerlink" title="数组中元素的删除"></a>数组中元素的删除</h2><p>按之前的写法，应该很容易写成下边方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">await this.db.collection(&quot;tunnelWorkSection&quot;).updateOne(</span><br><span class="line">   &#123;</span><br><span class="line">      tunnelID: tunnelID, </span><br><span class="line">      workSectionList:&#123;$elemMatch:&#123;workSectionName: workSection&#125;&#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;$pull: &#123;workSectionList:&apos;workSectionList.$&apos;&#125; &#125;</span><br><span class="line"> )</span><br></pre></td></tr></table></figure><p>但很不幸的是，不好使。原因大概是’workSectionList.$’放在value上，只会被认为是字符串。经过几次测试，从数组中删除元素只需要如此即可，pull与pullAll：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.students.update(&#123;tunnelID:tunnelID&#125;,&#123;$pull:&#123;workSectionList:&#123;workSectionName:workSection&#125;&#125;&#125;)</span><br><span class="line"></span><br><span class="line">        await this.db.collection(this.tunnelFixtureCollection).updateOne(</span><br><span class="line">            &#123;tunnelId:tunnelId, fixtureType:fixtureType&#125;,</span><br><span class="line">            &#123;$pull:</span><br><span class="line">                &#123;</span><br><span class="line">                    designValueList:&#123;layer:layer, subCode:subCode&#125;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>完成了对mongo数组中操作的整理后，发现这方面的资料很少<br>于是有些怀疑在数组中放置对每个元素进行操作的这种设计：查询时最终的方案是通过unwind之后进行的查询，unwind造成的结果是本来数组中的元素被扁平到外部，这也暗示这如果用户对数组中的元素感兴趣，它完全可以能就忽视了外层的信息，也就说明，这数组中的元素应该放到单独的表中。</p><h1 id="mongo表的设计"><a href="#mongo表的设计" class="headerlink" title="mongo表的设计"></a>mongo表的设计</h1><h2 id="设计总结"><a href="#设计总结" class="headerlink" title="设计总结"></a>设计总结</h2><ul><li><p>内嵌 or 链接<br>内嵌文档可以将整个数据组织在一个集合中，隧道内嵌工作段，工作段内嵌进尺，进尺内嵌消耗量。但这种内嵌，一方面是内嵌层数变身以后带来的效率的下降，最重要的是操作实现上的难度。</p><p>字典内嵌<br>  字典应该不属于内嵌，因为它的key值相当于属性，只能通过update的unset与set进行删除与新增。访问上可以通过 “.” 来实现快速的查询。<br>  1对多关系中的数据不应该放在字典内嵌中，字典内嵌说明着这些数据地位是不同的，但多中每个1的地位是相同的。<br>  如果内嵌能实现的化，字典内嵌应该是最有希望的。</p><p>数组内嵌<br>  数组类型就是来存储这种1对多关系的，将多方作为元素放在1方的某个属性的value数组里。<br>  这种使用方式就是如mongo基本操作中的内容，如果这些数组作为整体来查询，或者删除比较适合，对于个体进行</p><p>链接<br> 链接就像是关系型数据库类似，通过增加一个字段来完成链接，或者是增加一个保存ID的数组来完成。<br> 链接也存在问题，因为mongo本身不提供join以及事务，多表操作会存在一定的风险。</p></li></ul><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li><p>mongo每条记录都是一个文档，都是Json扩展的Bson<br>所以mongo中每个集合中的文档，可以完全不同。<br>从使用上，我们将文档当作成表的行来使用。</p></li><li><p>mongo的多个记录组成了集合<br>使用上集合当作表来使用</p></li><li><p>mongo不支持事务</p></li><li><p>mongo没有多表的join查询</p><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><h3 id="一对很少"><a href="#一对很少" class="headerlink" title="一对很少"></a>一对很少</h3><p>采用内嵌文档<br>person集合中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   name:&apos;张三&apos;,</span><br><span class="line">   age:20,</span><br><span class="line">   address:[</span><br><span class="line">    &#123;country:&quot;中国&quot;，province:&quot;山西省&quot;，city:&quot;长治市&quot;&#125;，</span><br><span class="line">    &#123;country:&quot;中国&quot;，province:&quot;山西省&quot;，city:&quot;太原市&quot;&#125;</span><br><span class="line">   ]</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><p>优点：不需要单独执行一条语句去获取内嵌的内容<br>缺点：法把这些内嵌文档当做单独的实体去访问<br>适用场合：一对很少且不需要单独访问内嵌内容</p><h3 id="一对少"><a href="#一对少" class="headerlink" title="一对少"></a>一对少</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">person集合</span><br><span class="line">&#123;</span><br><span class="line">  _id:ObjectID(12个字节组成)</span><br><span class="line">  name:&quot;张三&quot;</span><br><span class="line">  age:23</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">人员组集合</span><br><span class="line">&#123;</span><br><span class="line">  name:&quot;一组&quot;，</span><br><span class="line">  persons:[</span><br><span class="line">    ObjectID(&quot;aaaaa&quot;),</span><br><span class="line">    ObjectID(&quot;AAABBB&quot;)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>适用场合：一对多且多的一端内容因为各种理由需要单独存在的情况下可以通过数组的方式引用多的一方的。</p><h3 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">company集合</span><br><span class="line">&#123;</span><br><span class="line">  _id:ObjectID(&quot;company01&quot;)</span><br><span class="line">  name:&quot;可为时代&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">员工集合</span><br><span class="line">&#123;</span><br><span class="line">  name:&quot;张三&quot;,</span><br><span class="line">  age:23,</span><br><span class="line">  company:ObjectID(&quot;company01&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>适用场合：一对非常多的情况下，请将一的那端引用嵌入进多的一端对象中。</p><h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><p>双向的连接，一对多，多对1</p><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><p>a.优先考虑内嵌，除非有什么迫不得已的原因。</p><p>b.需要单独访问一个对象，那这个对象就不适合被内嵌到其他对象中。</p><p>c.数组不应该无限制增长。如果many端有数百个文档对象就不要去内嵌他们可以采用引用ObjectID的方案；如果有数千个文档对象，那么就不要内嵌ObjectID的数组。该采取哪些方案取决于数组的大小。</p><p>d.在进行反范式设计时请先确认读写比。一个几乎不更改只是读取的字段才适合冗余到其他对象中。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li>分组TOP N</li><li>解析器 或 状态机</li><li>多条件查询</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结在8月份开发过程中对mongo使用经验&lt;/p&gt;
    
    </summary>
    
      <category term="数据存储" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
    
      <category term="Mongo" scheme="http://yoursite.com/tags/Mongo/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript ES6基础</title>
    <link href="http://yoursite.com/2018/08/10/JavaScript%20ES6%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/08/10/JavaScript ES6基础/</id>
    <published>2018-08-10T01:50:00.000Z</published>
    <updated>2018-11-28T02:05:56.392Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍es6，包括了块级作用域、数组对象的解构赋值、…操作符、基本类型的扩展、引用类型的扩展（Array、Set、Map），函数的扩展、对象的扩展、class、异步等内容，最后是装饰器的简单介绍，还有一些特性并未加入，比如Generator、yield，proxy等内容。</p><h1 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h1><p>在es5中，只有全局作用域与函数作用域，没有块级作用域。es6通过引入let与const，实际上新增了块级作用域。对于var还是与es5兼容。</p><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><ul><li><p>let命令所声明的变量，只在所在的代码块内有效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (let i=0; i&lt;10; i++)&#123;&#125;</span><br><span class="line">console.log(i);   // ReferenceError</span><br></pre></td></tr></table></figure></li><li><p>不存在变量提升<br>在es5中，var声明的变量，会发生变量提升，即脚本开始运行时，变量已经存在，但没有值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(foo)  // 输出undefined</span><br><span class="line">console.log(bar)  // Error</span><br><span class="line">var foo = 3;</span><br><span class="line">let bar = 4;</span><br></pre></td></tr></table></figure></li><li><p>不允许重复声明<br>let不允许在相同作用域内，重复声明同一个变量。</p></li></ul><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>const如其他语言的const，在JavaScript中，与let相同也是在块级作用域中。</p><h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><h2 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h2><p>  像是照搬了python的处理，也增加了自己的处理，如：</p><ul><li><p>初识<br>python中，可以使用 x,y,z = 1,2,3来定义变量<br>JavaScripty中，使用 let [x,y,z] = [1,2,3] 或者直接 [x,y,z]=[1,2,3]</p><p>python中可以使用 x,y = y,x来交换变量<br>JavaScripty中需要使用 [x,y]=[y,x] </p></li><li><p>默认值</p><p>var [x, y=”b”] = [“a”]   // x=’a’, y=’b’ </p><p>这里需要注意es6中使用 === undefined来判断是否有值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var [x=1] = [undefined];  // x = 1</span><br><span class="line">var [y=1] = [null];  //y=null</span><br></pre></td></tr></table></figure></li></ul><h2 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h2><ul><li>初识</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var &#123;foo,bar&#125; = &#123;foo:&quot;aaa&quot;, bar:&quot;bbb&quot;&#125;</span><br><span class="line">foo  // &quot;aaa&quot;</span><br><span class="line">bar  // &quot;bbb&quot;</span><br></pre></td></tr></table></figure><ul><li>数组元素是按次序排列的，变量取值由位置决定，而对象属性没有次序，变量必须与属性名相同。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var &#123;bar,foo&#125; = &#123;foo:&quot;aaa&quot;, bar:&quot;bbb&quot;&#125;</span><br><span class="line">foo  // &quot;aaa&quot;</span><br><span class="line">bar  // &quot;bbb&quot;</span><br></pre></td></tr></table></figure><ul><li>如果左边的变量名，与右边的属性名不一样，则必须如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123; first: &apos;hello&apos;, last: &apos;world&apos; &#125;;</span><br><span class="line">let &#123; first: one, last: two &#125; = obj; </span><br><span class="line">one // &apos;hello&apos;</span><br><span class="line">two // &apos;world&apos;</span><br></pre></td></tr></table></figure><h2 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const [a,b,c] = &quot;world&quot;</span><br><span class="line">a // &quot;w&quot;</span><br><span class="line">b // &quot;o&quot;</span><br><span class="line">c // &quot;r&quot;</span><br></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>解构赋值应用之一就是函数参数的结构赋值，但后边又有…操作符及默认传参。<br>返回参数通过这种方式倒是可以一起返回多个参数</p><ul><li>返回多个参数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function example() &#123;</span><br><span class="line">  return [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line">var [a, b, c] = example();</span><br></pre></td></tr></table></figure><ul><li>提取Json或者对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var jsonData = &#123;</span><br><span class="line">  id: 42,</span><br><span class="line">  status: &quot;OK&quot;,</span><br><span class="line">  data: [867, 5309]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let &#123; id, status, data: number &#125; = jsonData;</span><br><span class="line"></span><br><span class="line">console.log(id, status, number);</span><br><span class="line">// 42, &quot;OK&quot;, [867, 5309]</span><br></pre></td></tr></table></figure><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="spread运算符-…"><a href="#spread运算符-…" class="headerlink" title="spread运算符(…)"></a>spread运算符(…)</h2><ul><li>初识<br>将一个数组转为用逗号分隔的参数序列。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(...[1, 2, 3])</span><br><span class="line">// 1 2 3</span><br><span class="line"></span><br><span class="line">console.log(1, ...[2, 3, 4], 5)</span><br><span class="line">// 1 2 3 4 5</span><br></pre></td></tr></table></figure><ul><li>应用<ul><li>合并数组</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2].concat(more)  // es5</span><br><span class="line">[1, 2, ...more]   // es6</span><br></pre></td></tr></table></figure><ul><li>与解构赋值结合</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const [first, ...rest] = [1, 2, 3, 4, 5];</span><br><span class="line">first // 1</span><br><span class="line">rest  // [2, 3, 4, 5]</span><br></pre></td></tr></table></figure><ul><li>字符串</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...&apos;hello&apos;]</span><br><span class="line">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span><br></pre></td></tr></table></figure><ul><li>对象也可用<br>扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let z = &#123; a: 3, b: 4 &#125;;</span><br><span class="line">let n = &#123; ...z &#125;;</span><br><span class="line">n // &#123; a: 3, b: 4 &#125;</span><br></pre></td></tr></table></figure><h1 id="基本类型扩展"><a href="#基本类型扩展" class="headerlink" title="基本类型扩展"></a>基本类型扩展</h1><h2 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h2><ul><li>includes(), startsWith(), endsWith()<br>es5中只有indexOf()方法来判断一个字符串是否包含在另一个字符串中。es6新增以上3个。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;Hello world!&apos;;</span><br><span class="line"></span><br><span class="line">s.startsWith(&apos;Hello&apos;) // true</span><br><span class="line">s.endsWith(&apos;!&apos;) // true</span><br><span class="line">s.includes(&apos;o&apos;) // true</span><br></pre></td></tr></table></figure><p>  同时都支持第二个参数，表示开始搜索的位置</p><ul><li>repeat()<br>repeat方法返回一个新字符串，表示将原字符串重复n次</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;x&apos;.repeat(3) // &quot;xxx&quot;</span><br></pre></td></tr></table></figure><ul><li>padStart(), padEnd()<br>字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart用于头部补全，padEnd用于尾部补全。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;x&apos;.padStart(4, &apos;ab&apos;) // &apos;abax&apos;</span><br><span class="line">&apos;x&apos;.padEnd(4, &apos;ab&apos;) // &apos;xaba&apos;</span><br></pre></td></tr></table></figure><ul><li><p>模板字符串<br>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p><p>// 字符串中嵌入变量</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;Bob&quot;, time = &quot;today&quot;;</span><br><span class="line">`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`</span><br></pre></td></tr></table></figure><h2 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h2><ul><li><p>二进制与八进制<br>ES6提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。</p></li><li><p>Number.isFinite(), Number.isNaN()</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Number.isFinite()用来检查一个数值是否为有限的（finite）。</span><br><span class="line">Number.isNaN()用来检查一个值是否为NaN。</span><br><span class="line"></span><br><span class="line">Number.isFinite(15); // true</span><br><span class="line">Number.isFinite(0.8); // true</span><br><span class="line">Number.isFinite(NaN); // false</span><br><span class="line">Number.isFinite(Infinity); // false</span><br><span class="line">Number.isFinite(&apos;foo&apos;); // false</span><br><span class="line">Number.isFinite(&apos;15&apos;); // false</span><br><span class="line">Number.isFinite(true); // false</span><br><span class="line"></span><br><span class="line">Number.isNaN(NaN) // true</span><br><span class="line">Number.isNaN(15) // false</span><br><span class="line">Number.isNaN(&apos;15&apos;) // false</span><br><span class="line">Number.isNaN(true) // false</span><br><span class="line">Number.isNaN(9/NaN) // true</span><br><span class="line">Number.isNaN(&apos;true&apos;/0) // true</span><br></pre></td></tr></table></figure><ul><li>Number.isInteger()<br>Number.isInteger()用来判断一个值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Number.isInteger(25) // true</span><br><span class="line">Number.isInteger(25.0) // true</span><br><span class="line">Number.isInteger(25.1) // false</span><br></pre></td></tr></table></figure><ul><li>Number.EPSILON<br>ES6在Number对象上面，新增一个极小的常量Number.EPSILON。原因不言自明</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number.EPSILON</span><br><span class="line">// 2.220446049250313e-16</span><br></pre></td></tr></table></figure><h1 id="引用类型扩展"><a href="#引用类型扩展" class="headerlink" title="引用类型扩展"></a>引用类型扩展</h1><h2 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h2><ul><li>Array.from()<br>Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arrayLike = &#123;</span><br><span class="line">  &apos;0&apos;: &apos;a&apos;,</span><br><span class="line">  &apos;1&apos;: &apos;b&apos;,</span><br><span class="line">  &apos;2&apos;: &apos;c&apos;,</span><br><span class="line">  length: 3</span><br><span class="line">&#125;;</span><br><span class="line">let arr2 = Array.from(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br></pre></td></tr></table></figure><p>  我觉得，在Map、set向数组的转换比较有用，arrayLike本来就是数组，谁也不会那样定义，arguments感觉在es6中在弱化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Array.from(&apos;hello&apos;)</span><br><span class="line">// [&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;]</span><br><span class="line"></span><br><span class="line">let namesSet = new Set([&apos;a&apos;, &apos;b&apos;])</span><br><span class="line">Array.from(namesSet) // [&apos;a&apos;, &apos;b&apos;]</span><br></pre></td></tr></table></figure><p>  Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.from([1, 2, 3], (x) =&gt; x * x)  // [1, 4, 9]</span><br></pre></td></tr></table></figure><ul><li>Array.of()<br>Array.of方法用于将一组值，转换为数组。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Array.of(3, 11, 8) // [3,11,8]</span><br><span class="line">Array.of(3) // [ 3 ]</span><br><span class="line">Array.of(3).length // 1</span><br></pre></td></tr></table></figure><ul><li>数组实例的copyWithin()<br>数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组.<br>三个参数： target(必需)，开始替换位置; start（可选），开始读取位置，默认0; end（可选），到该位置前停止读取数据，默认等于数组长度。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5].copyWithin(0, 3)</span><br><span class="line">// [4, 5, 3, 4, 5]</span><br></pre></td></tr></table></figure><ul><li>数组实例的find()和findIndex()<br>数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员，没有则返回undefined</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[1, 4, -5, 10].find((n) =&gt; n &lt; 0)</span><br><span class="line">// -5</span><br><span class="line"></span><br><span class="line">[1, 5, 10, 15].find(function(value, index, arr) &#123;</span><br><span class="line"> return value &gt; 9;</span><br><span class="line">&#125;) // 10</span><br><span class="line"> </span><br><span class="line">[1, 5, 10, 15].findIndex(function(value, index, arr) &#123;</span><br><span class="line">   return value &gt; 9;</span><br><span class="line">&#125;) // 2</span><br></pre></td></tr></table></figure><ul><li>数组实例的fill()<br>fill方法使用给定值，填充一个数组。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new Array(3).fill(7)</span><br><span class="line">// [7, 7, 7]</span><br></pre></td></tr></table></figure><ul><li>数组实例的entries()，keys()和values()<br>entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历<br>对于数组感觉也很鸡肋</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) &#123;</span><br><span class="line">  console.log(index);</span><br><span class="line">&#125;</span><br><span class="line">// 0</span><br><span class="line">// 1</span><br><span class="line"></span><br><span class="line">for (let elem of [&apos;a&apos;, &apos;b&apos;].values()) &#123;</span><br><span class="line">  console.log(elem);</span><br><span class="line">&#125;</span><br><span class="line">// &apos;a&apos;</span><br><span class="line">// &apos;b&apos;</span><br><span class="line"></span><br><span class="line">for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) &#123;</span><br><span class="line">  console.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line">// 0 &quot;a&quot;</span><br><span class="line">// 1 &quot;b&quot;</span><br></pre></td></tr></table></figure><ul><li>数组实例的includes()<br>Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].includes(2);     // true</span><br></pre></td></tr></table></figure><ul><li>数组的空位<br>数组的空位指，数组的某一个位置没有任何值.空位不是undefined，一个位置的值等于undefined，依然是有值的.<br>ES5对空位的处理，已经很不一致了，大多数情况下会忽略空位。ES6则是明确将空位转为undefined</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Array.from([&apos;a&apos;,,&apos;b&apos;])</span><br><span class="line">// [ &quot;a&quot;, undefined, &quot;b&quot; ]</span><br><span class="line"></span><br><span class="line">扩展运算符（...）也会将空位转为undefined</span><br><span class="line">[...[&apos;a&apos;,,&apos;b&apos;]]</span><br><span class="line">// [ &quot;a&quot;, undefined, &quot;b&quot; ]</span><br></pre></td></tr></table></figure><h2 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h2><ul><li>函数参数的默认值<br>在ES6之前，不能直接为函数的参数指定默认值，ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。默认参数与C++类似，最好放在后边。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function log(x, y = &apos;World&apos;) &#123;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(&apos;Hello&apos;) // Hello World</span><br><span class="line">log(&apos;Hello&apos;, &apos;China&apos;) // Hello China</span><br></pre></td></tr></table></figure><p>  参数默认值可以与解构赋值的默认值，结合起来使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo(&#123;x, y = 5&#125;) &#123;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(&#123;&#125;) // undefined, 5</span><br><span class="line">foo(&#123;x: 1&#125;) // 1, 5</span><br><span class="line">foo(&#123;x: 1, y: 2&#125;) // 1, 2</span><br></pre></td></tr></table></figure><ul><li>函数的length属性<br>指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(function (a) &#123;&#125;).length  // 1</span><br><span class="line">(function (a, b, c = 5) &#123;&#125;).length // 2</span><br></pre></td></tr></table></figure><ul><li>rest参数<br>ES6引入rest参数（形式为“…变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。这个与python也类似，.args与..kargs</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function add(...values) &#123;</span><br><span class="line">  let sum = 0;</span><br><span class="line"></span><br><span class="line">  for (var val of values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(2, 5, 3) // 10</span><br><span class="line"></span><br><span class="line">var args = [0, 1, 2];</span><br><span class="line">add(...args);  // 3</span><br></pre></td></tr></table></figure><ul><li>箭头函数<br>参数多余一个用（），语句多于一条用{}</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125;</span><br></pre></td></tr></table></figure><p>  箭头函数可以与变量解构结合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const full = (&#123; first, last &#125;) =&gt; &#123;first +&apos; &apos; + last&#125;;</span><br><span class="line">// 等同于</span><br><span class="line">function full(person) &#123;</span><br><span class="line"> return person.first + &apos; &apos; + person.last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  箭头函数有几个使用注意点。<br>  （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。<br>  （2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。<br>  （3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。<br>  （4）不可以使用yield命令，因此箭头函数不能用作Generator函数。</p><ul><li><p>尾调用优化<br>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数，并返回，就是函数式变成可以链起来。<br>正面实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function f(x)&#123;</span><br><span class="line">  return g(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反面实例：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 情况一</span><br><span class="line">function f(x)&#123;</span><br><span class="line">  let y = g(x);</span><br><span class="line">  return y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 情况二</span><br><span class="line">function f(x)&#123;</span><br><span class="line">  return g(x) + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 情况三</span><br><span class="line">function f(x)&#123;</span><br><span class="line">  g(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除 f(x) 的调用帧，只保留 g(3) 的调用帧。</p><p>  这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</p><ul><li><p>尾递归<br>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p><p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p></li></ul><h2 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h2><ul><li><p>属性的简写<br>ES6允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁</p><p>变量</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var foo = &apos;bar&apos;;</span><br><span class="line">var baz = &#123;foo&#125;;</span><br><span class="line">baz // &#123;foo: &quot;bar&quot;&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">var baz = &#123;foo: foo&#125;;</span><br></pre></td></tr></table></figure><p>  函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">  method() &#123;</span><br><span class="line">    return &quot;Hello!&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 等同于  </span><br><span class="line">var o = &#123;</span><br><span class="line">  method: function() &#123;</span><br><span class="line">    return &quot;Hello!&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>Object.assign()<br>Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var target = &#123; a: 1 &#125;;</span><br><span class="line">var source1 = &#123; b: 2 &#125;;</span><br><span class="line">var source2 = &#123; c: 3 &#125;;</span><br><span class="line"></span><br><span class="line">Object.assign(target, source1, source2);</span><br><span class="line">target // &#123;a:1, b:2, c:3&#125;</span><br></pre></td></tr></table></figure><p>  Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</p><ul><li><p>属性的遍历<br>ES6一共有5种方法可以遍历对象的属性。</p><p>（1）for…in<br>for…in循环遍历对象自身的和继承的可枚举属性（不含Symbol属性）。</p><p>（2）Object.keys(obj)<br>Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）。</p><p>（3）Object.getOwnPropertyNames(obj)<br>Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）。</p><p>（4）Object.getOwnPropertySymbols(obj)<br>Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有Symbol属性。</p><p>（5）Reflect.ownKeys(obj)<br> Reflect.ownKeys返回一个数组，包含对象自身的所有属性，不管是属性名是Symbol或字符串，也不管是否可枚举。  </p></li><li><p>Object.keys()<br>ES5引入了Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。</p><p>var obj = { foo: “bar”, baz: 42 };<br>Object.keys(obj)<br>// [“foo”, “baz”]</p><p>Object.values(), Object.entries()在提案中。</p></li></ul><h2 id="set与map"><a href="#set与map" class="headerlink" title="set与map"></a>set与map</h2><p>这个大概是学习了C++</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var set = new Set([1, 2, 3, 4, 4]);</span><br><span class="line">[...set]</span><br><span class="line">// [1, 2, 3, 4]</span><br><span class="line">set.size // 4</span><br><span class="line"></span><br><span class="line">// 去除数组的重复成员</span><br><span class="line">[...new Set(array)]</span><br></pre></td></tr></table></figure><p>属性<br>Set.prototype.size：返回Set实例的成员总数。<br>Set实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。</p><p>操作方法：<br>add(value)：添加某个值，返回Set结构本身。<br>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。<br>has(value)：返回一个布尔值，表示该值是否为Set的成员。<br>clear()：清除所有成员，没有返回值。</p><p>遍历方法：<br>keys()：返回键名的遍历器<br>values()：返回键值的遍历器<br>entries()：返回键值对的遍历器<br>forEach()：使用回调函数遍历每个成员</p><p>WeakSet<br>WeakSet结构与Set类似，也是不重复的值的集合。但是，它与Set有两个区别。<br>首先，WeakSet的成员只能是对象，而不能是其他类型的值。<br>其次，WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul><li>初识<br>JavaScript的对象（Object），本质上是键值对的集合（Hash结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。<br>为了解决这个问题，ES6提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var map = new Map([</span><br><span class="line">  [&apos;name&apos;, &apos;张三&apos;],</span><br><span class="line">  [&apos;title&apos;, &apos;Author&apos;]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">map.size // 2</span><br><span class="line">map.has(&apos;name&apos;) // true</span><br><span class="line">map.get(&apos;name&apos;) // &quot;张三&quot;</span><br></pre></td></tr></table></figure><ul><li>注意<br>这个map与C++类似，但有一点需要注意：<br>只有对同一个对象的引用，Map结构才将其视为同一个键。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var map = new Map();</span><br><span class="line"></span><br><span class="line">map.set([&apos;a&apos;], 555);</span><br><span class="line">map.get([&apos;a&apos;]) // undefined</span><br></pre></td></tr></table></figure><p>  实际上这是两个[‘a’]值，内存地址是不一样的，因此get方法无法读取该键，返回undefined</p><ul><li><p>操作方法：<br>set(key, value)<br>get(key)<br>has(key)<br>delete(key)<br>clear()清空所有成员</p></li><li><p>遍历方法：<br>keys()：返回键名的遍历器。<br>values()：返回键值的遍历器。<br>entries()：返回所有成员的遍历器。<br>forEach()：遍历Map的所有成员。</p></li><li><p>相互转换<br>数组转成Map</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let newMap =  new Map([[true, 7], [false, 6]])</span><br><span class="line">  // Map &#123;true =&gt; 7, false =&gt; 7&#125;</span><br></pre></td></tr></table></figure><p>  Map转为数组<br>  […newMap]</p><p>  对象转成Map</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function objToStrMap(obj) &#123;</span><br><span class="line">  let strMap = new Map();</span><br><span class="line">  for (let k of Object.keys(obj)) &#123;</span><br><span class="line">    strMap.set(k, obj[k]);</span><br><span class="line">  &#125;</span><br><span class="line">  return strMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">objToStrMap(&#123;yes: true, no: false&#125;)</span><br><span class="line">// [ [ &apos;yes&apos;, true ], [ &apos;no&apos;, false ] ]</span><br></pre></td></tr></table></figure><p>  Map转成对象，如果所有Map键都是字符串，它可以转为对象，起始不是也可以先转换成字符串，再转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function strMapToObj(strMap) &#123;</span><br><span class="line">  let obj = Object.create(null);</span><br><span class="line">  for (let [k,v] of strMap) &#123;</span><br><span class="line">    obj[k] = v;</span><br><span class="line">  &#125;</span><br><span class="line">  return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myMap = new Map().set(&apos;yes&apos;, true).set(&apos;no&apos;, false);</span><br><span class="line">strMapToObj(myMap)</span><br><span class="line">// &#123; yes: true, no: false &#125;</span><br></pre></td></tr></table></figure><h1 id="class"><a href="#class" class="headerlink" title="class"></a>class</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>es6终于脱离了es5要使用构造函数与原型相结合的方法来完成类定义的方式，提供了class关键字,在class内部声明的函数就被定义在了原型上，class内部有construtor函数，在其中定义的属性，就是在构造函数上。</p><p>es5代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Point(x, y) &#123;</span><br><span class="line">  this.x = x;</span><br><span class="line">  this.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = function () &#123;</span><br><span class="line">  return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var p = new Point(1, 2);</span><br></pre></td></tr></table></figure><p>等同于es6的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  constructor(x, y) &#123;</span><br><span class="line">    this.x = x;</span><br><span class="line">    this.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类的数据类型就是函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typeof Point     //&quot;function&quot;</span><br><span class="line">Point === Point.prototype.constructor  // true</span><br></pre></td></tr></table></figure><h2 id="constructor方法"><a href="#constructor方法" class="headerlink" title="constructor方法"></a>constructor方法</h2><p>constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。</p><p>constructor方法默认返回实例对象（即this）。</p><h2 id="class表达式"><a href="#class表达式" class="headerlink" title="class表达式"></a>class表达式</h2><p>与函数一样，类也可以使用表达式的形式定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const MyClass = class Me &#123;</span><br><span class="line">  getClassName() &#123;</span><br><span class="line">    return Me.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">let inst = new MyClass();</span><br><span class="line">inst.getClassName();  // Me</span><br></pre></td></tr></table></figure><h2 id="class私有方法"><a href="#class私有方法" class="headerlink" title="class私有方法"></a>class私有方法</h2><p>es6中，并不直接提供私有方法。可以通过一些技术来模拟，但感觉都不好。</p><h2 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h2><p>类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。<br>以下边例子来说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Logger &#123;</span><br><span class="line">  printName(name = &apos;there&apos;) &#123;</span><br><span class="line">    this.print(`Hello $&#123;name&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  print(text) &#123;</span><br><span class="line">    console.log(text);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const logger = new Logger();</span><br><span class="line">const &#123; printName &#125; = logger;</span><br><span class="line">printName(); // TypeError: Cannot read property &apos;print&apos; of undefined</span><br></pre></td></tr></table></figure><p>我稍微有点不理解，好不容易封装的函数，再解构出来用，几个意思啊？</p><h2 id="class的继承"><a href="#class的继承" class="headerlink" title="class的继承"></a>class的继承</h2><p>es5中的继承麻烦的要命，既要用subClass的原型链的constructor指向superClass的实例来继承函数，还要通过在subClass的构造函数中去调用superClass.call(this,..)来继承对象，简直不想让人用啊。<br>好在es6中增加了extends关键字来简化了继承，下边来看一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class ColorPoint extends Point &#123;</span><br><span class="line">  constructor(x, y, color) &#123;</span><br><span class="line">    super(x, y); // 调用父类的constructor(x, y)</span><br><span class="line">    this.color = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    return this.color + &apos; &apos; + super.toString(); // 调用父类的toString()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造函数中调用super()应该用于从构造函数中继承对象，然后外边的函数类似于原型继承了。<br>子类必须在constructor方法中调用super方法，否则新建实例时会报错。</p><h2 id="类的prototype属性和proto属性"><a href="#类的prototype属性和proto属性" class="headerlink" title="类的prototype属性和proto属性"></a>类的prototype属性和<strong>proto</strong>属性</h2><p>Class作为构造函数的语法糖，同时有prototype属性和<strong>proto</strong>属性，因此同时存在两条继承链。<br>（1）子类的<strong>proto</strong>属性，表示构造函数的继承，总是指向父类。<br>（2）子类prototype属性的<strong>proto</strong>属性，表示方法的继承，总是指向父类的prototype属性。</p><h2 id="Class的取值（getter）和存值函数（setter）"><a href="#Class的取值（getter）和存值函数（setter）" class="headerlink" title="Class的取值（getter）和存值函数（setter）"></a>Class的取值（getter）和存值函数（setter）</h2><p>与ES5一样，在Class内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">  get prop() &#123;</span><br><span class="line">    return &apos;getter&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  set prop(value) &#123;</span><br><span class="line">    console.log(&apos;setter: &apos;+value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let inst = new MyClass();</span><br><span class="line"></span><br><span class="line">inst.prop = 123;</span><br><span class="line">// setter: 123</span><br><span class="line"></span><br><span class="line">inst.prop</span><br><span class="line">// &apos;getter&apos;</span><br></pre></td></tr></table></figure><h2 id="class的静态方法"><a href="#class的静态方法" class="headerlink" title="class的静态方法"></a>class的静态方法</h2><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用。<br>这个有点意思，我们看的构造函数（类）的prototype原型也就是静态的方法，又像Java/C++学习增加了static方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">  static classMethod() &#123;</span><br><span class="line">    return &apos;hello&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.classMethod() // &apos;hello&apos;</span><br><span class="line"></span><br><span class="line">var foo = new Foo();</span><br><span class="line">foo.classMethod()</span><br><span class="line">// TypeError: foo.classMethod is not a function</span><br></pre></td></tr></table></figure><p>父类的静态方法，可以被子类继承。</p><h2 id="class的静态属性和实例属性"><a href="#class的静态属性和实例属性" class="headerlink" title="class的静态属性和实例属性"></a>class的静态属性和实例属性</h2><p>只有这种写法可行，因为ES6明确规定，Class内部只有静态方法，没有静态属性。对于这条在TypeScirpt中已经该了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">  static myStaticProp = 42;   // 静态属性</span><br><span class="line">  myProp = 43;                // 实例属性</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    console.log(MyClass.myProp); // 42</span><br><span class="line">    console.log(this.myProp);   //43</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ES6诞生以前，异步编程的方法，大概有下面四种。<br>  回调函数<br>  事件监听<br>  发布/订阅<br>  Promise 对象<br>  ES6将JavaScript异步编程带入了一个全新的阶段，ES7的Async函数更是提出了异步编程的终极解决方案。</p><p>异步<br>  异步就像中断，启动一个耗时操作，然后程序可以继续运行，等耗时操作的中断返回再执行耗时操作的处理。</p><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(&apos;/etc/passwd&apos;, function (err, data) &#123;</span><br><span class="line">  if (err) throw err;</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取A文件之后，再读取B文件，代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(fileA, function (err, data) &#123;</span><br><span class="line">  fs.readFile(fileB, function (err, data) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>不难想象，如果依次读取多个文件，就会出现多重嵌套,Promise就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var readFile = require(&apos;fs-readfile-promise&apos;);</span><br><span class="line"></span><br><span class="line">readFile(fileA)</span><br><span class="line">.then(function(data)&#123;</span><br><span class="line">  console.log(data.toString());</span><br><span class="line">&#125;)</span><br><span class="line">.then(function()&#123;</span><br><span class="line">  return readFile(fileB);</span><br><span class="line">&#125;)</span><br><span class="line">.then(function(data)&#123;</span><br><span class="line">  console.log(data.toString());</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function(err) &#123;</span><br><span class="line">  console.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用了fs-readfile-promise模块，它的作用就是返回一个Promise版本的readFile函数。Promise提供then方法加载回调函数，catch方法捕捉执行过程中抛出的错误。</p><h2 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h2><p>ES7提供了async函数，使得异步操作变得更加方便。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var asyncReadFile = async function ()&#123;</span><br><span class="line">  var f1 = await readFile(&apos;/etc/fstab&apos;);</span><br><span class="line">  var f2 = await readFile(&apos;/etc/shells&apos;);</span><br><span class="line">  console.log(f1.toString());</span><br><span class="line">  console.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>返回值是Promise。async函数的返回值是Promise对象</p><p>注意：<br>  第一点，await命令后面的Promise对象，运行结果可能是rejected，，所以最好把await命令放在try…catch代码块中。</p><p>  一般写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async function myFunction() &#123;</span><br><span class="line">  await somethingThatReturnsAPromise()</span><br><span class="line">  .catch(function (err) &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  第二点，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let foo = await getFoo();</span><br><span class="line">let bar = await getBar();</span><br></pre></td></tr></table></figure><p>  getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发。</p><p>  let [foo, bar] = await Promise.all([getFoo(), getBar()]);</p><p>  第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  async function dbFuc(db) &#123;</span><br><span class="line">  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  // 报错</span><br><span class="line">  docs.forEach(function (doc) &#123;</span><br><span class="line">    await db.post(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上面代码会报错，因为await用在普通函数之中了。但是，如果将forEach方法的参数改成async函数，也有问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  async function dbFuc(db) &#123;</span><br><span class="line">  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  // 可能得到错误结果</span><br><span class="line">  docs.forEach(async function (doc) &#123;</span><br><span class="line">    await db.post(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  原因是这时三个db.post操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用for循环。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async function dbFuc(db) &#123;</span><br><span class="line">  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  for (let doc of docs) &#123;</span><br><span class="line">    await db.post(doc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Decorator"><a href="#Decorator" class="headerlink" title="Decorator"></a>Decorator</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>es的装饰器应该与python类似，使用闭包技术，将要修改的函数传入装饰函数即可。还有Generator,yield以及协程概念，都像是与python的相互借鉴。<br>修饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，修饰器能在编译阶段运行代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function testable(target) &#123;</span><br><span class="line">  target.isTestable = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@testable</span><br><span class="line">class MyTestableClass &#123;&#125;</span><br><span class="line"></span><br><span class="line">console.log(MyTestableClass.isTestable) // true</span><br></pre></td></tr></table></figure><p>@testable就是一个修饰器。它修改了MyTestableClass这个类的行为，为它加上了静态属性isTestable<br>如果觉得一个参数不够用，可以在修饰器外面再封装一层函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function testable(isTestable) &#123;</span><br><span class="line">  return function(target) &#123;</span><br><span class="line">    target.isTestable = isTestable;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@testable(true)</span><br><span class="line">class MyTestableClass &#123;&#125;</span><br><span class="line">MyTestableClass.isTestable // true</span><br><span class="line"></span><br><span class="line">@testable(false)</span><br><span class="line">class MyClass &#123;&#125;</span><br><span class="line">MyClass.isTestable // false</span><br></pre></td></tr></table></figure><h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><p>修饰器不仅可以修饰类，还可以修饰类的属性。<br>此时，修饰器函数一共可以接受三个参数，第一个参数是所要修饰的目标对象，第二个参数是所要修饰的属性名，第三个参数是该属性的描述对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  @readonly</span><br><span class="line">  name() &#123; return `$&#123;this.first&#125; $&#123;this.last&#125;` &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function readonly(target, name, descriptor)&#123;</span><br><span class="line">    // descriptor对象原来的值如下</span><br><span class="line">    // &#123;</span><br><span class="line">    //   value: specifiedFunction,</span><br><span class="line">    //   enumerable: false,</span><br><span class="line">    //   configurable: true,</span><br><span class="line">    //   writable: true</span><br><span class="line">    // &#125;;</span><br><span class="line">    descriptor.writable = false;</span><br><span class="line">    return descriptor;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>@log修饰器，可以起到输出日志的作用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Math &#123;</span><br><span class="line">  @log</span><br><span class="line">  add(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function log(target, name, descriptor) &#123;</span><br><span class="line">  var oldValue = descriptor.value;    // descriptor.value就是方法add</span><br><span class="line"></span><br><span class="line">  descriptor.value = function() &#123;     // 在这里重新赋值desciptor.value，应该包含对原函数的调用</span><br><span class="line">    console.log(`Calling &quot;$&#123;name&#125;&quot; with`, arguments);</span><br><span class="line">    return oldValue.apply(null, arguments);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return descriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const math = new Math();</span><br><span class="line"></span><br><span class="line">// passed parameters should get logged now</span><br><span class="line">math.add(2, 4);</span><br></pre></td></tr></table></figure></p><h2 id="装饰器不能用于函数"><a href="#装饰器不能用于函数" class="headerlink" title="装饰器不能用于函数"></a>装饰器不能用于函数</h2><p>修饰器只能用于类和类的方法，不能用于函数，因为存在函数提升</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要介绍es6，包括了块级作用域、数组对象的解构赋值、…操作符、基本类型的扩展、引用类型的扩展（Array、Set、Map），函数的扩展、对象的扩展、class、异步等内容，最后是装饰器的简单介绍，还有一些特性并未加入，比如Generator、yield，proxy等内
      
    
    </summary>
    
      <category term="语言" scheme="http://yoursite.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript基础</title>
    <link href="http://yoursite.com/2018/08/08/JavaScript%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/08/08/JavaScript基础/</id>
    <published>2018-08-08T04:50:00.000Z</published>
    <updated>2018-11-28T02:05:48.748Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍JavaScript的发展、组成，在Http中的使用，基础语法，变量、执行环境、内存等内容</p><a id="more"></a><h1 id="JavaScript简介"><a href="#JavaScript简介" class="headerlink" title="JavaScript简介"></a>JavaScript简介</h1><h2 id="经历"><a href="#经历" class="headerlink" title="经历"></a>经历</h2><ul><li>由网景公司研发的，在网络带宽很低的年代，用于在浏览器端对表单的数据进行验证，而降低带宽而发明的</li><li>由于JaScript在浏览器的成功，微软也在IE中增加了JScript的实现。</li><li>以JavaScript1.1为版本的标准化<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2></li><li>核心：ECMAScript<br>语言基础：<ul><li>语法</li><li>类型</li><li>语句</li><li>关键字</li><li>保留字</li><li>操作符</li><li>对象</li></ul></li><li><p>文档对象模型：DOM<br>就是对XML解析的那个DOM</p></li><li><p>浏览器对象模型：BOM</p><ul><li>弹出新浏览器窗口的功能</li><li>移动、缩放和关闭浏览器的功能</li><li>提供浏览器详细信息的navigator对象</li><li>提供浏览器所加载页面的详细信息的location对象</li><li>提供用户显示器分辨率信息的screen对象</li><li>对cookies的支持</li><li>XMLHttpRequest这样的自定义对象</li></ul></li></ul><h2 id="在HTTP中的使用"><a href="#在HTTP中的使用" class="headerlink" title="在HTTP中的使用"></a>在HTTP中的使用</h2><ul><li>script元素<ul><li>async: 表示立即下载脚本，只对外部脚本文件有效</li><li>charset：表示src属性指定的代码的字符集</li><li>defer：表示脚本可以延迟到文件完全被解析和显示之后再执行，外部有效</li><li>src</li><li>type：text/javacript</li></ul></li><li><p>标签的位置<br>按惯例，script元素都应该放在页面的head元素中，但这样意味着必须等到全部的JS代码都被下载、分析执行完成后，才能展示页面，导致页面加载的延迟。为此，一般把全部JS放在boday元素中页面内容的后面</p></li><li><p>延迟脚本<br>有时会将script放在head中，而用derfer=”defer”属性，这样告诉浏览器立即下载，但延迟执行</p></li><li><p>异步脚本<br>async 目的是不让页面等待两个脚本的下载和执行，从而异步加载页面其他内容。书中建议，异步脚本不要在加载期间修改DOM</p></li></ul><h1 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h1><ul><li>typeof<br>作为一种动态语言，JS需要有一种手段来检测数据类型：typeof操作符（在C/C++中也有）<br>返回的类型包括：<br>“undefined”<br>“boolean”<br>“string”<br>“number”<br>“object”<br>“function”：这似乎意味着函数并不是对象</li></ul><h2 id="undefined与Null"><a href="#undefined与Null" class="headerlink" title="undefined与Null"></a>undefined与Null</h2><p>  有一段比较有趣：从类型上看，JS有一种Null类型，而”undefined”其实是从Null派生的.而执行typeof(Null对象)结果是object。<br>  声明而未初始化类型是”undefined”，声明对象后，直接赋值”Null”是告诉赋了个空值对象</p><h2 id="number"><a href="#number" class="headerlink" title="number"></a>number</h2><p>  JS也存在float禁止直接 == 的比较<br>  Infinity:Number.MIN_VALUE:一般为5e-324, Number.MAX_VALUE:1.79e+308，超过这些范围则为Infinity 或者-Infinity</p><ul><li><p>NaN:Not a Number<br>任意数/0 = NaN， NaN不与任意数相等，包括其自身</p></li><li><p>数值转换<br>Number()<br>parseInt()<br>parseFloat()</p></li><li><p>函数<br>toFixed(): 按参数的小数位返回数值的字符串表示</p><p>var num=10<br>alert(num.toFixed(2))  // “10.00”</p></li></ul><pre><code>toExponential(1)： 同上，不过是以e表示的toPrecision(1): 同上，参数表示的是数字的位数 </code></pre><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li><p>字符串特点<br>ECMAScprit中字符串是不可变的。字符串一旦创建，值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串。<br>这一点与python一致</p></li><li><p>转换为字符串<br>几乎每个值都有toStrig()方法，这个与Java类似<br>或者Stirng(变量)的方式在转换</p></li><li><p>函数<br>charAt(1) ： 在某个位置上的字符</p><p>var str = “hello world”<br>alert(str.CharAt(1))   // e</p></li></ul><p>  concat(): 拼接,参数个数不限，不修改原值<br>  alert(str.concat(“!”, “thanks”))</p><p>  切片：<br>  slice(起始，结束)， substring(起始，结束)，substr(起始，个数)<br>  str.slice(3, -1)</p><p>  位置:<br>  indexOf()和lastIndexOf()  与C++中的find（）与rfind（）类似<br>  str.indexOf(“or”)</p><p>  删除前后空格：<br>  trim()<br>  str.trim()</p><p>  大小写转换：<br>  toUpperCase()/toLowerCase()<br>  str.toUpperCase()</p><h2 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h2><p>  这个Object与Java的Object类似，就是说Object类型是所有其他实例的基础。<br>  Constructor():构造函数<br>  hasOwnProperty(属性名)，建材给定的属性在爱当前实例中。<br>  isPrototypeOf(object)，传入的对象是否是另一个对象的原型<br>  propertyIsEnumerable(属性名)，检查属性是否可以通过for-in来枚举<br>  toLocaleString()返回对象的字符串表示<br>  toString()：同上<br>  valueOf()：返回字符串、数值或者布尔值表示。</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>++ 与 – 类似与 C/</p><p>+操作符，就是正号，需要注意的是对非数值使用，该操作符回想Number()转型函数一样对这个数进行转换。</p><p> == 与 === :早期的ECMAScript版本中的相等和不相等–先转换再比较。===则仅比较而不转换。</p><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>with 语句：with语句的作用是将代码的作用域设置到一个特定对象中。这个有点像python的with语句。严格模式下不允许使用with语句，被认为是语法错误</p><h2 id="理解参数"><a href="#理解参数" class="headerlink" title="理解参数"></a>理解参数</h2><ul><li><p>ECMAScript中的所有参数传递都是值，不可能通过引用传递参数。</p></li><li><p>ECMAScript 函数并不介意传递进来多少个参数，也不在乎传入的参数是什么类型。<br>即使定义的函数只接收两个参数，在调用这个函数时，也未必一定要传递2个参数。<br>原因是ECMAScript中的参数在内部是用一个数组来表示。函数接收到的始终都是这个数组，而并不关心数组中包含哪些参数。在函数体内可以通过arguments对象来访问这个参数数组，从而获得传递给函数的每一个参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function doAdd()&#123;</span><br><span class="line">  if (arguments.length == 1)&#123;</span><br><span class="line">    return arguments[0]+10;</span><br><span class="line">    &#125; else if (arguments.length == 2)&#123;</span><br><span class="line">        return argument[0]+argument[1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = doAdd(10);</span><br><span class="line">let b = doAdd(10,20);</span><br></pre></td></tr></table></figure><p>关于arguments有一点比较有趣，它的值永远与对应命名参数的值保持同步。<br>但它们访问的内存空间是独立的，但它们的值会同步。但这种同步也是单向的，修改命名参数不会改变arguments中的对应值，而修改arguments会改变命名参数的。</p></li></ul><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h2><ul><li><p>基本类型与引用类型<br>ECMAScript变量可能包含2种不同数据类型的值：基本类型值和引用类型值。<br>基本类型包括5种：Null,Undefined,Number,String,Boolean<br>引用类型就是最有一种Object类型。<br>多数语言中String类型都是对象：如C++/Java，因而是引用类型，但JavaScript并不是。</p><p>基本类型在内存中都是按值来存储【这一点跟python还有一点区别，python的小整数都是相同的内存】<br>而引用类型跟C++/C的思路一直，变量名仅保留其指针，对变量名的复制仅仅是浅copy，内存中并不会创建一份新的引用类型。</p></li><li><p>传递参数<br>对于引用类型的传参，是挺有意思的，首先形参是重新定义了一个对象，传递的值是引用类型值的指针。若使用这个对象直接修改属性，则函数外的属性也会修改。但如果这个形参对象重新指向别的对象，则外边的对象便不会修改了,就是这个指针已经指向别处了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function setName(obj)&#123;</span><br><span class="line">  obj.name= &quot;li&quot;</span><br><span class="line">  obj = new Object();</span><br><span class="line">  obj.name = &quot;wang&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Object()</span><br><span class="line">setName(person);   // person.name = &quot;li&quot;</span><br></pre></td></tr></table></figure></li><li><p>检测类型<br>对应基本类型用typeOf()进行对象的检测<br>对于引用类型，使用instanceof来判断：这个与C++类似</p></li></ul><h2 id="执行环境及作用域"><a href="#执行环境及作用域" class="headerlink" title="执行环境及作用域"></a>执行环境及作用域</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p><img src="函数执行过程.png" alt=""></p><ul><li><p>所谓的执行环境，其实就是函数的环境一层一层的压栈，然后出栈的过程，对于作用域的查询也与C语言类似：先找局部、然后上一层的栈..直到全局变量。</p></li><li><p>但与之不同的是，每一个执行环境都有一个与其关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。 </p></li><li><p>当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的作用，是保证对执行环境有权访问的所有变量合函数的有序访问。这个作用域链用来保存各个执行环境的变量对象。</p></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><p>需要注意一点：JavaScript中没有块级作用域：即不能像C/C++通过{}来设置一个作用域.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (var i=0; i&lt;10; i++)&#123;</span><br><span class="line">    doSomething(i);</span><br><span class="line">&#125;</span><br><span class="line">alert(i);  // i=10</span><br></pre></td></tr></table></figure></li><li><p>还有一个比较坑<br>在非严格模式下如果在函数内定义一个变量没有var标志,那么这个定义的变量是全局变量.</p></li></ul><h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><ul><li><p>标记清除<br>标记清除用于局部变量的清除</p></li><li><p>引用计数<br>与python类似.也存在严重的循环引用问题。<br>但python中有隔代清理机制，没见JavaScript有介绍。</p></li><li><p>注意：<br>对于不同的对象，将变量直接赋null。这个在有垃圾收集机制的语言中通用。如Java\Pthon。即使在C++/C中，也建议将delete后的指针赋null，防止野指针。</p></li></ul><h1 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1><h2 id="Object类型-1"><a href="#Object类型-1" class="headerlink" title="Object类型"></a>Object类型</h2><ul><li><p>两种构造构造方法：</p><ul><li><p>new Object方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var person = new Object();</span><br><span class="line">person.name = &quot;sun&quot;</span><br><span class="line">person.age = 31</span><br></pre></td></tr></table></figure></li><li><p>对象字面量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">  name : &quot;sun&quot;,</span><br><span class="line">  age: 29</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>第一种形式就是C++的struct，第二种形式就是python的字典</p></li><li><p>访问<br>访问上也是沿用struct或者字典类型：<br>person.name<br>person[“name”]</p></li><li><p>注意：<br>起始对象字面量种的变量如name，age都是string。</p></li></ul><h2 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a>Array类型</h2><ul><li><p>定义<br>同Object，Array也有2种定义方法：即对象定义方法与对象字面量，前一种类似与c++的vector，后一种类似与python的列表[]</p><ol><li>对象定义方法<br>var colors = new Array();</li><li>对象字面量方法<br>var colors = []</li></ol></li><li><p>操作<br>Javasript为它的Array定义了好多的函数</p><ul><li>检测数组</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (value instanceof Array)&#123;&#125;</span><br><span class="line">if (Array.isArray(value))&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>转换</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]</span><br><span class="line">colors.toString()</span><br></pre></td></tr></table></figure><ul><li><p>栈方法<br>push与pop 方法</p></li><li><p>队列方法<br>shift与unshift<br>shift是取并移除队列头部的元素<br>unshift是往头部塞数据</p></li><li><p>顺序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var values = [1, 2, 4, 5]</span><br><span class="line">values.reverse() //values的顺序是倒序了，这个并没用python的好用</span><br><span class="line">    </span><br><span class="line">values.sort() // 这个是个坑，竟然是按照字符串来测序。</span><br><span class="line"></span><br><span class="line">// 好在这个坑，可以通过传入函数的方式来填</span><br><span class="line">function compare(v1, v2)&#123;</span><br><span class="line">   return v1-v2;</span><br><span class="line">&#125;</span><br><span class="line">values.sort(compare)</span><br></pre></td></tr></table></figure></li><li><p>切片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">slice()</span><br><span class="line">var values = [1, 2, 4, 5]</span><br><span class="line"> values.slice(1)    // 取的是1,-1</span><br><span class="line"> values.slice(1,3)  //也是左开右闭的区</span><br><span class="line"></span><br><span class="line">splice()  // 这个太强悍了，是一个基于切片的删除、插入方法</span><br><span class="line">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]</span><br></pre></td></tr></table></figure><p>完全体下： removed = colors.splice(1,1,”red”,”yellow”)<br>意思是，从1个位置上，删除1个，并插入”red”与”yellow”</p></li><li><p>查找<br>indedOf（）/lastIndexOf()<br>竟然不叫find()与rfind（），真另类。</p></li><li><p>迭代方法<br>这个挺牛逼，包含map</p></li></ul></li></ul><table><thead><tr><th>函数</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>every()</td><td style="text-align:right">对每一项运行函数，每一项皆true，结果才true</td></tr><tr><td>some()</td><td style="text-align:right">对每一项运行函数，有一项true，则结果true</td></tr><tr><td>forEach()</td><td style="text-align:right">遍历每个对象，运行函数</td></tr><tr><td>filter()</td><td style="text-align:right">通python</td></tr><tr><td>map()</td><td style="text-align:right">通python</td></tr></tbody></table><ul><li><p>reduce方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var values = [1, 2, 3, 4]</span><br><span class="line">var sum = values.reduce(function(pre, cur, index, array)&#123;</span><br><span class="line">   return prev + cur;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul><li><p>当前时间：<br>var now = new Date()</p><p>这样返回的是当前时间的毫秒数， 可以用来计算运算的时间<br>var start = Date.now()  </p></li><li><p>构建时间<br>需要在Date（）中传入一个表示该日期的毫秒数（自1970-1-1），类型位是int<br>但我们要想自己算毫秒数，人会疯掉，于是有了两个函数，用来将其他类型的转换成毫秒数</p><p>Date.parse():将本地的string类型转换成毫秒数。<br>Date.UTC():将以年月日、时分秒等数值转换成毫秒数。</p><p>于是有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var date1 = new Date(Date.parse(&quot;2018-7-30&quot;))</span><br><span class="line">var date2 = new Date(Date.UTC(2018, 7, 30))</span><br></pre></td></tr></table></figure><p>注意这里有个小坑： Date中的月，都是从0开始算的，所以1月是0, 8月是7.</p></li></ul><h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3><h4 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h4><ul><li>toString（）       // 可能是伦敦时间，格式也也是CST的</li><li><p>toLocalString()  // 北京时间： 年月日+时分秒 “2017-7-30 00:00:00”</p></li><li><p>toDateString()  // 星期、月、日、年</p></li><li><p>toLocalDateString() // “2017-7-30”</p></li><li><p>toTimeString()  // 时分秒 CST等等</p></li><li>toLocalTimeString() // “00:00:00”</li></ul><p>总之，用Locale的更好看一些</p><h4 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h4><ul><li>getTime()  // 返回表示日期的毫秒数</li></ul><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ul><li>getFullYear() //年</li><li>getMonth()    // 月，并以0为起始</li><li>getDate()     // 日:竟然是Date而不是Day 1-31</li><li>getDay()      // 星期几： 也以0位开始，Day竟然是周几，吐槽一下</li><li>getHours()    // 时：0-23</li><li>getMinutes()  // 分：0-59</li><li>getSeconds()  // 秒：0-59</li></ul><p>上述操作，有get也有set，还有个毫秒。</p><h2 id="ReqExp类型"><a href="#ReqExp类型" class="headerlink" title="ReqExp类型"></a>ReqExp类型</h2><p>JS的正则表达式与别的语言的大约类似<br>var expression = / pattern / flags<br>flags有： g 全局模式， i 不区分大小写， m 多行</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li><p>字面量形式<br>匹配第一个bat或者cat，且不区分大小写<br>var pattern1 = /[bc]at/i</p><p>匹配所有以at结尾的3个字符的组合，不区分大小写<br>var pattern2 = /.at/gi</p><p>同样模式中使用元字符需要转义： 如{[( \ ^ $ ? * . +)]}</p></li><li><p>还有一种构造函数的形式(起始就是类的形式)<br>var pattern1 = new RegExp(“[bc]at”, “i”)<br>在这里边，所有的元字符都需要双重转义</p></li><li><p>示例</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var text = &quot;mom and dad and baby&quot;;</span><br><span class="line">var pattern = /mom (and dad (and baby)?)?/gi</span><br><span class="line"></span><br><span class="line">var matches = pattern.exec(text)</span><br><span class="line">alert(matches.input)  // &quot;mom and dad and baby&quot;</span><br><span class="line">alert(matches[0]);    // &quot;mom and dad and baby&quot;</span><br><span class="line">alert(matches[1]);    // &quot;and dad and baby&quot;</span><br><span class="line">alert(matches[2]);    // &quot;and baby&quot;</span><br></pre></td></tr></table></figure><h3 id="实例属性或方法"><a href="#实例属性或方法" class="headerlink" title="实例属性或方法"></a>实例属性或方法</h3><p>var pattern3 = /[bc]]at/i</p><p>pattern3.lastIndex  // 0 表示开始搜索下一个匹配项的字符位置。<br>pattern3.source      // “[bc]at” 正则表达式的字符串表示</p><p>pattern3.exec()<br>pattern3.test(字符串) // 与模式匹配的情况下返回true，否则返回false</p><p>pattern3.toString()   // 返回增则表达式的字面量<br>pattern3.toLoacaleString() </p><h3 id="构造函数属性（类的属性）"><a href="#构造函数属性（类的属性）" class="headerlink" title="构造函数属性（类的属性）"></a>构造函数属性（类的属性）</h3><table><thead><tr><th>长属性名</th><th style="text-align:center">短属性名</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>input</td><td style="text-align:center">$_</td><td style="text-align:right">最近一次要匹配的字符串</td></tr><tr><td>lastMatch</td><td style="text-align:center">$&amp;</td><td style="text-align:right">最近一次的匹配项</td></tr><tr><td>lastParen</td><td style="text-align:center">$+</td><td style="text-align:right">最近一次的匹配捕获组</td></tr><tr><td>leftContext</td><td style="text-align:center">$`</td><td style="text-align:right">匹配项之前的文本</td></tr><tr><td>rightContext</td><td style="text-align:center">$’</td><td style="text-align:right">匹配项之后的文本`</td></tr><tr><td>multiline</td><td style="text-align:center">$*</td><td style="text-align:right">是否是多行</td></tr></tbody></table><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var text = &quot;this has been a short summer&quot;</span><br><span class="line">var pattern = /(.)hort/g</span><br><span class="line"></span><br><span class="line">if (pattern.test(text))&#123;</span><br><span class="line">  alert(RegExp.input)       // this has been a short summer</span><br><span class="line"></span><br><span class="line">  alert(RegExp.leftContext  // this has been a</span><br><span class="line">  alert(RegExp.lastMatch)   // short</span><br><span class="line">  alert(RegExp.rightContext // summer</span><br><span class="line"></span><br><span class="line">  alert(RegExp.lastParen)   // s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a>Function类型</h2><p>特意将函数拉到最后，因为后边的2章：面向对象、函数表达式其实都是对函数的深入理解。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>函数起始也是对象（这与python一样），每个函数都是Function类型的实例。而且Function与其他引用类型一样，具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。</p><h3 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h3><p>// 函数表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var fun1 = function(num)&#123;</span><br><span class="line">    return num+10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// 函数声明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function fun2(num)&#123;</span><br><span class="line">    retrun num+10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析器在向执行环境中加载数据时，对函数表达式与函数声明并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用（有点类似于静态语言的编译），至于函数表达式，则必须等到解析器之行到它所在的代码行，才会真正被解释执行。</p><h3 id="函数的内部属性"><a href="#函数的内部属性" class="headerlink" title="函数的内部属性"></a>函数的内部属性</h3><p>函数内部，有2个特殊的对象：arguments和this。</p><ul><li><p>arguments<br>前边介绍过，它是一个类数组对象，包含着传入函数的所有参数。但它还有一个callee属性，该属性是一个指针，指向拥有这个对象的函数名。</p><p>看阶乘函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function factorial(num)&#123;</span><br><span class="line">   if (num &lt;= 1)&#123;</span><br><span class="line">     return 1;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     return num * factoril(num-1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题，但这样这个函数的执行与函数名factorial紧耦合在一起了，如果将：</p><p>let factorial2 = factorial<br>let factorial = null<br>再运行factorial2，会报错。python也存在这样的问题。<br>如此可以这样改写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function factorial(num)&#123;</span><br><span class="line">   if (num &lt;= 1)&#123;</span><br><span class="line">     return 1;</span><br><span class="line">   &#125; else&#123;</span><br><span class="line">     return num * arguments.callee(num-1)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就不会有问题了。</p></li><li><p>this<br>this与Java/C++类似，this引用的是函数据以之行的环境对象。按之前的写法叫运行环境的变量对象，也就是作用域对象。</p></li></ul><h3 id="函数属性和方法"><a href="#函数属性和方法" class="headerlink" title="函数属性和方法"></a>函数属性和方法</h3><p>每个函数都包含2个属性：length与prototype，最好戏是这个prototype.</p><ul><li><p>length<br>length属性表示函数接收的命名参数的个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function sum(n1, n2)&#123;</span><br><span class="line">  return n1+n2;</span><br><span class="line">&#125;</span><br><span class="line">alert(sum.length)</span><br></pre></td></tr></table></figure></li><li><p>prototype<br>prototype放在下一章来写，在下一章会对 构造函数（类）， 实例， prototype进行详述。</p></li><li><p>apply()/call（）<br>这两个方法都是在特定的作用域中调用函数。他们的第一个参数都是作用域对象，差异是apply()的第二个参数是数组，call第二个对象是元素</p><p>// 作用域没变的情况下，就是传参或者调用函数，还不如直接调用省事</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function sum(a,b)&#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line">fuction callSum(a, b)&#123;</span><br><span class="line">   return sum.call(this, a, b)</span><br><span class="line">&#125;</span><br><span class="line">let color = &quot;red&quot;</span><br><span class="line">var o = &#123;color:&quot;blue&quot;&#125;</span><br><span class="line">function sayColor()&#123;</span><br><span class="line">  alert(this.color)</span><br><span class="line">&#125;</span><br><span class="line">sayColor();   // red</span><br><span class="line">sayColor(this);  // red</span><br><span class="line">sayColor(o);   // blue</span><br></pre></td></tr></table></figure></li><li><p>bind()<br>与apply类似，也是一种用来扩展作用域的方式，只是调用上不一样</p><p>var sayColor2 = sayColor.bind(o)<br>sayColor2()  // blue</p></li></ul><h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><p>包括有：Object、Array等都是内置对象，下边还有2个：Global与Math</p><h3 id="Global"><a href="#Global" class="headerlink" title="Global"></a>Global</h3><p>实际上没有全局变量与全局函数，所有在全局作用域中定义的属性和函数都是Global对象的属性，如isNaN（），isFinite（），parseInt（），parseFloat（）等</p><ul><li><p>encodeURI与encodeURIComponent()<br>主要用于对URI进行编码，区别在于encodeURI不会对本身属于URI的特殊字符进行编码例如: # ? /,而encodeURIComponent()会对任何非标准字符进行编码。<br>在实践中常见的是对查询字符串参数，而不是对基础URI编码，故使用后者会多一些</p></li><li><p>decodeURI与decodeURIComponent()解码<br>只能对应自己的编码</p></li></ul><p>在浏览器中，将Global对象作为window对象的一部分加以实现。</p><h3 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h3><table><thead><tr><th>属性</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>Math.E</td><td style="text-align:right">e</td></tr><tr><td>Math.LN10</td><td style="text-align:right">ln10</td></tr><tr><td>Math.LN2</td><td style="text-align:right">ln2</td></tr><tr><td>Math.LOG2E</td><td style="text-align:right">log 2底e</td></tr><tr><td>Math.LOG10E</td><td style="text-align:right">log 10底e</td></tr><tr><td>Math.PI</td><td style="text-align:right">pi</td></tr><tr><td>Math.SQRT2</td><td style="text-align:right">根2</td></tr></tbody></table><table><thead><tr><th>方法</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>Math.min()</td><td style="text-align:right">最小值</td></tr><tr><td>max（）</td><td style="text-align:right">最大值</td></tr><tr><td>ceil()</td><td style="text-align:right">向上舍入</td></tr><tr><td>floor()</td><td style="text-align:right">向下舍入</td></tr><tr><td>round()</td><td style="text-align:right">标志舍入</td></tr><tr><td>random()</td><td style="text-align:right">0-1间的随机数</td></tr><tr><td>abs(num)</td><td style="text-align:right">绝对值</td></tr><tr><td>exp(num)</td><td style="text-align:right">e的num次幂</td></tr><tr><td>log(num)</td><td style="text-align:right">num的自然对数</td></tr><tr><td>pow(num,power)</td><td style="text-align:right">num的power次幂</td></tr><tr><td>sqrt(num)</td><td style="text-align:right">平方根</td></tr><tr><td>三角函数..</td></tr></tbody></table><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>在这一里，主要对几个重要的技术进行说明，并不想对这一章进行整体的展开。这几个重要概念是：对象、构造函数（类）、原型、基于原型及构造函数的继承。</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>定义：无序属性的集合，其属性可以包含基本值、对象或者函数。</li><li>可以把es对象想象成散列表：无非就是一组名值对，其中值可以是数据与函数。<br>对与这个，首先我们在C++/Java里的对象，就是将他们的函数名当作的键。<br>其次也符合对python中的字典类型的认识，即可以当作struct来使用。<h3 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h3>es5中有两种属性：数据属性和访问器属性.这些属性是只在内部才可用的特性。<h4 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h4></li></ul><table><thead><tr><th>属性</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>Configurable</td><td style="text-align:right">表示能否通过delete删除属性从而重新定义属性</td></tr><tr><td>Enumerable</td><td style="text-align:right">表示能否通过for-in循环返回属性</td></tr><tr><td>Writable</td><td style="text-align:right">表示能否修改属性的值</td></tr><tr><td>value</td><td style="text-align:right">包含这个属性的数据值</td></tr></tbody></table><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;&#125;</span><br><span class="line">Object.defineProperty(person, &quot;name&quot;, &#123;</span><br><span class="line">   wriable: false,</span><br><span class="line">   configurable: fales,  //一旦设置为不可配置，就无法再配置回来</span><br><span class="line">   value: &quot;sun&quot;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">alert(person.name)  // &quot;sun&quot;</span><br><span class="line">delete person.name  </span><br><span class="line">alert(person.name)  // &quot;sun&quot;</span><br><span class="line">person.name = &quot;yan&quot;</span><br><span class="line">alert(person.name)  // &quot;sun&quot;</span><br></pre></td></tr></table></figure><p>这种类似于const</p><h4 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h4><table><thead><tr><th>属性</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>Configurable</td><td style="text-align:right">同上</td></tr><tr><td>Enumerable</td><td style="text-align:right">同上</td></tr><tr><td>Get</td><td style="text-align:right">在读取属性时调用的函数</td></tr><tr><td>Set</td><td style="text-align:right">在写入属性时调用的函数</td></tr></tbody></table><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var book = &#123;</span><br><span class="line">   _year: 2004   // _year表示只能通过对象方法访问的属性，私用，同python，可能也是改了下名字</span><br><span class="line">   edition:1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(book &quot;year&quot;, &#123;</span><br><span class="line">   get:function()&#123;</span><br><span class="line">     return this.__year;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   set:function(newValue)&#123;</span><br><span class="line">      </span><br><span class="line">      if(newValue &gt; 2004)&#123;</span><br><span class="line">         this.__year = newValue;</span><br><span class="line">         this.edition += newValue-2004</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">book.year = 2005</span><br><span class="line">alert(book.edition)</span><br></pre></td></tr></table></figure><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fuction createPerson(name, age, job)&#123;</span><br><span class="line">   var o = new Object();</span><br><span class="line">   o.name = name;</span><br><span class="line">   o.age = age;</span><br><span class="line">   o.job =job;</span><br><span class="line">   o.sayName = function()&#123;</span><br><span class="line">      alert(this.name)</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 = createPerson(&quot;sun&quot;, 19, &quot;Teacher&quot;);</span><br><span class="line">var person2 = createPerson(&quot;yan&quot;, 29, &quot;Doctor&quot;);</span><br></pre></td></tr></table></figure><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>工厂模式解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即知道一个对象的类型）</p><h3 id="构造函数（类）"><a href="#构造函数（类）" class="headerlink" title="构造函数（类）"></a>构造函数（类）</h3><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line"></span><br><span class="line">    this.sayName = function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 = new Person(&quot;sun&quot;, 19, &quot;software engieer&quot;)</span><br><span class="line">var person2 = new Person(&quot;yan&quot;, 29, &quot;doctor&quot;)</span><br></pre></td></tr></table></figure><h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h4><ul><li>这种构造函数的方法跟类是一致的</li><li>person1和person2分别保存着Person的一个不同的实例，这两个对象都有一个constructor（构造函数）属性，该属性指向Person</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(person1.constructor == Person) //true</span><br><span class="line">alert(person2.constructor == Person) //true</span><br></pre></td></tr></table></figure><ul><li>对象的constructor属性最初是用来标识对象类型的。但是，检测对象类型，还是用instanceof操作符更可靠一些。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(person1 instance of Person)  // true</span><br></pre></td></tr></table></figure><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul><li>构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。如person1和person2都有一个sayName()的方法，但那个方法不是同一个Function实例。</li></ul><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = &quot;Sun&quot;;</span><br><span class="line">Person.prototype.age = 29;</span><br><span class="line">Person.prototype.job = &quot;doctor&quot;</span><br><span class="line">Person.prototype.sayName = function()&#123;</span><br><span class="line">     alert(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 = new Person()</span><br><span class="line">person1.sayName(); //&quot;sun&quot;</span><br><span class="line"></span><br><span class="line">var person2 = new Person()</span><br><span class="line">person2.sayName(); // &quot;sun&quot;</span><br><span class="line"></span><br><span class="line">alert(person1.sayName == person2.sayName); // true</span><br></pre></td></tr></table></figure><h4 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h4><h5 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h5><p>原型对象类似于静态变量，类唯一。<br><img src="实例、构造函数、原型之间的关系.png" alt=""><br>上图很好的说明了实例、构造函数、原型之间的关系。<br>函数与原型之间的关系：每个新函数都有一个prototype属性，这个属性指向原型对象。默认情况下，所有原型对象会也有一个constructor属性，这个属性指向所原型所在的函数。</p><h5 id="实例与原型"><a href="#实例与原型" class="headerlink" title="实例与原型"></a>实例与原型</h5><p>新实例的内部包含一个指针，指向构造函数的原型对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(Object.getPrototypeOf(person1) == Person.prototype);  // true</span><br></pre></td></tr></table></figure><p>hasOwnProperty()可以检测一个属性是存在于实例，还是存在于原型中。只在属性存在于对象实例中，才会返回true</p><p>in:in操作符可以单独使用，在操作符会在通过对象能够访问给定属性时，返回true，无论是在实例还是在原型中。</p><p>若实例中添加一个属性，与原型中的属性同名，则该属性屏蔽原型中的属性.[这里就有一种类似于作用域东西，先搜索实例，没有找到就搜索原型]<br>这个新属性只会阻止访问原型中的属性，并不会修改那个属性，即使设置位null，也只会在实例中设置这个属性，而不会恢复其指向原型的连接。但delete操作符，则可以完全删除实例属性，从而恢复原型属性.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">person1.name = &quot;feng&quot;</span><br><span class="line">alert(person1.name); //&quot;feng&quot;</span><br><span class="line">person1.hasOwnProperty(&quot;name&quot;);  // true</span><br><span class="line">alert(&quot;name&quot; in person1);  // true</span><br><span class="line"></span><br><span class="line">delete person1.name;</span><br><span class="line">alert(person1.name)  // &quot;sun&quot;</span><br><span class="line">person1.hasOwnProperty(&quot;name&quot;)  // false</span><br><span class="line">alert(&quot;name&quot; in person1)   // true</span><br></pre></td></tr></table></figure><h5 id="更简单的原型语法"><a href="#更简单的原型语法" class="headerlink" title="更简单的原型语法"></a>更简单的原型语法</h5><p>前面每添加一个属性，都要敲一遍Person.prototype，更常见的做法是用一个对象字面量来重写整个原型对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  name:&quot;sun&quot;,</span><br><span class="line">  age:29,</span><br><span class="line">  job:teacher,</span><br><span class="line">  sayName: function()&#123;</span><br><span class="line">      alert(this.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样存在一个问题，原来prototype中的constructor指向Person构造函数，但重新赋值后,constructor属性不再指向Person了。可以通过制定constructor: Person来指定。但这样指定的，也可通过in来访问到，最好的方式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(Person.prototype, &quot;constructor&quot;, &#123;</span><br><span class="line">  enumrable: false,</span><br><span class="line">  value: Person</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="原型动态修改"><a href="#原型动态修改" class="headerlink" title="原型动态修改"></a>原型动态修改</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var friend = new Person();</span><br><span class="line"></span><br><span class="line">Pserson.prototype = &#123;</span><br><span class="line">  constructor: Person,</span><br><span class="line">  name: &quot;sun&quot;,</span><br><span class="line">  age: 29,</span><br><span class="line">  sayName: function()&#123;</span><br><span class="line">     alert(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">friend.sayName(); // error</span><br></pre></td></tr></table></figure><p>这是因为friend所中的原型指针指向的是赋值之前的原型，而不是之后的。<br><img src="原型动态修改.png" alt=""></p><h4 id="原型对象的问题"><a href="#原型对象的问题" class="headerlink" title="原型对象的问题"></a>原型对象的问题</h4><p>原型中所有的属性是被所有实例共享的，是静态的，所以修改一个，全部都会修改。故适合函数的复用。</p><h3 id="原型与构造函数的组合使用"><a href="#原型与构造函数的组合使用" class="headerlink" title="原型与构造函数的组合使用"></a>原型与构造函数的组合使用</h3><h4 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h4><p>即普通属性放到构造函数中，将函数放到原型中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job)&#123;</span><br><span class="line">   this.name = name;</span><br><span class="line">   this.age = age;</span><br><span class="line">   this.job = job;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  constructor: Person,</span><br><span class="line">  sayName: function()&#123;</span><br><span class="line">    alert(this.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job)&#123;</span><br><span class="line">   this.name = name;</span><br><span class="line">   this.age = age;</span><br><span class="line">   this.job = job;</span><br><span class="line"></span><br><span class="line">   if(typeof this.sayName != &quot;function&quot;)&#123;</span><br><span class="line">         Person.prototype.sayName = funciton()&#123;</span><br><span class="line">             alert(this.name)</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">   this.property = true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = function()&#123;</span><br><span class="line">    return this.property;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubType()&#123;</span><br><span class="line">    this.subProperty = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = new SuperType()  </span><br><span class="line">SubType.prototype.getSubValue = funtion()&#123;</span><br><span class="line">      return this.subProperty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var istance = new SubType();</span><br><span class="line">alert(instance.getSuperValue)</span><br></pre></td></tr></table></figure><h4 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h4><p>这种方法起始就是在设置子类的原型时指向父类的一个实例，这与用字面量来定义原型类似。他们之间的关系如下：<br><img src="原型链继承.png" alt=""></p><h4 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h4><ol><li>在为子类的原型添加其他属性的时候不能再用字面量了</li><li>依然存在对引用类型属性共享带来的问题。</li><li>故一般直接用的原型链继承的。<h3 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h3><h4 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h4></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">funtion SuperType()&#123;</span><br><span class="line">  this.colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubType()&#123;</span><br><span class="line">   superType.call(this)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var instance1 = new SubType();</span><br><span class="line">instance1.colors.push(&quot;black&quot;)</span><br><span class="line">alert(instance1.colors)   // &quot;red,green,blue,black&quot;</span><br><span class="line"></span><br><span class="line">var instance2 = new SubType();</span><br><span class="line">alert(instance2.colors)  //&quot;red,green blue&quot;</span><br></pre></td></tr></table></figure><h4 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a>说明</h4><p>通过使用call（）方法，就是在新创建SubType实例时，调用了SuperType构造函数，这样就会在SubType对象上初始化了所有SuperType（）函数的属性。</p><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><p>问题依旧明确，函数没有办法复用。</p><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><h4 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name)&#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.colors = [&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = function()&#123;</span><br><span class="line">   alert(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function SubType(name, age)&#123;</span><br><span class="line">   SuperType.call(this, name);</span><br><span class="line">   this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = new SuperType()</span><br><span class="line">subType.prototype.sayAge = function()&#123;</span><br><span class="line">   alert(this.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="说明-5"><a href="#说明-5" class="headerlink" title="说明"></a>说明</h4><p>属性通过构造函数来继承，避免了由于原型链继承带来的静态问题。<br>函数通过原型链继承，避免了构造函数继承带来的函数复用问题。<br>而且通过instanceof合isPrototypeOf()也能识别基于组合继承的对象。</p><h1 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="普通递归"><a href="#普通递归" class="headerlink" title="普通递归"></a>普通递归</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function factorial(num)&#123;</span><br><span class="line">   if (num &lt;= 1)&#123;</span><br><span class="line">      return 1;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      return num*facorial(num-1)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var another = factorial;</span><br><span class="line">factorial = null;</span><br><span class="line">alert(another(4));  // 出错</span><br></pre></td></tr></table></figure><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>函数内的arguments有一个 callee属性，指向正在之行函数的指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function factorial(num)&#123;</span><br><span class="line">   if (num &lt;= 1)&#123;</span><br><span class="line">      return 1;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      return num *  arguments.callee(num-1)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>当某个函数第一次调用时，会创建一个执行环境（execution context）及相应的作用域链，并把作用域链赋值给execution context一个内部特殊属性（[Scope]）。然后，使用this, arguments和其它命名参数的值来初始化函数的活动对象(activity object)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">funtion compare(v1, v2)&#123;</span><br><span class="line">   if(v1 &lt; v2)&#123;</span><br><span class="line">     return -1;</span><br><span class="line">   &#125; else if (v1 &gt; v2)&#123;</span><br><span class="line">     return 1;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     return 0;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="函数执行过程.png" alt=""></p><p>闭包是一个函数内部创建另一个函数，内部函数引用外部函数的变量。<br>这样内部函数的作用域链中，就含有外部函数的作用域（活动对象）</p><h3 id="闭包与变量"><a href="#闭包与变量" class="headerlink" title="闭包与变量"></a>闭包与变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createFuntions()&#123;</span><br><span class="line">   var result = new Array();</span><br><span class="line">   </span><br><span class="line">   for(var i=0; i&lt;10; i++)&#123;</span><br><span class="line">      result[i] = function()&#123;</span><br><span class="line">        return i;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内层函数直接访问外层函数的变量，而这个变量最后都变成了10,故所有的函数都返回10</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function createFuntions()&#123;</span><br><span class="line">   var result = new Array();</span><br><span class="line"></span><br><span class="line">   for(var i=0; i&lt;10; i++)&#123;</span><br><span class="line">     result[i] = function(num)&#123;</span><br><span class="line">        return function()&#123;</span><br><span class="line">            return num;</span><br><span class="line">        &#125;;</span><br><span class="line">     &#125;(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关于this"><a href="#关于this" class="headerlink" title="关于this"></a>关于this</h3><p>this对象是在运行时，基于函数的执行环境绑定的.当函数作为某个对象的方法调用时，this等于那个对象。不过匿名函数的执行环境具有全局性。</p><h2 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h2><p>私有变量起始跟类的私有成员类似。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function MyObject()&#123;</span><br><span class="line">   var privateVar = 10;</span><br><span class="line">   function privateFunction()&#123;</span><br><span class="line">    return false;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   this.publicMethod = function()&#123;</span><br><span class="line">     privateVar++;</span><br><span class="line">     return privateFunction();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数内部定义的的私有变量和函数不能在外部访问，但可以通过公有的函数进行访问。<br>可以认为有this的为公有，没有的就是私有。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍JavaScript的发展、组成，在Http中的使用，基础语法，变量、执行环境、内存等内容&lt;/p&gt;
    
    </summary>
    
      <category term="语言" scheme="http://yoursite.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>python进阶</title>
    <link href="http://yoursite.com/2018/07/25/python%E8%BF%9B%E9%98%B6/"/>
    <id>http://yoursite.com/2018/07/25/python进阶/</id>
    <published>2018-07-25T03:00:00.000Z</published>
    <updated>2018-07-30T01:52:29.116Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要包括：闭包与装饰器，内存管理，常用的模块介绍，pdb调试，进程及线程，python网络(tcp/udp/select/poll)，数据库等<br><a id="more"></a></p><h1 id="python进阶"><a href="#python进阶" class="headerlink" title="python进阶"></a>python进阶</h1><h2 id="模块与导入模块的路径设置"><a href="#模块与导入模块的路径设置" class="headerlink" title="模块与导入模块的路径设置"></a>模块与导入模块的路径设置</h2><ul><li><p>查看模块搜索路径<br>import sys<br>sys.path<br>所谓模块的搜索路径，指的是path执行import时，搜索的路径，这点有点像Windows的path环境变量，以上函数是查看现有的路径</p></li><li><p>添加搜索路径<br>sys.path.append(‘/home/xxx文件夹’)  #加在最后<br>sys.path.insert(‘/home/xxx文件夹’)  #加在首部<br>这两个函数是添加新的路径</p></li><li><p>重新导入模块<br>from imp import *<br>reload(模块名)<br>这块重新加载</p></li><li><p>查看安装的模块</p><ol><li>在交互解释器中使用help(“modules”)</li><li>import sys ; sys.modules.keys()这个会把具体的包中模块也打印出来<br>这个主要是这个help命令，可以模块名<br>help(“pygame.Rect”)</li></ol><p>dir()<br>如dir(sys)，其实就是列出给出对象的属性，这个些属性有对象的<strong>dir</strong>()提供<br>如果是module对象，只有module的属性<br>如果是类对象，会列出其本身的属性，以及基类的属性</p><h3 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h3><p>dir能列出模块中的类、对象等属性，对于自己的代码，需要先通过sys.path.insert将模块的目录导入，然后再调用dir(模块名)来查看 </p></li></ul><h3 id="循环导入"><a href="#循环导入" class="headerlink" title="循环导入"></a>循环导入</h3><ul><li>两个模块互相的导入</li><li><p>怎样避免循环导入</p></li><li><p>类似与#ifdef __DEFINE_H_H吗？</p></li></ul><h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><p>浅拷贝这里就是拷贝了引用,深拷贝就是对一个对象所有层次的拷贝。其实与C++的深浅拷贝概念相同<br>就是deepcopy会递归的copy，而浅拷贝不会<br>import copy<br>  copy.deepcopy<br>  copy.copy</p><ul><li><p>实例：<br>a = [1,2,3]<br>b = [4,5]<br>c = [a,b]<br>d = c</p><p>import copy<br>e = copy.deepcopy(c)<br>f = copy.copy(c)<br><img src="8.深拷贝.png" alt=""></p><p><img src="9.浅拷贝.png" alt=""></p></li></ul><p>浅拷贝对不可变类型和可变类型的copy不同（元组与列表）<br>  a=(1,2,3)<br>  b = copy.copy(a)<br>  a is b #True<br>  对于不可变类型的copy，其实就是a=b，引用指向相同的地址</p><h2 id="【新】生成器，yield"><a href="#【新】生成器，yield" class="headerlink" title="【新】生成器，yield"></a>【新】生成器，yield</h2><ul><li>初识(列表生成器)<br>g=(x for x in range(5))<br>g.next(),没有更多元素时,抛出StopIteration的异常<br>生成器只能用一次<br>for i in g:<pre><code>print(i)</code></pre></li><li><p>第二种方法:yield<br>def fib(times):<br>  n = 0<br>  a,b=0,1<br>  while n&lt;times:</p><pre><code>yield b   #yied投降,运行在这里就停一下,并且抛出后边的内容,调用一次next执行一次a,b=b,a+bn+=1</code></pre><p>  return ‘done’</p><p> g = fit(5)</p><p> #输出<br> next(g)<br> for x in g:</p></li><li><p>生成器方法:<strong>next</strong>()<br>g = fib(5)<br>g.<strong>next</strong>()</p></li><li><p>生成器方法:send()<br>g = fib(5)<br>g.<strong>next</strong>()  / g.send(None)<br>g.send(“hehe”)  </p><p>send给生成器传递一个参数<br>在生成器内部:<br>temp = yield b  #生成器抛出b,传递进的”哈哈”赋值给temp</p></li></ul><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="可迭代对象：iterator"><a href="#可迭代对象：iterator" class="headerlink" title="可迭代对象：iterator"></a>可迭代对象：iterator</h3><p>from collection import Iterable<br>isinstance([],Iterable)<br>集合对象<br>生成器对象</p><h3 id="迭代器：可以被next对象调用，并不断返回下一个对象"><a href="#迭代器：可以被next对象调用，并不断返回下一个对象" class="headerlink" title="迭代器：可以被next对象调用，并不断返回下一个对象"></a>迭代器：可以被next对象调用，并不断返回下一个对象</h3><p>l = [1,2,3]<br>it = iter(l)<br>next(it)  #集合本身不是迭代器<br>from collector imort Iterator<br>isinstance(it,Iterator)</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>函数内部可以再定义内部函数,内部函数对外部函数的属性可以直接引用,则称内部函数为闭包<br>2个条件:嵌套函数定义,内部函数引用外部函数变量<br>只调用内部函数时,被引用的外部函数变量,会绑定到闭包中,一定程度上延长了生命周期<br>其实可以理解为,构成闭包时,外部函数的变量声明周期到了延长到了内部</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def fun1():</span><br><span class="line">    def fun3():</span><br><span class="line">        print(&quot;fun3&quot;)</span><br><span class="line">    return fun3</span><br><span class="line">fun1()</span><br></pre></td></tr></table></figure><p>返回的是一个函数对象</p><h4 id="闭包-1"><a href="#闭包-1" class="headerlink" title="闭包"></a>闭包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def outter(num):</span><br><span class="line">    def inner(num_in):</span><br><span class="line">        print(&quot;num_in is %d&quot;%num_in)</span><br><span class="line">        return num_in+num</span><br><span class="line">    return inner</span><br><span class="line">fun = outer(20)</span><br><span class="line">fun(10)</span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="一元一次方程-y-ax-b"><a href="#一元一次方程-y-ax-b" class="headerlink" title="一元一次方程:y = ax+b"></a>一元一次方程:y = ax+b</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def line_conf(a,b):</span><br><span class="line">    def line(x):</span><br><span class="line">       return a*x + b</span><br><span class="line">    return line</span><br><span class="line">line1 = line_conf(1,1)</span><br><span class="line">line2 = line_conf(4,5)</span><br><span class="line"></span><br><span class="line">print(line1(5))</span><br><span class="line">print(line2(5))</span><br></pre></td></tr></table></figure><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>装饰器其实就是一个闭包,把一个函数当作参数,其中对函数进行包装,返回一个替代版新函数,其实与设计语言中了一样,也类似AOP<br>2个特性:<br>   一个是把被装饰的函数替代为其他函数<br>   而是可以在加载模块时立即执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def w1(func):</span><br><span class="line">   def inner():</span><br><span class="line">       #验证1</span><br><span class="line">       #验证2</span><br><span class="line">       func()</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">@w1</span><br><span class="line">def f1()</span><br><span class="line">   print(&quot;f1&quot;)</span><br></pre></td></tr></table></figure><p>其实就是AOP</p><p>装饰器内部函数的参与与被装饰的参数相同<br>不定长参数：可以将内部函数的参数设置为不定长参数，(<em>args,**kwargs)          </em>args表示任何多个无名参数，它是一个tuple；<strong>kwargs表示关键字参数，它是一个dict。并且同时使用*args和</strong>kwargs时，必须*args参数列要在**kwargs前<br>函数可以认为都有返回值，没有return时，return的是None</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li>引入日志：开放封闭原则，就是对增加开放，对修改封闭</li><li>函数执行时间统计</li><li>执行函数前预备处理</li><li>执行函数后清理功能</li><li>全校校验</li><li>缓存<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def makeBold(fn):</span><br><span class="line">   def wrapped():</span><br><span class="line">      return &quot;&lt;b&gt;&quot; + fn() + &quot;&lt;/b&gt;&quot;</span><br><span class="line"></span><br><span class="line">@makeBold</span><br><span class="line">def test1():</span><br><span class="line">   return &quot;hello world&quot;</span><br><span class="line"></span><br><span class="line">print(test1())</span><br></pre></td></tr></table></figure><h3 id="通用装饰器"><a href="#通用装饰器" class="headerlink" title="通用装饰器"></a>通用装饰器</h3><ul><li>不定长参数</li><li>带返回值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from time import ctime</span><br><span class="line">def doca(fun):</span><br><span class="line">   def wrapper(*args,**kwargs):</span><br><span class="line">      print(&quot;%s called at %s&quot;%(fun.__name__,ctime()))</span><br><span class="line">      ret = fun()</span><br><span class="line">      return ret</span><br><span class="line">   return wrapper</span><br><span class="line"></span><br><span class="line">@doca</span><br><span class="line">def foo():</span><br><span class="line">  print(&quot;i am foo&quot;)</span><br><span class="line"></span><br><span class="line">@doca</span><br><span class="line">def gegInfo():</span><br><span class="line">   return &quot;--hehe--&quot;</span><br><span class="line"></span><br><span class="line">@doca</span><br><span class="line">def sum(a,b):</span><br><span class="line">  return a+b</span><br></pre></td></tr></table></figure><h2 id="动态语言特性"><a href="#动态语言特性" class="headerlink" title="动态语言特性"></a>动态语言特性</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>动态语言：在运行过程中，可以修改代码,大多数脚本语言：python,JavaScript,PHP,Ruby<br>静态语言：编译时已经确定好的代码，运行过程中不能修改,C,C++,Java</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>为对象动态添加属性</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line">    def __init__(self,name=None,age=None)</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">p = Person(&quot;小明&quot;,&quot;12&quot;)</span><br><span class="line">p.sex = &quot;male&quot;   #这里动态为p定义了属性sex</span><br><span class="line">print(p.sex)</span><br><span class="line">dir(p)</span><br></pre></td></tr></table></figure><p>  这里动态添加的属性，只是对p这个对象添加的，其他的Person类的对象是没有的<br>  这里可以动态的添加类的动态属性，这样所有的对象都会有且一致。</p><ul><li>为对象动态添加实例方法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def showInfo(self):</span><br><span class="line">    print(self.name)</span><br><span class="line">    print(self.age)</span><br><span class="line"></span><br><span class="line">import types</span><br><span class="line">p.showInfo = types.MethodType(showInfo, p)#这里就是用p作为self来传递给showInfo，做一个装饰器即可。</span><br><span class="line">p.showInfo()</span><br></pre></td></tr></table></figure><ul><li>为类动态添加类方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@classmethod</span><br><span class="line"> def fun1(cls):</span><br><span class="line">    print(&quot;class Method&quot;)</span><br><span class="line"></span><br><span class="line">Person.fun1 = fun1</span><br><span class="line">p.fun1()</span><br></pre></td></tr></table></figure><ul><li>为类添加静态方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@staticmethod</span><br><span class="line">def fun2(a,b):</span><br><span class="line">   return a+b</span><br><span class="line">Person.fun2 = fun2</span><br><span class="line">print(p.fun2(1+2))</span><br></pre></td></tr></table></figure><h3 id="限制修改对象的属性"><a href="#限制修改对象的属性" class="headerlink" title="限制修改对象的属性"></a>限制修改对象的属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line">  __slots__=(&quot;name&quot;,&quot;age&quot;)</span><br></pre></td></tr></table></figure><p>这样就会限制对象往里添加属性，只限于name与age</p><h2 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h2><h3 id="前情"><a href="#前情" class="headerlink" title="前情"></a>前情</h3><h4 id="函数对象-与-类"><a href="#函数对象-与-类" class="headerlink" title="函数对象 与 类"></a>函数对象 与 类</h4><p>装饰器函数就是一个接口约束，它必须接受一个callable对象作为参数，然后返回一个callable对象<br>一般callable对象都是函数，但也有例外，只要某个类重写了<strong>call</strong>()方法那么就可以调用了</p><h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Test(object):</span><br><span class="line">   def __call__(self):</span><br><span class="line">      print(&quot;call me&quot;)</span><br><span class="line"></span><br><span class="line"> t = Test()</span><br><span class="line"> t()</span><br></pre></td></tr></table></figure><h3 id="类装饰器-1"><a href="#类装饰器-1" class="headerlink" title="类装饰器"></a>类装饰器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Test(object):</span><br><span class="line">   def __init__(self, func):</span><br><span class="line">       print(&quot;初始化&quot;)</span><br><span class="line">       print(&quot;func name is %s&quot;%func__name__)</span><br><span class="line">       self.__func = func</span><br><span class="line"></span><br><span class="line">  def __call__(self):</span><br><span class="line">       print(&quot;装饰器中的功能&quot;)</span><br><span class="line">       self.__func()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> #这里会生成一个Test对象，调用__init__方法，并且将test()作为参数产地给init</span><br><span class="line"> @Test       </span><br><span class="line"> def test():</span><br><span class="line">    print(&quot;---test---&quot;)</span><br><span class="line"> test()           #调用时，其实是调用Test对象的__call__</span><br></pre></td></tr></table></figure><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h3><p>Python为了优化速度，<br>小整数：使用了[-5,257)对象池，避免为整数频繁申请和销毁内存。[257,无穷)都是新建对象<br>单个字符：也使用对象池，常驻内存<br>一个单词的字符串：也是在对象池中。采用引用计数共用，引用计数为0则销毁。</p><h4 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">c = &apos;a&apos;</span><br><span class="line">b = &apos;a&apos;</span><br><span class="line">b is a #True</span><br><span class="line"></span><br><span class="line">s1 = &quot;hello&quot;</span><br><span class="line">s2 = &quot;hello&quot;</span><br><span class="line">s1 = s2 #True</span><br><span class="line"></span><br><span class="line">s3 = &quot;hello world&quot;</span><br><span class="line">s4 = &quot;hello world&quot;</span><br><span class="line">s3 = s4 #False</span><br></pre></td></tr></table></figure><h3 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>为新生成的对象分配内存，识别那些垃圾对象，从垃圾对象那里回收内存<br>python采用的是引用计数机制为主，标记-清除、隔代收集两种机制为辅的策略</p><p>python里每个东西都是对象，他们的核心是一个结构体：PyObject</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct_object&#123;</span><br><span class="line">    int obj_refcnt;</span><br><span class="line">    struct_typeobject *ob_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define Py_INCREE(op) ((op)-&gt;ob_refcnt++)</span><br><span class="line">#define Py_DECREE(op) \</span><br><span class="line">    if(--(op)-&gt;ob_refcnt!=0) \</span><br><span class="line">      ;\</span><br><span class="line">    else \</span><br><span class="line">      _Py_Dealloc((PyObject *)(op))</span><br></pre></td></tr></table></figure><h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><p>实时，一旦没有引用，内存就直接释放，不用其他机制的等待特定时机</p><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>多占点内存<br>有可能出现循环引用：a中有b，b中有a.这是用的是隔代收集来收集</p><h5 id="导致-1的"><a href="#导致-1的" class="headerlink" title="导致+1的"></a>导致+1的</h5><ul><li>对象被创建：a=23</li><li>对象被引用：b=a</li><li>对象被传参：func(a)</li><li>对象作为一个元素，存在容器里:list=[a,a]<h5 id="导致-1的-1"><a href="#导致-1的-1" class="headerlink" title="导致-1的"></a>导致-1的</h5></li><li>对象别名被显示销毁，del a</li><li>对象别名被赋予新的对象 a = 24</li><li>一个对象离开它的作用域，如f函数执行完毕，func函数的局部变量都会-1</li><li>对象所在的容器被销毁，或者从容器中删除。<h5 id="查看引用计数"><a href="#查看引用计数" class="headerlink" title="查看引用计数"></a>查看引用计数</h5></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">a = &quot;hello world&quot;</span><br><span class="line">sys.getrefcount(a)</span><br></pre></td></tr></table></figure><p>此时最少打印2，因为a创建+1，传参+1</p><h5 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h5><ol><li>调用gc.collect()</li><li>当gc模块的计数器达到阀值（有3个）的时候</li><li>程序退出</li></ol><h5 id="gc模块"><a href="#gc模块" class="headerlink" title="gc模块"></a>gc模块</h5><p>gc.garbage列表<br>gc.get_threshold()获取gc模块中自动执行垃圾回收的频率<br>gc._threshold(thrshold0[,th])<br>gc.get_count()，隔代收集中每代的个数<br>gc.collect([generation])隔代收集的0代表直线查第一代，1代表检查1.2代<br>gc模块唯一处理不了的是循环引用的类都有<strong>del</strong>方法，所以项目中避免定义<strong>del</strong>方法<br>gc.disable()手动关掉垃圾回收</p><h4 id="隔代收集"><a href="#隔代收集" class="headerlink" title="隔代收集"></a>隔代收集</h4><h2 id="内建"><a href="#内建" class="headerlink" title="内建"></a>内建</h2><h3 id="方法方法"><a href="#方法方法" class="headerlink" title="方法方法"></a>方法方法</h3><p><img src="10.内建属性.png" alt=""></p><ul><li><strong>new</strong>：构造函数</li><li><strong>init</strong>：初始化函数</li><li><strong>clas</strong>：实例所在类</li><li><strong>str</strong>：类似与Java的toString</li><li><strong>repr</strong>：</li><li><strong>del</strong>：析构</li><li><strong>dict</strong>:实例地定义属性</li><li><strong>doc</strong>：类文档，子类不继承</li><li><strong>getattibute</strong>:属性访问拦截器</li><li><p><strong>bases</strong>:类的所有父类构成元素</p></li><li><p><strong>getattribute</strong>属性访问拦截器<br>正常使用</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class School(object):</span><br><span class="line">   def __init__(self,s1):</span><br><span class="line">       self.subject1 = s1</span><br><span class="line">       self.subject2 = &apos;c++&apos;</span><br><span class="line"></span><br><span class="line">   def __getattribute__(self, obj):</span><br><span class="line">       if obj == &apos;subject1&apos;:</span><br><span class="line">           print(&quot;log subject1&quot;)</span><br><span class="line">           return &apos;redirect python&apos;</span><br><span class="line">       else:   #注意else一定要有，否则其他属性就是None了</span><br><span class="line">           return object.__getattribute__(self,ojb)</span><br><span class="line"></span><br><span class="line"> s = School(&apos;Pyhont&apos;)</span><br><span class="line"> print(s.subject1)</span><br><span class="line"> print(s.subject2)</span><br></pre></td></tr></table></figure><p> 坑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line">   def __getattribute__(self,obj):</span><br><span class="line">      print(&quot;---test---&quot;)</span><br><span class="line">      if obj.startwith(&quot;a&quot;):</span><br><span class="line">         return &quot;haha&quot;</span><br><span class="line">      else:</span><br><span class="line">         return self.test</span><br><span class="line"></span><br><span class="line">   def test(self):</span><br><span class="line">      print(&quot;heihei&quot;)</span><br><span class="line"></span><br><span class="line">  # 函数执行内存都在栈上</span><br><span class="line">  t=Person()</span><br><span class="line">  t.a </span><br><span class="line">  t.b #会让程序死掉，因为会递归调用__getattribute__所有就崩掉了</span><br></pre></td></tr></table></figure><h3 id="内建方法"><a href="#内建方法" class="headerlink" title="内建方法"></a>内建方法</h3><ul><li>dir<br>dir(<strong>buildins</strong>)</li><li>range(1,10,2)</li><li><p>map(function, sequence[,sequence,…])根据提供的函数，对指定序列做映射<br>map(lambda x:x*x,[1,2,3])：结果为[1,4,9],python2直接是序列，python3是可迭代的对象<br>map(lamdbda x,y:x+y,[1,2,3],[4,5,6]) ：结果为[5,7,9]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def f1(x,y):</span><br><span class="line">   return (x,y)</span><br><span class="line">l1 = [1,2,3]</span><br><span class="line">l2 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]</span><br><span class="line">l3 = map(f1,l1,l2)</span><br><span class="line">print(list(l3))</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>filter(function or None,sequence)对指定序列执行过滤操作<br>filter(lambda x:x%2,[1,2,3,4])<br>filter(None,”hello”)</p></li><li><p>reduce(function,sequence[,initial])对参数序列中元素进行累积<br>python3中，reduce从全局名字空间中移除，放在functools模块里<br>from functools import reduce<br>reduce(lambda x,y:x+y, [1,2,3,4]) #10<br>reduce(lambda x,y:x+y, [1,2,3,4],5)  #15<br>reduce(lambda x,y:x+y, [‘aa’,’bb’,’cc’],’dd’)  #’ddaabbcc’</p></li></ul><h3 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h3><ul><li>支持的运算：<br>|:union：并集<br>&amp;：intersection:交集<br>-:difference:差集<br>^:sysmmetric_difference：对称差集，x^y，在x或y中，但不会同时出现在二者之中</li></ul><h2 id="常用模块"><a href="#常用模块" class="headerlink" title="常用模块"></a>常用模块</h2><h3 id="functools"><a href="#functools" class="headerlink" title="functools"></a>functools</h3><ul><li><p>partial：偏函数<br>把一个函数的某些参数设置默认参数，返回一个新的采纳数，调用这个函数会更简单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line">def showarg(*args,**kwagrs):</span><br><span class="line">   print(args)</span><br><span class="line">   print(kwargs)</span><br><span class="line"></span><br><span class="line">p1=functools.partial(showarg,1,2,3)</span><br><span class="line">p1()  #1,2,3 #&#123;&#125;</span><br><span class="line">p1(4,5,6)  #1,2,3,4,5,6 #&#123;&#125;</span><br><span class="line">p1(a=&apos;python&apos;, b=&apos;c++&apos;)  #1,2,3 #&#123;&quot;a&quot;:&quot;python&quot;,&quot;b&quot;:&quot;c++&quot;&#125;</span><br><span class="line"></span><br><span class="line">p2=functools.partial(showarg,a=3,b=&apos;linux&apos;)</span><br><span class="line">p2()</span><br><span class="line">p2(1,2)</span><br><span class="line">p2(a=&quot;ptyon&quot;,b=&quot;c++&quot;)#这个会将默认值改掉</span><br></pre></td></tr></table></figure></li><li><p>wraps：包装函数<br>使用装饰器后，被装饰的函数已经是另外一个函数了，wraps的装饰器可以消除这样的副作用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line">def note(func):</span><br><span class="line">   @functools.wraps(func)</span><br><span class="line">   def wrapper():</span><br><span class="line">      print(&quot;note something&quot;)</span><br><span class="line">      return func()</span><br><span class="line">   return wrapper</span><br><span class="line"></span><br><span class="line">@note</span><br><span class="line">def test():</span><br><span class="line">   print(&quot;i am test&quot;)</span><br><span class="line"></span><br><span class="line">test()</span><br><span class="line">print(test.__doc__) 如果不加，则返回的是wrapper(), 反之为test</span><br></pre></td></tr></table></figure></li></ul><p>  其实就是在新家的这个装饰器内部，修改了wrapper的<strong>doc</strong></p><h3 id="常用标准模块"><a href="#常用标准模块" class="headerlink" title="常用标准模块"></a>常用标准模块</h3><p><img src="11.常用标准模块.png" alt=""></p><h3 id="常用三方模块"><a href="#常用三方模块" class="headerlink" title="常用三方模块"></a>常用三方模块</h3><p> <img src="12.常用三方模块.png" alt=""></p><h2 id="pdb调试"><a href="#pdb调试" class="headerlink" title="pdb调试"></a>pdb调试</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><ul><li><p>执行时调试<br>python -m pdb some.py<br>只用这种就行<br>-m 指的是module， 像脚本一样运行模块</p></li><li><p>交互调试<br>import pdb<br>pdb.run(‘testfun(args)’)</p></li><li><p>程序下断点<br>import pdb<br>pdb.set_trace()<br>运行到这之后停住，使用与gdb类似，p打印，n单步，s进入函数，c继续执行，<br><img src="13.pdb调试.png" alt=""></p></li></ul><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="fork方法"><a href="#fork方法" class="headerlink" title="fork方法"></a>fork方法</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>fork调用一次返回2次，父进程返回子进程id，子进程返回0<br>一个父进程可以fork出很多子进程，所以父进程要记下每个子进程的id，而子进程只需要调用getppid()就可以拿到父进程的id</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">imprt time</span><br><span class="line">pid = os.fork()</span><br><span class="line">if pid&lt;0:</span><br><span class="line">   time.sleep(2)</span><br><span class="line">   print(&quot;fork调用失败&quot;)</span><br><span class="line">elif pid==0:</span><br><span class="line">   time.sleep(1)</span><br><span class="line">   print(&quot;我是子进程(%s),我的父进程是(%s)&quot;%(os.getpid(), os.getppid()))</span><br><span class="line">else:</span><br><span class="line">   print(&quot;我是父进程(%s),我的子进程是(%s)&quot;%(os.getpid(), pid))</span><br><span class="line"></span><br><span class="line">print(&quot;父子进程都可以执行这里的代码&quot;)</span><br></pre></td></tr></table></figure><h4 id="多个fork"><a href="#多个fork" class="headerlink" title="多个fork"></a>多个fork</h4><p>这里创建了4个进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">pid = os.fork()</span><br><span class="line">if pid==0:</span><br><span class="line">   print(&quot;子进程11&quot;)</span><br><span class="line">else:</span><br><span class="line">   print(父进程11)</span><br><span class="line"></span><br><span class="line">pid = os.fork()</span><br><span class="line">if pid == 0:</span><br><span class="line">   print(&quot;子进程22&quot;)</span><br><span class="line">else:</span><br><span class="line">   print(&quot;父进程22&quot;)</span><br></pre></td></tr></table></figure><h4 id="复习-1"><a href="#复习-1" class="headerlink" title="复习"></a>复习</h4><p>fork返回值是子进程的pid,如果本身是子进程,返回值就是0</p><h3 id="通过Process对象创建子进程"><a href="#通过Process对象创建子进程" class="headerlink" title="通过Process对象创建子进程"></a>通过Process对象创建子进程</h3><h4 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">def run_proc(name):  #子进程只执行这个函数</span><br><span class="line">   print(&quot;子进程运行中，name=%s,pid=%d&quot;%(name,os.getpid()))</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;</span><br><span class="line">   print(&quot;父进程%d&quot;%s.getpid())</span><br><span class="line">   p = Process(target=run_proc,args=(&apos;test&apos;,))</span><br><span class="line">   print(&quot;子进程将要执行&quot;)</span><br><span class="line">   p.start()</span><br><span class="line">   p.join()  #加这句话，父进程等待子进程结束之后再执行</span><br><span class="line">   print(&quot;子进程执行结束&quot;)</span><br></pre></td></tr></table></figure><h4 id="Process常用方法"><a href="#Process常用方法" class="headerlink" title="Process常用方法"></a>Process常用方法</h4><p>is_alive:判断进程是否执行<br>join([timeout])是否等待进程实例执行结束，或等待多少秒<br>start(),启动<br>run()，没有制定target时执行<br>terminat()，不管任务是否完成，终止任务，一般父进程来终止子进程</p><h4 id="Process常用属性"><a href="#Process常用属性" class="headerlink" title="Process常用属性"></a>Process常用属性</h4><p>name:当前进程实例别名，默认为Process-N<br>pid,当前进程pid</p><h3 id="通过Prcess子类创建子进程"><a href="#通过Prcess子类创建子进程" class="headerlink" title="通过Prcess子类创建子进程"></a>通过Prcess子类创建子进程</h3><h4 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">import time</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">class ProcessSubClass(Process):</span><br><span class="line">   def __init__(self,interval):</span><br><span class="line">     super().__init__()</span><br><span class="line">     self,interval = interval</span><br><span class="line"></span><br><span class="line">   #重写父类run</span><br><span class="line">   def run(self):</span><br><span class="line">       t_start= time.time()</span><br><span class="line">       time.sleep(self.interval)</span><br><span class="line">       t_end = tim.time()</span><br><span class="line">       print(%s执行结束，耗时%d%(os.getpid(),t_end-t_start))</span><br><span class="line"></span><br><span class="line"> if __name__==&quot;__main__&quot;:</span><br><span class="line">   print(&quot;主进程执行开始&quot;)</span><br><span class="line">   p = ProcessSubClass(2)</span><br><span class="line">   p.start()</span><br><span class="line">   p.join()</span><br><span class="line">   print(&quot;主进程执行结束&quot;)</span><br></pre></td></tr></table></figure><h3 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h3><p>multiprocessing模块提供的Pool方法<br>如果池已经满了，只能等待，如果没有满，并且有空闲的，则去空闲的，反之，创建一个新进程。</p><h4 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Pool</span><br><span class="line">import os,time,random</span><br><span class="line"></span><br><span class="line">def worker(msg):</span><br><span class="line">   t_start = time.time()</span><br><span class="line">   print(&quot;子进程%d,%d&quot;,%(os.getpid(),msg))</span><br><span class="line">   time.sleep(random.randint(1,3)*2)</span><br><span class="line">   t_stop = time.time()</span><br><span class="line">   print(&quot;执行完毕，用时:%d&quot;%(t_stop-t_start))</span><br></pre></td></tr></table></figure><p>#创建进程池<br>pool = Pool(3)</p><p>for i in range(0,10):</p><p>   #从进程池申请进程，传参为函数名、参数元组</p><p>   #apply_async是异步申请，apply是同步。异步同时请求3个，然后同时执行；同步一个一个请求，上一个进程退出才能执行下一个<br>   pool.apply_async(worker,(i,))</p><p>#关闭进程池，close之后再写join，进程池中的进程已经是start状态，所以不需要再start了<br>pool.close()<br>pool.join()</p><h4 id="multiprocessing-Pool函数解析"><a href="#multiprocessing-Pool函数解析" class="headerlink" title="multiprocessing.Pool函数解析"></a>multiprocessing.Pool函数解析</h4><ul><li>apply_async(func[,args[,kwagrs]]):</li><li>apply</li><li>close():进程池不再接受新的任务，已用的进程慢慢关闭</li><li>terminate()：不管任务是否完成，立即终止</li><li>join()：与Process相同</li></ul><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><h4 id="进程之间"><a href="#进程之间" class="headerlink" title="进程之间"></a>进程之间</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">from multiProcess import Process</span><br><span class="line">from multiProcess import Queue</span><br><span class="line"></span><br><span class="line">def writer(q):</span><br><span class="line">   for item in &quot;ABCDE&quot;</span><br><span class="line">       print(&quot;正在往消息队列中写入%s&quot;%item)</span><br><span class="line">       q.put(item)</span><br><span class="line">       time.sleep(1)</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">def reader(q):</span><br><span class="line">   while True:</span><br><span class="line">   if not q.empty():</span><br><span class="line">      item = q.get()</span><br><span class="line">      print(&quot;从消息队列中读出%s&quot;%item)</span><br><span class="line">      time.sleep(random.random())</span><br><span class="line">   else:</span><br><span class="line">      break</span><br><span class="line"></span><br><span class="line">q = Queue()</span><br><span class="line">pw = Process(target=writer,args=(q,))</span><br><span class="line">pw.start()</span><br><span class="line">pw.join()</span><br><span class="line"></span><br><span class="line">pr = Process(target=reader,args=(q,))</span><br><span class="line">pr.start()</span><br><span class="line">pr.join()</span><br></pre></td></tr></table></figure><h4 id="进程池-1"><a href="#进程池-1" class="headerlink" title="进程池"></a>进程池</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">from multiProcess import Pool,Manager</span><br><span class="line">import time,random</span><br><span class="line"></span><br><span class="line">def writer(q):</span><br><span class="line">   for item in &quot;ABCDE&quot;</span><br><span class="line">       print(&quot;正在往消息队列中写入%s&quot;%item)</span><br><span class="line">       q.put(item)</span><br><span class="line">       time.sleep(1)</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">def reader(q):</span><br><span class="line">   while True:</span><br><span class="line">   if not q.empty():</span><br><span class="line">      item = q.get()</span><br><span class="line">      print(&quot;从消息队列中读出%s&quot;%item)</span><br><span class="line">      time.sleep(random.random())</span><br><span class="line">   else:</span><br><span class="line">      break</span><br><span class="line"></span><br><span class="line">q = Manager().Queue()  #进程池中，只能使用Manager创建的消息队列</span><br><span class="line">pool = Pool(3)</span><br><span class="line">Pool.apply(writer,(q,))  #执行结束之后，再执行下一个进程</span><br><span class="line">Pool.apply(reader,(q,))</span><br><span class="line"></span><br><span class="line">Pool.close()</span><br><span class="line">Pool.join()</span><br></pre></td></tr></table></figure><h3 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h3><p>python的进程一部分继承了linux轻进程的特点</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h3><p>进程是作为资源分配的单位<br>调度和执行的单位</p><p>python的thread模块以及threading模块<br>threading模块对thread做了一些包装</p><h3 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def fun(num):</span><br><span class="line">    print(&quot;线程%d执行&quot;%num)</span><br><span class="line">    time.sleep(2)</span><br><span class="line"></span><br><span class="line">for i in range(5):</span><br><span class="line">    t = threading.Thread(target=fun,args=(i+1,))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul><li>threading.enumerate():当前线程数量</li></ul><h3 id="线程创建方式"><a href="#线程创建方式" class="headerlink" title="线程创建方式"></a>线程创建方式</h3><ul><li>threading.Tread的对象</li><li>子类化thread.Tread，实现run方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import threading,time</span><br><span class="line">class MyThread(threading.Thread):</span><br><span class="line">      def run(self):</span><br><span class="line">              for i in range(5):</span><br><span class="line">                      time.sleep(1)</span><br><span class="line">                      #这里self.name是父类的属性，默认是Thread-N</span><br><span class="line">                      print(&quot;I am &quot;+ self.name+&quot;@&quot;+str(i))</span><br><span class="line"></span><br><span class="line">if __name__==&quot;__main__&quot;:</span><br><span class="line">      t = MyThread()</span><br><span class="line">      t.start()</span><br></pre></td></tr></table></figure><p>  传参可以通过重新定义<strong>init</strong>方法来传参</p><h3 id="线程的几种状态"><a href="#线程的几种状态" class="headerlink" title="线程的几种状态"></a>线程的几种状态</h3><p><img src="14.线程的几种状态.png" alt=""><br>就绪，运行，阻塞状态<br>就绪状态到运行状态是需要系统的调用，才进入运行状态，运行状态受阻塞的事件，进入阻塞状态<br>运行状态下的时间片用完，进入就绪状态</p><h3 id="线程之间通信"><a href="#线程之间通信" class="headerlink" title="线程之间通信"></a>线程之间通信</h3><h4 id="共享全局变量"><a href="#共享全局变量" class="headerlink" title="共享全局变量"></a>共享全局变量</h4><h4 id="传参方式"><a href="#传参方式" class="headerlink" title="传参方式"></a>传参方式</h4><p>将全局变量作为参数传递给线程<br>w1 = threading.Tread(target=worker1,args=(numlist,))<br>这里的传参方式，直接调用函数传参需要注意的事项相同，对于可不变类型与不可变类型需要注意。对于可变参数，传递的是引用。不可变参数传递会创建新对象。</p><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>操作分为3步骤：<br>cpu线程内存将g_num读到寄存器<br>在寄存器中+1<br>将寄存器写回内存</p><h4 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h4><p>为保证线程安全<br>threading模块中定义了Lock类，可以处理锁定<br>mutex = threading.Lock()</p><p>mutex.acquire([blocking]),返回一个bool变量<br>   blocking默认为True，阻塞;False不阻塞<br>mutex.release()</p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>这个太熟悉了,不说了</p><h4 id="使用锁使线程顺序执行"><a href="#使用锁使线程顺序执行" class="headerlink" title="使用锁使线程顺序执行"></a>使用锁使线程顺序执行</h4><p>就是每个线程一个锁.初始时,除了第一个线程的锁,其他锁都锁死,第一个线程执行完,开第二把锁,第二个执行完开第三把,依次类推.</p><h4 id="Queue模块"><a href="#Queue模块" class="headerlink" title="Queue模块"></a>Queue模块</h4><p>python的Queue模块</p><ul><li>FIFO(先入先出):Queue</li><li>LIFO(后入先出):LifoQueue</li><li>优先级队列:PriorityQueue</li></ul><p>python2中from Queue import Queue<br>python3中from queue import Queue<br>使用方法与进程的相同<br>queue.put(对象)<br>queue.get()</p><h4 id="ThreadLocal变量"><a href="#ThreadLocal变量" class="headerlink" title="ThreadLocal变量"></a>ThreadLocal变量</h4><p>ThreadLocal变量虽是全局变量，但每个线程都只读写自己线程的独立副本，互不干扰。解决了一个线程中各个函数之间相互传递的问题。<br>threadLocal最常用的地方就是为每个线程绑定一个数据库连接，Http请求，用户身份信息等，这样一个线程的所有调用到的处理函数，都可以非常方便的访问这些这些资源</p><p>import threading<br>local_school = threading.local()  #这里的local说明可能不是一个类，是个函数也不对，听奇怪不遵循python3的类首字母大写的规范</p><p>就是一个线程函数中调用另一函数，这两个函数之间的数据传递。<br>其实是由于python的传参，对于可变类型传递的都是引用，造成了线程内部调用的函数都是线程不安全的，所以使用了这种类似与Queue的方法,将这些传参都放到全局变量里去获取。这个与queue不同的是threadLocal对各个线程是独立的，像是每个线程都有一个的样子。而且它是key-value方式存储</p><h4 id="复习-2"><a href="#复习-2" class="headerlink" title="复习"></a>复习</h4><p>主要是对ThreadLocal的理解，local可以看作是一个对象，它在不同线程中变量相同但数据不同。</p><h2 id="【新】协程"><a href="#【新】协程" class="headerlink" title="【新】协程"></a>【新】协程</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>比线程更小的执行单元，是在线程下的运行单元，协程一般由用户来实现，比线程占用资源更少<br>用处：<br>  IO密集型程序比较适合协程，而CPU密集型不适合协程<br>底层：<br>  yield来停下，然后用next来实现</p><h3 id="greenlet使用"><a href="#greenlet使用" class="headerlink" title="greenlet使用"></a>greenlet使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from greenlet import greenlet</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def test1():</span><br><span class="line">   while True:</span><br><span class="line">     print(&quot;---AAA---&quot;)</span><br><span class="line">     gr2.switch()#这里切换到test2方法中运行</span><br><span class="line">def test2():</span><br><span class="line">   while True:</span><br><span class="line">     print(&quot;---BBB---&quot;)</span><br><span class="line">     gr1.switch()</span><br><span class="line"> </span><br><span class="line">gr1 = greenlet(test1)</span><br><span class="line">gr2 = greenlet(test2)</span><br><span class="line">gr1.switch</span><br></pre></td></tr></table></figure><h3 id="gevent"><a href="#gevent" class="headerlink" title="gevent"></a>gevent</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import gevent</span><br><span class="line">def f(n):</span><br><span class="line">   for i in range(n):</span><br><span class="line">      print(&quot;%s:%d&quot;%(gevent.getcurrent(),n))</span><br><span class="line">      gevent.sleep(1)  #需要有io等待，这里模拟耗时任务，需要用gevent中的sleep，有IO等待，不需要人工调用，gevent自动切换</span><br><span class="line"></span><br><span class="line">g1 = gevent.spawn(f,5)</span><br><span class="line">g2 = gevent.spawn(f,5)</span><br><span class="line">g3 = gevent.spawn(f,5)</span><br><span class="line"></span><br><span class="line">g1.join()</span><br><span class="line">g2.join()</span><br><span class="line">g3.join()</span><br></pre></td></tr></table></figure><h3 id="并发下载器"><a href="#并发下载器" class="headerlink" title="并发下载器"></a>并发下载器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from gevent import monkey</span><br><span class="line">import gevent</span><br><span class="line">from  urllib import request</span><br><span class="line"></span><br><span class="line">#有IO需要有这句话，才可以对IO进行耗时进行捕获，从而自动切换</span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br><span class="line">def myDownload(url):</span><br><span class="line">   print(url)</span><br><span class="line">   response = request.urlopen(url)</span><br><span class="line">   data = response.read()</span><br><span class="line">   prin(&quot;%d bytes received from %s&quot;%(len(data),url)</span><br><span class="line"></span><br><span class="line">gevent.joinall([</span><br><span class="line">gevnet.spawn(myDownload,&quot;http://www.baidu.com&quot;),</span><br><span class="line">gevnet.spawn(myDownload,&quot;http://www.sina.com&quot;)</span><br><span class="line">gevnet.spawn(myDownload,&quot;http://www.weibo.com&quot;)</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h3 id="复习-3"><a href="#复习-3" class="headerlink" title="复习"></a>复习</h3><p>并发下载器，提示了多线程/多协程去爬取网页的技术，网页的爬取与网页的分析是可以分开来使用的，多线程可以用作很多方面。</p><h2 id="网络简介"><a href="#网络简介" class="headerlink" title="网络简介"></a>网络简介</h2><ul><li><p>网络地址与主机地址<br><img src="15.IP地址.png" alt=""><br>A类：1.0.0.1 - 126.255.255.254 可用的A类网络有126个每个网络容纳167 7214个主机<br>B类：128.1.0.1 - 191.255.255.254 B类网络有16384个，容纳主机65534个<br>C类：192.0.1.1 - 223.255.254 C类网络209 7152个，容纳主机254个<br>D类：第一个字节以1110开始，它并不指向特定的网络，目前这一类地址被用在多点广播中多点国博地址用来一次寻址一组计算机地址范围224.0.0.1 - 239.255.255.254<br>E类：以1111开始，为将来保留，作为实验使用</p><p>私有IP 有一部分ip用于局域网使用，不再公网中使用，包括</p><pre><code>-A类 10.0.0.0 - 10.255.255.255-B类 172.16.0.0 - 172.31.255.255-C类 192.168.0.0 - 192.168.255.255- 127.0.0.1 - 127.255.255.255用户回路测试</code></pre><p>共有IP ip<br>路由器完成公有ip与私有ip之间的转换：所以说一台私有ip的电脑不能作为网络服务器，因为外界不能正确访问到它</p></li><li><p>端口号<br>端口号只有整数，范围从0～65535<br>知名端口号，0～1023.如80:http, 21:ftp<br>动态端口：1024～65535<br>netstat -an</p></li><li><p>协议<br><img src="16.网络协议.png" alt=""><br>socket: cs架构与bs架构</p></li></ul><h2 id="socket-udp"><a href="#socket-udp" class="headerlink" title="socket-udp"></a>socket-udp</h2><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">socket.socket(AddressFamily, Type)</span><br><span class="line">  AddressFamily:AF_INET</span><br><span class="line">  Type:SOCK_STRAEM(tcp),SOCK_DGRAM(udp)</span><br></pre></td></tr></table></figure><h3 id="udp应用"><a href="#udp应用" class="headerlink" title="udp应用"></a>udp应用</h3><p>语音广播，视频，QQ，TFTP,SNMP,DNS，RIP（路由信息协议，报告股票市场）</p><h3 id="收发数据"><a href="#收发数据" class="headerlink" title="收发数据"></a>收发数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">updSocket = socke(AF_INET,SOCKET_DGRAM)</span><br><span class="line">sendAddr=(&apos;192.168.1.1&apos;,8080)</span><br><span class="line">sendData = raw_input(&quot;请输入要发的数据&quot;)</span><br><span class="line">updSocket.sendto(sendData,sendAddr)</span><br><span class="line"></span><br><span class="line">bindAddr=(&apos;192.168.1.2&apos;,7788)</span><br><span class="line">udpSokcet.bind(bindAddr)</span><br><span class="line">rcvData = udpSocket.recvfrom(1024) #1024代表本次接受的最大字节数,此处接受收时会阻塞</span><br><span class="line">print(rcvData)</span><br><span class="line">updSocket.close()</span><br></pre></td></tr></table></figure><h2 id="tftp"><a href="#tftp" class="headerlink" title="tftp"></a>tftp</h2><ul><li>使用协议udp，端口69</li><li>使用wireshark抓包</li><li><p>使用tftpd32来做tftp服务器</p></li><li><p>过程：</p><ol><li>客户端发请求，下载还是上传（操作类型）、文件名</li><li>服务器收到请求确认：如果文件没有，发出错信息；反之，发确认信息，或者直接发文件一部分</li><li>客户端收到文件后：如果收到文件数据，需要发确认信息，并且将数据保存本地<pre><code>如果收到出错信息，终止下载</code></pre></li><li>循环过程：服务器发文件一部分，客户端确认，知道文件发完</li><li>如果文件结束，应该有一个文件结束的标志<br><img src="17.tftp协议介绍.png" alt=""><br>操作码：1是读即下载，2是写即上传，3是数据包，4确认，5出错</li></ol></li></ul><p>struct模块，处理C语言的结构体<br>pack(): pack(fmt,v1,v2…)<br>unpack(): unpack(fmt,string)<br>calcsize(fmt)，计算给点内存</p><p>fmt：!大端，windows下下小端，linux下大端，网络也是大端。大端就是高位在前<br><img src="18.fmt意思.png" alt=""></p><h2 id="socket-tcp"><a href="#socket-tcp" class="headerlink" title="socket-tcp"></a>socket-tcp</h2><h3 id="服务器流程："><a href="#服务器流程：" class="headerlink" title="服务器流程："></a>服务器流程：</h3><ol><li>创建套接字</li><li>bind绑定ip与port</li><li>listen是套接字变为可以被动链接</li><li>accept等待客户端的连接</li><li>recv/send接收发送数据<br><img src="19.tcp服务器.png" alt=""></li></ol><h3 id="客户端历程"><a href="#客户端历程" class="headerlink" title="客户端历程"></a>客户端历程</h3><ol><li>创建socket</li><li>connect</li><li>send/recv</li><li>close</li></ol><h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>可以把socket当作文件读写的，用多路复用来监听<br><img src="20.多路复用select版.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import select</span><br><span class="line"></span><br><span class="line">socketServer = socket(AF_INET,SOCK_STREAM)</span><br><span class="line">socketServer.setsockopt(SOL_SOCKET,SO_REUSEADDR,1)</span><br><span class="line">inputs=[socketServer,sys.stdin]</span><br><span class="line">readable,writeable,exceptional = select.select(inputs,[],[])</span><br><span class="line">for r in readable:</span><br><span class="line">    if r == socketServer:</span><br><span class="line">       conn,addr = r.accept()</span><br><span class="line">       inputs.append(conn)</span><br><span class="line">    elif r== sys.stdin:</span><br><span class="line">       pass</span><br><span class="line">    else:</span><br><span class="line">       data = r.recv(1024)</span><br><span class="line">       if data:</span><br><span class="line">         r.send(data)</span><br><span class="line">        else:</span><br><span class="line">          inputs.remove(r)</span><br></pre></td></tr></table></figure><p>select 类似与中断，同时监听多少个,是一种轮询的方式</p><h3 id="epoll只有linux用"><a href="#epoll只有linux用" class="headerlink" title="epoll只有linux用"></a>epoll只有linux用</h3><p><img src="21.多路复用epoll版.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">from socket import *</span><br><span class="line">import select,sys</span><br><span class="line"></span><br><span class="line">epoll = select.epoll()</span><br><span class="line">epoll.register(tcpsocket.fileno(), select.EPOLLIN|select.EPOLLET)</span><br><span class="line">epoll.register(sys.stdin.fileno(), select.EPOLLIN|select.EPOLLET)</span><br><span class="line"></span><br><span class="line">conections = &#123;&#125;</span><br><span class="line">adress=&#123;&#125;</span><br><span class="line"></span><br><span class="line">epoll_list = epoll.poll()</span><br><span class="line">for fd,events in epoll_list:</span><br><span class="line">   if fd == tcpsocket.fileno()</span><br><span class="line">      conn,addr = tcpsocket.accept()</span><br><span class="line">      connections[conn.fileno()] = conn</span><br><span class="line">      address[conn.fileno()] = adress</span><br><span class="line">      epoll.register(conn.fileno(), select.EPOLLIN|select.EPOLLET)</span><br><span class="line">   elif fd == sys.stdin.fileno():</span><br><span class="line">      pass</span><br><span class="line">   elif events == select.EPOLLIN:</span><br><span class="line">     data = connections[fd].rect(1024)</span><br><span class="line">     if data:</span><br><span class="line">         connections[fd].send(data)</span><br><span class="line">     else:</span><br><span class="line">         conections[fd].close()</span><br><span class="line">         connections.pop(fd)</span><br><span class="line">         address.pop(fd)</span><br></pre></td></tr></table></figure><h2 id="网络工具"><a href="#网络工具" class="headerlink" title="网络工具"></a>网络工具</h2><h3 id="NetAssist-网络调试助手"><a href="#NetAssist-网络调试助手" class="headerlink" title="NetAssist:网络调试助手"></a>NetAssist:网络调试助手</h3><p>可以用tcp，udp协议与写的代码进行交互</p><h3 id="wireShark-网络抓波工具"><a href="#wireShark-网络抓波工具" class="headerlink" title="wireShark:网络抓波工具"></a>wireShark:网络抓波工具</h3><p>选中网卡，能抓到该网卡上的网络传输数据</p><h3 id="tftpd32：tftp服务器"><a href="#tftpd32：tftp服务器" class="headerlink" title="tftpd32：tftp服务器"></a>tftpd32：tftp服务器</h3><p>选中文件目录，提供文件上传、下载服务</p><h3 id="Packet-Tracer"><a href="#Packet-Tracer" class="headerlink" title="Packet Tracer"></a>Packet Tracer</h3><ol><li>集线器与交换机区别<br>集线器就是做转发，集线器网络容易出网络风暴<br>交换机有路由，可以做寻址等</li><li><p>arp<br>arp攻击：修改arp表，将所有的ip都指向攻击者，然后收到后进行篡改<br>arp就是寻址，根据ip去寻找mac地址，然后记录在本地的arp列表中</p></li><li><p>路由器作用</p><ul><li>连通不同的网络：<br>路由器相当于双网卡，一段连一个网络。一个网络中，需要设置一个网关。如果是同一网段，路由器直接发送个给对应机器，不同网段，则直接发送给网关<br>不同网络通信时，显示主机广播自己，然后寻址网关的的mac地址，网关返回后，主机将arp层的目的mac写为网关，ip当然还是要连接的另一网络的ip</li><li>路由寻址<br>多台路由器时，需要有路由表，仿真期间，用的是静态路由表，每个arp都根据路由表传递给下一个ip，返回下一个路由的mac地址，记录在前一个路由器中，这样，在发送imcp时，路由器根据需要，改写目的mac即可。</li></ul></li><li><p>Http<br>http包被tcp包含。前边握手包，后边结束包</p></li></ol><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="mycat"><a href="#mycat" class="headerlink" title="mycat"></a>mycat</h3><p>都是关系型数据库，就是在多个关系型数据库（尤其是mysql）上搭建的中间件，搭建成关系型数据库集群。<br>其实类似于zookeeper</p><h3 id="python下mysql的使用"><a href="#python下mysql的使用" class="headerlink" title="python下mysql的使用"></a>python下mysql的使用</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>pip3 install PyMySQL</p><h4 id="Connection对象"><a href="#Connection对象" class="headerlink" title="Connection对象"></a>Connection对象</h4><ul><li>建立与数据库的连接</li><li>创建对象，调用connect()方法<br>host:主机名，数据库名，用户名，密码，端口默认3306(oracle是1521)，参数charset默认’gb2312’</li><li>方法<br>close()关闭<br>commit()提交<br>rollback()回滚<br>cursor()游标</li></ul><h4 id="Cursor对象"><a href="#Cursor对象" class="headerlink" title="Cursor对象"></a>Cursor对象</h4><ul><li>执行sql语句</li><li>创建对象，Connection对象的cursor()方法<br>cursor = conn.cursor</li><li>方法<br>excute(operation[,parameters])<br>fetchone()<br>next()<br>fetchall()</li></ul><h4 id="实例-8"><a href="#实例-8" class="headerlink" title="实例"></a>实例</h4><p>import pymysql<br>connection = pymysql.connect(“localhost”,”root”,”sun12358”,”pythondb”)<br>cursor = connection.cursor()<br>cursor.execute(“select * from emp”)<br>rl = cursor.fetchall()</p><p>cursor.close()<br>connection.close()</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li><p>日期字符转换<br>datetime.datetime.strftime(emp[4 ], “%Y-%M-%D”)<br>emp[4].strftime(“%Y{y}%m{m}%d{d}”).format(y=’年’,m=’月’,d=’日’)</p></li><li><p>sql注入：select * from dept where depton &gt; 18 or 1=1<br>where后边的传参一定要注意</p></li></ul><h1 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h1><h2 id="基本语句"><a href="#基本语句" class="headerlink" title="基本语句"></a>基本语句</h2><h3 id="xxx-xxx-xxx"><a href="#xxx-xxx-xxx" class="headerlink" title="xxx, _xxx, __xxx"></a><strong>xxx</strong>, _xxx, __xxx</h3><pre><code>_xxx 不能用’from module import *’导入  （相当于protected） __xxx__ 系统定义名字   (系统内置的，比如关键字)__xxx 类中的私有变量名  （privated），所以更加不能使用from module import进行导入了,可以通过 _类名_xxx来访问。</code></pre><h3 id="上下文管理器with"><a href="#上下文管理器with" class="headerlink" title="上下文管理器with:"></a>上下文管理器with:</h3><p>  上下文管理器（Context Manager）：支持上下文管理协议的对象，这种对象实现了<strong>enter</strong>() 和 <strong>exit</strong>() 方法。上下文管理器定义执行 with 语句时要建立的运行时上下文，负责执行 with 语句块上下文中的进入与退出操作。通常使用 with 语句调用上下文管理器，也可以通过直接调用其方法来使用。</p><p>   with 语句的语法格式<br>   with context_expression [as target(s)]:<br>       with-body<br>   这里 context_expression 要返回一个上下文管理器对象，该对象并不赋值给 as 子句中的 target(s) ，如果指定了 as 子句的话，会将上下文管理器的 <strong>enter</strong>() 方法的返回值赋值给 target(s)。target(s) 可以是单个变量，或者由“()”括起来的元组（不能是仅仅由“,”分隔的变量列表，必须加“()”）</p><h3 id="调试："><a href="#调试：" class="headerlink" title="调试："></a>调试：</h3><p>  　- 执行时调试<br> 　　python -m pdb some.py<br> 　　只用这种就行<br> 　 -m 指的是module， 像脚本一样运行模块</p><pre><code>- 交互调试</code></pre><p>  　import pdb<br>  　pdb.run(‘testfun(args)’)</p><p>  　- 程序下断点<br> 　 import pdb<br> 　 pdb.set_trace()<br> 　 运行到这之后停住，使用与gdb类似，p打印，n单步，s进入函数，c继续执行，</p><h2 id="基本模块"><a href="#基本模块" class="headerlink" title="基本模块"></a>基本模块</h2><ul><li><p>re<br>主要2种用法：<br>re.find(r’\d[4-5]\s\d{1,2}’,’aetbert’ )</p><p>patten = re.compile(r’\b[a-zA-Z]{3}\b’)<br>patten.findall(x)</p><p>个数：<br>   +*? {}<br>范围：<br>  [a-z]<br>语法糖：<br>  \b \w \s \d<br>界定符：<br>  ^ $</p></li></ul><h2 id="语言特色"><a href="#语言特色" class="headerlink" title="语言特色"></a>语言特色</h2><h3 id="C-C内存管理"><a href="#C-C内存管理" class="headerlink" title="C++/C内存管理"></a>C++/C内存管理</h3><p>一个由C/C++编译的程序占用的内存分为以下几个部分：<br>1、栈区（stack）—  由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。<br>2、堆区（heap） —  一般由程序员分配释放，若程序员不释放，程序结束时可能由OS（操作系统）回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。<br>3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。<br>4、文字常量区  —常量字符串就是放在这里的。程序结束后由系统释放。<br>5、程序代码区—存放函数体的二进制代码。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要包括：闭包与装饰器，内存管理，常用的模块介绍，pdb调试，进程及线程，python网络(tcp/udp/select/poll)，数据库等&lt;br&gt;
    
    </summary>
    
      <category term="语言" scheme="http://yoursite.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python基础</title>
    <link href="http://yoursite.com/2018/07/25/python%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/07/25/python基础/</id>
    <published>2018-07-25T02:00:00.000Z</published>
    <updated>2018-07-30T01:52:29.112Z</updated>
    
    <content type="html"><![CDATA[<p>本文包括：语法、变量、运算、函数、文件、类与对象、枚举、异常<br><a id="more"></a></p><h1 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用python3.6.1<br>yum install zlib-devel bzip2-devel openssl-devel ncurese-devel gcczlib</p><p>OpenStack-云计算</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul><li>for/while<br>while/for也可以跟else，意思是for循环结束之后执行，break会跳过else<br>for  :<br>  if  :<pre><code>break</code></pre>else :</li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><img src="1.python中对象分类.png" alt=""></p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>分为堆内存、栈内存。堆中放具体的数据，栈中放引用</p><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><ul><li>数值类型Numeric<br>布尔型True<br>浮点<br>整形</li><li>空值<br>None，在堆内存中也有值</li></ul><h3 id="字符串String"><a href="#字符串String" class="headerlink" title="字符串String"></a>字符串String</h3><p>  单双引号都可以”bus”，’bus’<br>  name=”abcdef” #就是字符串数组</p><p>  print(name[0])<br>  还可以从右往左数,-1是起始位置<br>  print(name[-1])</p><ul><li><p>切片[起始位置:结束位置:步长]，切片属于顺序型数据的共同用法，list,tuple<br>包头不包尾</p></li><li><p>find()<br> my_str = “hello world”<br> my_str.find(“world”)<br> 找不到返回-1</p></li><li><p>index()<br> my_str.index(“world”)<br> 找不到返回错误</p></li><li><p>join()<br> 合并2字符串</p></li><li>count()<br> 出现的次数</li><li><p>replace()<br> 替代字符串中某段</p></li><li><p>split()<br>与Java中相同，返回一个List<br>若不指定，会将所有的隔开符都隔开</p></li><li><p>partition()<br>也是切割，将形参中的字符串，隔离出来</p></li><li>capitalize()<br>字符串首字母</li><li>title()<br>字符串每个word的首字母大写</li><li>upper()</li><li><p>lower()</p></li><li><p>startwith()</p></li><li><p>endswith()<br>判断开头与结尾</p></li><li><p>ljust(50)</p></li><li>rjust(50)</li><li><p>center(50)<br>对齐</p></li><li><p>rstrip</p></li><li>lstrip</li><li><p>strip<br>删除空格</p></li><li><p>isalpha<br>都是字某返回true</p></li><li>isdigit<br>都是数字</li><li>isalnum<br>字母或者数字</li><li><p>isspace<br>只包含空格</p></li><li><p>join<br>列表转字符串<br>names=[‘1’,’2’,’’3]<br>“”.join(names)<br>“.”.join(names)：笛卡尔积</p></li></ul><h3 id="list列表"><a href="#list列表" class="headerlink" title="list列表[]"></a>list列表[]</h3><p>list<br>names=[]</p><ul><li>增<br>append<br>  在最后追加<br>extend<br>  两个列表的合并<br>insert<br>  任意位置插入</li><li>修改<br>name[2]=’888’</li><li>查<br>in/not in 关键字<br>  判断是否有或者没有<br>index(元素)<br>  返回元素的下标位<br>count<br>  统计元素在</li><li><p>删<br>del<br>  删除某个位置上的元素<br>  del a[2]<br>remove<br>  删除具体的内容<br>  a.remove<br>pop<br>  拿出最后一个数据</p></li><li><p>排序<br>sort()<br>  默认是升序<br>  sort(reverse=True)：降序<br>reverse()<br>  a.reverse()<br>  a就倒叙了<br>  a[-1::-1]<br>  返回a的倒叙，但a不会倒叙a=[-1::-1]可以<br>  ::是一直到的意思</p><ul><li>range<br>c=rang(1,10),lazy的在操作元素时，才会创建<br>c是一个列表</li></ul></li></ul><h3 id="tuple元组"><a href="#tuple元组" class="headerlink" title="tuple元组()"></a>tuple元组()</h3><p>元祖与列表类似，不同之处在于元组里的数据不能修改，元组使用(),列表使用[]</p><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>my_str=(‘aa’,’bb’,’cc’)</p><h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><p>my_str[0]  ‘aa’<br>count<br>index</p><h4 id="可变类型："><a href="#可变类型：" class="headerlink" title="可变类型："></a>可变类型：</h4><ul><li>可变类型：list</li><li>不可变类型:数值，字符串，元组<br>声明好之后，长度固定，不能修改其中的元素，不能追加<br>元组中的列表元素可以修改<br><img src="2.元组.png" alt=""></li></ul><h3 id="dict字典-map"><a href="#dict字典-map" class="headerlink" title="dict字典{} = map"></a>dict字典{} = map</h3><p>d = {“michael”:95,”bob”:75,”tracy”:85}</p><ul><li><p>访问<br>d.get(‘bob’)：键不存在，返回None<br>d[‘bob’]：键不存在，报错<br>d[‘john’]=’78’</p></li><li><p>删<br>del stus[‘bob’]<br>del stus<br>stus.pop(‘bob’)<br>内存立即回收，stus就不存在了<br>d.clear()<br>d还存在，元素不在了</p></li><li><p>函数lens(),keys(),values(),items()</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">stu=&#123;&quot;name&quot;:&quot;laowang&quot;,&quot;age&quot;:33&#125;</span><br><span class="line"></span><br><span class="line">for k in stu.keys():</span><br><span class="line">        print(k)</span><br><span class="line"></span><br><span class="line">for v in stu.values():</span><br><span class="line">        print(v)</span><br><span class="line"></span><br><span class="line">for item in stu.items():</span><br><span class="line">        print(&quot;key为:%s,value为:%s&quot;%item)</span><br><span class="line">items()是元组</span><br></pre></td></tr></table></figure><pre><code>&quot;name&quot; in stu 返回True            </code></pre><ul><li>key值需要可以hash<br>a=[1,2,4]<br>b={a:”test”}  #此时是不可以的<br>可以认为，可变类型不能作为key</li></ul><h3 id="set集合"><a href="#set集合" class="headerlink" title="set集合{}"></a>set集合{}</h3><p>a={1,3}<br>print a=set()是空集合</p><ul><li>增add</li><li>删pop</li><li>改</li><li>查</li></ul><h3 id="相互转化"><a href="#相互转化" class="headerlink" title="相互转化"></a>相互转化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;1,2,3,4,4,4,4&#125;</span><br><span class="line">l = list(a)  #l是列表</span><br><span class="line">s = set(l)   #s是集合</span><br><span class="line">t = tuple(s) #t是元组</span><br></pre></td></tr></table></figure><h3 id="可变类型与不可变类型"><a href="#可变类型与不可变类型" class="headerlink" title="可变类型与不可变类型"></a>可变类型与不可变类型</h3><ul><li><p>不可变类型:数值，字符串，元组<br>a=’abc’<br>a.replace(“a”,’A’)，它返回一个Abc，但a还是abc<br>id(a) 打印a执行的内存地址<br>声明好之后，长度固定，不能修改其中的元素，不能追加</p></li><li><p>可变类型：list，字典<br>可变类型就是在原址上可以增加修改的类型</p></li><li><p>总结</p><ol><li><p>变量与对象<br>变量：python可以认为都是引用<br>对象：对象有类型的差异，并且有具体的内存地址，是内存里具体的东西</p></li><li><p>赋值<br>python的赋值有2种：一种是引用的指向，二种是创建一个对象<br>直接一个变量等于另一个变量，都是引用的指向修改，不会创建对象<br>不可改变类型，重新赋值时，会创建新的对象。</p></li><li><p>传参<br>传参都是引用的指向，不会创建对象</p></li><li><p>python的缓存:见下面的内存管理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = 256</span><br><span class="line">b = 256</span><br><span class="line">a is b #True</span><br><span class="line"></span><br><span class="line">c = 257</span><br><span class="line">d = 257</span><br><span class="line">c is d #False</span><br></pre></td></tr></table></figure></li></ol></li></ul><pre><code>python会缓存一些小的对象，比如数值与小的字符串，于是出现以上的情况</code></pre><ul><li><p>案例</p><ol><li>元组中的列表元素可以修改<br><img src="2.元组.png" alt=""></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a=[1,2]</span><br><span class="line">b=a</span><br><span class="line">b+=[3,4]</span><br><span class="line">#这时候a也是[1,2,3,4]</span><br><span class="line"></span><br><span class="line">def test(num):</span><br><span class="line">  num+=num</span><br><span class="line">  print(num)</span><br><span class="line"></span><br><span class="line">#a=10   ：数值是不可变类型，在num+=num时，会重新开辟空间使num重新指向</span><br><span class="line">#a=[10] ：[]可变类型，在num+=num时，在原用的内存修改</span><br><span class="line">test(a)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure></li></ul><h3 id="基本类型转换"><a href="#基本类型转换" class="headerlink" title="基本类型转换"></a>基本类型转换</h3><p>整数字符串转换为对应的整数<br>int(‘12’)</p><p>小数字符串转换为对应小数<br>float(‘12.34’)</p><p>数字转换为字符串<br>str(123.45)</p><p>ASCII码转换为相应字符<br>chr(97)</p><p>字符转换为响应ASCII码<br>ord(‘a’)</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="dict-pair"><a href="#dict-pair" class="headerlink" title="dict = pair"></a>dict = pair</h4><p>map中可以放很多数据，而中仅能放一条<br>[{},{}]这种结构还差不多</p><h4 id="python是一种弱类型语言，"><a href="#python是一种弱类型语言，" class="headerlink" title="python是一种弱类型语言，"></a>python是一种弱类型语言，</h4><p>{“name”:’sun’,”age”:18}，name与age其实是结构</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="命名空间（namespace）"><a href="#命名空间（namespace）" class="headerlink" title="命名空间（namespace）"></a>命名空间（namespace）</h3><h3 id="全局变量与局部变量"><a href="#全局变量与局部变量" class="headerlink" title="全局变量与局部变量"></a>全局变量与局部变量</h3><ul><li>LEGB: locals &gt; enclosing fuction(闭包) &gt; globals &gt; builtins(内建)<br>在函数内部要使用global时,需要声明:global a<br>globals()函数可以看全局的属性<br>locals()函数,可以看到局部的属性<br>dir(<strong>builtin</strong>)<h2 id="和-is"><a href="#和-is" class="headerlink" title="== 和 is"></a>== 和 is</h2>is是比较两个引用是否指向了统一对象(引用比较) 或者说地址比较<br>== 是比较两个对象是否相等（值比较）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = [1,2,3]</span><br><span class="line">b = a</span><br><span class="line"></span><br><span class="line">a == b #True</span><br><span class="line">a is b #True</span><br><span class="line"></span><br><span class="line">c = a[:] 或者 c=list(a)</span><br><span class="line">a == c #True</span><br><span class="line">a is c #False</span><br></pre></td></tr></table></figure><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><h3 id="进制、位运算"><a href="#进制、位运算" class="headerlink" title="进制、位运算"></a>进制、位运算</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int(o, 8) =  10 #把8转换为八进制的10</span><br><span class="line">int(h, 16) = 10</span><br><span class="line">bin(5) = &apos;0b101&apos;</span><br><span class="line">bin(-5) = &apos;=0b101&apos;</span><br></pre></td></tr></table></figure><p>位与&amp;<br>位或|<br>位异或^<br>取反~<br>左移&lt;&lt;<br>右移&gt;&gt;</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>表达式或者关键字没有(),且有：<br>函数才有()</p><h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><p><img src="3.内置函数.png" alt=""></p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def print_hello():</span><br><span class="line">    print(&quot;人生苦短，我要学python&quot;)</span><br><span class="line"></span><br><span class="line">def test(r):</span><br><span class="line">    s=3.14*(r**2)</span><br><span class="line">    print(s)</span><br><span class="line"></span><br><span class="line">def sum_2num(a,b):</span><br><span class="line">    if not isinstance((a,b),(int,float)) #是否为int或者浮点数(int,float)是个数组</span><br><span class="line">        print(&quot;请输入正确的字符类型&quot;)</span><br><span class="line">        return</span><br><span class="line">    return a+b</span><br><span class="line"></span><br><span class="line">def create():</span><br><span class="line">    a=1</span><br><span class="line">    b=3</span><br><span class="line">    return a,b</span><br><span class="line">x,y=create()</span><br><span class="line">z=create()  #z是元组</span><br></pre></td></tr></table></figure><p>看到def后会加载函数，并不会执行</p><h3 id="全局变量与局部变量-1"><a href="#全局变量与局部变量-1" class="headerlink" title="全局变量与局部变量"></a>全局变量与局部变量</h3><p>作用域与C语言相同即，全局变量可以在函数内获取并修改<br>修改不可变类型的引用，global</p><h3 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def test(x,y,*args):</span><br><span class="line">  print(x,y)</span><br><span class="line">  print(args)</span><br></pre></td></tr></table></figure><p>不定长参数是以元组的方式传入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def test(x,y, **kwarg):</span><br><span class="line">    print(x,y)</span><br><span class="line">    print(kwarg)</span><br></pre></td></tr></table></figure><p>此时候的不定参数是键值对</p><h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><h3 id="匿名函数lambda"><a href="#匿名函数lambda" class="headerlink" title="匿名函数lambda"></a>匿名函数lambda</h3><ul><li><p>lambda [arg1[,agr2…agrn]]:表达式<br>sum = lambda x,y:x+y<br>print(sum(22,45))</p></li><li><p>缺点不能简单的操作，因为函数体只能是表达式</p></li><li><p>lambda可以作为实参传递给函数</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def test(a,b,func):</span><br><span class="line">          result = func(a,b)</span><br><span class="line">          return result</span><br><span class="line">    </span><br><span class="line">print(test(23,33,lambda x,y:x*y))</span><br></pre></td></tr></table></figure><p>  感觉像是懒加载，以及lambda也是一个引用，定义在栈上</p><ul><li>dict排序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stus=[&#123;&quot;name&quot;:&quot;zs&quot;,&quot;age&quot;:12&#125;,&#123;&quot;name&quot;:&quot;ls&quot;,&quot;age&quot;:14&#125;]</span><br><span class="line">stus.sort(key=lambda x:x[&quot;name&quot;]) #返回类表中每个元素name的value</span><br><span class="line">print(stus)</span><br></pre></td></tr></table></figure><ul><li>动态语言：用户可以随意变化表达式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def test1(a,b,func):</span><br><span class="line">          return func(a,b)</span><br><span class="line">function = eval(input(&quot;请输入表达式:&quot;))  #eval可以将输入的字符串，转变为表达式</span><br><span class="line">print(test1(4,5,function))</span><br></pre></td></tr></table></figure><h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><p>a=1<br>b=3</p><p>#借用元组来实现的<br>a,b=b,a</p><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>与C语言类似<br>f = open(“test.txt”,’w’)<br>r/w/a<br>r+打开一个文件用于读写，文件指针在开头<br>w+读写，如果文件已存在就将其覆盖，否则就创建<br>a+读写，不创建，文件指针在最后。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">f.close()</span><br><span class="line">f.write(&quot;abcd&quot;)</span><br><span class="line"></span><br><span class="line">f.read()/f.read(6)：看参数</span><br><span class="line">f.readline()读取一行：一行一行读</span><br><span class="line"></span><br><span class="line">f.tell()返回文件指针位置</span><br><span class="line">f.seek(offset,from) form：0-文件开头，1当前位置，2文件末尾</span><br><span class="line">  f.seek(0,0)文件开头</span><br></pre></td></tr></table></figure><h3 id="文件夹"><a href="#文件夹" class="headerlink" title="文件夹"></a>文件夹</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">file_list=os.listdir(&quot;test/&quot;)</span><br><span class="line">for f in file_list</span><br><span class="line">   print(f)</span><br></pre></td></tr></table></figure><p> <img src="4.文件操作.png" alt=""></p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="从指定目录下，找包含有hello的py文件"><a href="#从指定目录下，找包含有hello的py文件" class="headerlink" title="从指定目录下，找包含有hello的py文件"></a>从指定目录下，找包含有hello的py文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">file_list=[]</span><br><span class="line">def find_hello(parent_dir,file_name):</span><br><span class="line">    file_abspath=os.path.join(parent_dir,file_name)</span><br><span class="line">    if os.path.isdir(file_abspath):</span><br><span class="line">        for f in os.listdir(file_abspath):</span><br><span class="line">           find_hello(file_abspath,f)</span><br><span class="line">    else:</span><br><span class="line">        if dir.endswith(&quot;.py&quot;):</span><br><span class="line">           if read_and_find_hello(file_abspath): #判断内容中是否有hello</span><br><span class="line">                file_list.append(file_abspath)</span><br><span class="line"></span><br><span class="line">def read_and_find_hello(file):</span><br><span class="line">   f = open(file,&quot;r&quot;)</span><br><span class="line">   while True:</span><br><span class="line">      line=f.readline()</span><br><span class="line">      if line==&quot;&quot;:</span><br><span class="line">         break</span><br><span class="line">      elif &quot;hello&quot; in line</span><br><span class="line">        f.close()</span><br><span class="line">        retrun True</span><br><span class="line">   else:</span><br><span class="line">      f.close()</span><br><span class="line">      return False</span><br><span class="line"></span><br><span class="line">find_hello(&quot;/home/&quot;,&quot;python&quot;)</span><br><span class="line">print(file_list)</span><br></pre></td></tr></table></figure><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><p>class 类名：<br>    属性<br>    方法列表<br>方法第一参数一定是self<br>对象名 = 类名()</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>使用上与C++/Jave相同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Car:</span><br><span class="line">         def start(self):</span><br><span class="line">                 print(&quot;汽车启动&quot;)</span><br><span class="line"> </span><br><span class="line">         def print_info(self):</span><br><span class="line">                 print(&quot;汽车名字%s,颜色%s&quot;%(self.name,self.color))</span><br><span class="line"></span><br><span class="line">car1= Car()</span><br><span class="line">car1.name=&quot;凯迪拉克&quot;</span><br><span class="line">car1.color=&quot;白色&quot;</span><br><span class="line">car1.start()</span><br><span class="line">car1.print_info()</span><br></pre></td></tr></table></figure><h3 id="不同"><a href="#不同" class="headerlink" title="不同"></a>不同</h3><p>  属性上很另类<br>  而且有self:self其实与this有些类似</p><h3 id="魔法方法xxx"><a href="#魔法方法xxx" class="headerlink" title="魔法方法xxx"></a>魔法方法<strong>xxx</strong></h3><h3 id="init-self"><a href="#init-self" class="headerlink" title="init(self)"></a><strong>init</strong>(self)</h3><p>类于构造函数，但构造函数是构造时，init是构造之后初始化的时候</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def __init__(self):</span><br><span class="line">    self.name=&quot;zs&quot;</span><br><span class="line">    self.age=18</span><br><span class="line"></span><br><span class="line">def __init__(self,name,age,height):</span><br><span class="line">    self.name=name</span><br><span class="line">    self.age=age</span><br><span class="line">    self.heigtht=height</span><br></pre></td></tr></table></figure><p>初始化对象的方法，不是构造方法：<strong>new</strong>()构造对象–&gt;得到一对象–&gt;<strong>init</strong>(self)</p><h3 id="del-self"><a href="#del-self" class="headerlink" title="del(self)"></a><strong>del</strong>(self)</h3><p>当内存中释放一个对象时，调用<strong>del</strong>()方法<br>类似于析构函数<br>注意python中=，都是引用，但其引用可以重新指向</p><h3 id="str-self"><a href="#str-self" class="headerlink" title="str(self)"></a><strong>str</strong>(self)</h3><p>def <strong>str</strong>(self):<br>    return “string here”<br>类似与Java的toString方法</p><h3 id="new-cls"><a href="#new-cls" class="headerlink" title="new(cls):"></a><strong>new</strong>(cls):</h3><ul><li>必须有返回值，类的对象</li><li>如果不返回，对象不会构建，也就不会运行<strong>init</strong>方法<br>return object.<strong>new</strong>(cls)</li><li>与init区别<br>1.new是构造，init是初始化<br>2.new是类方法[可以通过类来调用]，init是普通方法<br>3.先执行new后执行init</li></ul><h3 id="掷骰子"><a href="#掷骰子" class="headerlink" title="掷骰子"></a>掷骰子</h3><ul><li>range()也是包头不包尾</li><li>random.randint(1,7)需要引入import random</li><li>思路<br>掷骰子游戏可以有多个人来玩，多个骰子在一个骰子钟里抛掷相加得到结果<br>Game与Play是聚合，Play个数可以指定<br>Game与Dices（骰子钟）是组合关系<br>Dices与Dice也是聚合关系，个数可以指定</li></ul><h3 id="私有化（隐藏）"><a href="#私有化（隐藏）" class="headerlink" title="私有化（隐藏）"></a>私有化（隐藏）</h3><p>属性：__xxx</p><p>方法：def __xxx():</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li><p>定义<br>class Animal:<br>class Dog(Animal):<br>在子类后加()，写入父类即可。有些像函数，不可混。</p></li><li><p>差异<br>子类的<strong>init()</strong>会覆盖掉父类的<strong>init()</strong><br>经测试<strong>new</strong>方法也会覆盖掉父类的<br><strong>new</strong>会覆盖掉<strong>init</strong><br>父类的公有属性，如果父类<strong>init</strong>方法没有调用，也就继承不了，也就是说：属性没有继承super().<strong>init</strong>()可以手动去实现</p></li><li><p>多继承<br>class C(A,B):<br>就是多继承，继承关系的优先级C&gt;A&gt;B</p></li><li><p>print(C.<strong>mro</strong>)可以打印继承关系<br>可以所有类看出从object中继承，这一点与Java相同<br>其中的<strong>init</strong>(),<strong>del</strong>()</p></li><li><p>重写<br>子类与父类的方法名相同就叫重写<br>super().<strong>init</strong>()<br>重写中，可以通过super()调用父类的方法</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3></li><li>python是弱类型语言，没有多态<h3 id="类属性（对象属性的区别）与类方法"><a href="#类属性（对象属性的区别）与类方法" class="headerlink" title="类属性（对象属性的区别）与类方法"></a>类属性（对象属性的区别）与类方法</h3></li><li>类属性是类对象所拥有的属性，它被类对象的实例所共有，在内存中之后一个副本</li><li>就是C++/Java的静态成员变量</li><li>定义</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class People(object):</span><br><span class="line">    name = &quot;Tom&quot; #共有类属性</span><br><span class="line">    __age = 12  #私有类属性</span><br><span class="line"></span><br><span class="line">print(People.name)</span><br><span class="line">p = People()</span><br><span class="line">print(p.name)</span><br></pre></td></tr></table></figure><ul><li><p>对象属性<br>就是对象自己的<br>self.name = name 这种</p></li><li><p>区别<br>类属性可以被子类继承，对象属性不能直接继承<br>继承仅是继承父类的方法，以及类属性<br>类属性只能通过类来修改：People.name = “ww”<br>  当时有p.name = “zs”定义了一个对象属性name</p></li><li><p>类方法<br>一定要在类上加一个修饰器（注解）<br>@classmethod<br>def getName(cls):<br>其中cls代表调用这个方法的类<br>类方法可以通过类名来调用People.getName()<br>类方法可以修改类属性     </p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>@staticmethod<br>静态方法是类方法的特殊一种，属于类，没有默认传递的参数<br>@staticmethod<br>def getAge():</p></li></ul><p>调用与类方法相同：对象与类都可以调用<br>由于没有cls，只能通过类名在修改类属性</p><h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><p>1.伪单例：自己写getInstance()静态方法，通过调用此方法来获得对象<br>2.真单例：重写<strong>new</strong>方法，所有的构造的都是单例</p><h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><p>这个简单工厂就是用一个factory类的一个类方法，来生成继承关系的不同子类对象。<br><img src="5.工厂方法.png" alt=""></p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from enum import Enum</span><br><span class="line"></span><br><span class="line">class Color(Enum):</span><br><span class="line">   red = 1</span><br><span class="line">   green = 2</span><br><span class="line">   blue = 3</span><br></pre></td></tr></table></figure><h2 id="类的数据隐藏"><a href="#类的数据隐藏" class="headerlink" title="类的数据隐藏"></a>类的数据隐藏</h2><p><strong>x双下划线，属性私有，实现方法名字重整：</strong>num，在类dir(t)时，会改变私有对象的名字:_类名<strong>属性名，其实并没有真正的隐藏，只是外部的访问上改了名字<br>_x单下划线，被当作模块导入时，不导入。外边是可以访问的</strong>xx__:名字空间的魔法属性:<strong>init</strong></p><p>self这里不是关键字，第一个代表对象本身，可以用this等来代替</p><h3 id="property用法"><a href="#property用法" class="headerlink" title="property用法"></a>property用法</h3><ul><li>使用property方法升级getter 与 setter</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Test:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.__money=0</span><br><span class="line"></span><br><span class="line">    def getMoney(self):</span><br><span class="line">        return self.__money</span><br><span class="line"></span><br><span class="line">    def setMoney(self,money)</span><br><span class="line">        self.__money=money</span><br><span class="line"></span><br><span class="line">    money = property(getMoney,setMoney)</span><br><span class="line"></span><br><span class="line">test=Test()</span><br><span class="line">test.money=20</span><br></pre></td></tr></table></figure><p>#这种写法就把money变成共有不就好了</p><ul><li>装饰器写法<br>@property  : getter<br>@money.setter  : setter<br>方法名与属性名的去掉__一致</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Test:</span><br><span class="line">   def __init__(self):</span><br><span class="line">        self.__money=0</span><br><span class="line">   </span><br><span class="line">   @property  #getter</span><br><span class="line">   def money(self):</span><br><span class="line">       return self.__money</span><br><span class="line"></span><br><span class="line">   @money.setter</span><br><span class="line">   def money(this,money)</span><br><span class="line">       this.__money = money</span><br><span class="line"></span><br><span class="line">t = Test()</span><br><span class="line">t.money = 20</span><br><span class="line">print(r.money)</span><br></pre></td></tr></table></figure><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><p>try..except，except就是catch<br>Exception/NameError/FileNotFoundError/ZeroDivisionError<br>except可以用元组来实现多个异常<br>as ex，ex是异常变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">  print(a)</span><br><span class="line">except (NameError/ZeroDivisionError) as ex:</span><br><span class="line">  print(ex)</span><br><span class="line">else:</span><br><span class="line">  print(&quot;没有异常&quot;)</span><br><span class="line">finally:</span><br><span class="line">  print(&quot;无论有没有都能被执行&quot;)</span><br></pre></td></tr></table></figure><p>抛异常：raise exception</p><p>异常嵌套，异常传递</p><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>class PasswordException(Exception):</p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><ul><li>模块相当于jar包</li><li>import 即可<h2 id="模块与包"><a href="#模块与包" class="headerlink" title="模块与包"></a>模块与包</h2>相当于jar包<h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3></li><li><p>import 模块名<br>模块名.函数名()</p><p>import random<br>random.randint(1,5)</p></li><li><p>from 模块名 import 函数名(变量，类等)<br>from random import randint<br>randint(1,5)</p></li><li><p>from 模块 import *【几乎不用】<br>一个模块全部内容都导入</p></li><li><p>as 导入时，给模块重新命名<br>import random as rdm<br>rdm.randint(1,5)<br>random__file__</p></li><li><p>注意<br>若导入有相同的函数名，后导入的会覆盖先导入的</p></li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><strong>name</strong>:<strong>main</strong>()<br>if(<strong>name</strong>==”<strong>main</strong>“):#python解释器主动执行该模块代码为了测试<br>    print(isnull(“”))</p><p><strong>all</strong>：后边加列表，用于写出模块中需要导出的方法/变量/类，但这种方式只有from ..import *时可用，在python3中，使用较少<br><strong>all</strong>=[“isnull”]</p><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>本质上就是一个目录，把模块放入目录中，就可称为一个包<br>优先到当前目录，然后是python系统目录<br>  import 包(文件夹).模块(文件)<br>  from 包 import 模块</p><p>python3中目录就是一个包<br>python2中需要有<strong>init</strong>.py文件,即使是空文件也可以<br>如果在<strong>init</strong>.py中增加from . import module1，那么在其他中可以直接import包名</p><p>这里的import类似于c/c++的include</p><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>把自己写的模块，发布到python的系统目录下</p><ul><li>setup.py<br>在包同级目录下增加setup.py文件，并写</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from distutils.core import setup</span><br><span class="line">setup(name=&quot;my_packet&quot;,version=&quot;1.0&quot;,description=&quot;描述&quot;,author=&quot;作者&quot;,py_modules=[&quot;my_packet.module1&quot;])</span><br></pre></td></tr></table></figure><ul><li>python3 setup.py build</li><li>python3 setup.py sdist<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3></li><li>找到模块安装包</li><li>解压</li><li>进入文件夹</li><li>执行python3 setup.py install即可</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h3><p> import sys<br> sys.argv<br>  参数第一个是.py本身<br> sys.argv[1::]</p><h3 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h3><p>其实就是创建列表/字典的<br>a=[i for i in range(1,10)]<br>a=[i**i for i in range(1,10)]</p><p>b=[x for x in range(1,3) for y in range(0,2)]<br>[1,1,2,2] 循环的嵌套1循环2次，2也也是2次</p><p>c=[x for x in range(1,101) if x%2==1]</p><h3 id="传参-1"><a href="#传参-1" class="headerlink" title="传参"></a>传参</h3><p><img src="6.习题.png" alt=""><br><img src="6.习题解释.png" alt=""><br>其实即使函数的默认参数只会创建一次,因为它懒</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文包括：语法、变量、运算、函数、文件、类与对象、枚举、异常&lt;br&gt;
    
    </summary>
    
      <category term="语言" scheme="http://yoursite.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>redis基础</title>
    <link href="http://yoursite.com/2018/07/21/redis/"/>
    <id>http://yoursite.com/2018/07/21/redis/</id>
    <published>2018-07-21T04:00:00.000Z</published>
    <updated>2018-10-22T08:29:32.016Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍redis的基础，包括redis的数据结构，发布订阅，事务，数据持久化，主从结构等内容。<br>本文是学习《redis实战》整理的博客。<br><a id="more"></a></p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>redis存储的本身就是key:value形式的数据，所说的数据结构，指的是value的结构。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>key: string<br><img src="字符串类型.png" alt=""></p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ul><li>基本操作</li></ul><table><thead><tr><th>命令</th><th style="text-align:center">行为</th><th style="text-align:right">使用</th></tr></thead><tbody><tr><td>set</td><td style="text-align:center">设置存储在给定key中的值</td><td style="text-align:right">set name sun</td></tr><tr><td>get</td><td style="text-align:center">获取存储在给定key中的值</td><td style="text-align:right">get name</td></tr><tr><td>del</td><td style="text-align:center">删除存储在给定key中的值</td><td style="text-align:right">del name</td></tr></tbody></table><ul><li>数值操作<br>其实这个不应该说字符串，因为它的value值可以是数值，包括整数与浮点数。</li></ul><table><thead><tr><th>命令</th><th style="text-align:center">行为</th><th style="text-align:right">使用</th></tr></thead><tbody><tr><td>incr</td><td style="text-align:center">将键对应的值+1</td><td style="text-align:right">incr age</td></tr><tr><td>decr</td><td style="text-align:center">将键对应的值-1</td><td style="text-align:right">decr age</td></tr><tr><td>incrby</td><td style="text-align:center">将键对应值+amount</td><td style="text-align:right">incrby age 10</td></tr><tr><td>decrby</td><td style="text-align:center">将键对应值-amount</td><td style="text-align:right">decrby age 10</td></tr><tr><td>incrbyfloat</td><td style="text-align:center">将键对应值加浮点amount</td><td style="text-align:right">incrbyfloat height 5.6</td></tr></tbody></table><p>  对一个不存在的键或者一个保存了空串的键执行自增或者自减操作，那么redis在执行操作时，会将这个键的值当作0来处理。如果对无法转换成数值的字符串进行操作，那么返回一个错误。</p><ul><li>字串操作</li></ul><table><thead><tr><th>命令</th><th style="text-align:center">行为</th><th style="text-align:right">使用</th></tr></thead><tbody><tr><td>append</td><td style="text-align:center">将value追加给定键的值的末尾</td><td style="text-align:right">append key value</td></tr><tr><td>getrange</td><td style="text-align:center">获取一个由偏移量start-end的字串</td><td style="text-align:right">getrange key start end</td></tr><tr><td>setrange</td><td style="text-align:center">将从offset偏移量设置为定值</td><td style="text-align:right">setrange key offset value</td></tr><tr><td>getbit</td><td style="text-align:center">将字符串堪称二进制位串，返回offset的二进制</td><td style="text-align:right">getbit key offset</td></tr><tr><td>setbit</td><td style="text-align:center">将offset的二进制设为value</td><td style="text-align:right">setbit key offset value</td></tr><tr><td>bitcount</td><td style="text-align:center">统计二进制位串中1的数量</td><td style="text-align:right">bitcount key [start end]</td></tr><tr><td>bitop</td><td style="text-align:center">按位操作，包括and/or/xor/not</td><td style="text-align:right">bitop operation dest-key key-name</td></tr></tbody></table><p>  个人而言这些操作并没有什么用</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p>key：list<br><img src="列表类型.png" alt=""><br>这个列表可以认为是双向的队列，左边与右边都能push与pop</p><h3 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h3><ul><li>基本操作</li></ul><table><thead><tr><th>命令</th><th style="text-align:center">行为</th><th style="text-align:right">使用</th></tr></thead><tbody><tr><td>rpush</td><td style="text-align:center">将value推入列表右端</td><td style="text-align:right">rpush students wang</td></tr><tr><td>lpush</td><td style="text-align:center">将value推入列表的左端</td><td style="text-align:right">lpush students liu</td></tr><tr><td>rpop</td><td style="text-align:center">从右端弹出一个值，并返回此值</td><td style="text-align:right">rpop students</td></tr><tr><td>lpop</td><td style="text-align:center">从左端弹出一个值，并返回此值</td><td style="text-align:right">lpop students</td></tr><tr><td>lrange</td><td style="text-align:center">从左端切片</td><td style="text-align:right">lrange students 0 -1</td></tr><tr><td>lindex</td><td style="text-align:center">左端的下标操作</td><td style="text-align:right">lindex students 1</td></tr><tr><td>ltrim</td><td style="text-align:center">对列表进行剪裁，只保留start-end</td><td style="text-align:right">ltrim students 2 -1</td></tr></tbody></table><ul><li>阻塞操作</li></ul><table><thead><tr><th>命令</th><th style="text-align:center">行为</th><th style="text-align:right">使用</th></tr></thead><tbody><tr><td>blpop</td><td style="text-align:center">从第一个非空类表中弹出元素，或者为空在timeout内阻塞</td><td style="text-align:right">blpop key1 [key2…] timeout</td></tr><tr><td>brpop</td><td style="text-align:center">右端的阻塞pop</td><td style="text-align:right">brpop key1 [key2..] timeout</td></tr><tr><td>rpoplpush</td><td style="text-align:center">从source-key列表弹出元素，然后推入dest-key的左端</td><td style="text-align:right">rpoplpush source-key dest-key</td></tr><tr><td>brpoplpush</td><td style="text-align:center">阻塞的brpoplbush</td><td style="text-align:right">brpoplpush source-key dest-key timeout</td></tr></tbody></table><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h3><p>key: set<br><img src="集合类型.png" alt=""></p><h3 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a>操作</h3><ul><li>基本操作</li></ul><table><thead><tr><th>命令</th><th style="text-align:center">行为</th><th style="text-align:right">使用</th></tr></thead><tbody><tr><td>sadd</td><td style="text-align:center">往集合中添加元素</td><td style="text-align:right">sadd family father</td></tr><tr><td>smembers</td><td style="text-align:center">返回所有元素</td><td style="text-align:right">smembers family</td></tr><tr><td>sismember</td><td style="text-align:center">检测给定元素是否在集合中</td><td style="text-align:right">sismember family mother</td></tr><tr><td>srem</td><td style="text-align:center">如果元素在，则移除</td><td style="text-align:right">srem family thief</td></tr><tr><td>scard</td><td style="text-align:center">返回集合包括的元素数量</td><td style="text-align:right">scard family</td></tr><tr><td>srandmember</td><td style="text-align:center">从集合中随机返回一个或多个元素</td><td style="text-align:right">srandmember key [count]</td></tr><tr><td>spop</td><td style="text-align:center">随机移除一个元素，并返回</td><td style="text-align:right">spop key</td></tr><tr><td>smove</td><td style="text-align:center">如果一个移动到另一个</td><td style="text-align:right">smove source-key dest-key item</td></tr></tbody></table><ul><li>集合操作</li></ul><table><thead><tr><th>命令</th><th style="text-align:center">行为</th><th style="text-align:right">使用</th></tr></thead><tbody><tr><td>sinter</td><td style="text-align:center">两个集合取交集</td><td style="text-align:right">sinter family1 family2</td></tr><tr><td>sunion</td><td style="text-align:center">两个集合取并集</td><td style="text-align:right">sunion family1 family2</td></tr><tr><td>sdiff</td><td style="text-align:center">两个集合取差集</td><td style="text-align:right">sdiff family1 family2</td></tr><tr><td>sinterstore</td><td style="text-align:center">交集然后存储到另一集合</td><td style="text-align:right">sinterstore dest-key key1 [key2..]</td></tr><tr><td>sunionstore</td><td style="text-align:center">并集然后转存到另一集合</td><td style="text-align:right">suninstore dest-key key1 [key2..]</td></tr><tr><td>sdiffstore</td><td style="text-align:center">差集然后转存到另一集合</td><td style="text-align:right">sdiffstore dest-key key1 [key2..]</td></tr></tbody></table><h2 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h2><h3 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h3><p>key：hash(Map)<br><img src="散列类型.png" alt=""><br>散列类型其实就是字典类型</p><h3 id="操作-3"><a href="#操作-3" class="headerlink" title="操作"></a>操作</h3><ul><li>基本操作</li></ul><table><thead><tr><th>命令</th><th style="text-align:center">行为</th><th style="text-align:right">使用</th></tr></thead><tbody><tr><td>hset</td><td style="text-align:center">添加键值对</td><td style="text-align:right">hset family father yanfeng</td></tr><tr><td>hget</td><td style="text-align:center">获取指定键的值</td><td style="text-align:right">hget family father</td></tr><tr><td>hgetall</td><td style="text-align:center">获取所有键值对</td><td style="text-align:right">hgetall family</td></tr><tr><td>hdel</td><td style="text-align:center">如果键存在则删除</td><td style="text-align:right">hdel family father</td></tr><tr><td>hlen</td><td style="text-align:center">返回键值对数量</td><td style="text-align:right">hlen key</td></tr></tbody></table><ul><li>其他操作</li></ul><table><thead><tr><th>命令</th><th style="text-align:center">行为</th><th style="text-align:right">使用</th></tr></thead><tbody><tr><td>hexists</td><td style="text-align:center">检查键是否存在</td><td style="text-align:right">hexists family father</td></tr><tr><td>hkeys</td><td style="text-align:center">获取散列包含的所有键</td><td style="text-align:right">hkeys family</td></tr><tr><td>hvals</td><td style="text-align:center">获取散列包含的所有值</td><td style="text-align:right">kvals family</td></tr><tr><td>hincrby</td><td style="text-align:center">与incrby类似</td><td style="text-align:right">hincrby course english 10</td></tr><tr><td>hincrbyfloat</td><td style="text-align:center">与incrbyfloat类似</td><td style="text-align:right">hincrbyfloat height wang 5.4</td></tr></tbody></table><h2 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h2><h3 id="结构-4"><a href="#结构-4" class="headerlink" title="结构"></a>结构</h3><p>key: zset<br><img src="有序集合.png" alt=""><br>有序集合是一种特殊的散列，它能通过value值排序</p><h3 id="操作-4"><a href="#操作-4" class="headerlink" title="操作"></a>操作</h3><ul><li>基本操作</li></ul><table><thead><tr><th>命令</th><th style="text-align:center">行为</th><th style="text-align:right">使用</th></tr></thead><tbody><tr><td>zadd</td><td style="text-align:center">将给定分值的成员添加到有序集合</td><td style="text-align:right">zadd enScore 98 sun   [96 wang]</td></tr><tr><td>zrem</td><td style="text-align:center">如果元素存在则删除</td><td style="text-align:right">zrem enScore sun [wang]</td></tr><tr><td>zincrby</td><td style="text-align:center">同incrby</td><td style="text-align:right">zincry enScore 1 sun</td></tr><tr><td>zrange</td><td style="text-align:center">切片</td><td style="text-align:right">zrange enScore 0 -1 [withscores]</td></tr><tr><td>zrangebyscore</td><td style="text-align:center">获取在给定分值范围内的所有元素</td><td style="text-align:right">zrangebyscore enScore 90 100 [withsores]</td></tr><tr><td>zcount</td><td style="text-align:center">获取在给定分值范围内的元素数量</td><td style="text-align:right">zcount enScore 90 100</td></tr><tr><td>zcard</td><td style="text-align:center">返回包含的元素数量</td><td style="text-align:right">zcard enScore</td></tr><tr><td>zscore</td><td style="text-align:center">返回member的分数</td><td style="text-align:right">zrank enScore sun</td></tr><tr><td>zrank</td><td style="text-align:center">返回成员的排名</td><td style="text-align:right">zrank enScore sun</td></tr></tbody></table><ul><li>其他操作</li></ul><table><thead><tr><th>命令</th><th style="text-align:center">行为</th><th style="text-align:right">使用</th></tr></thead><tbody><tr><td>zrevrank</td><td style="text-align:center">返回成员member的排名，由大到小</td><td style="text-align:right">zrevrank enScore sun</td></tr><tr><td>zrevrange</td><td style="text-align:center">同zrange,由大到小</td><td style="text-align:right">zrevrange enScore 0 -1 [withscores]</td></tr><tr><td>zrevrangebyscore</td><td style="text-align:center">同zrangebyscore，由大到小</td><td style="text-align:right">zrevrangebyscore enScore 90 100 [with scores]</td></tr><tr><td>zremrangebyrank</td><td style="text-align:center">移除排名start-end间元素</td><td style="text-align:right">zremrangebyrank enScore 10 20</td></tr><tr><td>zremrangebyscore</td><td style="text-align:center">移除分值介于min-max间的元素</td><td style="text-align:right">zremrangebyscore enScore 90 100</td></tr><tr><td>zinterstore</td><td style="text-align:center">同sinterstore，执行的是+</td><td style="text-align:right">zinterstore dest-key  key1 [key2..]</td></tr><tr><td>zunionstore</td><td style="text-align:center">同sunionstore，执行的是min</td><td style="text-align:right">zunionstore dest-key  key1 [key2..]</td></tr></tbody></table><p>  zinterstore<br>  <img src="zinterstore.png" alt=""></p><p> zuninstore<br>  <img src="zunionstore.png" alt=""></p><h2 id="键的过期时间"><a href="#键的过期时间" class="headerlink" title="键的过期时间"></a>键的过期时间</h2><table><thead><tr><th>命令</th><th style="text-align:center">示例</th><th style="text-align:right">描述</th></tr></thead><tbody><tr><td>expire</td><td style="text-align:center">expire key seconds</td><td style="text-align:right">让键在指定seconds秒后过期</td></tr><tr><td>expireat</td><td style="text-align:center">expireat key timestamp</td><td style="text-align:right">让键在指定时间戳过期</td></tr><tr><td>pexpire</td><td style="text-align:center">pexpire key milliseconds</td><td style="text-align:right">让键在指定milliseconds毫秒后过期</td></tr><tr><td>pexpireat</td><td style="text-align:center">pexpireat key timestamp</td><td style="text-align:right">让键在指定的毫秒级时间戳上过期</td></tr><tr><td>ttl</td><td style="text-align:center">ttl key</td><td style="text-align:right">查看给定键距离过期还有多少秒</td></tr><tr><td>pttl</td><td style="text-align:center">pttl key</td><td style="text-align:right">查看给定键距离过期时间有多少毫秒</td></tr></tbody></table><h1 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h1><p>发送者向频道发送二进制字符串消息。每当有消息被发送至频道时，频道的所有订阅者都会收到消息。<br>使用上发布订阅用于在不同进程之间传递数据。</p><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><table><thead><tr><th>命令</th><th style="text-align:center">用例</th><th style="text-align:right">描述</th></tr></thead><tbody><tr><td>SUBSCRIBE</td><td style="text-align:center">SUBSCRIBE CHANNEL1 [CHANNEL2]</td><td style="text-align:right">订阅给定的一个或多个频道</td></tr><tr><td>UNSUBSCRIBE</td><td style="text-align:center">UNSUBSCRIBE [CHANNEL1 [CHANNEL2]]</td><td style="text-align:right">退订给定频道或全部频道</td></tr><tr><td>PSUBSCIBE</td><td style="text-align:center">PSUBSCIBE PATTERN1 [PATTERN2]</td><td style="text-align:right">订阅与模式匹配的所有频道</td></tr><tr><td>punsubscibe</td><td style="text-align:center">punsubscibe pattern1 [pattern2]</td><td style="text-align:right">退订与模式匹配的所有频道</td></tr><tr><td>publish</td><td style="text-align:center">publish channel message</td><td style="text-align:right">向给定频道发送消息</td></tr></tbody></table><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>发布订阅会存在2个问题:</p><ul><li><p>redis系统的稳定性<br>如果客户端订阅某个频道,但读取消息的速度很慢,那么会使redis输出缓冲区越来越大,这导致redis数度变慢,甚至直接崩溃.<br>此问题与redis版本有关,新版本会控制输出缓冲区的大小,过慢就会断开订阅</p></li><li><p>数据传输的可靠性<br>客户端在执行订阅操作的过程中断线,会使其丢失在断线期间的所有消息.<br>这个会可以在后边去处理.</p></li></ul><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="multi-exec"><a href="#multi-exec" class="headerlink" title="multi/exec"></a>multi/exec</h2><p>和关系数据库那种可以在执行过程中进行回滚的事物不同.在Redis中，被multi和exec命令包围的所有命令会一个接一个执行，直到所有命令都执行完毕为止。直到一个事务执行完毕之后，Redis才会处理其他客户端的命令。<br>当Redis从一个客户端接受到multi命令时，Reis会将这个客户端之后发送的所有命令都放到一个队列中，直到这个客户端发送exec命令为止，然后redis在不被打断的情况下，一个接一个的执行队列中的命令。</p><h1 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>redis提供了两种不同的持久化方法。<br>一种叫快照(snapshotting)，它可以将存在于某一时刻的所有数据都写到硬盘里。<br>另一种叫追加(append-only file)AOF,它会在执行命令写命令时，将被执行的写命令复制到硬盘里。（类似与oracle的重写日志）</p><p>持久化一方面可以防止系统而将数据备份到另一个远程位置，另一方面也是将长时间运算的结果保留下来（类似与spark的图运算）</p><p><img src="redis持久化选项.png" alt=""></p><h2 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h2><ul><li><p>快照存储位置<br>快照被写入DBFILENAME选项指定的文件里，并存在DIR选项指定的路径上。</p></li><li><p>创建快照方法</p><ul><li><p>客户端可以向REDIS发送BGSAVE命令来创建一个快照。<br>REDIS会调用FORK来创建一个子进程，负责将快照写入硬盘，而父进程继续处理命令【所有WINDOWS不支持】</p></li><li><p>客户端可以向REDIS发送SAVE命令来创建快照。<br>REDIS服务接到SAVE命令在快照创建完毕之前，不再相应其他命令，也就是单线程完成的。</p></li><li><p>设置了SAVE选项<br>SAVE 60 10000。从REDIS最近一次创建快照开始算，当满足60秒内有10000次写入，REDIS自动触发BGSAVE</p></li><li><p>关闭<br>当REDIS通过SHUTDOWN命令接收到关闭服务器的请求时，或者TERM信号时，会执行一个SAVE命令。</p></li><li><p>同步<br>当一个REDIS服务连接到另一个REDIS服务，并向对方发送SYNC命令开始一次复制操作的时候</p></li></ul></li></ul><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><ul><li><p>APPENDONLY<br>通过将APPENDONLY YES选项来打开，简单说AOF持久化会将被执行的写命令写到AOF文件末尾，以此来记录数据发生的变化。因此，REDIS只要从头到尾执行一次AOF文件所包括的写命令，就可以恢复。</p></li><li><p>APPENDFSYNC配置</p><p>| 选项     | 同步频率                 |<br>| - | -: |<br>| ALWAYS   | 每个写命令都立即写入硬盘 |<br>| EVERYSEC | 每秒执行一次写           |<br>| NO       | 让操作系统来决定何时写   |</p><p>对应NO选项，如果磁盘处理写的操作不快，当缓冲区被顶戴写入硬盘的数据填满时，REDIS写操作会被阻塞，并导致REDIS处理命令请求速度变慢。一般不用NO</p></li><li><p>BGREWRITEAOF<br>对于AOF，一些情况下AOF文件会不断的增大，这时，用户可以向REDIS发送BGREWRITEAOF命令。这个命令会通过移除AOF文件中冗余命令来重写AOF，以减小它。<br>BGREWRITEAOF原理跟BGSAVE类似：REDIS会创建一个子进程，然后有子进程负责AOF文件的重写。<br>可以通过AUTO-AOF-REWRITE-PERCENTAGE选项与AUTO-AOF-REWRITE-MIN-SIZE选项来自动执行BGREWRITEAOF。例如设置AUTO-AOF-REWRITE-PERCENTAGE 100 AUTO-AOF-REWITE-MIN-SIZE 64M当AOF文件的大于64MB并且AOF的体积比上一次重写之后的体积大至少（100%）1倍时候，REDIS执行。 </p></li></ul><h1 id="集群结构"><a href="#集群结构" class="headerlink" title="集群结构"></a>集群结构</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>关系型数据库通常会使用一个主服务器向多个从服务器发送更新，并使用从服务器来处理所有读请求，来增加扩展。redis也采用相同的方法来实现自己的复制特性，并作为扩展性能的一种手段。</p><h2 id="主辅同步"><a href="#主辅同步" class="headerlink" title="主辅同步"></a>主辅同步</h2><ul><li><p>开启<br>开启从服务的必须选项只有slaveof一个。当redis服务启动时，指定一个包括slaveof host port选项的配置，那么redis会根据配置来连接主服务器。<br>对已一个正财运行的redis服务器，可以通过发送SLAVEOF no one /SLAVEOF host port来终止或者开启从服务。</p></li><li><p>过程<br><img src="从服务连接主服务的步骤.png" alt=""><br>从服务在进行同步时，会清空自己的所有数据。<br>redis不支持主主复制</p></li></ul><h2 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h2><ul><li><p>主从链<br>主服务和从服务并没有特别不同之处，所以从服务也可以拥有自己的从服务，并由此形成了主从链。<br><img src="主从链.png" alt=""></p></li><li><p>检验硬盘写入<br>为了验证主服务是否已经将写数据发送到从服务，用户需要向主服务写入真正数据之后，再向主服务写入一个唯一的虚构值（哨兵），然后通过检查虚构值是否存在来判断写数据是否已经到达从服务。<br>检查数据是否保存到硬盘要困难多。检查info命令的输出结果中aof_pending_bio_fsync属性的值是否为0，如果是，则表明服务器已经将所有已知数据保存到硬盘上了。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍redis的基础，包括redis的数据结构，发布订阅，事务，数据持久化，主从结构等内容。&lt;br&gt;本文是学习《redis实战》整理的博客。&lt;br&gt;
    
    </summary>
    
      <category term="数据存储" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Mongo基础</title>
    <link href="http://yoursite.com/2018/07/18/mongo%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/07/18/mongo基础/</id>
    <published>2018-07-18T04:00:00.000Z</published>
    <updated>2018-11-28T11:38:16.438Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客从船长那摘抄，原始位置：<a href="https://github.com/zxhyJack/MyBlog/blob/master/mongodb/mongodb.md" target="_blank" rel="noopener">Jack博客链接</a></p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul><li>MongoDB 是一个基于分布式文件存储的数据库</li><li>属于NoSQL数据库，是介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的</li><li>旨在为WEB应用提供可扩展的高性能数据存储解决方案</li><li><p>数据结构： 键值对（key-value），类似JSON对象</p><pre><code>{  name：&apos;Paul&apos;,  age:21,  gender:&apos;man&apos;}</code></pre></li></ul><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><ul><li><p>创建</p><pre><code>use database_name</code></pre></li></ul><p>如果数据库存在，则进入指定数据库，否则，创建数据库<br>此时需要写入数据，数据库才能真正创建成功</p><ul><li><p>查看所有数据库</p><pre><code>show databases | dbs</code></pre></li><li><p>创建集合</p><pre><code>db.createCollection(collection_name)固定集合所谓的固定集合指的是规定集合大小，如果要保存的内容已经超过了集合的长度，那么会采用LRU的算法（最近最少使用原则）将最早的数据移出，从而保存新的数据。范例：创建一个空集合（固定集合）db.createCollection(&quot;depts&quot;, {&quot;capped&quot;: true, &quot;size&quot;: 1024, &quot;max&quot;: 5})其中“capped :true”表示为一个固定集合，而“size:1024”指的是集合所占的空间容量（字节）、“max : 5”最多只能够有五条记录。</code></pre></li><li><p>删除数据库<br>先进入要删除的数据库，然后执行命令</p><pre><code>db.dropDatabase()</code></pre></li><li><p>删除集合</p><pre><code>db.collection_name.drop()</code></pre></li></ul><h2 id="数据表操作"><a href="#数据表操作" class="headerlink" title="数据表操作"></a>数据表操作</h2><ul><li><p>增</p><pre><code>db.collection_name.insert(document)</code></pre></li><li><p>查</p><ul><li><p>db.collection.find(<query>,<projection>)<br>query: 查询条件<br>projection: 投影操作</projection></query></p></li><li><p>db.students.find({name:/张/i})<br>模糊查询：在进行信息查询的时候，不设置条件永远要比设置条件的查询快很多</p></li><li><p>db.students.count()<br>对于集合的数据量而言，在MongoDB里面直接使用count()函数就可以完成了</p></li></ul></li></ul><ul><li><p>改</p><pre><code>db.collection.updateOne(&lt;query&gt;,&lt;update&gt;) // 更新第一个符合条件的集合db.collection.updateMany(&lt;query&gt;,&lt;update&gt;)  // 更新所有符合条件的集合- query: 查询条件- update： 更新的内容</code></pre></li><li><p>删</p><pre><code>db.collection_name.deleteOne(&lt;query&gt;) // 删除第一个符合条件的集合db.collection_name.deleteMany(&lt;query&gt;) // 删除所有符合条件的集合</code></pre></li></ul><h2 id="runCommand"><a href="#runCommand" class="headerlink" title="runCommand"></a>runCommand</h2><p> 在MongoDB数据库里面，除了一些支持的操作函数之外，还有一个重要的命令：runCommand()，这个函数可以执行所有的特定的MongoDB命令（最底层的函数）。</p><p> 范例：利用runCommand()实现信息查询<br>        db.shop.runCommand({‘geoNear’:’shop’,near:[10,10],maxDistance:5,num:3})<br> 这类的命令可以说是MongoDB之中最为基础的命令。</p><p>  消除重复数据<br>        范例：查询所有name的信息<br>        db.students.runCommand({‘distinct’:’students’,’key’:’name’})<br>        本次的操作没有直接的函数支持，只能够利用runCommand()函数。</p><h1 id="数据操作（重点）"><a href="#数据操作（重点）" class="headerlink" title="数据操作（重点）"></a>数据操作（重点）</h1><p>数据库的核心——CRUD，增加和删除较为简单，查询和修改较复杂</p><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><ul><li><p>$gt 大于</p></li><li><p>$lt 小于</p></li><li><p>$gte  大于等于</p></li><li><p>$lte  小于等于</p></li><li><p>$eq | (key: value)  等于</p></li><li><p>$ne 不等于</p></li></ul><p>先往数据库中添加一些数据</p><pre><code>db.students.insert({&apos;name&apos;:&apos;张三&apos;,&apos;sex&apos;:&apos;男&apos;,&apos;age&apos;:19,&apos;score&apos;: 89,&apos;address&apos;: &apos;海淀区&apos;})db.students.insert({&apos;name&apos;:&apos;李四&apos;,&apos;sex&apos;:&apos;女&apos;,&apos;age&apos;:20,&apos;score&apos;: 100,&apos;address&apos;: &apos;朝阳区&apos;})db.students.insert({&apos;name&apos;:&apos;王五&apos;,&apos;sex&apos;:&apos;男&apos;,&apos;age&apos;:22,&apos;score&apos;: 50,&apos;address&apos;: &apos;西城区&apos;})db.students.insert({&apos;name&apos;:&apos;赵六&apos;,&apos;sex&apos;:&apos;女&apos;,&apos;age&apos;:21,&apos;score&apos;: 60,&apos;address&apos;: &apos;东城区&apos;})</code></pre><p>exp:</p><ol><li><p>查询姓名是张三的学生信息</p><pre><code>db.students.find({name:’张三’}).pretty()</code></pre></li><li><p>查询年龄大于19岁的学生</p><pre><code>db.students.find({age:{$gt:19}}).pretty()</code></pre></li><li><p>查询成绩大于等于60分的学生</p><pre><code>db.students.find({score:{$gte:60}}).pretty() </code></pre></li></ol><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ul><li><p><code>$and</code>   与</p></li><li><p><code>$or</code>   或</p></li><li><p><code>$not | $nor</code>  非</p></li></ul><p>exp:</p><ol><li><p>查询年龄在19 ~ 22岁的学生信息</p><pre><code>db.students.find({age:{$gte:19,$lte:22}}).pretty()</code></pre></li></ol><p>逻辑运算中与连接是最容易的，只需要利用<code>,</code>分割多个条件即可</p><ol start="2"><li><p>查询年龄小于20岁，或者成绩大于90分的学生信息</p><pre><code>db.students.find({$or:    [     {age:{$lt:20}},    {score:{$gt:90}}    ]}).pretty()</code></pre></li><li><p>查询年龄大于等于20岁，且成绩小于等于90分的学生信息</p><pre><code>db.students.find({$and:    [     {age:{$gte:20}},    {score:{$lte:90}}    ]}).pretty()</code></pre></li></ol><h3 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h3><p>$in: 在范围之中<br>$nin: 不在范围之中</p><p>exp:</p><ol><li><p>查询姓名是”张三“、”李四、”王五“的学生</p><pre><code>db.students.find({name: {$in:[&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;]}}).pret ty()</code></pre></li><li><p>查询姓名不是”张三“、”李四、”王五“的学生</p><pre><code>db.students.find({name: {$nin:[&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;]}}).pretty()</code></pre></li></ol><h3 id="数组查询"><a href="#数组查询" class="headerlink" title="数组查询"></a>数组查询</h3><ul><li><p>$all </p></li><li><p>$size </p></li><li><p>$slice </p></li><li><p>$elemMatch</p></li></ul><p>首先在数据库中新增一些数据</p><pre><code>db.students.insert({name:&apos;a&apos;,sex:&apos;男&apos;,age:19,score:89,address:&apos;海淀区&apos;,course:[&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;,&apos;音乐&apos;,&apos;政治&apos;]})db.students.insert({name:&apos;b&apos;,sex:&apos;男&apos;,age:19,score:89,address:&apos;海淀区&apos;,course:[&apos;语文&apos;,&apos;数学&apos;]})db.students.insert({name:&apos;c&apos;,sex:&apos;男&apos;,age:19,score:89,address:&apos;海淀区&apos;,course:[&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;]})db.students.insert({name:&apos;d&apos;,sex:&apos;男&apos;,age:19,score:89,address:&apos;海淀区&apos;,course:[&apos;英语&apos;,&apos;音乐&apos;,&apos;政治&apos;]})db.students.insert({name:&apos;e&apos;,sex:&apos;男&apos;,age:19,score:89,address:&apos;海淀区&apos;,course:[&apos;语文&apos;,&apos;政治&apos;]})</code></pre><p><code>$all</code>: 表示全都包括，用法：</p><pre><code>{$all:[内容1,内容2]}</code></pre><p>exp:</p><p>查询同时参加语文和数学的学生</p><pre><code>db.students.find({course:{$all:[&apos;语文&apos;,&apos;数学&apos;]}}).pretty()</code></pre><p>数组的操作，可以利用索引，使用<code>key.index</code>的方式来定义索引</p><p>查询数组中第二个内容是数学的学生(sh)</p><pre><code>db.students.find({&apos;course.1&apos;:&apos;数学&apos;}).pretty()</code></pre><p><code>$size</code>: 控制数组元素数量</p><p>exp:</p><p>查询只有两门课程的学生</p><pre><code>db.students.find({course:{$size: 2}}).pretty()</code></pre><p><code>$slice</code>: 控制查询结果的返回数量</p><p>exp:</p><p>查询年龄是19岁的学生，要求之显示两门参加的课程</p><pre><code>db.students.find({age:19},{course:{$slice:2}}).pretty()</code></pre><p>此时查询返回的是前两门课程，可以设置参数来取出想要的内容</p><pre><code>$slice:-2   //后两门$slice: [1,2]   // 第一个参数表示跳过的数据量，第二个参数表示返回的数据量</code></pre><h3 id="嵌套集合运算"><a href="#嵌套集合运算" class="headerlink" title="嵌套集合运算"></a>嵌套集合运算</h3><p>对象里面套对象</p><p>在数据库中新增数据</p><pre><code>db.students.insert({    name:&apos;A&apos;,sex:&apos;男&apos;,age:19,score:89,address:&apos;海淀区&apos;,    course:[&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;,&apos;音乐&apos;,&apos;政治&apos;],    parents:[        {name:&apos;A(father)&apos;,age:50,job:&apos;工人&apos;},        {name:&apos;A(mother)&apos;,age:50,job:&apos;职员&apos;}    ]})db.students.insert({    name:&apos;B&apos;,sex:&apos;男&apos;,age:19,score:89,address:&apos;海淀区&apos;,    course:[&apos;语文&apos;,&apos;数学&apos;],    parents:[        {name:&apos;B(father)&apos;,age:50,job:&apos;处长&apos;},        {name:&apos;B(mother)&apos;,age:50,job:&apos;局长&apos;}    ]})db.students.insert({    name:&apos;C&apos;,sex:&apos;男&apos;,age:19,score:89,address:&apos;海淀区&apos;,    course:[&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;],    parents:[        {name:&apos;C(father)&apos;,age:50,job:&apos;工人&apos;},        {name:&apos;C(mother)&apos;,age:50,job:&apos;局长&apos;}        ]})</code></pre><p>对于嵌套的集合中数据的判断只能通过<code>$elemMatch</code>完成</p><p>语法：<code>{ &lt;field&gt;: { $elemMatch: { &lt;query1&gt;, &lt;query2&gt;, ... } } }</code></p><p>exp:</p><p>查询父母中有人是局长的信息</p><pre><code>db.students.find({parents: {$elemMatch: {job: &apos;局长&apos;}}}).pretty()</code></pre><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p><code>sort({ field: value })</code> value是1表示升序，-1表示降序</p><p>exp:</p><p>学生信息按照分数降序排列</p><pre><code>db.students.find().sort({score:-1}).pretty()</code></pre><h3 id="分页显示"><a href="#分页显示" class="headerlink" title="分页显示"></a>分页显示</h3><p><code>skip(n)</code>: 跳过n条数据</p><p><code>limit(n)</code>: 返回n条数据</p><p>exp:</p><ol><li><p>分页显示，第一页，每页显示5条数据</p><pre><code>db.students.find({}).skip(0).limit(5).pretty()</code></pre></li><li><p>分页显示，第二页，每页显示5条数据</p><pre><code>db.students.find({}).skip(5).limit(5).pretty()</code></pre></li></ol><h3 id="判断某个字段是否存在"><a href="#判断某个字段是否存在" class="headerlink" title="判断某个字段是否存在"></a>判断某个字段是否存在</h3><p><code>{$exists:flag}</code>  flag为true表示存在，false表示不存在</p><p>exp:</p><ol><li><p>查询具有parents成员的学生</p><pre><code>db.students.find({parents:{$exists: true}}).pretty()</code></pre></li><li><p>查询不具有course成员的学生</p><pre><code>db.students.find({course: {$exists: false}}).pretty()</code></pre></li></ol><h3 id="取模"><a href="#取模" class="headerlink" title="取模"></a>取模</h3><p><code>$mod:[除数，余数]</code></p><p>exp: 查询年龄除以20余1的学生信息</p><pre><code>db.students.find({age:{$mod:[20,1]}}).pretty()</code></pre><h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p><code>updateOne()</code>     修改匹配的第一条数据</p><p><code>updateMany()</code>    修改所有匹配的数据</p><p>格式：<code>updateOne(&lt;filter&gt;,&lt;update&gt;)</code></p><h3 id="修改器"><a href="#修改器" class="headerlink" title="修改器"></a>修改器</h3><ul><li><code>$inc</code></li><li><code>$set</code></li><li><code>$unset</code></li><li><code>$push</code></li><li><code>$addToSet</code></li><li><code>$pop</code></li><li><code>$pull</code></li><li><code>$pullAll</code></li><li><code>$rename</code></li></ul><p><strong><code>$inc</code>：操作数字字段的数据内容</strong></p><p>语法: <code>{&quot;$inc&quot; : {成员 : 内容}}</code></p><p>exp: 将所有年龄为19岁的学生成绩一律减少30分，年龄增加1</p><pre><code>db.students.updateMany({age:19},{$inc:{score:-30,age:1}})</code></pre><p><strong><code>$set</code>：更新内容</strong></p><p>语法：<code>{$set: :{属性: 新内容}}</code></p><p>exp: 将20岁学生的成绩修改为89</p><pre><code>db.students.updateMany({age: 20},{$set: {score: 89}})</code></pre><p><strong><code>$unset</code>：删除某个属性及其内容</strong></p><p>语法：<code>{$unset: {属性: 1}}</code></p><p>exp:删除张三的年龄和成绩信息</p><pre><code>db.students.updateOne({name:&apos;张三&apos;},{$unset: {age: 1,score: 1}})</code></pre><p><strong><code>$push</code>：向数组中添加数据</strong></p><p>语法：<code>{$push: {属性: value}}</code></p><p>exp:在李四的课程中添加语文</p><pre><code>db.students.updateOne({name: &apos;李四&apos;},{$push: {course: &apos;语文&apos;}})</code></pre><p>如果需要向数组中添加多个数据，则需要用到<code>$each</code></p><p>exp: 在李四的课程中添加数学、英语</p><pre><code>db.students.updateOne(    {name:&apos;李四&apos;},    {$push:        {            course:{$each: [&apos;数学&apos;,&apos;英语&apos;]}        }    })</code></pre><p><strong><code>$addToSet</code>：向数组里面添加一个新的数据</strong></p><p>与<code>$push</code>的区别，<code>$push</code>添加的数据可能是重复的，<code>$addToSet</code>只有这个数据不存在时才会添加（去重）</p><p>语法：<code>{$addToSet: {属性：value}}</code></p><p>exp:王五新增一门舞蹈课程</p><pre><code>db.students.updateOne(    {name:&apos;王五&apos;},    {$addToSet: {course:&apos;舞蹈&apos;}})</code></pre><p><strong><code>$pop</code>：删除数组内的数据</strong></p><p>语法：<code>{$pop: {field: value}}</code>,value为-1表示删除第一个，value为1表示删除最后一个</p><p>exp:删除王五的第一个课程</p><pre><code>db.students.updateOne({name:&apos;王五&apos;},{$pop:{course:-1}})</code></pre><p>只是删除属性的内容，属性还在</p><p><strong><code>$pull</code>：从数组中删除一个指定内容的数据</strong></p><p>语法：<code>{$pull: {field：value}}</code> 进行数据比对，如果是该数据则删除</p><p>exp:删除李四的语文课程</p><pre><code>db.students.updateOne({name: &apos;李四&apos;},{$pull:{course:&apos;语文&apos;}})</code></pre><p><strong><code>$pullAll</code>：一次删除多个数据</strong></p><p>语法：<code>{$pullAll:{field:[value1,value2...]}}</code></p><p>exp:删除a的语文数学英语课程</p><pre><code>db.students.updateOne({name:&apos;a&apos;},{$pullAll:{course:[&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;]}})</code></pre><p><strong><code>$rename</code>：属性重命名</strong></p><p>语法： <code>{$rename: {旧属性名：新属性名}}</code></p><p>exp:把张三的name属性名改为姓名</p><pre><code>db.students.updateOne({name:&apos;张三&apos;},{$rename:{name:&apos;姓名&apos;}})</code></pre><h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><p>remove函数是有两个可选项：<br>·删除条件：满足条件的数据被删除；<br>·是否只删除一个数据，如果设置为true或者是1表示只删除一个</p><p>exp：删除所有姓名里面带有“谷”的信息，默认情况下会全部删除</p><pre><code>db.students.remove({name: /谷/})</code></pre><p>范例：删除姓名带有“高”的信息，要求只删除一个</p><pre><code>db.students.remove({name: /高/},true)</code></pre><h1 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h1><p>  所谓的游标就是指的数据可以一行行的进行操作，类似于关系型数据库处理。在MongoDB数据库里面对于游标的控制非常的简 单，只需要使用find()函数就可以返回游标了。对于返回的游标如果要想进行操作，使用两个函数。</p><p>  <code>hasNext()</code></p><p>  <code>next()</code></p><p>  相当于每一个数据都单独拿出来进行逐行的控制。当游标数据取出来之后，实际上每行数据返回的都是一个Object型的内容</p><p>  exp:</p><pre><code>var cursor = db.students.find()while(cursor.hasNext()){var student = cursor.next()print(student.name)printjson(student)}</code></pre><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>在任何的数据库之中，索引都是一种提升数据库检索性能的手段，这一点在MongoDB数据库之中同样是存在的，在MongoDB数据库里面依然会存在有两种的索引创建：是自动创建的，另外一种索引是手工创建的。</p><p>exp：重新准备一个新的简单集合</p><pre><code>db.students.drop()db.students.insert({&apos;name&apos;:&apos;张三&apos;,&apos;sex&apos;:&apos;男&apos;,&apos;age&apos;:19,&apos;score&apos;: 89,&apos;address&apos;: &apos;海淀区&apos;})db.students.insert({&apos;name&apos;:&apos;李四&apos;,&apos;sex&apos;:&apos;女&apos;,&apos;age&apos;:20,&apos;score&apos;: 100,&apos;address&apos;: &apos;朝阳区&apos;})db.students.insert({&apos;name&apos;:&apos;王五&apos;,&apos;sex&apos;:&apos;男&apos;,&apos;age&apos;:22,&apos;score&apos;: 50,&apos;address&apos;: &apos;西城区&apos;})</code></pre><p>  查询默认状态下的students集合的索引内容<br>        db.students.getIndexes()</p><p>  创建一个索引，在age字段上设置一个降序索引</p><pre><code>db.students.ensureIndex({‘age’:-1})</code></pre><p>  此时并没有设置索引的名字，所以名字是自动命名的。命名规范：“字段名称_索引的排序模式”。</p><p>  针对于当前的age字段上的索引做一个分析</p><pre><code>db.students.find({&apos;age&apos;:19}).explain()  </code></pre><p>  此时的查询使用了索引的技术</p><p>  针对于score字段上设置查询</p><pre><code>db.students.find({score:{$gt:60}}).explain()</code></pre><p>  此时在score字段上并没有设置索引，所以当前的索引形式就变为了全集合扫描的模式.</p><p>  复合索引：</p><pre><code>db.students.ensureIndex({age:1,score:-1},{name:&apos;age_1_score_1_index&apos;})</code></pre><p>  删除一个索引：</p><pre><code>db.students.dropIndex({age:1})</code></pre><p>  删除全部索引：</p><pre><code>db.students.dropIndexes()</code></pre><h2 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h2><p>唯一索引的主要目的是用在某一个字段上，使该字段的内容不重复.</p><p>创建唯一索引</p><pre><code>db.students.ensureIndex({name:1},{unique:true})</code></pre><p>此时若在name中添加重复数据，会报错。</p><h2 id="过期索引"><a href="#过期索引" class="headerlink" title="过期索引"></a>过期索引</h2><p>在一些程序站点会出现若干秒之后信息被删除的情况，例如：手机信息验证码，在MongoDB里面就可以轻松的实现过期索引，但是这个时间往往不怎么准确。必须要有时间，否则没法实现过期。</p><p>设置过期索引</p><pre><code>db.phones.ensureIndex({time:1},{expireAfterSeconds:10})</code></pre><p>如果要想实现过期索引，需要保存一个时间信息；</p><pre><code>db.phones.insert({tel:110,code:110,time:new Date()})db.phones.insert({tel:111,code:111,time:new Date()})</code></pre><h2 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h2><p>在一些信息管理平台上经常需要进行信息模糊查询，最早的时候是利用了某个字段上实现的模糊查询，但是这个时候返回的信息并不会很准确，因为只能够查A字段或者是B字段，而在MongoDB里面实现了非常简单的全文检索。</p><p>定义一个新的集合</p><pre><code>db.news.insert({&apos;title&apos;:&apos;gyh&apos;,content:&apos;sfq&apos;})db.news.insert({&apos;title&apos;:&apos;gyh&apos;,content:&apos;gry&apos;})db.news.insert({&apos;title&apos;:&apos;sfq&apos;,content:&apos;gry&apos;})</code></pre><p>设置全文检索</p><pre><code>db.news.ensureIndex({title:&apos;text&apos;,content:&apos;text&apos;})</code></pre><p>实现数据的模糊查询<br>如果要想表示出全文检索，则使用“$text”判断符，而要想进行数据的查询则使用“$search”运算符：</p><p>查询单个内容</p><pre><code>db.news.find({$text:{$search:&apos;gry&apos;}})</code></pre><p>包含有“gry”与“sfq”的信息</p><pre><code>db.news.find({$text:{$search:&apos;gry gyh&apos;}})</code></pre><p>同时包含有“mldn”与“lxh”的内容</p><pre><code>db.news.find({$text:{$search:&apos;\&apos;mldn\&apos; \&apos;lxh\&apos;&apos;}})</code></pre><p>在进行全文检索操作的时候还可以使用相似度的打分来判断检索成果。</p><pre><code>db.news.find({$text:{$search:&apos;gyh&apos;}},{‘score’:{$meta:&apos;textScore&apos;}})db.news.find({$text:{$search:&apos;gyh&apos;}},{‘score’:{$meta:&apos;textScore&apos;}}).sort({&apos;score&apos;:{$meta:&apos;textScore&apos;}})</code></pre><p>但是在这里面还有一个小问题，如果一个集合的字段太多了，那么每一个字段都分别设置全文检索麻烦点，所以简单一些，可以为所有的字段设置全文检索。<br>为所有字段设置全文检索</p><pre><code>db.news.ensureIndex({&apos;$**&apos;:&apos;text&apos;})</code></pre><h2 id="地理信息索引"><a href="#地理信息索引" class="headerlink" title="地理信息索引"></a>地理信息索引</h2><p>地理信息索引分为两类：2D平面索引，另外就是2DSphere球面索引。在2D索引里面基本上能够保存的信息都是坐标，而且坐标保存的就是经纬度坐标。</p><p>定义一个商铺的集合</p><pre><code>db.shop.insert({loc:[10,10]})db.shop.insert({loc:[11,10]})db.shop.insert({loc:[10,11]})</code></pre><p>为shop的集合定义2D索引<br>db.shop.ensureIndex({loc:’2d’})</p><p>这个时候shop集合就可以实现坐标位置的查询了，而要进行查询有两种查询方式：<br>·“$near”查询，查询距离某个点最近的坐标点；<br>·“$geoWithin”查询：查询某个形状内的点；</p><pre><code>db.shop.find({loc:{$near:[11,11]}})db.shop.find({loc:{$near:[11,11],$maxDistance:5}})</code></pre><p>但是需要注意一点，在2D索引里面虽然支持最大距离，但是不支持最小距离。<br>但是也可以设置一个查询的范围，使用“$geoWithin”查询，而可以设置的范围：<br>·矩形范围（$box）：{“$box”:[[x1,y1],[x2,y2]]}；<br>·圆形范围（$center）：{“$center” : [[x1,y1],r]}；<br>·多边型（$polygon）：{“$polygon” :[[x1,y1],[x2,y2][x3,y3] , …]}</p><p>查询矩形</p><pre><code>db.shop.find({loc:{$geoWithin:{$box:[[9,9],[12,12]]}}})</code></pre><p>查询圆形</p><pre><code>db.shop.find({loc:{$geoWithin:{$center:[[10,10],2]}}})</code></pre><p> 范例：利用runCommand()实现信息查询</p><pre><code>db.shop.runCommand({&apos;geoNear&apos;:&apos;shop&apos;,near:[10,10],maxDistance:5,num:3})</code></pre><p> 这类的命令可以说是MongoDB之中最为基础的命令。</p><h1 id="聚合-重点"><a href="#聚合-重点" class="headerlink" title="聚合(重点)"></a>聚合(重点)</h1><p>MongoDB的产生背景是在大数据环境，所谓的大数据实际上也就是进行的信息收集汇总。那么就必须存在有信息的统计操作，而这样的统计操作就称为聚合</p><p>MapReduce功能强大，但是它的复杂度和功能一样强大，那么很多时候我们需要MapReduce的功能，可是又不想把代码写的太复杂，所以从Mongo 2.x版本之后开始引入了聚合框架并且提供了聚合函数：aggregate()。</p><h2 id="group"><a href="#group" class="headerlink" title="$group"></a>$group</h2><p> group主要进行分组的数据操作。</p><ul><li><p>$sum</p><p>实现聚合查询的功能——求出每个职位的雇员人数</p><pre><code>db.emps.aggregate([{$group:{_id:&apos;$job&apos;,job_count:{$sum:1}}}])</code></pre><p>求出每个职位的总工资</p><pre><code>db.emps.aggregate([{$group:{_id:&apos;$job&apos;,job_sql:{$sum:&apos;$salary&apos;}}}])</code></pre></li><li><p>$avg</p><p>计算出每个职位的平均工资</p><pre><code>db.emps.aggregate([{$group:{_id:&apos;$job&apos;,job_avg:{$avg:&apos;$salary&apos;}}}])</code></pre></li><li><p>$max/$min</p><p>求出最高与最低工资</p><pre><code> db.emps.aggregate([{$group:{        _id:&apos;$job&apos;,        job_max:{$min:&apos;$salary&apos;},        job_min:{$min:&apos;$salary&apos;}}}])</code></pre></li><li><p>$push</p><p>计算出每个职位的工资数据（数组显示）</p><pre><code>db.emps.aggregate([{$group:        {_id:&apos;$job&apos;,        job_sal:{$push:&apos;$salary&apos;}}}])</code></pre></li><li><p>$addToSet</p><p>使用“$push”的确可以将数据变为数组进行保存，但是有一个问题出现了，重复的内容也会进行保存，那么在MongoDB里面提供有取消重复的设置。</p><pre><code> db.emps.aggregate([{$group:        {_id:&apos;$job&apos;,        job_sal:{$addToSet:&apos;$name&apos;}}}])</code></pre></li><li><p>$first/$last</p><p>保存第一个/最后一个内容</p><pre><code> db.emps.aggregate([{$group:        {_id:&apos;$job&apos;,        job_sal:{$first:&apos;$name&apos;}}}]) db.emps.aggregate([{$group:        {_id:&apos;$job&apos;,        job_sal:{$last:&apos;$name&apos;}}}])</code></pre></li></ul><h2 id="project（投影）"><a href="#project（投影）" class="headerlink" title="$project（投影）"></a>$project（投影）</h2><p>可以利用“$project”来控制数据列的显示规则，那么可以执行的规则如下：</p><pre><code>|- “_id”列（{&quot;_id&quot; : 0 | false}）：表示“_id”列是否显示；|- 普通列（{成员 : 1 | true}）：表示要显示的内容；|- 条件过滤列（{成员 : 表达式}）：满足表达式之后的数据可以进行显示。</code></pre><p>范例：只显示name、job列，不显示“_id”列</p><pre><code>db.emps.aggregate([        {$project:{_id:0, name:1, job:1}}])</code></pre><p>此时只有设置进去的列才可以被显示出来，而其它的列不能够被显示出来</p><p>实际上在进行数据投影的过程里面也支持四则运算：加法（“$add”）、减法（“$subtract”）、乘法（“$multiply”）、除法（“$divide”）、求模（$mod）。</p><p>范例：观察四则运算</p><pre><code>db.emps.aggregate([        {$project:{        _id:0,        name:1,        job:1,        salary:{&apos;年薪&apos;:{$multiply:[&apos;$salary&apos;,12]}}}}])</code></pre><p>除了算术运算之外也支持如下的各种运算符：这些操作一般会在$match中去使用，而不是在$project</p><p>·关系运算：大小比较（“$cmp”）、等于（“$eq”）、大于（“$gt”）、大于等于（“$gte”）、小于（“$lt”）、小于等于（“$lte”）、不等于（“$ne”）、判断NULL（“$ifNull”），这些返回的结果都是布尔型数据；</p><p>·逻辑运算：与（“$and”）、或（“$or”）、非（“$not”）；</p><p>·字符串操作：连接（“$concat”）、截取（“$substr”）、转小写（“$toLower”）、转大写（“$toUpper”）、不区分大小写比较（“$strcasecmp”）。</p><p>范例：查询职位是manager的信息。</p><pre><code>db.emps.aggregate([        {$project:{        _id:0,        name:1,        &apos;职位&apos;:&apos;$job&apos;,        job:{$eq:[&apos;$job&apos;,’manager’]}}}])</code></pre><p>范例：使用字符串截取</p><pre><code> db.emps.aggregate([        {$project:{        _id:0,        name:1,        &apos;职位&apos;:&apos;$job&apos;,        job:{&apos;job名称前三位字符&apos;:{$substr:[&apos;$job&apos;,0,3]}}}}])</code></pre><h2 id="match"><a href="#match" class="headerlink" title="$match"></a>$match</h2><p>“$match”是一个滤波操作，就是进行WHERE的过滤。<br>这个时候实现的代码严格来讲只是相当于“SELECT * FROM 表 WHERE 条件”，属于所有的内容都进行了查询。</p><p>范例：控制投影操作</p><pre><code>db.emps.aggregate([        {$match:{salary:{$gte:2000,$lte:5000}}},        {$project:{_id:0,name:1,salary:1}}])</code></pre><p>范例：继续分组<br>        db.emps.aggregate([<br>                {$match:{salary:{$gte:1000,$lte:10000}}},<br>                {$project:{_id:0,name:1,job:1,salary:1}},<br>                {$group:{_id:’$job’,count:{$sum:1},avg:{$avg:’$salary’}}}<br>        ])</p><h2 id="sort"><a href="#sort" class="headerlink" title="$sort"></a>$sort</h2><pre><code>db.emps.aggregate([        {$match:{salary:{$gte:1000,$lte:10000}}},        {$project:{_id:0,name:1,job:1,salary:1}},        {$group:{_id:’$job’,count:{$sum:1},avg:{$avg:’$salary’}}},        {$sort:{count:-1}}])</code></pre><h2 id="limit、-skip"><a href="#limit、-skip" class="headerlink" title="$limit、$skip"></a>$limit、$skip</h2><pre><code>db.emps.aggregate([        {$project:{_id:0,name:1,salary:1,job:1}},        {$skip:3},        {$limit:5}])</code></pre><h2 id="unwind"><a href="#unwind" class="headerlink" title="unwind"></a>unwind</h2><p>在查询数据的时候经常会返回数组信息，但是数组并不方便信息的浏览，所以提供有“$unwind”可以将数组数据变为独立的字符串内容。<br>范例：</p><pre><code>db.depts.insert({title:&apos;技术部&apos;,bus:[&apos;研发&apos;,&apos;生产&apos;,&apos;培训&apos;]})db.depts.insert({title:&apos;财务&apos;,bus:[&apos;工资&apos;,&apos;税收&apos;]})db.depts.aggregate([        {$project:{_id:0}},        {$unwind:&apos;$bus&apos;}])</code></pre><h2 id="geoNear"><a href="#geoNear" class="headerlink" title="$geoNear"></a>$geoNear</h2><p>范例</p><pre><code>db.shop.insert({loc:[10,10]})db.shop.insert({loc:[11,10]})db.shop.insert({loc:[10,11]}) db.shop.aggregate([        {$geoNear:{        &apos;near&apos;:[11,12],        &apos;distanceField&apos;:’loc’,        &apos;maxDistance&apos;:1,        &apos;num&apos;:2,        &apos;spherical&apos;:true}}])</code></pre><h2 id="out"><a href="#out" class="headerlink" title="$out"></a>$out</h2><p>$out”：利用此操作可以将查询结果输出到指定的集合里面。</p><pre><code> db.emps.aggregate([        {$project:{_id:0}},        {$out:&apos;emp_infos&apos;}])</code></pre><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><p>MapReduce是整个大数据的精髓所在（<em>实际中别用</em>），所谓的MapReduce就是分为两步处理数据：</p><p>· Map：将数据分别取出；</p><p>· Reduce：负责数据的最后的处理。</p><p>可是要想在MongoDB里面实现MapReduce处理，那么复杂度是相当高的。</p><p>范例：建立一组雇员数据</p><pre><code>db.emps.insert({name:&apos;zhangsan&apos;,age:30,sex:&apos;man&apos;,job:&apos;ClERK&apos;,salary:1000})db.emps.insert({name:&apos;lisi&apos;,age:28,sex:&apos;woman&apos;,job:&apos;ClERK&apos;,salary:5000})db.emps.insert({name:&apos;wangwu&apos;,age:26,sex:&apos;man&apos;,job:&apos;MANAGER&apos;,salary:6000})db.emps.insert({name:&apos;zhaoliu&apos;,age:32,sex:&apos;woman&apos;,job:&apos;MANAGER&apos;,salary:7000})db.emps.insert({name:&apos;sunqi&apos;,age:31,sex:&apos;man&apos;,job:&apos;ClERK&apos;,salary:2000})db.emps.insert({name:&apos;wangba&apos;,age:35,sex:&apos;woman&apos;,job:&apos;PRESIDENT&apos;,salary:9000})</code></pre><p>使用MapReduce操作最终会将处理结果保存在一个单独的集合里面，而最终的处理效果如下。</p><p>范例：按照职位分组，取得每个职位的人名<br>·编写分组的定义：</p><pre><code>var jobMapFun = function(){        emit(this.job,this.name)}</code></pre><p>第一组：{key:’CLERK’,values:[姓名,姓名…]}</p><p>·第二步：编写reduce操作；</p><pre><code>var jobReduceFun = function(key,values){        return {job:key,names:values}}</code></pre><p>·第三步：针对于MapReduce处理完成的数据实际上也可以执行一个最后处理。</p><pre><code> var jobFinalizeFun = function(key,values) {        if(key === &apos;PRESIDENT&apos;){                return {job:key,names:values,info:&apos;the boss&apos;}        }        return {job:key,names:values}}</code></pre><p>·进行操作的整合：<br>        db.runCommand({<br>                mapreduce:’emps’,<br>                map:jobMapFun,<br>                reduce:jobReduceFun,<br>                out:’t_job_emp’,<br>                finalize:jobFinalizeFun<br>        })</p><p>现在执行之后，所有的处理结果都保存在了“t_job_emp”集合里面。<br>        db.t_job_emp.find().pretty()</p><p>范例：统计出各性别的人数、平均工资、最低工资、雇员姓名</p><pre><code>var sexMapFun = function(){        // 定义好分组的条件，以及每个集合要取出的内容        emit(this.sex,{ccount:1,csal:this.salary,cmax:this.salary,cmin:this.salary,cname:this.name})}var sexReduceFun = function(key,values){        var total = 0      //统计        var sum = 0      // 计算总工资        var max = values[0]    //假设第一个数据是最高工资        var min = values[0]    //假设第一个数据是最低工资        var names = new Array()   //定义数组内容        for(var x in values) {    // 表示循环取出里面的内容                total += values[x].ccount // 人数增加                sum += values[x].csal     // 循环取出所有的工资，并且累加                if(max &lt; values[x]){                        max = values[x]                }                if(min &gt; values[x]){                        min = values[x]                }                names[x] = values[x].cname  // 保存姓名        }        var avg = (sum/total).toFixed(2)        // 返回数据的处理结果        return {count:total,avg:avg,sum:sum,max:max,min:min,names:names}}db.runCommand({mapreduce:&apos;emps&apos;,map:sexMapFun,reduce:sexReduceFun,out:&apos;t_sex_emp&apos;})**虽然大数据的时代提供有最强悍的MapReduce支持，但是从现实的开发来讲，真的不可能使用起来.**</code></pre><h2 id="mongofiles"><a href="#mongofiles" class="headerlink" title="mongofiles"></a>mongofiles</h2><p>在MongoDB里面支持大数据的存储（例如：图片、音乐、各种二进制数据），但是这个做法需要用户自己进行处理了，使用“mogofiles”命令完成。</p><p>1、 利用命令行进入到所在的路径下；<br>2、 mongofiles –port=27001 put photo.tif<br>3、 查看保存的文件；<br>        mongofiles –port=27001 list<br>4、 MongoDB里面有一个fs系统集合，这个集合默认保存在了test数据库下<br>        use test;<br>        db.fs.files.find()<br>5、删除文件<br>        mongofiles –port=27001 delete photo.tif</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇博客从船长那摘抄，原始位置：&lt;a href=&quot;https://github.com/zxhyJack/MyBlog/blob/master/mongodb/mongodb.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Jack博客链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据存储" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
    
      <category term="Mongo" scheme="http://yoursite.com/tags/Mongo/"/>
    
  </entry>
  
  <entry>
    <title>http协议基础</title>
    <link href="http://yoursite.com/2018/07/15/http%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/07/15/http协议基础/</id>
    <published>2018-07-15T01:00:00.000Z</published>
    <updated>2018-10-22T08:30:50.440Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍http的协议基础：主要包括报文的结构、请求的方法、url、状态码、header，以及http的连接</p><a id="more"></a><h1 id="报文协议基础"><a href="#报文协议基础" class="headerlink" title="报文协议基础"></a>报文协议基础</h1><h2 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h2><h3 id="起始行"><a href="#起始行" class="headerlink" title="起始行"></a>起始行</h3> <!-- ![test](/images/curiosity.jpg) --><p><img src="Http报文.png" alt="test"><br>如图：<br>请求报文起始行：方法 url 协议类型<br>响应报文起始行：协议类型 响应码 响应码的说明</p><h3 id="首部"><a href="#首部" class="headerlink" title="首部"></a>首部</h3><p>部首就是一系列键值对组合，用来说明连接及主体的数据的意义。下边会着重介绍请求与响应报文的相应首部。</p><h3 id="主体"><a href="#主体" class="headerlink" title="主体"></a>主体</h3><p>由任意数据组成的数据块。如上可以直接是字符串，上传的文件，表单等数据。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><table><thead><tr><th>方法</th><th style="text-align:center">描述</th><th style="text-align:right">是否包含主体</th></tr></thead><tbody><tr><td>GET</td><td style="text-align:center">从服务器获取资源</td><td style="text-align:right">N</td></tr><tr><td>HEAD</td><td style="text-align:center">只获取资源的首部</td><td style="text-align:right">N</td></tr><tr><td>POST</td><td style="text-align:center">发送需要处理的数据</td><td style="text-align:right">Y</td></tr><tr><td>PUT</td><td style="text-align:center">将主体部分存储在服务器上</td><td style="text-align:right">Y</td></tr><tr><td>TRACE</td><td style="text-align:center">追踪报文路径</td><td style="text-align:right">N</td></tr><tr><td>OPTIONS</td><td style="text-align:center">在服务器上可以执行哪些方法</td><td style="text-align:right">N</td></tr><tr><td>DELETE</td><td style="text-align:center">从服务器上删除文件.与put相对</td><td style="text-align:right">N</td></tr></tbody></table><ul><li>HEAD<br>与GET行为类似，但服务器只返回首部。一般用于：<ul><li>通过状态码，查看资源是否存在</li><li>在不获取资源情况下了解资源的类型</li><li>通过首部，测试资源是否被修改？【这个还不明白，难道是对比资源的长度】</li></ul></li><li><p>PUT与POST<br>put方法与post方法都是往服务器上传数据。put语义是让服务器用请求主体数据来创建一个由所请求url命名的新文档。如果已经存在，则替换它。<br>post将表单数据发送的服务器。<br>现在这里文件上传时，一般也是用post表单的方式上传。<br>put区分？</p></li><li><p>TRACE<br><img src="TRACE方法.png" alt="test"><br>如上图所示，主要用于验证请求穿过的代理</p></li><li><p>OPTIONS<br><img src="OPTIONS方法.png" alt="test"><br>用于请求服务器告知其支持的各种方法.</p><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2></li><li><p>组成部分<br><img src="URL组成.png" alt="test"></p><ul><li>URL的sheme，也就是协议类型，https/http/ftp等等</li><li>服务器位置</li><li>资源路径</li></ul></li><li><p>格式<br><img src="url格式.png" alt="test"></p></li><li><p>相对url</p><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2></li></ul><h3 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h3><table><thead><tr><th>整体范围</th><th style="text-align:center">已定义范围</th><th style="text-align:right">分类</th></tr></thead><tbody><tr><td>100-199</td><td style="text-align:center">100-101</td><td style="text-align:right">信息提示</td></tr><tr><td>200-299</td><td style="text-align:center">200-206</td><td style="text-align:right">成功</td></tr><tr><td>300-399</td><td style="text-align:center">300-305</td><td style="text-align:right">重定向</td></tr><tr><td>400-499</td><td style="text-align:center">400-415</td><td style="text-align:right">客户端错误</td></tr><tr><td>500-599</td><td style="text-align:center">500-505</td><td style="text-align:right">服务器错误</td></tr></tbody></table><h3 id="常见："><a href="#常见：" class="headerlink" title="常见："></a>常见：</h3><table><thead><tr><th>状态码</th><th style="text-align:center">原因</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>200</td><td style="text-align:center">OK</td><td style="text-align:right"></td></tr><tr><td>201</td><td style="text-align:center">Created</td><td style="text-align:right">创建成功</td></tr><tr><td>202</td><td style="text-align:center">Accepted</td><td style="text-align:right">请求被接受</td></tr><tr><td>300</td><td style="text-align:center">Multiple Choices</td><td style="text-align:right">url指向多个资源，Location</td></tr><tr><td>301</td><td style="text-align:center">Moved Permanently</td><td style="text-align:right">URL被移到Location</td></tr><tr><td>302</td><td style="text-align:center">Found</td><td style="text-align:right">URL临时定位资源到Location</td></tr><tr><td>400</td><td style="text-align:center">Bad Requese</td><td style="text-align:right">错误请求</td></tr><tr><td>401</td><td style="text-align:center">Unauthorized</td><td style="text-align:right">未授权，未登录</td></tr><tr><td>403</td><td style="text-align:center">Forbidden</td><td style="text-align:right">禁止访问</td></tr><tr><td>404</td><td style="text-align:center">Not Found</td><td style="text-align:right">没有url对应资源</td></tr><tr><td>405</td><td style="text-align:center">Method Not Allowed</td><td style="text-align:right"></td></tr><tr><td>406</td><td style="text-align:center">Not Acception</td><td style="text-align:right">客户端指令资源类型，服务器没有</td></tr><tr><td>500</td><td style="text-align:center">InternelServerErro</td><td style="text-align:right">服务器内部错误</td></tr><tr><td>502</td><td style="text-align:center">Bad Gateway</td><td style="text-align:right">代理无法连接到父网关</td></tr><tr><td>503</td><td style="text-align:center">Service Unavailabe</td><td style="text-align:right">服务器无法提供服务</td></tr></tbody></table><h2 id="首部Header"><a href="#首部Header" class="headerlink" title="首部Header"></a>首部Header</h2><h3 id="通用首部"><a href="#通用首部" class="headerlink" title="通用首部"></a>通用首部</h3><p>客户端与服务端通用的首部，常见如下</p><table><thead><tr><th>首部</th><th style="text-align:right">描述</th></tr></thead><tbody><tr><td>Connection</td><td style="text-align:right">指定请求/响应连接有关选项</td></tr><tr><td>Date</td><td style="text-align:right">报文创建时间</td></tr><tr><td>Transfer-Encoding</td><td style="text-align:right">报文编码的方式</td></tr><tr><td>Trailer</td><td style="text-align:right">报文采用分块传输编码时，列出报trailer信息</td></tr><tr><td>via</td><td style="text-align:right">trace方法时，经过的中间节点</td></tr><tr><td>Cache-Control</td><td style="text-align:right">随报文传送缓存指示</td></tr></tbody></table><h3 id="请求首部"><a href="#请求首部" class="headerlink" title="请求首部"></a>请求首部</h3><p>客户端特有首部，为服务器提供一些额外的（客户端）信息。</p><table><thead><tr><th>首部</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>Client-IP</td><td style="text-align:center">客户端ip</td></tr><tr><td>From</td><td style="text-align:center">客户端email</td></tr><tr><td>Host</td><td style="text-align:center">请求服务器的ip与端口（一般是url）</td></tr><tr><td>Referer</td><td style="text-align:center">提供了当前uri文档的url</td></tr><tr><td>User-Agent</td><td style="text-align:center">浏览器名</td></tr><tr><td>Accept</td><td style="text-align:center">告知服务器应该发送那些类型</td></tr><tr><td>Accept-Charset</td><td style="text-align:center">告知服务器字符集</td></tr><tr><td>Accept-Encoding</td><td style="text-align:center">告知服务器编码方式</td></tr><tr><td>If-Match</td><td style="text-align:center">条件请求：标记匹配，则请求</td></tr><tr><td>Authorization</td><td style="text-align:center">安全请求：认证数据</td></tr><tr><td>Cookie</td><td style="text-align:center">安全请求：cookie</td></tr></tbody></table><h3 id="响应首部"><a href="#响应首部" class="headerlink" title="响应首部"></a>响应首部</h3><p>服务器特有首部，为客户的提供信息</p><table><thead><tr><th>首部</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>Age</td><td style="text-align:center">响应持续时间</td></tr><tr><td>Public</td><td style="text-align:center">服务器为其资源提供的请求方法列表</td></tr><tr><td>Proxy-Authenticate</td><td style="text-align:center">安全响应：代理对客户端的质询列表</td></tr><tr><td>Set-Cookie</td><td style="text-align:center">安全响应：设置cookie</td></tr><tr><td>WWW-Authenticate</td><td style="text-align:center">安全响应：服务器对客户端的质询列表</td></tr></tbody></table><h3 id="实体首部"><a href="#实体首部" class="headerlink" title="实体首部"></a>实体首部</h3><p>用于对应主体部分的首部</p><table><thead><tr><th>首部</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>Content-Type</td><td style="text-align:center">主体类型</td></tr><tr><td>Content-Length</td><td style="text-align:center">主体长度或尺寸</td></tr><tr><td>Content-Location</td><td style="text-align:center">资源实际所处位置</td></tr><tr><td>Content-Encoding</td><td style="text-align:center">主体编码方式</td></tr><tr><td>Content-MD5</td><td style="text-align:center">主体MD5校验和</td></tr><tr><td>Content-Base</td><td style="text-align:center">相对URL的基URL</td></tr><tr><td>Last-Modified</td><td style="text-align:center">实体最后一次被修改的时间</td></tr><tr><td>Expires</td><td style="text-align:center">实体过期，要从源端再次获取时间与日期</td></tr></tbody></table><h1 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h1><h2 id="Connection首部"><a href="#Connection首部" class="headerlink" title="Connection首部"></a>Connection首部</h2><p>  浏览器与服务器之间，可以经过很多层代理，整个连接被分成了好多块小的连接。Connection首部由一个逗号分隔的标签列表，这些标签指定了在小连接之间的选项，不会传播到其它小连接上去。<br>  接收端接收到Connection首部时，首先会解析这些选线，并将其应用。然后在此报文转发给下一跳之前，删除Connection首部及列表中的所有首部。</p><p>  http首部字段名标签包括：<br>  Http首部字段名，列出只与此连接相关的首部<br>  任意标签值，用于描述此连接的非标准选项<br>  close，说明操作完成之后需关这条连接。</p><h2 id="串行加载"><a href="#串行加载" class="headerlink" title="串行加载"></a>串行加载</h2><p><img src="串行连接.png" alt="test"><br>如上图，一个网页有3个图片，串行加载需要4个http事物来显示页面，每个事物都需要建立一个新的连接，这样整个网页加载的速度就会累加起来。</p><h2 id="并行连接"><a href="#并行连接" class="headerlink" title="并行连接"></a>并行连接</h2><p><img src="并行连接.png" alt="test"><br>如图，并行连接就是并发4个连接去请求资源，这样加载速度就会提升。<br>并行连接受到带宽、内存的影响，会引起很多问题。<br>一般浏览器确实使用并行连接，但连接数会很小（通常4个）。</p><h2 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h2><p><img src="并行连接.png" alt="test"><br>如图，持久连接就是4个资源在一个连接中去请求，这样就避免了重新建立连接带来的延时。</p><ul><li><p>Keep-Alive操作<br>客户端通过Connection:Keep-Alive首部请求持久连接<br>服务器如果愿意建立持久连接，就在相应首部中返回Connection:Keep-Alive，反之没有<br>客户端若接收到Keep-Alive，则建立持久连接，反之就会关闭连接。</p></li><li><p>哑代理<br><img src="哑连接.png" alt="test"><br>哑代理就是一些老代理，他们不支持持久连接，而且会转发所有的首部，包括Connection:Keep-Alive。这样就造成浏览器与服务器都认为可以建立持久连接，而哑代理却忽略与客户端连接上的再次请求(半关闭)，造成持久连接失败。</p><p>一种解决方案：Proxy-Connection。这里就不展开了，这种方案也存在问题，仅当服务器与浏览器之间存在一个代理时可用。反之不可。</p></li><li><p>http/1.1持久连接<br>http/1.1用Persistent Connection来代替Keep-Alive.Http/1.1持久连接在默认情况下是激活的，需要关闭时显示添加Connection:close首部来关闭。</p></li></ul><h2 id="管道化连接"><a href="#管道化连接" class="headerlink" title="管道化连接"></a>管道化连接</h2><p><img src="管道化持久连接.png" alt="test"><br>HTTP/1.1允许在建立可选的请求管道。在相应到达之前，经多条请求放入发送队列。</p><ul><li><p>连接关闭<br>任何一种技术都会有其要解决的问题，也有其带来的问题，如管道连接。管道连接带来的问题是由于服务器可以随意关闭连接，客户端发送出的连接还未到达，连接就关闭了，这样就造成了客户端并不知道发送的数据到了没有。另外服务器永远无法确定在关闭“空闲”连接那一刻，在线路另一端有没有数据要发送。<br>这个挺费解的，tcp关闭是4次握手，一端关闭会发送关闭，等待ack后才进入半关闭状态？</p><p>每条HTTP响应都应有精确的Content-Length首部。这样接收端可以根据若实体长度与Content-Length匹配来确定连接是否完成。</p></li></ul><h1 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h1><h2 id="web服务器"><a href="#web服务器" class="headerlink" title="web服务器"></a>web服务器</h2><h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h3><p>Web服务器逻辑实现了HTTP协议，管理着Web资源，并负责提供Web服务器的管理功能。</p><h3 id="小实现-跟tcp服务端编写一样"><a href="#小实现-跟tcp服务端编写一样" class="headerlink" title="小实现:跟tcp服务端编写一样"></a>小实现:跟tcp服务端编写一样</h3><p><img src="Web服务器.png" alt=""></p><ul><li>建立连接：接受一个客户端连接</li><li>接收请求：从网络中读取一条HTTP请求报文</li><li>处理请求：对请求报文进行解释，并采取行动</li><li>访问资源：访问报文中指定的资源</li><li>构建响应：构建带有正确首部的HTTP响应报文</li><li>发送响应：将相应报文发送给的客户端</li><li>记录事务处理过程：将事务有关的内容记录在日志文件中<h2 id="中间商"><a href="#中间商" class="headerlink" title="中间商"></a>中间商</h2><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3></li><li><p>代理位于客户端与服务器之间，于是它既是服务器也是客户端。Http客户端会向代理发生报文，代理必须像Web服务器一样，正确地处理请求和连接，然后返回响应。同时，代理自身要向服务器发送请求。<br>攻守兼备^_^</p></li><li><p>代理vs网关<br>严格说，代理连接的是2个使用相同协议的应用程序，而网关是不同协议，但其实人为设定，它们从设计模式上看，都是代理。</p></li></ul><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><ul><li><p>出口代理<br>本地网络的出口，便于控制本地网络与外部网络之间的流量。小学使用出口代理防止早熟的少年浏览不该浏览的内容。</p></li><li><p>反向代理<br>部署在Web服务器前，处理所有传送给Web服务器的求，并只在必要时间向Web服务器请求资源。如：Nginx。感觉这才是入口代理。</p></li><li><p>网络交换代理（中间代理）<br>可以将具有足够能力的代理放在网络之间的对等交换点上，通过缓存在减轻因特网节点的拥堵，并对流量进行监视。<br>PS：这一块书上表述不清，它的入口代理感觉就是缓存，也就是这里的交换代理，故删掉。</p></li></ul><h4 id="代理获取流量的方式"><a href="#代理获取流量的方式" class="headerlink" title="代理获取流量的方式"></a>代理获取流量的方式</h4><ul><li><p>修改客户端<br>手动修改浏览器的代理配置</p></li><li><p>修改网络【拦截】<br>通过网络基础设施（交换机、路由器），通过技术手段在没有客户端参与情况下，拦截网络流量并将其导入代理。</p></li><li><p>修改DNS的命名空间【反向代理】<br>反向代理会直接加班Web服务器的名字和IP。可以手动编辑DNS名称列表，或者用特殊的动态DNS服务器根据需要来确定适当的代理或者服务器。</p></li><li><p>修改Web服务器<br>重定向命令到代理上</p></li></ul><h4 id="与代理相关问题"><a href="#与代理相关问题" class="headerlink" title="与代理相关问题"></a>与代理相关问题</h4><ul><li>代理请求URI与服务器uri差异<br>客户端向web服务器发送请求，请求行只包括部分URI；而向代理发送，会包含全部<br><img src="URI差异.png" alt=""></li><li>拦截和反向代理对主机信息的隐藏<h4 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h4><img src="追踪.png" alt=""></li><li>TRACE方法</li><li>Via首部<h4 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h4>由于客户端、服务器、代理实现不同版本HTTP规范，以及对特性支持各不相同，可能会存在一些棘手问题。<br>可以通过OPTIONS方法，客户端（代理）可以发现Web服务器或者某个特定资源所支持的功能（所支持的方法）。这样在正式交互之前，确定服务器的能力。</li><li>Allow首部<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><h4 id="代理解决的问题：慢"><a href="#代理解决的问题：慢" class="headerlink" title="代理解决的问题：慢"></a>代理解决的问题：慢</h4></li><li>冗余数据传输</li><li>带宽瓶颈</li><li>瞬时拥塞</li><li>距离延时<h4 id="处理问题所用的方法"><a href="#处理问题所用的方法" class="headerlink" title="处理问题所用的方法"></a>处理问题所用的方法</h4><img src="缓存命中.png" alt=""><br>如图即可，采用的方法与电脑的缓存相同。<h4 id="代理的处理步骤：对比服务器7步骤"><a href="#代理的处理步骤：对比服务器7步骤" class="headerlink" title="代理的处理步骤：对比服务器7步骤"></a>代理的处理步骤：对比服务器7步骤</h4><img src="缓存步骤.png" alt=""></li><li>接收：缓存请求报文</li><li>解析：解析报文，提出URL与首部</li><li>查询：查询是否有本地副本可用，没有就获取一份，并存在本地</li><li>新鲜度检测：就是确定数据一致性</li><li>创建响应</li><li>发送响应</li><li>日志</li></ul><p>则合理用过If-Modified-Since/If-None-Match等首部</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>为了保证新鲜度（数据一致性）采用了很多的算法，这里不在叙述了</li><li>缓存和广告：这个挺有意思<br>ISP的很多收益通过广告来实现，每次点击广告就收取一定的收益。而代理会隐藏实际的次数，这样就使服务器收益降低。^_^<h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><h4 id="网关要解决的问题"><a href="#网关要解决的问题" class="headerlink" title="网关要解决的问题"></a>网关要解决的问题</h4>网络上的资源太多了，这些资源的获取使用不同的协议来访问，于是通过http就不能实现对资源的访问。从一个角度上看，网关就是协议的转换，将http转换成其他协议来实现资源的访问，从另一个角度看，网关就是把其他协议访问资源做http代理，使其能被共有的http协议访问。<h4 id="几种网关"><a href="#几种网关" class="headerlink" title="几种网关"></a>几种网关</h4></li><li>协议网关：HTTP/FTP服务器端FTP网关<br><img src="HTTP_FTP网关.png" alt=""><br>网关接收到请求后，会打开一条与FTP服务器端口（21）的FTP连接，通过FTP协议获取对象。</li><li><p>协议网关：HTTPS/HTTP客户端安全网关<br><img src="http_https网关.png" alt=""><br>对http进行加密，对https进行解密完成协议转换。</p></li><li><p>资源网关：HTTP/CGI服务器端应用程序网关<br>资源网关其实就是服务器，这时候它不是返回文件，而是调用应用程序。<br>CGI（Common Gateway Interface）:其实就是Web服务器调用应用程序的接口，Web服务用它来装载程序以响应URL的请求，并收集程序的输出数据，将其在http响应中回送。</p><h3 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h3></li><li><p>概述<br>web隧道允许用户通过HTTP连接发送非HTTP流量，这样可以在http上稍带其他协议数据。使用web隧道最常见的原因是在http连接中嵌入非http流量，这样，这些流量就可以穿过只允许web流量穿过的防火墙。<br><img src="隧道.png" alt=""><br>隧道就是用http报文发送ssl协议报文，来穿过防火墙。</p></li><li><p>SSL与http/https网关对比<br>网关需要完整的ssl实现，来完成http/https的转换<br>隧道连接本质是ssl，只是中间一段用http报文来传输。</p><h2 id="Web客户端：爬虫"><a href="#Web客户端：爬虫" class="headerlink" title="Web客户端：爬虫"></a>Web客户端：爬虫</h2><h3 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h3></li><li><p>爬虫是一种机器人，它们会递归的对各种web站点进行遍历，获取第一个web页面，然后从那个页面中解析指向的其他页面，接着爬取那些页面，依次类推的爬取。</p></li><li><p>根集选择<br>在Web结构中，有些页面是独立的，没有任何连接指向它们。如下图：<br><img src="网络结构示意图.png" alt=""><br>要遍历整个网络，根集可以选择A、G、S</p><h3 id="爬虫面对的问题"><a href="#爬虫面对的问题" class="headerlink" title="爬虫面对的问题"></a>爬虫面对的问题</h3></li><li><p>机器人爬行时，要避免环路。环路就是几个页面相互引用成环，使爬虫一直在这些页面中重复爬行。</p></li><li><p>文件系统连接环路<br>符号链接引起:<br><img src="文件系统环路.png" alt=""></p></li><li><p>动态虚拟web空间<br>有的应用程序可以在传输中构造出包含同一服务器上虚拟URL连接的HTML。 当爬虫去请求时，这个“邪恶”的服务器会捏造出带有新的URL的新HTML来。</p><h3 id="爬虫HTTP"><a href="#爬虫HTTP" class="headerlink" title="爬虫HTTP"></a>爬虫HTTP</h3><p>鼓励爬虫加入一些识别首部，这样在追踪错误爬虫时，或者向服务器提供爬虫所能处理内容类型时，是有用的。</p></li><li><p>User-Agent<br>将爬虫的名字告知服务器</p></li><li><p>From<br>提供机器人管理者的email</p></li><li><p>accept<br>告知服务器可以发送哪些类型（文本、图片等）</p></li><li><p>referer<br>有些站点管理者尝试记录机器人是如何找到其站点的</p></li><li><p>host<br>一个主机有多个域名，若不指明host，可能获取错内容。</p><h3 id="爬虫要遵守的规范：robots-txt"><a href="#爬虫要遵守的规范：robots-txt" class="headerlink" title="爬虫要遵守的规范：robots.txt"></a>爬虫要遵守的规范：robots.txt</h3></li><li>web服务器可以在服务器文档根目录提供一个可选的、名为robots.txt的文件。这个文件说明机器人可以访问服务的哪些部分。</li><li><p>爬虫在请求页面时，要先去查看robots.txt文件，看它是否有访问的权限。</p></li><li><p>robots.txt文件的格式<br>User-Agent：slurp<br>User-Agent: webcrawler<br>Disallow:/private</p><p>User-Agent:*<br>Disallow</p><p>以一个或者多个User-Agent开始，说明哪些机器人会受此记录影响，然后跟着Disallow和Allow，说明这些机器人可以访问哪些URL</p><h3 id="爬虫的应用：搜索引擎"><a href="#爬虫的应用：搜索引擎" class="headerlink" title="爬虫的应用：搜索引擎"></a>爬虫的应用：搜索引擎</h3><p><img src="搜索引擎.png" alt=""><br>搜索引擎爬虫搜索web页面，然后将内容添加全文索引数据库中。用户引擎文章对全文索引进行查询。</p></li></ul><h1 id="客户端识别"><a href="#客户端识别" class="headerlink" title="客户端识别"></a>客户端识别</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>无状态<br>HTTP最初是一个匿名、无状态的请求/响应协议。服务器处理来自客户的请求，然后向客户回送一条响应。web服务器几乎没有什么信息可以判断是哪个用户发送的请求，也无法记录访问用户的请求序列。</li><li><p>有状态<br>现在，他们需要对客户端有更多的了解，并在用户浏览页面时，对其进行跟踪。<br>如今一般在用的技术有：用户登录、胖url、cookie（ip技术已经基本淘汰）</p><h2 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h2><p>早期开发者曾尝试将客户端的ip地址作为一种标识形式使用。web服务器可以找到http对应的tcp连接，调用类似与getpeername(tcp_socket,…)函数来获取ip</p></li><li><p>存在问题：<br>1.ip记录的是机器，而不是用户，在多人共享一台机器时就无法区分。<br>2.动态分配ip</p><ol><li>NAT防火墙会隐藏后边那些实际客户端的ip</li><li>代理的存在，web服务看到的是代理的ip<h2 id="用户登录：Authorization首部，即认证"><a href="#用户登录：Authorization首部，即认证" class="headerlink" title="用户登录：Authorization首部，即认证"></a>用户登录：Authorization首部，即认证</h2></li></ol></li><li>用户访问服务器</li><li>服务器返回401</li><li>浏览器显示登录框</li><li>在请求时用Authorization首部在下一条对服务器请求提供这些信息<br>这个部分就是基本认证部分：<br><img src="基本认证.png" alt="test"></li></ul><h2 id="胖url"><a href="#胖url" class="headerlink" title="胖url"></a>胖url</h2><ul><li><p>web服务器为每个用户生成特定版本的URL来追踪用户的身份。通常会对真正的URL进行扩展，在URL路径结束的地方添加一些状态信息。用户浏览网页时，web服务器动态生成一些超连接，继续维护URL中的状态信息。</p></li><li><p>存在问题：<br>丑陋的url<br>无法共享URL，共享时可能泄密<br>破坏缓存，不再有可供公共访问的url需要缓存<br>额外的服务器负荷</p></li></ul><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><ul><li><p>cookie如何工作<br> <img src="cookie.png" alt="test"><br>首次访问时，web服务器给用户“拍上”一个独有的cookie，浏览器记住服务器返回Set-Cookie首部中cookie内容，并将cookie存储在浏览器的cookie数据库中。将来用户访问同一站点时，浏览器会挑中那个服务器用户上的cooike，将其传送回去。</p></li><li><p>cookie组成<br>网景的cookie会将cookie存在一个cookies.txt文本文件中如：</p></li></ul><p>| 名称       | 值            | 说明                           |<br>| domain     | <a href="http://www.fedex.com" target="_blank" rel="noopener">www.fedex.com</a> | 域                             |<br>| allh       | FALSE         | 是域中所有的主机都获取cookie？ |<br>| path       | /             | 域中与cookie相关的路径前缀     |<br>| secure     | FALSE         | 是否只有SSL才发送这个cookie    |<br>| expiration | 1136109676    | 过期时间间隔                   |<br>| name       | cc            | cookie变量的名字               |<br>| value      | /us/          | cookie变量的值                 |</p><p> domain:<br> 告诉浏览器，只有往这个域访问时才使用此cookie<br> set-cookie: user=”mary17”; domain=”airtravelbargains.com”</p><p> path:<br> 告诉浏览器，只有往域的这个路径访问时，才是有此cookie<br> set-cookie: user=”mary17”; domain=”airtravelbargains.com”; path=/autos/</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍http的协议基础：主要包括报文的结构、请求的方法、url、状态码、header，以及http的连接&lt;/p&gt;
    
    </summary>
    
      <category term="数据传输" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/"/>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
</feed>
