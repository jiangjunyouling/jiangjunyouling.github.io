<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>思 见</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-09T01:47:54.042Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>sun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第三周ARTS</title>
    <link href="http://yoursite.com/2019/04/08/%E7%AC%AC%E4%B8%89%E5%91%A8ARTS/"/>
    <id>http://yoursite.com/2019/04/08/第三周ARTS/</id>
    <published>2019-04-08T02:22:36.000Z</published>
    <updated>2019-04-09T01:47:54.042Z</updated>
    
    <content type="html"><![CDATA[<p>第三周打卡<br><a id="more"></a></p><h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><p><a href="https://sunyanfeng.cn/2019/04/04/kth%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/#more" target="_blank" rel="noopener">kth最大元素</a></p><h1 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h1><p>本周主要Review了陈皓老师的编程范式</p><p><a href="https://sunyanfeng.cn/2019/04/01/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/#more" target="_blank" rel="noopener">编程范式</a></p><h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><p><a href="https://sunyanfeng.cn/2019/04/08/Matrix-Eigenvalue/#more" target="_blank" rel="noopener">Matrix Eigenvalue</a></p><h1 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h1><p>本周顺便做了一个工具的记录，就当share了，稍显薄了一点</p><p><a href="https://sunyanfeng.cn/2019/04/04/vscode%E4%B8%8Bmd%E5%AF%BCpdf/#more" target="_blank" rel="noopener">vscode下md导pdf</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第三周打卡&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Matrix Eigenvalue</title>
    <link href="http://yoursite.com/2019/04/08/Matrix-Eigenvalue/"/>
    <id>http://yoursite.com/2019/04/08/Matrix-Eigenvalue/</id>
    <published>2019-04-08T02:14:22.000Z</published>
    <updated>2019-04-09T01:48:05.014Z</updated>
    
    <content type="html"><![CDATA[<p>本周清明回家，只完成2节的Matrix学习，Lesson21～Lesson22<br>为保持博客的完整性，下周的Matrix依旧会放到本篇博客中</p><a id="more"></a><h1 id="Eigenvalues-and-eigenvectors"><a href="#Eigenvalues-and-eigenvectors" class="headerlink" title="Eigenvalues and eigenvectors"></a>Eigenvalues and eigenvectors</h1><ul><li><p>定义</p><p>AX = λX</p><p>A matrix A acts on vectors x . Eigenvectors are vectors for which Axis parallel to x。</p></li><li><p>计算</p><p>det(A-λI) = 0</p></li><li><p>复数eigenvalues</p><p>对称阵的特征值为实数，反对称阵的特征值为纯虚数<br>Symmetric matrices have real eigenvalues<br>For antisymmetric matrices like Q, for which AT = −A, all eigenvalues are imaginary (λ=bi). </p></li><li><p>重复的eigenvalues</p><p>非重复的eigenvalues用于相互独立的eigenvector，重复的eigenvalues可能用于独立的，也可能不独立的eigenvector</p><p><img src="重复的eigenvalues示例.png" alt="重复的eigenvalues示例"></p></li></ul><h1 id="Diagonalization-and-powers-of-A"><a href="#Diagonalization-and-powers-of-A" class="headerlink" title="Diagonalization and powers of A"></a>Diagonalization and powers of A</h1><ul><li><p>对角化：Diagonalization</p><p><img src="对角化公式.png" alt="对角化公式"><br><img src="对角化证明.png" alt="对角化证明"></p></li><li><p>A的幂运算，Powers of A<br><img src="A的幂运算.png" alt="A的幂运算"></p><p>当A的K次幂 -&gt; 0时，说明A的特征向量绝对值&lt;1</p></li><li><p>差分方程<br><img src="差分方程.png" alt="差分方程"></p><p><img src="差分方程的解.png" alt="差分方程的解"><br>在这里，它将U0用A的特征向量来表示的，有点当成一组基在使用</p></li><li><p>菲比队列</p><p><img src="Fibonacci队列.png" alt="Fibonacci"><br><img src="构造矩阵.png" alt="构造矩阵"><br><img src="解.png" alt="解"></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周清明回家，只完成2节的Matrix学习，Lesson21～Lesson22&lt;br&gt;为保持博客的完整性，下周的Matrix依旧会放到本篇博客中&lt;/p&gt;
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Matrix" scheme="http://yoursite.com/tags/Matrix/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>kth最大元素</title>
    <link href="http://yoursite.com/2019/04/04/kth%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2019/04/04/kth最大元素/</id>
    <published>2019-04-04T05:57:09.000Z</published>
    <updated>2019-04-09T01:43:59.866Z</updated>
    
    <content type="html"><![CDATA[<p>本题是 Leecode的 215.Kth Largest Element in an Array<br><a id="more"></a></p><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p><p>Example 1:</p><p>Input: [3,2,1,5,6,4] and k = 2<br>Output: 5<br>Example 2:</p><p>Input: [3,2,3,1,2,4,5,5,6] and k = 4<br>Output: 4<br>Note:<br>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>本题，想到了2种可行方式：</p><ol><li>用排序算法，对数组进行排序，然后返回地k-1个元素即可，既然是训练分治，这里可以使用归并排序的方式。</li><li>设计一个k大小的窗口，然后从数组上滑过，每个元素与这k个元素比较，根据大小做处理。类似于插入排序的方式。<br>本题准备实现一下1方式</li></ol><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sortedNums = sort(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> sortedNums[k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mergeNums;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(low == high)&#123;</span><br><span class="line">            mergeNums.push_back(nums[low]);</span><br><span class="line">            <span class="keyword">return</span> mergeNums;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> middle = (low + high)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lnums = sort(nums, low, middle);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hnums = sort(nums, middle+<span class="number">1</span>, high);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&lt;lnums.size() &amp;&amp; j&lt;hnums.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(lnums[i] &gt;= hnums[j])&#123;</span><br><span class="line">                mergeNums.push_back(lnums[i++]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mergeNums.push_back(hnums[j++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&lt;lnums.size())&#123;</span><br><span class="line">            mergeNums.push_back(lnums[i++]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(j&lt;hnums.size())&#123;</span><br><span class="line">            mergeNums.push_back(hnums[j++]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mergeNums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上边2种做法，1中对所有的数组进行了排序，2中对k个元素进行了排序，不是直接去找Kth，应该能直接找子数组与kth之间的关系来直接分治。想了一种k分的方式，取最大，然后再取这k个值的最小，但是错误的;还有2分各取k应该，排序然后取第K，也是一种做法，但受K的影响，如果K &gt; length/2，还需要作转换，衰减也并不明显。<br>暂时并未想到可行的直接分治的方法</p><p>google了一下结果，发现有用快排方式的，有用二分方式的，复杂度都是nlog(n)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本题是 Leecode的 215.Kth Largest Element in an Array&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vscode下md导pdf</title>
    <link href="http://yoursite.com/2019/04/04/vscode%E4%B8%8Bmd%E5%AF%BCpdf/"/>
    <id>http://yoursite.com/2019/04/04/vscode下md导pdf/</id>
    <published>2019-04-04T02:47:46.000Z</published>
    <updated>2019-04-04T03:17:19.548Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下通过vscode转md导成pdf的方法</p><a id="more"></a><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>用md写文档已经渐渐成为习惯，尤其可以通过hexo，直接发布成博客。<br>造成的问题呢，很多文档并不是博客，比如会议纪要、工作的一些记录，写成md分享给非技术人员看，并不太合适，尤其有图片的时候，于是就想用md转成pdf。</p><h1 id="Markdown-Pdf插件安装"><a href="#Markdown-Pdf插件安装" class="headerlink" title="Markdown Pdf插件安装"></a>Markdown Pdf插件安装</h1><p>从扩展中安装Markdown Pdf</p><p><img src="插件.png" alt="插件"></p><p>安装成功后，可以在md文件中右键看到如下菜单</p><p><img src="右键.png" alt="右键"></p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>看到很多介绍，说到这里就可以直接点击导出就能成功，但在我机器上并没有成功。</p><p>点击后，发现没有任何反应，最初以为是导出的目录可能不对，搜索了一下，发现可以通过<code>markdown-pdf.outputDirectory</code>的方式来配置导出的目录，于是进行了设置，发现还是没反应</p><p>我注意到每次启动时，vscode坐下脚的提示中，总在install chromium，于是就有数了，这个Markdown Pdf其实是调用了chromium的接口来完成转换的。也是就看一下这个插件的配置。如下</p><p><img src="ExecutablePath.png" alt="ExecutablePath"></p><p>由于本机上有chromium浏览器，就<code>whereis chromium-browser</code>，然后在进行了配置，在settings.json中增加：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"markdown-pdf.executablePath": "/usr/bin/chromium-browser"</span><br></pre></td></tr></table></figure><p>重试，导出成功。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下通过vscode转md导成pdf的方法&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>编程范式</title>
    <link href="http://yoursite.com/2019/04/01/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/04/01/编程范式/</id>
    <published>2019-04-01T09:26:14.000Z</published>
    <updated>2019-04-08T02:54:46.369Z</updated>
    
    <content type="html"><![CDATA[<p>本篇作为笔记形式存在，对左耳听风中的编程范式做笔记，便于以后去查看。<br>原文中主要用到了语言有C、C++、Python、Java、Javascript、Go、Prolog。由于我对Go语言了解不深，委托范式像是一种组合方式的应用，这里就不对这种范式进行记录了，以后有机会，再回来补充;另外Prolog的方式我觉得很有趣，以后想去研究一下再写，这里也不包括在内。</p><p>我需要找到一种合适的记录顺序：原文以一种语言发展的顺序展开，是一种不错的方式; 根据我学习语言的前后顺序，也是一种不错的方式; 再有一种是总分式展开方式。这里选用第二种吧，以我接触这些范式的先后关系来展开。</p><a id="more"></a><h1 id="过程式编程"><a href="#过程式编程" class="headerlink" title="过程式编程"></a>过程式编程</h1><p>作为学习的起点，我也是从C语言起步的，但作为使用的起点却不能算是。真正使用的起点应该是汇编语言了，那时候在学校里做课程设计，用汇编控制循环。后来第二次做的时候就用上了C语言，感觉轻松了好多，循环用for就可以了，不用来回的jump。</p><p>对C语言的特性，这里直接引用了</p><ul><li>C 语言是一个静态弱类型语言，在使用变量时需要声明变量类型，但是类型间可以有隐式转换；</li><li>不同的变量类型可以用结构体（struct）组合在一起，以此来声明新的数据类型；</li><li>C 语言可以用 typedef 关键字来定义类型的别名，以此来达到变量类型的抽象；</li><li>C 语言是一个有结构化程序设计、具有变量作用域以及递归功能的过程式语言；</li><li>C 语言传递参数一般是以值传递，也可以传递指针；</li><li>通过指针，C 语言可以容易地对内存进行低级控制，然而这引入了非常大的编程复杂度；</li><li>编译预处理让 C 语言的编译更具有弹性，比如跨平台。</li></ul><p>我这里尝试来回忆一下：</p><ul><li>从数据上看，数据本身都是二进制，类型是对这段二进制的解释，类型本身并不是数据。</li><li>从内存山看，可以分成静态区、堆区、栈区、常量区，分别用来存储存储全局、new、局部、常量字符串等数据</li><li>数据对齐方式要注意大小端的差异，尤其在传输过程中，一般都需要大小端的转换，实现方式就是按中轴进行互换。</li><li>还有一些比较有趣的结构：比如union，还记得老师写的那段代码，用union来包含两个struct，它们的长度相同，但在传输与解析时做不同的使用。</li><li>还有很多宏定义，像是去年看的，内核中使用链表时候那段宏定义就很有意义。</li><li>中断的处理，单片机上的中断口有限，需要对中断手动进行配置，包括端口以及回调函数。中断其实一种异步方式，中断方式比起轮询方式节省很多资源。</li></ul><p>C语言回忆就到这里了，说是过程式的，不如说是指令式的，你像机器发送着一些指令，这其实比汇编语言好多了，起码不需要记住每一个寄存器。另外，以前只听老师说过C语言其实可以写OO，一直无缘得见，后来看vfs时候才明白，原来面向对象是一种思想，并不一定被语言限制，在C中一样可以用这种思想。</p><h1 id="面向对象式编程"><a href="#面向对象式编程" class="headerlink" title="面向对象式编程"></a>面向对象式编程</h1><p>最早接触C++其实是在实验室里，那时候用MFC做桌面端的应用程序，当然那时候我们称桌面为上位机。对C++的认识也比较模糊，因为MFC做了好多封装，也体会不出C++的特点。工作之后，写了5年的C++，目前为止，在所有语言里使用时间也是最长的。</p><p>面向对象的3大特性：封装、继承、多态。<br>对面向对象的评价继续引用：</p><ul><li><p>优点</p><ul><li>能和真实的世界交相辉映，符合人的直觉。</li><li>面向对象和数据库模型设计类型，更多地关注对象间的模型设计。</li><li>强调于“名词”而不是“动词”，更多地关注对象和对象间的接口。</li><li>根据业务的特征形成一个个高内聚的对象，有效地分离了抽象和具体实现，增强了可重用性和可扩展性。</li><li>拥有大量非常优秀的设计原则和设计模式。S.O.L.I.D（单一功能、开闭原则、里氏替换、接口隔离以及依赖反转，是面向对象设计的五个基本原则）、IoC/DIP……</li></ul></li><li><p>缺点</p><ul><li>代码都需要附着在一个类上，从一侧面上说，其鼓励了类型。</li><li>代码需要通过对象来达到抽象的效果，导致了相当厚重的“代码粘合层”。</li><li>因为太多的封装以及对状态的鼓励，导致了大量不透明并在并发下出现很多问题。</li></ul></li></ul><p>缺点上这两点原文中，原文中的举例都是针对Java，像Spring的那些注入，导致了大量的封装，这些封装还屏蔽了细节。</p><p>这里只对自己在使用C++的时候的一些回忆吧，主要针对面向对象的3大特性来展开</p><ul><li>封装，封装其实沿用着C语言模块化编程的思维，讲究低耦合高内聚的方式，只不过面向对象是将数据与操作封装成一个类，这里的数据也就是后边说的状态。</li><li>继承，继承是代码复用的一种方式，起先比较喜欢继承，后来发现继承也是有缺点的，会出现类爆炸的情况。于是就提倡使用组合的方式来复用代码。尤其加之与后边将的多态，使对组合元素的依赖于接口，而不是具体实现，耦合程度进一步降低。</li><li>多态，就是刚才说的，依赖于接口而不是具体实现。其实后来发现那些设计模式，其实就是对继承、组合、多态的一些常见用法，直接点就是套路。</li></ul><p>还有一部分是开发过程的控制</p><ul><li>多线程及线程池的使用，重构预处理服务的时候，将不同的处理策略抽象各自的实现中，然后将整个流程又封装成了各自的过程对象，最后获取线程池中的线程运行过程对象。后来发现这种方式在Java中与runable的方式类似，而且当时各个流程是硬编码的，如果是面AOP的方式，或者装饰器的方式会更好一些。</li><li>由于各个处理步骤的只完成对数据处理的一部分，可能会new出一段数据区来，在不同的步骤之间传递引用，但当时的的情况不同，最后的结果并不是线性依赖的，而是根据各个步骤处理结果的逻辑运算。在实现的过程中将数据放到了一块contex的数据区，并将每个步骤的结果也保存在集中，最后将取结果的逻辑与结果本身解耦出来。</li><li>在多线程中处理全局数据，对锁的要求很高。</li></ul><p>感慨一下，没想到3年过去了，还能顺利记起当时的做法。</p><p>其实这隐含着这种编码方式很大的问题，在分布式系统中，状态如此之多，处理起来会加倍的困难。虽然当时从内存监控上看，并没有出现泄露的情况，但也是战战兢兢，如履薄冰的。</p><p>Java其实在面向对象方面其实比C++做的好一些，从我的基础上看，MVC、IoC、动态代理这些是接触到Java之后才真正了解，而且Java的那本Head First设计模式比C++那本更容易理解。由于Java使用并没有C++使用的深，就此作罢吧。</p><h1 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h1><p>对于泛型编程，除去比用的STL，其实自己写的时候还真的比较少，记忆中，刚开始写Qt界面的时候，3个表格数据不同，表达基本相同，我用泛型做了一个实现。这里做个引用：</p><p>理想情况下，算法应是和数据结构以及类型无关的，各种特殊的数据类型理应做好自己分内的工作。算法只关心一个标准的实现。而对于泛型的抽象，我们需要回答的问题是，如果我们的数据类型符合通用算法，那么对数据类型的最小需求又是什么呢？<br>原文中给出的方式包括3重：</p><ol><li><p>它通过类的方式来解决<br>构造函数与析构函数<br>拷贝构造函数，表示对内存的复制<br>重载操作符</p></li><li><p>通过模板达到类型和算法的妥协。</p></li><li><p>通过虚函数和运行时类型识别。</p></li></ol><p>这里想说一下STL，没有接触STL之前，培训老师出了一题，题目现在已经忘记了，记得最主要的数据结构就是动态数据了，我们自己写链表来实现，人家直接用vector，效率高出许多。如果没用vector、set、map，那C++的路还会坎坷一些。</p><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>函数式编程最早也是从coolshell中看到的，而且缺少实践，需要引用的东西更多一些了。</p><ul><li><p>定义</p><p>定义输入数据和输出数据相关的关系，数学表达式里面其实是在做一种映射（mapping），输入的数据和输出的数据关系是什么样的，是用函数来定义的。</p><p>从通篇来看，函数式编程都是在借鉴函数，y = f(x) ,在这里只定义了一种关系，而且这种关系可以替换，如 z = g(y)，这时候可以将y带入变成z = g(f(x))，由此，函数与变量本身是等价的，自然也就是懒惰的，并且，是可以嵌套的。</p></li><li><p>特点</p><p>stateless: 无状态，就像是电路，本身不能存储电荷一样，有出有入，入多少出多少<br>immutable： 输入数据是不能动的，动了输入数据就有危险，所以要返回新的数据集。这条其实是从stateless中演化而来，对与函数f(x)，进了x就要出y，且x不能变</p></li><li><p>一些技术</p><ul><li>first class function（头等函数），函数像变量一样使用，参考 z = g(f(x))</li><li>recursing(递归)， z = f(f(x))，是对上一条的加深</li><li>pipeline(管道), 原文解释：将函数实例成一个一个的 action，然后将一组 action 放到一个数组或是列表中，再把数据传给这个 action list，数据就像一个 pipeline 一样顺序地被各个函数所操作，最终得到我们想要的结果。 pipleline最早也是shell的管道操作了。在代码方面有点。这些用法其实都是基于stateless的。</li><li>tail recursion optimization(尾递归)</li><li>map &amp; reduce &amp; filter，这个不论在python还是js中都有使用<br>…</li></ul></li><li><p>一些总结</p><ul><li>函数式编程的核心就stateless，仿照y = f(x)，仿照节点不存电荷</li><li>函数可以替换，也就是函数与变量等价，因为这种等价，在多线程调用时候，也就更安全</li><li>函数可以嵌套，也就可以currying、可以recursing、可以pipeline</li></ul></li><li><p>一些问题</p><ul><li><p>关于无状态<br>联想到了http协议，本来设计是一个无状态的协议，最后却不得不加上cookie、session等的加上状态。那函数式变成处理陈老师提到的频繁复制的问题，还会有什么问题。</p><p>另一个是体系架构，都是尽量在做到无状态，但一个请求需要在不同的服务中流转来完成，这种感觉有些像pipeline，需要流转的次序可配置，并且需要记录在每个流程中的一些信息，比如日志聚合，这种方式跟http协议上加cookie是何等的相似。</p><p>需要状态才是函数编程存在的问题，无状态是一种存在，优点也是缺点。</p></li><li><p>函数编程与面向对象编程<br>面向对象基础其实是封装了，封装是将数据与操作封装在一起的思想，这些数据也就是成员变量，就是状态。但完全可以封装一个类，没有成员变量，里边的函数全是函数式的无状态。这种范式即是面向对象，也是函数编程。那其实也就没有继承的必要性了，完全组合就可以，但多态还是需要的，面向接口编程会保存下来。</p></li></ul></li></ul><h1 id="基于原型的编程"><a href="#基于原型的编程" class="headerlink" title="基于原型的编程"></a>基于原型的编程</h1><p>基于原型的编程已经单独总结过了，这里只放个链接：<br><a href="https://sunyanfeng.cn/2019/03/31/js%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B/#more" target="_blank" rel="noopener">js中的原型</a>  </p><p>基于原型的编程，其实就是用组合的方式在完成着继承。继承跟组合的界限在这里有些模糊了。<br>node.js中的异步其实是一种软中断，这一部分可以整体梳理成一个博文了，包括单片机的中断处理、linux上下部的中断处理、以及node.js异步的处理，这里就不多写了。</p><h1 id="编程的本质"><a href="#编程的本质" class="headerlink" title="编程的本质"></a>编程的本质</h1><p>陈老师给出的编程本质也是函数式的：<br>Programs = Algorithms + Data Structures<br>Algorithm = Logic + Control<br>So:<br>Promgrams = Logic + Control + DataStructures<br>其中Logic是业务逻辑，逻辑过程的抽象，加上由术语表示的数据结构的定义<br>Control与业务逻辑无关，你控制它的执行，控制一个程序执行的方式，串行or并行，以及调度不同的执行模块，数据之间的存储关系，这些和业务逻辑无关。</p><p>尤其其中给出的注册验证的代码例子，看的我有些汗颜，重构那个模块时，没有想起来，然后这块代码其实在pg测试里见过，没有联想到可以这样玩。</p><p>这里对logic与control的分离做一点简单的思考：</p><p>在代码级别上，将logic以配置的方式（json、xml）来表达出来，然后将control针对格式来做，而不是针对内容。<br>在服务级别上，跟上边的无状态服务有些类似，每个无状态的服务可以看作是logic，通过编排来control执行的服务。</p><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>本文为了自己记忆方便，做一些记录与思考的东西，所有引用都是从陈皓老师，极客时间《左耳听风》处引来。若有不妥，请联系我，联系方式，详见站内“关于”部分。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇作为笔记形式存在，对左耳听风中的编程范式做笔记，便于以后去查看。&lt;br&gt;原文中主要用到了语言有C、C++、Python、Java、Javascript、Go、Prolog。由于我对Go语言了解不深，委托范式像是一种组合方式的应用，这里就不对这种范式进行记录了，以后有机会，再回来补充;另外Prolog的方式我觉得很有趣，以后想去研究一下再写，这里也不包括在内。&lt;/p&gt;
&lt;p&gt;我需要找到一种合适的记录顺序：原文以一种语言发展的顺序展开，是一种不错的方式; 根据我学习语言的前后顺序，也是一种不错的方式; 再有一种是总分式展开方式。这里选用第二种吧，以我接触这些范式的先后关系来展开。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ARTS第二周</title>
    <link href="http://yoursite.com/2019/03/31/%E7%AC%AC%E4%BA%8C%E5%91%A8ARTS/"/>
    <id>http://yoursite.com/2019/03/31/第二周ARTS/</id>
    <published>2019-03-31T14:00:37.000Z</published>
    <updated>2019-04-01T01:21:44.271Z</updated>
    
    <content type="html"><![CDATA[<p>第二周打卡<br><a id="more"></a></p><h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><p><a href="https://sunyanfeng.cn/2019/03/31/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98/#more" target="_blank" rel="noopener">最大子数组问题</a></p><h1 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h1><p><a href="https://codeburst.io/interfaces-in-javascript-with-es6-naive-implementation-91b703110a09" target="_blank" rel="noopener">Interfaces in JavaScript with ES6 Symbol. Naive implementation</a></p><p>在javascript中通过Symbol的方式来实现interface</p><p>这种打算通过重写一些代码，有一些东西需要依赖接口来编程，于是就探索了一下在javascript中如何使用接口。这其实与本周share中的原型继承有一定的联系了，于是找到了这篇文章。</p><p>在这篇文章中，通过es6提供的Symbol实现了接口的功能，而且使用了es6的getter与setter，主要依赖就是Symbol的唯一性,试想，如果不用Symbol而是使用string，那样如果一个类不具有这个接口实现中，而偏偏有了一个相同的属性名，这样在判断undefine时就是真，就会出现问题。</p><h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><p><a href="https://sunyanfeng.cn/2019/03/31/Matrix-Determinants/#more" target="_blank" rel="noopener">Matrix Determinants</a></p><h1 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h1><p><a href="https://sunyanfeng.cn/2019/03/31/js%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B/#more" target="_blank" rel="noopener">js中的原型</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二周打卡&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>js中的原型</title>
    <link href="http://yoursite.com/2019/03/31/js%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/03/31/js中的原型/</id>
    <published>2019-03-31T13:08:47.000Z</published>
    <updated>2019-04-02T01:59:42.229Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客主要是想总结一下js中的原型，其中包含《左耳听风》36节之后的一点思考。</p><a id="more"></a><h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><p>在去年刚看JS高程的时候，觉得javascipt这继承真麻烦，并没有去深入思考一下，在看到左耳听风这篇文章后，觉得有了一些新的认识。这里对原型再深入探索一下。</p><p><img src="原型链-1.png" alt="原型链.jpg"><br>从这个图里，可以很明白表达原型链的含义，在每个对象里都有一个<code>__proto__</code>的属性，用来指向其原型。</p><p><img src="原型链-2.png" alt="原型链.jpg"><br>这里是对<code>__proto__</code>与prototype差异的一个说明，Foo每个Function对象都会多一个prototype属性，指向一个对象，其他对象的通过<code>__proto__</code>指向Foo.prototype。</p><p><img src="原型链继承.png" alt="原型链继承"><br>这个是JS高程中原型链继承中的图片，很清楚的看出SubType的prototype对象通过<code>__proto__</code>指向SuperType的prototype来继承其中的方法，instance实例通过<code>__proto__</code>来使用subtype中的方法。</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>这引发了我对两个问题的思考：</p><ol><li><p>为什么要有prototype与<code>__proto__</code></p><p>首先原型链的本质就是通过<code>__proto__</code>来指向其他对象的方式来复用代码，典型的组合方式。那为什么会用prototype呢，我觉得是原因Function两个维度上的使用，其一直接new对象，其二被子类继承使用。因为需要直接new对象，也就需要<code>__proto__</code>；因为需要被其他子Function继承，所以将被继承、被共用的部分独立出来，放到prototype中，本质上是一种模块化思维，将可以被复用的与不能被复用的分离。</p></li><li><p>js为什么以这种方式来实现继承</p><p>js基本属于一切皆对象的语言，函数是对象、类是对象。这样的情况注定没有类型，也就注定只能是组合的方式来完成类。在静态语言中，我们生命一个Student类，然后实例化一个xiaoMing的实例，在这里Student是一个对象，它与xiaoMing本质上是一种东西。xiaoMing通过一个指定的属性依赖Student。</p><p>这其实引发另一个问题，这种组合方式是动态类型语言唯一的方式吗？python中好像并不是这样玩的，这个问题留给以后来思考。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇博客主要是想总结一下js中的原型，其中包含《左耳听风》36节之后的一点思考。&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="编程范式" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Matrix Determinants</title>
    <link href="http://yoursite.com/2019/03/31/Matrix-Determinants/"/>
    <id>http://yoursite.com/2019/03/31/Matrix-Determinants/</id>
    <published>2019-03-31T12:21:42.000Z</published>
    <updated>2019-04-08T02:37:55.934Z</updated>
    
    <content type="html"><![CDATA[<p>本周完成了Gilbert Strang线性代数的中行列式的学习，课程中的Lesson18~Lesson20.</p><p>笔记都是用课程中手记的，这里只做一个简单的记录。</p><a id="more"></a><h1 id="determinants"><a href="#determinants" class="headerlink" title="determinants"></a>determinants</h1><ol><li><p>det I = 1</p></li><li><p>交换2行的位置，符合改变。</p></li><li><p>在每一个行上，都是线性的。</p></li><li><p>A中存在2个相同的行，det A = 0</p></li><li><p>substract c*row(i) from row(j), and the det does not change</p></li><li><p>A: Row of zeros, det A = 0</p></li><li><p>U: 上三角矩阵，d1,d2…dn为主元素， det U = d1 <em> d2 ..</em> dn<br>这个说明可以通过消元法来求解行列式，而且Gilbert老师说，是matlib等求det的主要方法。</p></li><li><p>A: singular, det A = 0</p></li><li><p>det(AB) = detA <em> detB<br>det2A = 2^n </em> det A<br>其实看到这里的时候，Gilbert老师就提到过，这种样子像是求体积，自然而然就意识到det其实就是矩阵的体积，不过带有方向。</p></li><li><p>det A transpose = det A</p></li></ol><h1 id="Big-formula"><a href="#Big-formula" class="headerlink" title="Big formula"></a>Big formula</h1><p><img src="bigformular.png" alt="bigformular"></p><h1 id="cofactor"><a href="#cofactor" class="headerlink" title="cofactor"></a>cofactor</h1><p><img src="cofactor-1.png" alt="cofactor"><br><img src="cofactor-2.png" alt="cofactor"></p><h1 id="原矩阵与逆矩阵"><a href="#原矩阵与逆矩阵" class="headerlink" title="原矩阵与逆矩阵"></a>原矩阵与逆矩阵</h1><h2 id="formular-for-A-1"><a href="#formular-for-A-1" class="headerlink" title="formular for A^(-1)"></a>formular for A^(-1)</h2><p><img src="A-1.png" alt="逆矩阵"></p><h2 id="Cramer’s-Rule"><a href="#Cramer’s-Rule" class="headerlink" title="Cramer’s Rule"></a>Cramer’s Rule</h2><p><img src="cramer_rule_1.png" alt="cramer_rule"><br><img src="cramer_rule_2.png" alt="cramer_rule"><br><img src="cramer_rule_3.png" alt="cramer_rule"></p><p>这个Cramer法则好看不中用</p><h1 id="Volumn"><a href="#Volumn" class="headerlink" title="Volumn"></a>Volumn</h1><p>这个很有趣，是对行列式终极含义</p><p>|det A| is equal to the volumn of matrix</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周完成了Gilbert Strang线性代数的中行列式的学习，课程中的Lesson18~Lesson20.&lt;/p&gt;
&lt;p&gt;笔记都是用课程中手记的，这里只做一个简单的记录。&lt;/p&gt;
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Matrix" scheme="http://yoursite.com/tags/Matrix/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>最大子数组问题</title>
    <link href="http://yoursite.com/2019/03/31/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/03/31/最大子数组问题/</id>
    <published>2019-03-31T09:41:06.000Z</published>
    <updated>2019-04-04T05:58:50.355Z</updated>
    
    <content type="html"><![CDATA[<p>本题是 Leecode的53.Maximum Subarray</p><a id="more"></a><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p><p>Example:</p><p>Input: [-2,1,-3,4,-1,2,1,-5,4],<br>Output: 6<br>Explanation: [4,-1,2,1] has the largest sum = 6.<br>Follow up:</p><p>If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>与上周的主题一样，本周训练的主题还是分治，题目是最大子数组，属于分治里的例题了。</p><p>这个题目思路用暴力来求解，可以设置一个窗口，长度是length(from 1 to length-1)，然后不断的在数组中滑动，比较得到最大的数组,这个的复杂度在o(n^2).</p><p>分治的思路大概是找递归的过程，或者找f(n)与f(n-1)之间关系的过程。子问题的划分其实也与数组的分裂相关，最快的分法就是每次都均分。这个问题就可以这样来解决了，最长子数组：</p><ul><li>完全位于子数组nums[low, middle]</li><li>完全位于子数组nums[middle+1, high]</li><li>子数组跨越中点，这种情况下，需要去求middle~low的最大值以及middle~high的最大值，然后求和即可。</li></ul><p>对于完全位于的，可以继续去递归。</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> constMinInt = <span class="number">-2147483648</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = findMaxSubArray(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (low == high) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[low];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> middle = (low+high)/<span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> leftMax = findMaxSubArray(nums, low, middle);</span><br><span class="line">            <span class="keyword">int</span> rightMax = findMaxSubArray(nums, middle+<span class="number">1</span>, high);</span><br><span class="line">            <span class="keyword">int</span> crossMax = findMaxCrossSubArray(nums, low, high, middle);</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span>  getMax(leftMax, rightMax, crossMax);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxCrossSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> middle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leftMax = constMinInt;</span><br><span class="line">        <span class="keyword">int</span> rightMax = constMinInt;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// left</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=middle; i&gt;=low; --i) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; leftMax) &#123;</span><br><span class="line">                leftMax = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// right</span></span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=middle+<span class="number">1</span>; i&lt;=high; ++i) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; rightMax) &#123;</span><br><span class="line">                rightMax = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> leftMax+rightMax;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span> leftMax, <span class="keyword">int</span> rightMax, <span class="keyword">int</span> crossMax)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (leftMax&gt;=rightMax &amp;&amp; leftMax&gt;=crossMax) &#123;</span><br><span class="line">            <span class="keyword">return</span> leftMax;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (rightMax&gt;=leftMax &amp;&amp; rightMax&gt;=crossMax) &#123;</span><br><span class="line">            <span class="keyword">return</span> rightMax;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> crossMax;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个算法在写的过程中，在getMax时候出现了一点问题，即&gt;=写成了&gt;，造成在获取最大值的时候出现了一点问题，提交后问题解决。</p><p>T(n) = 2T(n/2) + O(n)，根据主定理，复杂度是nlgn.</p><p>还有一个要思考的是对最大子数组的思考。将数组每个元素位置看成横坐标，值看成纵坐标，求和的过程其实是积分的过程，这样，最大子数组，其实是在求这个数组表达的函数的定积分。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本题是 Leecode的53.Maximum Subarray&lt;/p&gt;
    
    </summary>
    
      <category term="练习" scheme="http://yoursite.com/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>ARTS第一周</title>
    <link href="http://yoursite.com/2019/03/24/%E7%AC%AC%E4%B8%80%E5%91%A8ARTS/"/>
    <id>http://yoursite.com/2019/03/24/第一周ARTS/</id>
    <published>2019-03-24T15:22:45.000Z</published>
    <updated>2019-04-01T01:17:34.848Z</updated>
    
    <content type="html"><![CDATA[<p>第一周打卡<br><a id="more"></a></p><h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><p><a href="https://sunyanfeng.cn/2019/03/24/%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/#more" target="_blank" rel="noopener">求两个排序数组的中位数</a></p><h1 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h1><p>Socket.io:优点、缺点、丑陋<br>原文地址：(Socket.io — The Good, the Bad, and the Ugly)[<a href="https://dzone.com/articles/socketio-the-good-the-bad-and-the-ugly]" target="_blank" rel="noopener">https://dzone.com/articles/socketio-the-good-the-bad-and-the-ugly]</a></p><p>本周在做一个消息服务过程中，使用了Socket.io这个模块，并对这个模块进行了简单的分析，这里不再记录，在搜索过程中，发现了这篇由James Roper发表DZone上的文章，觉得比较适合做Review。</p><p>这里抛开它对socket.io不谈，我觉得他说的价值观还不错：</p><ol><li>他强烈的支持反应式系统，这种系统相应，弹性，可扩展，并且是消息驱动的</li><li>他支持高生产率的软件开发的工具、lib以及框架</li><li>他认为好的定义标准以及接口能最大化两个解耦实现之间的兼容性</li></ol><p>这里他说的这几个特点，与陈皓老师在技术领导力以及分布式系统架构的一些观念类似，比如提高效率的事，分布式架构之间解耦的过程等</p><h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><p><a href="https://sunyanfeng.cn/2019/03/24/Matrix-Projection/#more" target="_blank" rel="noopener">Matrix Projection</a></p><h1 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h1><p><a href="https://sunyanfeng.cn/2019/03/21/%E7%94%B1%E4%B8%80%E4%B8%AASelect%E5%BC%95%E8%B5%B7%E7%9A%84%E6%8E%A2%E7%B4%A2/#more" target="_blank" rel="noopener">由一个Select引起的探索</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一周打卡&lt;br&gt;
    
    </summary>
    
      <category term="ARMS" scheme="http://yoursite.com/categories/ARMS/"/>
    
    
  </entry>
  
  <entry>
    <title>Matrix Projection</title>
    <link href="http://yoursite.com/2019/03/24/Matrix-Projection/"/>
    <id>http://yoursite.com/2019/03/24/Matrix-Projection/</id>
    <published>2019-03-24T15:08:56.000Z</published>
    <updated>2019-04-01T01:21:18.523Z</updated>
    
    <content type="html"><![CDATA[<p>本周完成了Gilbert Strang线性代数的正交、投影、正交矩阵的学习，课程中的Lesson14～Lesson17</p><p>笔记都是用课程中手记的，这里只做一个简单的记录。</p><a id="more"></a><h1 id="Orthogonal-正交"><a href="#Orthogonal-正交" class="headerlink" title="Orthogonal 正交"></a>Orthogonal 正交</h1><ol><li>两个向量正交的定义</li><li>子空间正交： row space is orthogonal to null space;<pre><code>column space is orthogonal to null space of A tranpose</code></pre></li><li><p>正交的意义：the best solution Ax=b when there is no solution</p><pre><code>which means seperate the nosize from the infomation.A^T&lt;/sup&gt;AX = A&lt;sup&gt;T&lt;/sup&gt;b</code></pre></li></ol><h1 id="Projection投影"><a href="#Projection投影" class="headerlink" title="Projection投影"></a>Projection投影</h1><ol><li>向量投影</li><li>矩阵投影</li><li>投影矩阵</li><li>最小二乘法</li></ol><p>这一部分已经充分说明了一个基本认知：矩阵就是向量。主要研究的是投影矩阵，因为任何向量与它想乘都会映射到相应的空间中。这里对最小二乘法的矩阵解释也很令人印象深刻。</p><h1 id="Orthonomal-Matrix-正交矩阵"><a href="#Orthonomal-Matrix-正交矩阵" class="headerlink" title="Orthonomal Matrix 正交矩阵"></a>Orthonomal Matrix 正交矩阵</h1><p>正交矩阵就是一个向量空间两两垂直的向量组成的一组基。<br>它的好处是简化了投影运算效率</p><ol><li>正交矩阵的定义与意义</li><li>求解正交矩阵的方法：Gramh-schmit方法，（其实就是不断减p然后归一化的过程）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周完成了Gilbert Strang线性代数的正交、投影、正交矩阵的学习，课程中的Lesson14～Lesson17&lt;/p&gt;
&lt;p&gt;笔记都是用课程中手记的，这里只做一个简单的记录。&lt;/p&gt;
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Matrix" scheme="http://yoursite.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>求两个排序数组的中位数</title>
    <link href="http://yoursite.com/2019/03/24/%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://yoursite.com/2019/03/24/求两个排序数组的中位数/</id>
    <published>2019-03-24T00:06:42.000Z</published>
    <updated>2019-04-01T00:58:16.177Z</updated>
    
    <content type="html"><![CDATA[<p>这道题，我并没有完全解答，但从中锻炼了对分治法的理解。</p><a id="more"></a><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p><p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p><p>You may assume nums1 and nums2 cannot be both empty.</p><p>Example 1:</p><p>nums1 = [1, 3]<br>nums2 = [2]</p><p>The median is 2.0<br>Example 2:</p><p>nums1 = [1, 2]<br>nums2 = [3, 4]</p><p>The median is (2 + 3)/2 = 2.5</p><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = nums1.size() + nums2.size();</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// this should throw an error</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums1.size()!=<span class="number">0</span> &amp;&amp; nums2.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>; c&lt;count;++c)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i] &lt; nums2[j])&#123;</span><br><span class="line">                    nums.push_back(nums1[i]);</span><br><span class="line">                    i++;</span><br><span class="line">                    <span class="keyword">if</span>(i==nums1.size())&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    nums.push_back(nums2[j]);</span><br><span class="line">                    j++;</span><br><span class="line">                    <span class="keyword">if</span>(j==nums2.size())&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(i==nums1.size() &amp;&amp; j&lt;nums2.size())&#123;</span><br><span class="line">                <span class="keyword">while</span>(j!=nums2.size())&#123;</span><br><span class="line">                    nums.push_back(nums2[j++]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(j==nums2.size() &amp;&amp; i&lt;nums1.size())&#123;</span><br><span class="line">                <span class="keyword">while</span>(i!=nums1.size())&#123;</span><br><span class="line">                    nums.push_back(nums1[i++]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums1.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;nums2.size(); ++k)&#123;</span><br><span class="line">                nums.push_back(nums2[k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums2.size() == <span class="number">0</span>)&#123;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;nums1.size(); ++k)&#123;</span><br><span class="line">                nums.push_back(nums1[k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> ret = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = count/<span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(count%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            ret = ((<span class="keyword">double</span>)(nums[m<span class="number">-1</span>]+nums[m]))/<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ret = nums[m];</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上答案是一种m+n的算法，虽然通过了，但并不符合复杂度的要求。</p><p>于是进行了第二次的思考，这里选的题目本身，是分治标签下的，上述算法是归并排序中一步的做法，然后就思考怎样用分治的想法来实现。<br>另一种思路是，分治应该是在什么维度上进行分治，本身应该类似于数学归纳法的方式。在维度上既然是数组，就采用数组元素的方式来分。首先思考的是如果两个表，慢慢增加元素会是什么样的，1-0,1-1,2-1,3-2，2-2，这样发现一种可以递归的方式，即每次拿一个数组的最大值与另一个数组的最大值对比去掉最大的，最小值与最小值对比去掉最小的，这样，如果总和为奇数剩余1个，为最后结果，为偶数剩余2个，其平均值为最后结果。<br>回头意向这个复杂度也不是ln(m+n)，而是(m+n)/2，比上一种算法略有提升。</p><p>那最后就看一下提供的解法吧<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = A.length;</span><br><span class="line">        <span class="keyword">int</span> n = B.length;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) &#123; <span class="comment">// to ensure m&lt;=n</span></span><br><span class="line">            <span class="keyword">int</span>[] temp = A; A = B; B = temp;</span><br><span class="line">            <span class="keyword">int</span> tmp = m; m = n; n = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> iMin = <span class="number">0</span>, iMax = m, halfLen = (m + n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (iMin &lt;= iMax) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = (iMin + iMax) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> j = halfLen - i;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; iMax &amp;&amp; B[j-<span class="number">1</span>] &gt; A[i])&#123;</span><br><span class="line">                iMin = i + <span class="number">1</span>; <span class="comment">// i is too small</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; iMin &amp;&amp; A[i-<span class="number">1</span>] &gt; B[j]) &#123;</span><br><span class="line">                iMax = i - <span class="number">1</span>; <span class="comment">// i is too big</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// i is perfect</span></span><br><span class="line">                <span class="keyword">int</span> maxLeft = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123; maxLeft = B[j-<span class="number">1</span>]; &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123; maxLeft = A[i-<span class="number">1</span>]; &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; maxLeft = Math.max(A[i-<span class="number">1</span>], B[j-<span class="number">1</span>]); &#125;</span><br><span class="line">                <span class="keyword">if</span> ( (m + n) % <span class="number">2</span> == <span class="number">1</span> ) &#123; <span class="keyword">return</span> maxLeft; &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> minRight = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (i == m) &#123; minRight = B[j]; &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j == n) &#123; minRight = A[i]; &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; minRight = Math.min(B[j], A[i]); &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> (maxLeft + minRight) / <span class="number">2.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题，我并没有完全解答，但从中锻炼了对分治法的理解。&lt;/p&gt;
    
    </summary>
    
      <category term="练习" scheme="http://yoursite.com/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>由一个Select引起的探索</title>
    <link href="http://yoursite.com/2019/03/21/%E7%94%B1%E4%B8%80%E4%B8%AASelect%E5%BC%95%E8%B5%B7%E7%9A%84%E6%8E%A2%E7%B4%A2/"/>
    <id>http://yoursite.com/2019/03/21/由一个Select引起的探索/</id>
    <published>2019-03-21T09:48:41.000Z</published>
    <updated>2019-04-01T00:58:16.177Z</updated>
    
    <content type="html"><![CDATA[<p>好久没有写问题处理类的博客了，正好今天解决了一个小问题，而且时间还有些，就写一下吧，作为本周的一share。</p><a id="more"></a><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>背景是这样的，今天帮人写了一个查询语句，用于查询一个1（表A）对多（表B）关系中，表B的一个字段的累加和。由于表A已经连接了多张表，而且我不太原因去动那段代码，就想着用表A的id从表B中去获取，而且她已经写好了一个接口来获取列表，我索性就直接在内存里计算了。代码就不贴了，这段代码效率比较低。<br>    问题出现了，我拿出来的数据莫名变成了字符串，数据相加以后成了字符串相加。”50”+”100” = “50100”.</p><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>出现问题咱就处理吧，首先去看一下表结构:<br><img src="表结构.png" alt="表结构"><br>字段是amount 类型是numeric,是数字没问题。</p><p>然后就怀疑是不是存储的时候是字符串，就去调试了一下，发现并没有问题。</p><p>那现在就是存的时候是数字，数据库里也是数字，而读取出来的是字符串。那问题肯定就是读取的时候出现问题了，读取时候调用的是node.js中’pg’这个模块，那就移步到这里去看一下。</p><p>pg模块中的目录如下：<br><img src="pg目录结构.png" alt="pg目录结构"><br>既然怀疑是读取时候出现了问题，从这个结构中，就直接去看结果的处理部分：result.js。在这其中，发现对每个Field都有一个对应的parser，那问题自然就归结到这个Parser上了。</p><p>这个Parser是从’pg-types’中引用而来，那就从pg-types中去看一下<br>在这里定义了3个Parse，arrayParser、binaryParsers、textParsers，在index.js中，通过<code>setTypeParser</code>来设置相应类型的parese，通过<code>getTypeParser</code>来获取。在这里并没有看出问题，然后看了一下这个库的test，这里看到</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bignum = <span class="string">'31415926535897932384626433832795028841971693993751058.16180339887498948482045868343656381177203091798057628'</span></span><br><span class="line">exports.numeric = &#123;</span><br><span class="line">format: <span class="string">'text'</span>,</span><br><span class="line">id: <span class="number">1700</span>,</span><br><span class="line">tests: [</span><br><span class="line">    [bignum, bignum]</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它其实是将numeric放到text这种format下，解析出来的自然就是text了。</p><p>既然是有意将numeric当成text来处理，那就numeric这种类型就要注意一下，在pgsql的官方文档中对其论述为：</p><p>numeric类型可以存储非常大的数字并且准确地进行计算。 我们特别建议将它用于货币金额和其它要求精确计算的场合。不过， numeric类型上的算术运算比整数类型或者我们下一节描述的浮点数类型要慢很多。</p><p> 一个numeric类型的标度 (scale)是小数部分的位数，精度(precision) 是全部数据位的数目，也就是小数点两边的位数总和。 因此数字 23.5141 的精度为 6 而标度为 4 。你可以认为整数的标度为零。</p><p>这样可以思考numeric本身用来处理很大的浮点数，这种数字转换成text也能理解了</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>由于我们的数字比较小，也就修改了一下表结构，将这numeric变成了real，这样问题就解决了。当然也可以通过ParseFloat来从表层处理一下。</p><h1 id="探索"><a href="#探索" class="headerlink" title="探索"></a>探索</h1><p>下边会探索一下pg的结构。这里时间限制，简单写一下依赖关系：<br>index.js中做聚合，聚合了client、Query、Connection、Pool等模块，<br>Client中依赖Connection,通过调用Connection来完成其业务<br>Connect中，依赖net.Socket来完成对postgresql的链接，以及在链接之上的接口；<br>在Client中还还依赖Query，并有一个queryQueue，来异步处理各个请求。<br>在Query中，依赖一个Result模块，来对返回的数据进行解析，其调用了以上的parse模块。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久没有写问题处理类的博客了，正好今天解决了一个小问题，而且时间还有些，就写一下吧，作为本周的一share。&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="node.js" scheme="http://yoursite.com/tags/node-js/"/>
    
      <category term="pgsql" scheme="http://yoursite.com/tags/pgsql/"/>
    
  </entry>
  
  <entry>
    <title>关于技术领导力的思考</title>
    <link href="http://yoursite.com/2019/03/19/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF%E9%A2%86%E5%AF%BC%E5%8A%9B/"/>
    <id>http://yoursite.com/2019/03/19/关于技术领导力/</id>
    <published>2019-03-19T06:14:00.000Z</published>
    <updated>2019-04-01T00:58:16.177Z</updated>
    
    <content type="html"><![CDATA[<p> 本文从极客时间《左耳听风》触发而来。</p><a id="more"></a><h1 id="何为技术领导力"><a href="#何为技术领导力" class="headerlink" title="何为技术领导力"></a>何为技术领导力</h1><p>陈老师的技术领导力定义：</p><ul><li>尊重技术，追求核心基础技术</li><li>追逐自动化的高效率的工具和技术，同时避免无效率的组织架构和管理</li><li>解放生产力，追逐人效的提高</li><li>开发抽象和高质量的可以重用的技术组件</li><li>坚持高于社会主流的技术标准和要求</li></ul><p>这些语言对我来说有些离散，我需要重新逻辑化一下</p><ul><li>追求核心基础技术</li><li>由核心基础技术派生的高质量、可重用的技术组件</li><li>由技术、技术组件而形成的工具，提高效率与人效</li><li>在这些工具之上，进行合理的组织架构与管理</li></ul><h1 id="拥有技术领导力需要的特质"><a href="#拥有技术领导力需要的特质" class="headerlink" title="拥有技术领导力需要的特质"></a>拥有技术领导力需要的特质</h1><p>陈老师的技术领导力特质</p><ul><li>能够发现问题</li><li>能够提供解决问题的思路和方案，并能比较这些方案的优缺点</li><li>能够作出正确的技术决定</li><li>能够用更优雅，更简单，更容易的方式来解决问题</li><li>能够提高代码或软件的扩展性、可重用性和可维护性</li><li>能够用正确的方式管理团队：正确的人干正确的事，提高团队的人效</li><li>创新能力</li></ul><p>同样，也需要逻辑化一下</p><ul><li>发现问题能力</li><li>寻找最佳解决方案的能力</li><li>优雅、高效实现方案的能力</li><li>发现、培养他人拥有以上能力的能力</li></ul><h1 id="如何才能拥有技术领导力"><a href="#如何才能拥有技术领导力" class="headerlink" title="如何才能拥有技术领导力"></a>如何才能拥有技术领导力</h1><p>陈老师在文章中举出了4点，这里只节选2点即可，其余两点价值观更重一些</p><ul><li><p>吃透基础技术</p><ul><li><p>编程部分</p><p>C语言，推荐《C程序设计语言（第二版）》</p><p>编程范式，面向对象变成，泛型编程，函数式编程</p><p>算法和数据结构</p></li><li><p>系统部分</p><p>计算机系统原理。推荐《深入理解计算机系统》</p><p>操作系统原理和基础。cpu，内存，硬盘，中断。推荐《UNIX环境高级编程》、《UNIX网络编程》《Windows核心编程》，可以让你更能从本质理解各种语言或者技术的底层原理（这一步似乎少了编译原理）。</p><p>网络基础。推荐《TCP/IP详解》</p><p>数据库原理。SQL与NoSQL，用于数据性能调优</p><p>分布式技术架构。包括负载均衡、DNS解析、多子域名、无状态应用层、缓存层、数据库分片、容错和恢复机制、Paxos、MR操作、分布式SQL数据库的一致性等。</p></li></ul><p>ps：这一部分比较硬核，也比较干，对于技术联系并没有叙述，我这里也不去说了。</p></li><li><p>提高学习能力</p><ul><li>学习的信息源，Quora、Stack Overflow,书，API、论文、博客</li><li>与高手交流</li></ul></li></ul><h1 id="我的思考"><a href="#我的思考" class="headerlink" title="我的思考"></a>我的思考</h1><h2 id="关于技术"><a href="#关于技术" class="headerlink" title="关于技术"></a>关于技术</h2><p>技术理念</p><ul><li>技术概念中包含实践性;切忌光学不练</li><li>技术概念中包含着理论性;所有光练不学，也是不对的</li><li>可以想像这个模型，技术底层是理论，技术上层是产品，底层的变动要比上层会慢，但来的更有变革性，产品。产品因人而异，因人而变，变化也就很多啦，但不论怎么变，也受技术的制约。</li><li>技术与艺术创作可以类比，若只固守，或者人云亦云，成就不了伟大，只有那些创新，那些拓展技术边界的创新，才能称得上伟大。（技术想象力）</li></ul><p>技术问题</p><ul><li>每一种技术，都是面向问题的，这个问题是什么？</li><li>对于这个问题，如果让你来实现，如何来做？</li><li>技术是如何解决面向的问题？</li><li><p>对比自己的做法与技术的做法，既可以丰富思维，也可以找到技术的不足</p></li><li><p>技术既然是发展的，那承前启后了哪些技术？（技术发展观）</p></li><li>这些技术面向的问题又有怎样的变化？</li><li>由此也就培养了技术鉴赏能力。（技术鉴赏力）</li></ul><h1 id="关于领导力"><a href="#关于领导力" class="headerlink" title="关于领导力"></a>关于领导力</h1><ul><li>领导力这个概念中包含着团队，所以是关于人的</li><li>领导，指引道路；领导力也就是指引的能力；技术领导力也就是在技术方面指引方向的能力啦</li><li>领导力与管理力有区别，有联系</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 本文从极客时间《左耳听风》触发而来。&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>中序遍历二叉树</title>
    <link href="http://yoursite.com/2019/03/16/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2019/03/16/中序遍历二叉树/</id>
    <published>2019-03-16T14:08:33.000Z</published>
    <updated>2019-04-01T00:58:16.177Z</updated>
    
    <content type="html"><![CDATA[<p> 本文是第一周ARMS挑战的Algorithm部分，也是为了熟悉一下Leetcode，选择了一个中序遍历二叉树。其中递归方式很快就完成、通过，但迭代方式花了一点时间，也终于通过啦，主要对迭代方式进行分析。</p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>Given a binary tree, return the inorder traversal of its nodes’ values.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [1,3,2]</span><br></pre></td></tr></table></figure></p><p>Follow up: Recursive solution is trivial, could you do it iteratively?</p><h1 id="递归方式"><a href="#递归方式" class="headerlink" title="递归方式"></a>递归方式</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vecVal;</span><br><span class="line">        recursiveTraversalNode(root, vecVal);        </span><br><span class="line">        <span class="keyword">return</span> vecVal;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recursiveTraversalNode</span><span class="params">(TreeNode * root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vecVal)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            recursiveTraversalNode(root-&gt;left, vecVal);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vecVal.push_back(root-&gt;val);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            recursiveTraversalNode(root-&gt;right, vecVal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="迭代方式"><a href="#迭代方式" class="headerlink" title="迭代方式"></a>迭代方式</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vecValue;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode *&gt; stackTreeNode;</span><br><span class="line">        </span><br><span class="line">        TreeNode *p = root;</span><br><span class="line">        <span class="keyword">while</span>(!stackTreeNode.empty() || p!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                stackTreeNode.push(p);</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                p = stackTreeNode.top();</span><br><span class="line">                stackTreeNode.pop();</span><br><span class="line">                </span><br><span class="line">                vecValue.push_back(p-&gt;val);</span><br><span class="line">                p = p-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> vecValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在迭代方式中，二叉树的指针一定会先遍历最深的left，然后返回遍历父节点，再遍历右节点，结构体中并没有指向父元素的指针，也就是要缓存一下父元素的指针，递归一下，所有的左侧线路上所有的父节点都需要缓存，而且每次完成指向父节点时，都是取最近的一个指针，那这种缓存的结构很自然就想到了stack。这步完成的比较顺利，只是没写C++了一开始想用vector来当stack用，但vector在获取最后一个节点时，处理的不太优雅，其实stack相对会好点，其实感觉pop直接返回数据，更方便一些。</p><p>出现了2个问题：一是入栈时候并没有入到叶子节点，造成出栈时处理的问题；二是在循环的判断上，对循环的结束只思考成stack的empty()。第二遍写的时候，很自然就解决了第一个问题，接着解决了第二个问题，也就顺利通过啦。</p><p>错误代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode&gt; stackNode;</span><br><span class="line">        TreeNode *p = root;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(p == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                p = stackNode.top();</span><br><span class="line">                stackNode.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;left != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                stackNode.push(p);</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                vecVal.push_back(p-&gt;val);</span><br><span class="line"></span><br><span class="line">                p = stackNode.top();</span><br><span class="line">                stackNode.pop();</span><br><span class="line">                </span><br><span class="line">                vecVal.push_back(p-&gt;val);</span><br><span class="line">                </span><br><span class="line">                p = p-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">while</span>(!stackNode.empty());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h1><p>树的遍历有3种，preorder、inorder、postorder,题目给的是inorder方式，后边需要对其余两种进行练习。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 本文是第一周ARMS挑战的Algorithm部分，也是为了熟悉一下Leetcode，选择了一个中序遍历二叉树。其中递归方式很快就完成、通过，但迭代方式花了一点时间，也终于通过啦，主要对迭代方式进行分析。&lt;/p&gt;
    
    </summary>
    
      <category term="练习" scheme="http://yoursite.com/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>旅途</title>
    <link href="http://yoursite.com/2019/03/16/%E6%97%85%E9%80%94/"/>
    <id>http://yoursite.com/2019/03/16/旅途/</id>
    <published>2019-03-16T02:27:59.000Z</published>
    <updated>2019-04-01T00:58:16.177Z</updated>
    
    <content type="html"><![CDATA[<p>  这周机缘巧合之下，参加了陈皓老师的ARTS的挑战，作为一段路途的起点，应该立个flag来表达一下决心，同时需要对这段旅途做一个规划，并论述一下旅途中潜在的问题。</p><a id="more"></a><h1 id="机缘"><a href="#机缘" class="headerlink" title="机缘"></a>机缘</h1><p>与陈老师的机缘应该从coolshell中的那篇《程序员练级攻略》开始，很多技术书籍的选择也是听从了这篇博文中的建议，这是其一；</p><p>回首毕业到现在，自己在技术的广度方面已经有了很多的积累，由C++，到了Java Web栈，到了Hadoop栈，到了我最爱的数据分析栈与机器学习栈，到近来node微服务架构的学习。但在广度之外，深感自己在技术深度方面的不足，于是想在深度方面下一番功夫，这是其二；</p><p>年初开始极客时间的体验，一个月的vip每日一课，可惜更新不足，很多课程看到1/3也就可以了，后有订阅了一个微服务架构栏目，认可了栏目这种方式。刚看完微服务架构，碰到陈老师的ARTS挑战三期，这是其三。</p><h1 id="由ARTS到ARMS"><a href="#由ARTS到ARMS" class="headerlink" title="由ARTS到ARMS"></a>由ARTS到ARMS</h1><p>ARTS挑战是 Algorithm、Review、Tip、Share，具体要求：<br>（1）每周至少做一个 leetcode 的算法题<br>（2）阅读并点评至少一篇英文技术文章<br>（3）学习至少一个技术技巧<br>（4）分享一篇有观点和思考的技术文章</p><p>ARTS挑战是一个习惯的养成，于我而言，已经有了的自己的学习的习惯或者生态，那就借鉴陈老师的ARTS概念，来夯实自己的学习生态。在这4条挑战中</p><p>Algorithm，虽然自己看过很多算法书、视频，但在训练上确实不够，这也是陈老师所说的没有训练看再多也没用的典型代表，而leetcode是一种方式，并没有规定路线，那我就选择按导论中的顺序挑选题目来进行训练，这样会更全面一些。</p><p>Review，应该是评论的意思，在英文方面，我已经迈过了这道坎，所以并不需要刻意去，以后的google过程中，我会更多使用英语来搜索，至于评论或者叫读后的思考，这个就从陈老师的栏目开始吧，结果刚结束的微服务架构，对提到的内容、技术做一个深入的探索。</p><p>Tip，我觉得指的是技术工具，分析、检测工具的使用，这个于当下，可以做一些变通，那就依据我的习惯，改成Math吧，课程依据原来的计划进行。</p><p>Share，我就用我的博客来做share，内容还是保持现有发布的技术性文章，主要是想将Review到的内容share在这里。数学方面的整理，md写数学公式以及矩阵，较为麻烦，写作成本有点高，可能会写一些的纲领性概念。对于我的哲学思考，就先不对外发布了。纠结了一下要不要开启评论，想想先作罢了,这源于我对信息爆炸时代的看法，让我去寻找，不要推送给我。</p><p>那这样就改成ARMS，跟学生时代用的芯片架构很像，挺美。</p><h1 id="矛盾"><a href="#矛盾" class="headerlink" title="矛盾"></a>矛盾</h1><p>在这里也要写一下现实的冲突与内心的冲突。</p><p>本阶段产品的开发效果来看，业务逻辑需要进一步的梳理与优化，产品如此复杂难以用起来，需要进一步简化;开发架构上，由总监开发的node后端框架已经影响到了后端的效率，并造成了代码可维护性的问题;团队成员水平有限，很多时候顶不上，一片败象之下我却想努力一把，不仅源于我对徐老师（老板）的认可，我不想善良、正直的人输的很惨，也源于我对旅途的看法，<strong>每一段旅途，都是生命最美好的馈赠（the best gift of life）</strong>，每一份工作都是一段旅途，如果不去努力，如何对得起这gift。</p><p>接下来的时间，势必耗费极大的精力，这又与ARTS产生了一些冲突，我并不处于当年陈老师简单完成任务而可以追求技术精深的处境上。好在是一周一个循环，需要我好好安排一下时间。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  这周机缘巧合之下，参加了陈皓老师的ARTS的挑战，作为一段路途的起点，应该立个flag来表达一下决心，同时需要对这段旅途做一个规划，并论述一下旅途中潜在的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="ARMS" scheme="http://yoursite.com/categories/ARMS/"/>
    
    
  </entry>
  
  <entry>
    <title>微服务架构</title>
    <link href="http://yoursite.com/2019/03/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    <id>http://yoursite.com/2019/03/12/微服务架构/</id>
    <published>2019-03-11T16:00:00.000Z</published>
    <updated>2019-03-16T04:27:23.300Z</updated>
    
    <content type="html"><![CDATA[<p>本文整理的极客时间中，杨波讲的微服务架构<br><a id="more"></a><br>本来打算把杨老师的图重新画完，一来做一个复习，二来也避免一些问题，但由于时间有限，就一起跟旅途发出来了，若有不妥，请联系我，联系方式见博客的关于。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><img src="overview.png" alt="概述"><br>整个分层体系如上图所示，底层是基础设施，主要是硬件iaas层。往上是平台服务paas层，包括发布系统，集群资源调度，镜像治理，资源治理等，在这层我们的镜像使用阿里的镜像仓库，集群资源调度使用的k8s。再网上是支撑服务，这一部分是课程的重点，包括服务发现，集中配置，容错限流，日志聚合，监控告警，这一层后变各节进行分述。再上一层是业务服务，在业务服务里，这里也分成了2层，聚合服务与基础服务，聚合服务对不同的接入进行相应，并调用基础服务，对web端、手机端、第三方接入提供不同的聚合服务。再一层是网关，网关就像是aop，对接入进行控制、检查等，对网关也会进行分述。</p><p>提出一个重要的思想：系统架构与组织结构相一致<br><img src="微服务团队组织.png" alt="微服务团队组织"></p><p>提出了中台战略</p><p><img src="阿里大中台战略.png" alt="阿里大中台战略"></p><h1 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h1><p><img src="网关整体.jpg" alt="网关整体"><br><img src="zuul网关1.jpg" alt="zuul网关"><br><img src="zuul网关2.jpg" alt="zuul网关"></p><h1 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h1><p><img src="服务发现.jpg" alt="服务发现"></p><h1 id="通讯-jpg"><a href="#通讯-jpg" class="headerlink" title="通讯.jpg"></a>通讯.jpg</h1><p><img src="通讯.jpg" alt="通讯"></p><h1 id="集中配置"><a href="#集中配置" class="headerlink" title="集中配置"></a>集中配置</h1><p><img src="配置中心1.jpg" alt="配置中心"><br><img src="配置中心2.jpg" alt="配置中心"></p><h1 id="熔断限流"><a href="#熔断限流" class="headerlink" title="熔断限流"></a>熔断限流</h1><p><img src="熔断限流1.jpg" alt="熔断限流1"><br><img src="熔断限流2.jpg" alt="熔断限流"></p><h1 id="日志聚合"><a href="#日志聚合" class="headerlink" title="日志聚合"></a>日志聚合</h1><p><img src="日志聚合1.jpg" alt="日志聚合"><br><img src="日志聚合2.jpg" alt="日志聚合"></p><h1 id="监控告警"><a href="#监控告警" class="headerlink" title="监控告警"></a>监控告警</h1><p><img src="监控告警1.jpg" alt="监控告警1"><br><img src="监控告警2.jpg" alt="监控告警2"></p><h1 id="资源调度"><a href="#资源调度" class="headerlink" title="资源调度"></a>资源调度</h1><p><img src="资源调度.jpg" alt="资源调度"></p><h1 id="镜像中心"><a href="#镜像中心" class="headerlink" title="镜像中心"></a>镜像中心</h1><p><img src="镜像中心.jpg" alt="镜像中心"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文整理的极客时间中，杨波讲的微服务架构&lt;br&gt;
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="架构" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="微服务" scheme="http://yoursite.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>《简约至上》</title>
    <link href="http://yoursite.com/2019/03/03/%E7%AE%80%E7%BA%A6%E8%87%B3%E4%B8%8A%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/03/03/简约至上总结/</id>
    <published>2019-03-03T11:36:00.000Z</published>
    <updated>2019-03-11T03:08:53.609Z</updated>
    
    <content type="html"><![CDATA[<p>书中分成8章来讲述，其中第一章介绍什么是简单，为什么要简单，第二章了产品设计的步骤，由人物、场景而到情节来设计产品的逻辑，第三章总的来介绍了4种策略：删除、组织、隐藏、转移，后四章对4种策略的分述，最后一章所示算是结语。<br><a id="more"></a></p><p>前几天写了一个读书方法论，是从读这本书体会到的一个认知方法，那现在，将通过这个方法中想到的3个层次来总结一下这本书。</p><h1 id="具体设计"><a href="#具体设计" class="headerlink" title="具体设计"></a>具体设计</h1><ul><li><p>错误提示的挫败感:对时间选择的设计<br><img src="错误提示.png" alt="错误提示的挫败感"></p></li><li><p>认知分层:地铁线路的颜色设计<br><img src="地铁.png" alt="认知分层"></p></li><li><p>突出重点：对万豪酒店页面的重新设计<br><img src="万豪网站.png" alt="突出重点"></p></li><li><p>网格优化<br><img src="网格.png" alt="网格优化"></p></li><li><p>渐进展示：保存<br><img src="保存.jpeg" alt="渐进展示"></p></li><li><p>期望路径与实际路径<br><img src="期望路径.png" alt="期望路径"> </p></li></ul><h1 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h1><ul><li><p>产品使用环境分析：</p><p>  办公室：容易受打扰</p><p>  家中：电视剧空隙</p><p>  户外：繁忙</p></li><li><p>用户分类</p><p>  专家用户：发烧友、高级用户</p><p>  随意用户：用过类似产品，对新功能要求简单，中级用户</p><p>  主流用户：有需要才会用的，问题导向型用户</p></li><li><p>产品与故事</p><p>  产品的概念包括了使用者、使用环境，以及在什么情节中使用，这就构成了一个故事情节。</p><p>  故事情节需要从观察使用者出发，然后从众多场景中，抽象出故事。故事中包含着需求与产品的特点</p><p>  故事的精进还需要与不同的人去讲述，看其对故事（产品）的反馈，反馈的过程可以借助于原型与竞品。</p></li><li><p>墨水率<br> 并通过提出了一个有趣的概率：数据墨水率，墨水（像素）不应该浪费在那些不是内容或者重要的内容上。</p></li></ul><h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><ul><li><p>整体原则</p><ul><li><p>办公室里假如用户来讨论需求是无效的</p></li><li><p>最好的观察用户的途径是从竞品与原型来观察用户的需要</p></li><li><p>用户并不知道自己提出需求所带来的负面作用</p></li></ul></li><li><p>删除原则</p><ul><li><p>紧跟核心，去掉不必要的功能，去掉不完善的功能，强化核心功能</p></li><li><p>突出重点可以用颜色与大小来提示<br>颜色只用在最关键的一两点上<br>大小而不是粗体提示重要的内容，非关键的尽量是小字体，原文是如果这个内容重要程度是1/2，那么使用1/4的字体。</p></li><li><p>颜色也常用来表达认知分层</p></li><li><p>尽量避免错误提示，这样会给用户带来挫败感</p></li><li><p>尽量避免结构化表单，这样会给人以约束</p></li><li><p>能用图片就用图片，能少用文字就少用文字，精简文字，去掉冗余的描述</p></li><li><p>尽量避免打扰用户的注意力，使其分心</p></li><li><p>避免给用户过多的选择，过多的选择让人无法选择<br>为用户提供更少的选择，并为选择提供默认选项</p></li><li><p>有选择尽量又默认选项</p></li></ul></li><li><p>组织原则</p><ul><li><p>使用组织时，最重要是只强调一两个最重要的主题<br>围绕这些主题进行分块，这些主题本身是根据用户行为来分类</p></li><li><p>最好先对内容有效的组织，然后再考虑如何设计搜素</p></li><li><p>按时间与空间来组织</p></li><li><p>控制信息的层次，不超过3层，标题、子标题、正文。<br>降低控制信息，如网格，加粗，用均匀的浅色代替</p></li><li><p>避免用户自定义界面，用户往往不知道如何最有效布置</p></li><li><p>渐进展示内容，普通用户使用默认的简单功能，而必要时候可以选择更细节的功能</p></li><li><p>避免使用“高级”等字眼，会给人以被鄙视的暗示</p></li></ul></li><li><p>转移原则</p><ul><li><p>手机端与电脑端的差异：手机端不适合录入文字，并且是及时使用</p></li><li><p>人与电脑的差异：人更是个与计划，电脑更适合与记录</p></li></ul></li><li><p>隐藏原则</p><ul><li>不得不存在，但有很少用的，最佳案例是设置部分</li></ul></li></ul><h1 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h1><ul><li><p>产品的设计产生与对用户的观察、思考与想象。</p><p>想象的过程就像是写故事，人物、场景、情节，也就是某些人，在什么样的情况下，使用这个产品，这个场景中有哪些故事会发生。这种情况下，人们对产品有着怎样的需要，尤其指的是特点。</p></li><li><p>产品的设计像是写文章，铭记核心，删减与核心无关的内容</p></li><li><p>针对大众设计产品，而不是专家</p></li><li><p>用户并不知道它们提出的需求所带来的负面影响</p></li><li><p>简单并不是初见的简单，它是在扬起复杂之后的简单</p></li><li><p>所以最好的设计是大众与专家都觉得很舒服</p></li><li><p>用户喜欢掌控产品，而不是被产品所掌握</p></li><li><p>产品需要留白，给用户留有再创造的空间</p></li><li><p>认知分层</p></li><li><p>很多时候简约设计是把这个复杂性放在哪里的问题</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;书中分成8章来讲述，其中第一章介绍什么是简单，为什么要简单，第二章了产品设计的步骤，由人物、场景而到情节来设计产品的逻辑，第三章总的来介绍了4种策略：删除、组织、隐藏、转移，后四章对4种策略的分述，最后一章所示算是结语。&lt;br&gt;
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="产品" scheme="http://yoursite.com/tags/%E4%BA%A7%E5%93%81/"/>
    
  </entry>
  
  <entry>
    <title>数系</title>
    <link href="http://yoursite.com/2019/02/18/%E6%95%B0%E7%B3%BB/"/>
    <id>http://yoursite.com/2019/02/18/数系/</id>
    <published>2019-02-17T16:00:00.000Z</published>
    <updated>2019-02-18T01:05:34.740Z</updated>
    
    <content type="html"><![CDATA[<h1 id="起因：由激活函数所引发的对数系的探索"><a href="#起因：由激活函数所引发的对数系的探索" class="headerlink" title="起因：由激活函数所引发的对数系的探索"></a>起因：由激活函数所引发的对数系的探索</h1><ul><li><p>激活函数</p><p>先是看到了激活函数：</p><p>$f(x) = \frac{1}{1+e^{-x}} = \frac{e^x}{1+e^x}$</p></li><li><p>值域在[-1,1]之间对称的函数</p><p>然后想去构造一个新的函数</p><p>特点：$+\infty$趋向1，$-\infty$趋向-1,0处为0，并且对称。</p><p>$f(x) = \frac{e^x-1}{e^x+1}$</p><p>试过用其他基础函数，都办法实现，首先定义域得相同，难处在于两个极限处要变号。</p></li><li><p>基本函数</p><p>通过实验，发现幂函数系没有发现满足要求的形式。因为在无穷处要想趋向与1，只有除法可以，这样在正负无穷都是一样的。<br>在上述函数的构造过程中，也思考过作为基础函数的三角函数。但三角函数是一种周期函数，此处更不能用。</p><p>理解三角函数与圆离不开关系，这样自然而然的想起了复指数函数。</p></li><li><p>复指数函数</p><p>欧拉公式：<br>$e^{ix} = cosx + isinx$</p><p>欧拉公式的证明很有趣，既可以通过微分的方法，又可以通过积分的方法来证明。<br>这又引起了对复数的兴趣，要说复数，我们先从数系入手。</p></li></ul><h1 id="数系"><a href="#数系" class="headerlink" title="数系"></a>数系</h1><p>  人类了解数的过程，真是很艰难的过程，远远不是数学课本上的，实数、虚数、有理数、无理数、整数、分数等几个概念那么简单。</p><p>  以下内容摘自：<a href="http://shc2000.sjtu.edu.cn/030802/congjishu.htm" target="_blank" rel="noopener">从计数法到复数域</a></p><p>  自然数：</p><p>  自然数系是一个离散的、而不是稠密的数系，因此，作为量的表征，它只能限于去表示一个单位量的整数倍，而无法表示它的部分。同时，作为运算的手段，在自然数系中只能施行加法和乘法，而不能自由地施行它们的逆运算。这些缺陷，由于分数和负数的出现而得以弥补。</p><p>  分数与负数：</p><p>  分数都是有理数，非整除的都是无限循环小数。分数系是一个稠密的数系，它对于加、乘、除三种运算是封闭的。为了使得减法运算在数系内也同行无阻，负数的出现就是必然的了。</p><p>  无理数：</p><p>  有理数系的缺陷：一条直线上的有理数尽管是“稠密”，但是它却漏出了许多“孔隙”，而且这种“孔隙”多的“不可胜数”。这样。人们对微积分基础的关注，使得实数域的连续性问题再次突显出来。因为，微积分是建立在极限运算基础上的变量数学，而极限运算，需要一个封闭的数域。无理数正是实数域连续性的关键。</p><p>  无理数是什么？变量数学独立建造完备数域的历史任务，终于在19世纪后半叶，由维尔斯特拉斯（Weierstrass,1815- 1897）、戴德金（R.Dedekind1831- 1916、康托（G.Cantor,1845- 1918）等人加以完成了。1872年，实数的三大派理论：戴德金“分割”理论；康托的“基本序列”理论，以及维尔斯特拉斯的“有界单调序列”理论，同时在德国出现了。由“戴德金分割”定义的实数，是完全不依赖于空间与时间直观的人类智慧的创造物。</p><p>  复数：</p><p>  1545年，此时的欧洲人尚未完全理解负数、无理数，然而他们智力又面临一个新的“怪物”的挑战。例如卡丹在所著《重要的艺术》（1545）中提出一个问题：把10分成两部分，使其乘积为40。这需要解方程x (10-x) = 40，他求得的根是$5+\sqrt{-15}$和$5-\sqrt{-15}$. 对复数的模糊认识，莱布尼兹（Leibniz,1646- 1716）的说法最有代表性：“圣灵在分析的奇观中找到了超凡的显示，这就是那个理想世界的端兆，那个介于存在与不存在之间的两栖物，那个我们称之为虚的—1的平方根。”。在使人们接受复数方面，高斯(1777－1855)的工作更为有效。他不仅将 a+ bi 表示为复平面上的一点 ( a, b)，而且阐述了复数的几何加法和乘法。</p><p>  在澄清复数概念的工作中，爱尔兰数学家哈米尔顿（Hamilton,1805 – 1865） 是非常重要的。哈米尔顿所关心的是算术的逻辑，并不满足于几何直观。他指出：<strong>复数a+ bi 不是 2 ＋ 3意义上的一个真正的和，加号的使用是历史的偶然，而 bi 不能加到a 上去。复数a+ bi 只不过是实数的有序数对（a，b），并给出了有序数对的四则运算，同时，这些运算满足结合律、交换率和分配率</strong>。在这样的观点下，不仅复数被逻辑地建立在实数的基础上，而且至今还有点神秘的 也完全消除了。</p><h1 id="数、运算、函数"><a href="#数、运算、函数" class="headerlink" title="数、运算、函数"></a>数、运算、函数</h1><p>  函数是一种自变与因变关系，是一种因果、变化思维<br>  基础运算（+-×/乘法与开方）都是一种增减逻辑<br>  微积分是一种基于函数（变量）的极限逻辑</p><ul><li><p>数系的扩展与运算：</p><p>如小数与分数的出现与四则运算的完备相关；<br>无理数的出现起初与乘方、开方相关，后又与微积分相关；<br>复数的出现也与开方相关。</p></li><li><p>运算都有与之对应的逆运算</p><p>乘法对除法<br>乘方对开方<br>积分对微分</p></li><li><p>运算的律</p><p>结合律、交换律、分配率。<br>乘法结合律:(a×b)×c=a×(b×c)<br>乘法交换律:a×b=b×a<br>乘法分配律:(a+b)×c=a×c+b×c</p></li></ul><ul><li><p>初等运算都有与之对应的函数</p><p>基础运算：<br>乘方对应的(负)幂函数与指数函数<br>开方对应的对数函数</p><p>微积分：<br>多数的基础函数都在自己的域内<br>如幂函数、指数函数、三角函数。<br>但对数函数与负幂函数是例外；<br>三角函数也通过欧拉公式与复指数函数相关了；</p></li><li><p>函数</p><p>初等函数：<br>幂、指、对、三角、反三角</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;起因：由激活函数所引发的对数系的探索&quot;&gt;&lt;a href=&quot;#起因：由激活函数所引发的对数系的探索&quot; class=&quot;headerlink&quot; title=&quot;起因：由激活函数所引发的对数系的探索&quot;&gt;&lt;/a&gt;起因：由激活函数所引发的对数系的探索&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="探索" scheme="http://yoursite.com/categories/%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="数学" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>docker中pgsql数据的导入导出</title>
    <link href="http://yoursite.com/2019/01/10/docker%E4%B8%ADpgsql%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"/>
    <id>http://yoursite.com/2019/01/10/docker中pgsql数据的导入导出/</id>
    <published>2019-01-10T02:28:42.000Z</published>
    <updated>2019-02-15T08:01:26.578Z</updated>
    
    <content type="html"><![CDATA[<p> 测试环境中录入了一些数据，这些数据不想重复再在运行环境中录入，就想着通过导入导出的方式来解决。<br><a id="more"></a></p><h1 id="pgsql数据库、数据表的导出导入"><a href="#pgsql数据库、数据表的导出导入" class="headerlink" title="pgsql数据库、数据表的导出导入"></a>pgsql数据库、数据表的导出导入</h1>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">导出表：pg_dump -U root -d builder -t 表名 &gt; ~/表名.sql</span><br><span class="line">导出库：pg_dump -U root -d builder &gt; ~/库名.sql</span><br><span class="line">导 入：psql -d  builder  -f  ~/*.sql</span><br><span class="line"></span><br><span class="line">ps: -U: User </span><br><span class="line">    -d: database </span><br><span class="line">    -t: table </span><br><span class="line">    -f: file</span><br></pre></td></tr></table></figure><h1 id="docker中传输文件到运行机器"><a href="#docker中传输文件到运行机器" class="headerlink" title="docker中传输文件到运行机器"></a>docker中传输文件到运行机器</h1><p>  docker中安装scp<br>  <code>apt-get update</code><br>  <code>apt-get install openssh-client</code></p><p>  传输文件<br>  <code>scp 源文件 用户名@主机：路径</code><br>  <code>scp ~/表名.sql root@baidu.com:/home/root/</code></p><h1 id="运行机器将文件copy到docker中"><a href="#运行机器将文件copy到docker中" class="headerlink" title="运行机器将文件copy到docker中"></a>运行机器将文件copy到docker中</h1><p>  从主机copy文件到容器，在主机中执行：<br>  <code>docker cp /opt/test/file.txt mycontainer：/opt/testnew/</code></p><p>  从容器copy文件到主机：<br>  <code>docker cp mycontainer：/opt/testnew/file.txt /opt/test/</code></p><h1 id="docker中导入表"><a href="#docker中导入表" class="headerlink" title="docker中导入表"></a>docker中导入表</h1><p>  <code>psql -d  builder  -f  ~/*.sql</code></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p> <a href="https://blog.csdn.net/allen_oscar/article/details/9061573" target="_blank" rel="noopener">postgresql的导入、导出</a><br> <a href="https://blog.csdn.net/dongdong9223/article/details/71425077" target="_blank" rel="noopener">docker与主机的copy</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 测试环境中录入了一些数据，这些数据不想重复再在运行环境中录入，就想着通过导入导出的方式来解决。&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
</feed>
