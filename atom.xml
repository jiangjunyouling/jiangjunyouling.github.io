<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>思 见</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-06T02:08:22.540Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>sun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《简约至上》</title>
    <link href="http://yoursite.com/2019/03/03/%E7%AE%80%E7%BA%A6%E8%87%B3%E4%B8%8A%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/03/03/简约至上总结/</id>
    <published>2019-03-03T11:36:00.000Z</published>
    <updated>2019-03-06T02:08:22.540Z</updated>
    
    <content type="html"><![CDATA[<p>书中分成8章来讲述，其中第一章介绍什么是简单，为什么要简单，第二章了产品设计的步骤，由人物、场景而到情节来设计产品的逻辑，第三章总的来介绍了4种策略：删除、组织、隐藏、转移，后四章对4种策略的分述，最后一章所示算是结语。<br><a id="more"></a></p><p>前几天写了一个读书方法论，是从读这本书体会到的一个认知方法，那现在，将通过这个方法中想到的3个层次来总结一下这本书。</p><h1 id="具体设计"><a href="#具体设计" class="headerlink" title="具体设计"></a>具体设计</h1><ul><li><p>错误提示的挫败感:对时间选择的设计<br><img src="错误提示.png" alt="错误提示的挫败感"></p></li><li><p>认知分层:地铁线路的颜色设计<br><img src="地铁.png" alt="认知分层"></p></li><li><p>突出重点：对万豪酒店页面的重新设计<br><img src="万豪网站.png" alt="突出重点"></p></li><li><p>网格优化<br><img src="网格.png" alt="网格优化"></p></li><li><p>渐进展示：保存<br><img src="保存.jpeg" alt="渐进展示"></p></li><li><p>期望路径与实际路径<br><img src="期望路径.png" alt="期望路径"> </p></li></ul><h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><ul><li><p>办公室里假如用户来讨论需求是无效的</p></li><li><p>最好的观察用户的途径是从竞品与原型来观察用户的需要</p></li><li><p>用户并不知道自己提出需求所带来的负面作用</p></li><li><p>删掉与核心无关的内容，突出核心</p></li><li><p>突出重点可以用颜色与大小来提示<br>颜色只用在最关键的一两点上<br>大小而不是粗体提示重要的内容，非关键的尽量是小字体，原文是如果这个内容重要程度是1/2，那么使用1/4的字体。</p></li><li><p>颜色也常用来表达认知分层</p></li><li><p>尽量避免错误提示，这样会给用户带来挫败感</p></li><li><p>尽量避免结构化表单，这样会给人以约束</p></li><li><p>能用图片就用图片，能少用文字就少用文字</p></li><li><p>尽量避免打扰用户的注意力，使其分心</p></li><li><p>避免给用户过多的选择，过多的选择让人无法选择</p></li><li><p>有选择尽量又默认选项</p></li><li><p>使用组织时，最重要是只强调一两个最重要的主题<br>围绕这些主题进行分块，这些主题本身是根据用户行为来分类</p></li><li><p>最好先对内容有效的组织，然后再考虑如何设计搜素</p></li><li><p>按时间与空间来组织</p></li><li><p>注意观察期望逻辑与设计路径</p></li><li><p>避免用户自定义界面，用户往往不知道如何最有效布置</p></li><li><p>渐进展示内容，普通用户使用默认的简单功能，而必要时候可以选择更细节的功能</p></li><li><p>避免使用高级等字眼</p></li><li><p>手机端与电脑端的差异：手机端不适合录入文字，并且是及时使用</p></li><li><p>人与电脑的差异：人更是个与计划，电脑更适合与记录</p></li></ul><h1 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h1><ul><li><p>产品的设计产生与对用户的观察、思考与想象。</p><p>想象的过程就像是写故事，人物、场景、情节，也就是某些人，在什么样的情况下，使用这个产品，这个场景中有哪些故事会发生。这种情况下，人们对产品有着怎样的需要，尤其指的是特点。</p></li><li><p>产品的设计像是写文章，铭记核心，删减与核心无关的内容</p></li><li><p>针对大众设计产品，而不是专家</p></li><li><p>用户并不知道它们提出的需求所带来的负面影响</p></li><li><p>简单并不是初见的简单，它是在扬起复杂之后的简单</p></li><li><p>所以最好的设计是大众与专家都觉得很舒服</p></li><li><p>用户喜欢掌控产品，而不是被产品所掌握</p></li><li><p>产品需要留白，给用户留有再创造的空间</p></li><li><p>认知分层</p></li><li><p>很多时候简约设计是把这个复杂性放在哪里的问题</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;书中分成8章来讲述，其中第一章介绍什么是简单，为什么要简单，第二章了产品设计的步骤，由人物、场景而到情节来设计产品的逻辑，第三章总的来介绍了4种策略：删除、组织、隐藏、转移，后四章对4种策略的分述，最后一章所示算是结语。&lt;br&gt;
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="产品" scheme="http://yoursite.com/tags/%E4%BA%A7%E5%93%81/"/>
    
  </entry>
  
  <entry>
    <title>数系</title>
    <link href="http://yoursite.com/2019/02/18/%E6%95%B0%E7%B3%BB/"/>
    <id>http://yoursite.com/2019/02/18/数系/</id>
    <published>2019-02-17T16:00:00.000Z</published>
    <updated>2019-02-18T01:05:34.740Z</updated>
    
    <content type="html"><![CDATA[<h1 id="起因：由激活函数所引发的对数系的探索"><a href="#起因：由激活函数所引发的对数系的探索" class="headerlink" title="起因：由激活函数所引发的对数系的探索"></a>起因：由激活函数所引发的对数系的探索</h1><ul><li><p>激活函数</p><p>先是看到了激活函数：</p><p>$f(x) = \frac{1}{1+e^{-x}} = \frac{e^x}{1+e^x}$</p></li><li><p>值域在[-1,1]之间对称的函数</p><p>然后想去构造一个新的函数</p><p>特点：$+\infty$趋向1，$-\infty$趋向-1,0处为0，并且对称。</p><p>$f(x) = \frac{e^x-1}{e^x+1}$</p><p>试过用其他基础函数，都办法实现，首先定义域得相同，难处在于两个极限处要变号。</p></li><li><p>基本函数</p><p>通过实验，发现幂函数系没有发现满足要求的形式。因为在无穷处要想趋向与1，只有除法可以，这样在正负无穷都是一样的。<br>在上述函数的构造过程中，也思考过作为基础函数的三角函数。但三角函数是一种周期函数，此处更不能用。</p><p>理解三角函数与圆离不开关系，这样自然而然的想起了复指数函数。</p></li><li><p>复指数函数</p><p>欧拉公式：<br>$e^{ix} = cosx + isinx$</p><p>欧拉公式的证明很有趣，既可以通过微分的方法，又可以通过积分的方法来证明。<br>这又引起了对复数的兴趣，要说复数，我们先从数系入手。</p></li></ul><h1 id="数系"><a href="#数系" class="headerlink" title="数系"></a>数系</h1><p>  人类了解数的过程，真是很艰难的过程，远远不是数学课本上的，实数、虚数、有理数、无理数、整数、分数等几个概念那么简单。</p><p>  以下内容摘自：<a href="http://shc2000.sjtu.edu.cn/030802/congjishu.htm" target="_blank" rel="noopener">从计数法到复数域</a></p><p>  自然数：</p><p>  自然数系是一个离散的、而不是稠密的数系，因此，作为量的表征，它只能限于去表示一个单位量的整数倍，而无法表示它的部分。同时，作为运算的手段，在自然数系中只能施行加法和乘法，而不能自由地施行它们的逆运算。这些缺陷，由于分数和负数的出现而得以弥补。</p><p>  分数与负数：</p><p>  分数都是有理数，非整除的都是无限循环小数。分数系是一个稠密的数系，它对于加、乘、除三种运算是封闭的。为了使得减法运算在数系内也同行无阻，负数的出现就是必然的了。</p><p>  无理数：</p><p>  有理数系的缺陷：一条直线上的有理数尽管是“稠密”，但是它却漏出了许多“孔隙”，而且这种“孔隙”多的“不可胜数”。这样。人们对微积分基础的关注，使得实数域的连续性问题再次突显出来。因为，微积分是建立在极限运算基础上的变量数学，而极限运算，需要一个封闭的数域。无理数正是实数域连续性的关键。</p><p>  无理数是什么？变量数学独立建造完备数域的历史任务，终于在19世纪后半叶，由维尔斯特拉斯（Weierstrass,1815- 1897）、戴德金（R.Dedekind1831- 1916、康托（G.Cantor,1845- 1918）等人加以完成了。1872年，实数的三大派理论：戴德金“分割”理论；康托的“基本序列”理论，以及维尔斯特拉斯的“有界单调序列”理论，同时在德国出现了。由“戴德金分割”定义的实数，是完全不依赖于空间与时间直观的人类智慧的创造物。</p><p>  复数：</p><p>  1545年，此时的欧洲人尚未完全理解负数、无理数，然而他们智力又面临一个新的“怪物”的挑战。例如卡丹在所著《重要的艺术》（1545）中提出一个问题：把10分成两部分，使其乘积为40。这需要解方程x (10-x) = 40，他求得的根是$5+\sqrt{-15}$和$5-\sqrt{-15}$. 对复数的模糊认识，莱布尼兹（Leibniz,1646- 1716）的说法最有代表性：“圣灵在分析的奇观中找到了超凡的显示，这就是那个理想世界的端兆，那个介于存在与不存在之间的两栖物，那个我们称之为虚的—1的平方根。”。在使人们接受复数方面，高斯(1777－1855)的工作更为有效。他不仅将 a+ bi 表示为复平面上的一点 ( a, b)，而且阐述了复数的几何加法和乘法。</p><p>  在澄清复数概念的工作中，爱尔兰数学家哈米尔顿（Hamilton,1805 – 1865） 是非常重要的。哈米尔顿所关心的是算术的逻辑，并不满足于几何直观。他指出：<strong>复数a+ bi 不是 2 ＋ 3意义上的一个真正的和，加号的使用是历史的偶然，而 bi 不能加到a 上去。复数a+ bi 只不过是实数的有序数对（a，b），并给出了有序数对的四则运算，同时，这些运算满足结合律、交换率和分配率</strong>。在这样的观点下，不仅复数被逻辑地建立在实数的基础上，而且至今还有点神秘的 也完全消除了。</p><h1 id="数、运算、函数"><a href="#数、运算、函数" class="headerlink" title="数、运算、函数"></a>数、运算、函数</h1><p>  函数是一种自变与因变关系，是一种因果、变化思维<br>  基础运算（+-×/乘法与开方）都是一种增减逻辑<br>  微积分是一种基于函数（变量）的极限逻辑</p><ul><li><p>数系的扩展与运算：</p><p>如小数与分数的出现与四则运算的完备相关；<br>无理数的出现起初与乘方、开方相关，后又与微积分相关；<br>复数的出现也与开方相关。</p></li><li><p>运算都有与之对应的逆运算</p><p>乘法对除法<br>乘方对开方<br>积分对微分</p></li><li><p>运算的律</p><p>结合律、交换律、分配率。<br>乘法结合律:(a×b)×c=a×(b×c)<br>乘法交换律:a×b=b×a<br>乘法分配律:(a+b)×c=a×c+b×c</p></li></ul><ul><li><p>初等运算都有与之对应的函数</p><p>基础运算：<br>乘方对应的(负)幂函数与指数函数<br>开方对应的对数函数</p><p>微积分：<br>多数的基础函数都在自己的域内<br>如幂函数、指数函数、三角函数。<br>但对数函数与负幂函数是例外；<br>三角函数也通过欧拉公式与复指数函数相关了；</p></li><li><p>函数</p><p>初等函数：<br>幂、指、对、三角、反三角</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;起因：由激活函数所引发的对数系的探索&quot;&gt;&lt;a href=&quot;#起因：由激活函数所引发的对数系的探索&quot; class=&quot;headerlink&quot; title=&quot;起因：由激活函数所引发的对数系的探索&quot;&gt;&lt;/a&gt;起因：由激活函数所引发的对数系的探索&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="探索" scheme="http://yoursite.com/categories/%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="数学" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>docker中pgsql数据的导入导出</title>
    <link href="http://yoursite.com/2019/01/10/docker%E4%B8%ADpgsql%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"/>
    <id>http://yoursite.com/2019/01/10/docker中pgsql数据的导入导出/</id>
    <published>2019-01-10T02:28:42.000Z</published>
    <updated>2019-02-15T08:01:26.578Z</updated>
    
    <content type="html"><![CDATA[<p> 测试环境中录入了一些数据，这些数据不想重复再在运行环境中录入，就想着通过导入导出的方式来解决。<br><a id="more"></a></p><h1 id="pgsql数据库、数据表的导出导入"><a href="#pgsql数据库、数据表的导出导入" class="headerlink" title="pgsql数据库、数据表的导出导入"></a>pgsql数据库、数据表的导出导入</h1>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">导出表：pg_dump -U root -d builder -t 表名 &gt; ~/表名.sql</span><br><span class="line">导出库：pg_dump -U root -d builder &gt; ~/库名.sql</span><br><span class="line">导 入：psql -d  builder  -f  ~/*.sql</span><br><span class="line"></span><br><span class="line">ps: -U: User </span><br><span class="line">    -d: database </span><br><span class="line">    -t: table </span><br><span class="line">    -f: file</span><br></pre></td></tr></table></figure><h1 id="docker中传输文件到运行机器"><a href="#docker中传输文件到运行机器" class="headerlink" title="docker中传输文件到运行机器"></a>docker中传输文件到运行机器</h1><p>  docker中安装scp<br>  <code>apt-get update</code><br>  <code>apt-get install openssh-client</code></p><p>  传输文件<br>  <code>scp 源文件 用户名@主机：路径</code><br>  <code>scp ~/表名.sql root@baidu.com:/home/root/</code></p><h1 id="运行机器将文件copy到docker中"><a href="#运行机器将文件copy到docker中" class="headerlink" title="运行机器将文件copy到docker中"></a>运行机器将文件copy到docker中</h1><p>  从主机copy文件到容器，在主机中执行：<br>  <code>docker cp /opt/test/file.txt mycontainer：/opt/testnew/</code></p><p>  从容器copy文件到主机：<br>  <code>docker cp mycontainer：/opt/testnew/file.txt /opt/test/</code></p><h1 id="docker中导入表"><a href="#docker中导入表" class="headerlink" title="docker中导入表"></a>docker中导入表</h1><p>  <code>psql -d  builder  -f  ~/*.sql</code></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p> <a href="https://blog.csdn.net/allen_oscar/article/details/9061573" target="_blank" rel="noopener">postgresql的导入、导出</a><br> <a href="https://blog.csdn.net/dongdong9223/article/details/71425077" target="_blank" rel="noopener">docker与主机的copy</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 测试环境中录入了一些数据，这些数据不想重复再在运行环境中录入，就想着通过导入导出的方式来解决。&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>ssh免密配置</title>
    <link href="http://yoursite.com/2019/01/09/ssh%E5%85%8D%E5%AF%86%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/01/09/ssh免密配置/</id>
    <published>2019-01-09T06:07:01.000Z</published>
    <updated>2019-02-15T08:01:26.578Z</updated>
    
    <content type="html"><![CDATA[<p> 本文是第一篇转到md写的文档，作为对问题的总结，也作为使用md语法的开始。<br> <a id="more"></a></p><h1 id="ssh简介"><a href="#ssh简介" class="headerlink" title="ssh简介"></a>ssh简介</h1><p> ssh(Secure Shell)是一种加密的网络传输协议，在网络中创建安全隧道来实现ssh客户端与服务器之间的连接。<br> 虽然任何网络服务都可以通过ssh实现安全传输，ssh最常见的用途是远程登录系统。在设计上ssh是Telnet和非安全shell的替代品，telnet等协议采用明文传输，不使用不可靠的密码，容易遭到监听、嗅探和中间人攻击。ssh旨在保护非安全网络环境中信息加密完整可靠。<br> ssh以非对称加密实现身份验证，人工生成一对公钥和私钥，通过生成的密钥进行认证，这样就可以在不输入密码的情况下登录。公钥需要放在待访问的计算机之中，而对应的私钥需要由用户自行保管。认证过程基于生成出来的私钥，但整个认证过程中私钥本身不会传输到网络中。<br> 核实未知密钥来源都是重要的事情，因为SSH只验证提供用户是否拥有与公钥相匹配的私钥，只要接受公钥而且密钥匹配服务器就会授予许可。这样的话，一旦接受了恶意攻击者的公钥，那么系统也会把攻击者视为合法用户。</p><h1 id="ssh原理"><a href="#ssh原理" class="headerlink" title="ssh原理"></a>ssh原理</h1><p> <a href="https://www.jianshu.com/p/33461b619d53" target="_blank" rel="noopener">图解SSH原理</a><br>  简单概述一下：原来是通过ssh user@host申请，然后server应答后，输入password，但这样会造成中间人攻击，就是代理截获了client与server之间的通信，伪装server骗取client的密码，然后对server进行攻击。<br>  于是有了公钥认证的过程，就是俗称的免密，其过程就是客户端生成一段密钥对，然后把公钥设置到服务器的authorized_keys中，这样client与server都各有一对密钥，同时握有对方的公钥，只要进行配对认证，就可以不再输入密码了。</p><h1 id="ssh免密配置"><a href="#ssh免密配置" class="headerlink" title="ssh免密配置"></a>ssh免密配置</h1><ul><li><p>client端生成密钥对<br>cd ~/.ssh<br>ssh-keygen -t rsa -C “名字” -f “名字_rsa”</p></li><li><p>放到server的~/.ssh/authorized_keys中<br>上传到服务器有好几种方式，可以手动打开粘帖进去，也可以在客户端使用命令：<br><code>ssh-copy-id -i 公钥 用户名@服务器</code></p></li><li><p>client配置~/.ssh/config</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host xw</span><br><span class="line">    HostName 47.98.197.178</span><br><span class="line">    User root</span><br><span class="line">    Port 22</span><br><span class="line">    PubKeyAuthentication yes</span><br><span class="line">    IdentityFile ~/.ssh/chenjing_rsa</span><br></pre></td></tr></table></figure></li></ul><ul><li>问题：<br> signing failed: agent refused operation问题：<br> 一般情况下设置完如上操作，就可以访问了，若出现：sign_and_send_pubkey: signing failed: agent refused operation，则需要在client端将key增加到agent，操作如下：<br> <code>ssh-add ~/.ssh/your-key-name</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 本文是第一篇转到md写的文档，作为对问题的总结，也作为使用md语法的开始。&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="ssh" scheme="http://yoursite.com/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>谷歌软件测试之道</title>
    <link href="http://yoursite.com/2019/01/01/%E8%B0%B7%E6%AD%8C%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B9%8B%E9%81%93/"/>
    <id>http://yoursite.com/2019/01/01/谷歌软件测试之道/</id>
    <published>2019-01-01T07:23:57.000Z</published>
    <updated>2019-02-15T08:01:26.578Z</updated>
    
    <content type="html"><![CDATA[<p> 测试是开发过程中必不可少的一部分，当开发过程和测试一起不分彼此之时，即是得到质量<br> 本博文是摘自《谷歌软件测试之道》，尚未看完，陆续更新中</p><a id="more"></a><h1 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h1><ul><li><p>SWE： software engineer<br>创建设计文档，选择最优的数据结构和整体架构，代码实现与代码审核。<br>需要编写测试代码，包括测试驱动的设计、单元测试、参与构建各种大小规模的测试等。</p></li><li><p>SET： software engineer in test<br>工作重心：可测性和通用测试基础框架上<br>参与设计评审，增加可测性。<br>编写单元测试框架和自动化测试框架。</p></li><li><p>TE： test engineer<br>把用户放在第一位来思考，代表用户的利益。有时会花费大量时间在模拟用户的使用场景和自动化脚本或代码的编写上，分析、解释、测试运行结果，驱动测试执行，构建端到端的自动化测试。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 测试是开发过程中必不可少的一部分，当开发过程和测试一起不分彼此之时，即是得到质量&lt;br&gt; 本博文是摘自《谷歌软件测试之道》，尚未看完，陆续更新中&lt;/p&gt;
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="测试" scheme="http://yoursite.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>linux内核导读</title>
    <link href="http://yoursite.com/2018/12/17/linux%E5%86%85%E6%A0%B8%E5%AF%BC%E8%AF%BB/"/>
    <id>http://yoursite.com/2018/12/17/linux内核导读/</id>
    <published>2018-12-17T04:46:44.000Z</published>
    <updated>2019-02-15T08:01:26.530Z</updated>
    
    <content type="html"><![CDATA[<p>本博文从《linux内核设计与实现》第三版的笔记，主要是任务调度、终端、内存管理、虚拟文件系统等部分。作为导读来存在，为以后看源码做点准备。</p><a id="more"></a><h1 id="内核开发的特点"><a href="#内核开发的特点" class="headerlink" title="内核开发的特点"></a>内核开发的特点</h1><ul><li><p>内核编程既不能访问C库，也不能访问标准的C头文件<br>内核不能链接使用标准C函数库，因为C函数库依赖系统调用（操作系统），而且C库对于内核，太大太低效。但大部分常用的C库函数在内核中都已经得到实现。</p></li><li><p>内核编程必须使用GNU C<br>内核并不完全符合ANSI C标准。它总是用到gcc提供的许多语言的扩展部分。</p></li><li><p>内核编程时缺乏像用户空间那样的内存保护机制<br>用户进程访问非法内存时，内核就会发现错误，并发送SIGSEGV信号。但内核如果访问了非法内存，那就很难控制了。<br>内核中的内存不分页。也就是说，没掉一个字节，物理内存就减少一个字节。</p><p>CPU通过寻址来访问内存。32位CPU的寻址宽度是4G，就是可支持的物理内存最大是4G，但如果物理内存小于4G，程序不得不降低内存占用。为解决此类问题，现在CPU引入MMU（内存管理单元），思想就是利用虚拟地址来替代物理地址，即CPU寻址时使用虚拟地址替代物理地址，即CPU寻址时，使用虚拟地址，由MMU负责将虚拟地址映射为物理地址。<br>内存分页（Paging）是在使用MMU的基础上，提出的内存管理机制。它将虚拟地址和物理地址按固定大小（4K）分割成页（page）和页帧（page frame），并保证页与页帧的大小相同。</p></li><li><p>内核变成时难以执行浮点运算。<br>用户空间的进程进行浮点操作的时候，内核会完成从整数操作到浮点数操作的模式转换。而内核并不完美支持浮点操作，因为它本身不能陷入。在内核中使用浮点数时，除了人工保存和恢复浮点寄存器，还有一些琐碎的事情要做。</p></li><li><p>内核给每个进程只有一个很小的定长堆栈<br>内核空间的栈比较小，一般就2页，即32位的内核是8KB，64位是16KB。</p></li><li><p>由于内核支持异步中断、抢占和SMP<br>SMP：（Symmetric mutliprocessing）是一种多处理器的计算硬件构架，在对称多处理架构下，每个处理器的地位都是平等的，对资源的使用权相同。有两个或更多的相同的处理器共享同一主存，由一个操作系统控制。<br>SMP，里那个以上的cpu内核有可能访问共享的同一资源<br>中断是异步的，中断处理程序就可能访问同一资源<br>inux内核可以抢占，内核中一段正在执行的代码可能会被另一段代码抢占，从而还是访问相同的资源。<br>常用的解决办法是自旋锁和信号量。</p></li></ul><h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><p>虚拟机制<br>进程提供了2种虚拟机制：虚拟处理器和虚拟内存。虽然多个进程正在共享一个处理，但虚处理器给进程一种假象，让这些进程觉得自己在独享处理器。而虚拟内存让进程在分配和管理内存时觉得自己拥有整个系统的所有内存资源。</p></li><li><p>进程描述符pid与任务结构task_struct<br>内核中通常把进程叫做任务（task）<br><img src="进程任务队列.png" alt=""></p></li><li><p>任务结构task_struct<br><img src="内核栈与进程描述.png" alt=""><br>thread_info,指针指向task_struct，通过slab分配器分配task_struct，这样能达到对象复用和缓存的目的。放在内核站的尾端是为了通过栈指针就能找到它的位置。</p></li><li><p>进程的状态<br><img src="进程状态转化.png" alt=""></p></li><li><p>进程树<br>所有进城都是通过fork()来实现，所以就有了父子进程的关系，在task_struct中有父进程的指针，以及子进程的列表。</p></li><li><p>进程创建<br>资源： 地址空间（VM）、文件系统资源(FS)、文件描述符(FILES)、信号处理程序(SIGHAND)<br>fork()： 大体是从父进程拷贝相同的task_struct，然后将描述符、资源从父进程分离。对于线程，就可以有些资源就不分离而已。</p></li><li><p>进程终结<br>首先会回收task_struct中的资源，并给其子进程找到合适的父进程，然后返回到其父进程，然后删除进程描述符。</p></li></ul><h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>进程调度系统可以看作在运行态P35<br>抢占式与非抢占式的区别</p><p>进程调度历史<br>简单调动 =》 O（1）调度程序 =》 完全公平调度算法（CFS）</p><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><p>调度程序角度对进程的划分：I/O消耗型与cpu消耗型<br>调度策略的平衡：进程响应迅速（响应时间短）和最大系统利用率（高吞吐量）<br>进程优先级，2套优先级范围：<br>nice值（人越nice越礼让，进程nice越大优先级越低），范围-20 到 +19<br>rtprio实时优先级，其值可配置，范围是0-99。越高优先级越高。任何实时进程的优先级都高于普通的进程，实时优先级与nice优先级处于互补相交的两个范畴。<br>时间片<br>调度策略必须规定一个默认的时间片，时间过长会导致系统对交互的响应欠佳（I/O消耗型），时间片太短会明显增大进程切换带来的cpu耗时。但linux的CFS调度器并没有直接分配时间片到进程，它是将处理器的使用比划分给了进程，这样进程所获得的时间片其实是个系统负载密切相关的。CFS调度器，其抢占时机决定于新的可运行程序消耗了多少处理器使用比，如果消耗的使用比比当前进程小，则新进程立即投入运行，抢占当前进程。</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>假设有2个运行进程，在标准Unix调度模型中，我们先运行其中一个5ms，然后再运行另一个5ms。但它们任何一个运行时都将占有100%的处理器。而在理想情况下，完美的多任务处理器模型应该是：我们在10ms内同时运行两个进程，它们各自使用处理器一半的能力。</p><p>CFS的做法是允许每个进程运行一段时间、循环论转、选择运行最少的集成作为下一个运行进程，而不再采用分配给每个进程时间片的做饭，CFS在所有可运行进程总数基础上计算出一个进程应该运行多久，而不是依靠nice值来计算时间片。nice值在CFS中被作为进程获得的处理器运行比的权重。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li><p>时间记账<br>多数Unix系统中，分配一个时间片给每一个进程，当系统时钟节拍发生时，时间片都会减少每一个节拍周期，当一个进程的时间片减少至0,它就会被另一进程抢占。</p><p>CFS不再用时间片的概念，但它也必须维护每一个进程运行的时间到帐。vruntime变量存放进程的虚拟运行时间，该运行是经过所有可运行进程总数的标准化，跟定时器节拍不再相关。vruntime变量来记录一个程序到底运行了多长时间以及它还应该再运行多久。</p><p> update_curr()函数来实现记账功能，它是有系统定时器周期性调用，curr-&gt;vruntime每次都增加一个 delta_exec_weighted，而这个delta_exec_weighted是根据当前任务的本次间隔delta_exec来，以及所有其他进程的delta_exec来计算的。</p><p> 应该这个权重是考虑了nice值的，但没有看到vruntime对任务调度的影响的部分代码，应该是在update_min_vruntime(cfs_rq)中产生了影响。</p></li><li><p>进程选择<br>当CFS需要选择下一个运行进程时，它会挑选一个具有最小vruntime的进程。CFS使用红黑树来组织可运行进程队列，红黑树是一个自平衡二叉搜索树小于节点在其左节点，大于在右节点，且是一种平衡的二茶树。</p></li><li><p>调度器入口<br>入口为schedule()，在kernel/sched.c中，它会找到一个最高优先级的调度类，然后有最高优先级的调度类下一该运行的进程。<br>CFS是对普通进程的调度类，而系统运行的绝大多数进程都是普通进程。</p></li><li><p>休眠<br>休眠的进程处于不可执行状态，需要从红黑树里移出，放入等待队列。待唤醒后，再从等待队列移出，放入红黑树。</p></li><li><p>总结<br>CFS就是通过vruntime实现对所有进程运行时间归一化的处理，处理过程肯定有nice值、以及进程数的参与。然后每次选取最小vruntime的去调度。</p></li></ul><h3 id="抢占"><a href="#抢占" class="headerlink" title="抢占"></a>抢占</h3><ul><li><p>上下文切换<br>抢占就需要进行上下文的切换，上下文切换主要负责：</p><ol><li>把虚拟内存从上一个进程切换到新进程中</li><li>调用switch_to()，从上一个进程的处理器状态切换到新进程的处理器状态。这包括保存、恢复栈信息和寄存器信息，还有其他任何与体系结构相关的状态信息。</li></ol></li><li><p>用户抢占<br>内核将返回用户空间的时候，如果need_resched标志被设置，会导致schedule()被调用，此时就会发生用户抢占。用户抢占发生在：</p><ol><li>从系统调用返回用户空间时</li><li>从中断处理程序返回用户空间时</li></ol></li><li><p>内核抢占<br>Linux完整支持内核抢占，不支持抢占的内核中，内核代码可以一直执行，到它去完成为止，调度程序没法在一个内核级任务正在执行的时候重新调度。Linux内核就可以在任何时间抢占正在执行的任务。内核抢占发生在：</p><ol><li>中断处理程序正在执行，且返回内核空间之前。</li><li>内核代码再一次具有可抢占性的时候</li><li>内核中的任务显式调用schedule()</li><li>内核中的任务阻塞</li></ol></li></ul><h3 id="实时调度策略"><a href="#实时调度策略" class="headerlink" title="实时调度策略"></a>实时调度策略</h3><p>linux提供了两种实时调度策略： SCHED_FIFO 和 SCHED_RR。<br>SCHED_FIFO实现了一种简单那的,先入先出的调度算法: 一旦一个SCHED_FIFO进程处于可执行状态,就会一直执行,知道它自己受阻或显式释放处理器,它不基于时间片,可以一直执行下去.只有更高优先级的SCHED_FIFO或者SCHED_RR任务才能抢占SCHED_FIFO人任务,且高优先级的SCHED_FIFO可以立即抢占低有线的.<br>SCHED_RR与SCHED_FIFO大体相同,只是SCHED_RR带有时间片.当时间片耗尽,它在统一优先级的其他实时进程被轮流调度,时间片之用来重新调度同一优先级的进程.即使时间片耗尽,低优先级的也不能抢占SCHED_RR高优先级的任务.</p><p>一点疑问: SCHED_FIFO是一种先入先出的队列,如果一个高优先级的紧挨在一个低优先级的后面,那会发生什么? 低优先级先运行,接着被高优先级的抢占,并将低优先级任务处于TASK_INTERRUPTABLE状态,并指导高优先级的运行完,再去运行低优先级的.<br>反过来,低优先级在一个高优先级的后边,会发生什么? 高优先级的先运行,低优先级的会继续在队列里,还是在其他的等待对立里?</p><p>优先级范围<br>实时优先级从0 到 MAX_RT_PRIO-1(99),SCHED_NORMAL级进程的nice值共享了这个取值空间,它的取值从MAX_RT_PRIO 到 (MAX_RT_PRIO + 40),也就是说 nice从-20到+19对应着 100到139的实时优先级范围.</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>时间片理解<br>对传统unix的时间片还有有些疑问,首先时间片是按nice值来进行分配,当高优先级运行完再运行低优先级的,当都运行完呢? 应该由调度程序继续来划分时间片,再继续运行,那这样,高优先级的任务也会等较久的时间啦,如果有100个任务,轮过一遍还是挺费事的.<br>不对,传统unix的时间片是固定的,什么样的优先级对应的时间片是固定的,那就需要有一个队列,时间片运行完后,将任务放到队列的后面,继续运行.且队列不能按优先级排序,因为一排序,它就又到前面了.不排序就会造成低优先级的比高优先级的先运行的情况,又会造成问题.</li></ul><h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在os中，内核提供了用户进程与内核进程进行交互的一组接口，这些接口让应用程序受限地访问硬件设备，提供了创建新进程并与已有进程进行通信的机制，也提供了申请操作系统其他资源的能力。</p><p>在linux中，系统调用是用户空间访问内核的唯一手段。</p><h2 id="系统调用-与-应用程序接口（API）"><a href="#系统调用-与-应用程序接口（API）" class="headerlink" title="系统调用 与 应用程序接口（API）"></a>系统调用 与 应用程序接口（API）</h2><p>大约关系是，内核提供系统调用接口，供用户空间的应用程序使用，但一般都会将系统调用进行进一步的封装变成应用程序编程接口API，这些接口中最流行的标准是POSIX，最后应用程序直接使用的是这些编程接口。以C库为中printf()调用为例：<br><img src="系统调用与API.png" alt=""><br>C库提供了POSIX绝大部分API</p><h2 id="系统调用-1"><a href="#系统调用-1" class="headerlink" title="系统调用"></a>系统调用</h2><p>在Linux系统中，每个syscall被赋予一个系统调用号，通过这个独一无二的号就可以关联系统调用。当用户空间的进程执行一个系统调用的时候，这个系统调用号来指明到底是要执行哪个系统调用。如此可见，系统调用号是静态的，如果一个系统调用被删除，它占用的系统调用号不允许被回收。</p><p>如getpid()系统调用，它会返回当前进程的PID，内核中的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE0(getpid)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">return</span> task_tgid_vnr(current);   <span class="comment">//return current-&gt;tgid</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SYSCALL_DEFINE0是一个宏，它定义一个无参数的系统调用，展开后的代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_getpid</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br></pre></td></tr></table></figure></p><p>asmlinkage限定词，是一个编译指令，通知编译器仅从栈中提取该函数的参数。</p><h2 id="系统调用处理程序"><a href="#系统调用处理程序" class="headerlink" title="系统调用处理程序"></a>系统调用处理程序</h2><p>用户空间的程序无法直接执行内核代码，也不能直接调用内核空间的函数，因为内核驻留在受保护的地址空间上。<br>应用程序应该以某种方式通知系统，告诉内核自己需要执行一个系统调用，系统系统切换到内核态，这样内核就可以代表应用程序在内核空间执行系统调用。<br>通知内核的机制是靠软中断（中断号128）实现的。通过引发一个异常，促使系统切换到内核态去执行异常处理程序，这个异常处理程序就是系统调用的处理程序。</p><p>仅陷入内核空间是不够的。必须将系统调用号、函数的参数一并传给内核。这些传递，是通过寄存器来完成的，分别放在eax,ebx,ecx,edx,esi,edi（前5个参数）中。<br><img src="系统调用处理程序.png" alt=""></p><h2 id="系统调用上下文"><a href="#系统调用上下文" class="headerlink" title="系统调用上下文"></a>系统调用上下文</h2><p>内核在执行系统调用的时候，处于进程上下文中。current指针指向当前任务，即引发系统调用的那个进程。<br>在进程上线文中，内核可以休眠，可以被抢占。</p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><ul><li><p>参数验证<br>指针、权限等验证防止内核崩溃<br>内核提供了2个方法来完成内核空间与用户空间之间数据的来回拷贝。注意内核无论何时都不能轻率的接受来自用户空间的指针。（这就需要数据的拷贝了，但数据的拷贝本身就需要起止的指针）。copy_to_user（）与copy_from_user()</p></li><li><p>例子</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(silly_copy,</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span> * src,</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span> * dst,</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> buf;  <span class="comment">// 书中例子，直接一个long的buf就能使用？</span></span><br><span class="line">    <span class="keyword">if</span>(copy_from_user(&amp;buf, src, len))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    <span class="keyword">if</span>(copy_to_user(dst, &amp;buf, len))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  还有对权限的检验： capable(CAP_SYS_BOOT) 来进行用户权限的检验。</p><p>  还需要将这个系统掉哟个你注册：</p><ol><li>在系统调用表最后，增加新的一项，类似与枚举，用于获取新的系统调用号。</li><li>对于所有支持的体系结构，系统调用都必须定义于 &lt;asm/unistd.h&gt;中。</li><li><p>系统调用必须被编译进内核影像(不能被编译成模块)。这需要将实现放到kernel/下的一个相关文件中，比如sys.c（包含各种各样的系统调用）</p><p>这样虽然定义了系统调用，但在C库中肯定没有对它的支持，好在linux提供了一组宏，用户对系统掉哟个你进行直接访问</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NR_foo 283</span></span><br><span class="line">_syscall3(<span class="keyword">long</span>, silly_copy, src, dst, len)</span><br></pre></td></tr></table></figure></li></ol></li></ul><h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><ul><li><p>简介<br>中断也是老朋友了，就是硬件中，使能了某个引脚的中断，然后编写这个中断的响应函数来处理。只不过在操作系统中会稍微麻烦了一点，它将终端分为2部分，其中上半部用来响应硬件、恢复中断，下半部用来处理硬件的数据。</p></li><li><p>上、下半部的对比<br>中断处理程序是上半部，接收一个中断，它就立即开始执行，只做有限的工作，例如对接收的中断进行应答，或者复位硬件，这些工作都是在所有中断被禁止的情况下完成的。能够被允许稍后完成的工作会推迟到下半部去。</p></li><li><p>注册中断处理程序<br>中断处理程序是驱动程序的组成部分，驱动程序通过request_irq()函数&lt;linux/iterrupt.h&gt;中注册一个中断处理程序，并激活给定的中断线，以处理中断。<br>主要参数是中断号与中断处理程序。</p></li><li><p>中断上下文<br>当执行一个中断处理程序时，内核处于中断上下文中。回忆进程上下文，进程上下文是一种内核所处的操作模式，此时内核代表进程执行如系统调用，运行内核线程等任务，在进程上下文中，可以通过current宏关联当前进程，因为进程是以进程上下文的形式连接到内核中，因此，进程上下文可以睡眠，可以调用调度程序。<br>中断上下文则相反，它与进程无关，也就没有后备进程，所以不能睡眠，中断上下文具有严格的时间限制，因为它打断了其他代码。<br><img src="中断处理程序.png" alt=""></p><p>/proc/interrupts中存放与系统中中断的相关信息。</p></li><li><p>下半部<br>下半部就主要有三种选择：软中断、tasklet和工作队列，其中tasklet基于软中断，工作队列依靠内核线程实现。<br>对于后半部，如果有休眠的需要，工作队列是唯一选择，否则就用tasklet。软中断一般不会用，因为它就32个，且被整个系统严格格共享且规范使用。</p></li></ul><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><ul><li><p>页<br>内核以page(页)作为管理内存的基本单位，因为MMU(内存管理单元，把虚拟地址转换成物理地址的硬件)通常就是以页为单位进行处理。<br>32位体系结构支持4KB页，64位体系一般支持8KB页大小。<br>内核用struct page结构表示系统中的每个物理页，该结构位于&lt;linux/mm_types.h中&gt;<br>page结构与物理页相关，而并非虚拟页。保存着页是否脏页，引用计数，虚拟地址（高地址可能没有，null）。</p></li><li><p>区<br>由于硬件限制，内核并不能对所有的页一视同仁，只有特定物理地址上的page才能用于也写特定的任务，所以内核就把页划分为不同的区。<br>linux主要用于4个区：</p><ol><li>ZONE_DMA – 这个区包含的页用来执行DMA操作【好久不见DMA，印象中是内存不再cpu参与下，直接与I/O交互】</li><li>ZONE_DMA32 – 只能被32位设备访问的DMA</li><li>ZONE_NORMAL – 能正常映射的页</li><li>ZONE_HIGHM – 所谓的高端内存，其中的页并不能永久的映射到内核地址空间。<br>这些区不不是都会有，如在64位体系中，所有内存都被映射，ZONE_HIGHMEM就为空<br>在x86-32上</li></ol></li></ul><table><thead><tr><th>区</th><th style="text-align:right">物理内存</th></tr></thead><tbody><tr><td>ZONE_DMA</td><td style="text-align:right">&lt;16MB</td></tr><tr><td>ZONE_NORMAL</td><td style="text-align:right">16~896MB</td></tr><tr><td>ZONE_HIGHMEM</td><td style="text-align:right">&gt;896MB</td></tr></tbody></table><p>  这些区域一般在&lt;linux/mmzone.h&gt;中的struct zone中定义<br>  比较重要的有lock域，是一个自旋锁，它防止zone被并发访问，这个域只保护zone结构，而不是保护这个区中的所有页。watermark数组，持有该区的最小值、最低和最高水位值。内核使用水位为每个内存设置合适的内存消耗基准，该水位随空闲内存的多少而变化。</p><ul><li><p>每个cpu的内存分配<br>一般来说，每个CPU的数据存放在一个数组中，数组中的每一项对应系统上一个存在的处理器。按当前处理器确定这个元素的当前元素。这些数据对当前处理器来说是唯一的，且除了当前处理器，没有其他处理器可接触到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cpu;</span><br><span class="line">cpu = get_cpu();  <span class="comment">// 获取当前处理器，并禁止内核抢占</span></span><br><span class="line">...操作</span><br><span class="line">put_cpu();       <span class="comment">// 激活内核抢占</span></span><br></pre></td></tr></table></figure><p>2.6版本引入新接口，percup来创建和操作每个CPU的数据<br>编译时，定义每个CPU变量<br>DEFINE_PER_CPU(type, name) 它为系统中的每一个处理器都创建一个类型为type，名字为name的变量。<br>DECLARE_PER_CPU(type, name)这是声明一个变量<br>get_cpu_var(name) 和 put_cpu_var(name)返回当前处理器的中指定变量.</p><p>这里有个问题,什么样的数据适合放在为每个cpu分配的内存上呢?</p></li><li><p>内存分配的选择<br>如果需要连续的物理页，可以使用某个低级页分配器或者kmalloc()。这是内核中内存分配的常用方式，也就是大多数应该使用的内存分配方式。传递给这些函数通常的标志是GFP_ATOMIC和GFP_KERNEL。GFP_ATOMIC表示进行不睡眠的高优先级分配，这是终端处理程序和其他不能睡眠的代码段的需要。GFP_KERNEL表示可以睡眠的代码，比如进程上下文中。</p><p>如果想从高端内存进行分配，就是用alloc_pages()。alloc_pages()函数返回一个指向struct page结构体的指针，而不是指向某个逻辑地址的指针。因为高端内存很可能没有被映射，因此访问它的唯一方式就是通过相应的struct page结构。有时为了获得真正的指针，应该调用kmap()，把高端内存映射到内存的逻辑地址空间，kmap在高端内存用会永久映射高端内存，而在低端用就是获取内存地址。</p><p>如果不需要物理上连续的页，而仅仅需要虚拟地址上连续的页，那么就使用vmalloc()。vmallog()函数分配的内存虚地址是连续的，但它本身不保证物理上的连续。</p><p>如果要创建和撤销很大的内存结构，那么应该考虑slab高速缓存。slab层会给每个处理器维持一个对象高速缓存（空闲链表）。这种高速缓存会极大提高对象分配和回收的性能【就是提前new出好多空间，使用时直接使用，无需新建跟销毁】</p></li></ul><h1 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h1><ul><li><p>unix文件系统：文件、目录项、索引节点和安装点<br>从本质上讲文件系统是特殊的数据分层存储系统，它包含文件、目录和相关的控制信息。文件系统的通用操作包括创建、删除和安装。<br>文件可以做一个有序字符串，字符串的第一个字节是文件的头，最后一个字节是文件的尾。每一个文件为了便于系统和用户识别，都被分配了一个便于理解的名字。典型的文件系统有读、写、创建和删除。<br>在Unix中，目录属于普通文件，它列出包含在其中的所有文件，由于VFS把目录当作文件对待，所以可以对目录执行和文件相同的操作。<br>Unix系统将文件本身 和 文件的控制信息2个概念区分，例如访问控制权限、大小、拥有者、创建时间等信息。文件信息被存储在一个单独的数据结构中，该结构被称为索引节点（inode）。文件控制信息被存储磁盘的超级块中。</p></li><li><p>vfs对象及其数据结构<br>vfs采用面向对象的设计思路。VFS中四个主要的对象类型，它们分别是：<br>（super）超级块对象，它代表一个具体的已安装文件系统<br>（inode）索引节点对象，它代表一个具体文件<br>（dentry）目录项对象，它代表一个目录项，是路径的一个组成部分<br>（file）文件对象，它代表有进行打开的文件。<br>unix是用C实现了，也就不会有class等关键字，那如何来实现面向对象呢，4个主要的对象类型都是结构体，而对他们的操作都封装在一个操作对象里作为类型对象的属性，操作对象中包含指向操作其父对象的函数指针;这就是之前听说过的，用C来实现面向对象的技术。</p></li><li><p>超级块对象<br>super_block结构体，定义在&lt;linux/fs.h&gt;中，用于存储特定文件系统的信息<br>超级块对象的操作位于fs.super.c中，超级块对象通过alloc_super()函数创建并初始化。在文件系统安装时，文件系统会调用该函数从磁盘读取文件系统超级块，并且将其信息填充到内存中的超级块对象中。</p><ul><li>超级块操作<br>超级块对象中最重要的一个属性s_op，它指向超级块的操作函数表。该函数表由super_operations结构体表示，定义在linux/fs.h中。<br>所有的操作都在进程上下文中调用。除了dirty_inode()，其他函数都可以阻塞。</li></ul></li><li><p>索引节点对象<br>一个索引节点代表文件系统的一个文件，它也可以是设备或管道这样的特殊文件。索引节点对象必须在内存中创建，以便于文件系统使用。<br>索引节点对象包含了对象操作文件或目录时需要的全部信息。对于Unix风格的文件系统，这些信息可以从磁盘索引节点直接读入，但有些文件系统需要特殊的转换，不管哪种情况，索引节点对象必须在内存中创建，以便VFS使用。<br>inode 结构体在 &lt;linux/fs.h&gt;中</p></li><li><p>目录项对象<br>目录项对象是为了简化索引对象对目录的操作而来的，在磁盘上并没有一个目录项的文件与之对应，是在访问的过程中，在内存中创建的对象。<br>路径中的每一项都属于目录项对象：/mnt/cdrom/foo中，/、mnt、cdrom和foo都属于目录项对象。VFS在执行目录操作时，会现场创建目录项对象<br>dentry 结构体在&lt;linux/dcache.h&gt;中</p><p>目录项状态： 被使用、未被使用、负状态; 被使用与未被使用的状态都对应一个有效的索引节点，而负状态则没有对应的有效节点。</p><p>如果VFS层便利路径中所有的元所将他们逐个解析成目录项对象，还要到达最深层的目录，将是一个非常费力的工作，会浪费大量的时间。所以内核将目录项对象缓存在目录项缓存中。使用时，先在目录项缓存中去查找，如果知道则直接使用，反之就按路径逐层解析、搜索，找到后，将目录项加入dcache中。</p></li><li><p>文件对象<br>文件对象表示进程已打开的文件在内存中的表示。该对象由相应的open()系统调用创建，而由close()调用撤销。所有这些文件相关的调用实际上都是文件操作表中定义的方法。<br>多个进程可以同时打开和操作一个文件，所以同一个文件可能存在多个文件对象。<br>文件系统仅仅在进程观点上代表已打开文件，它反过来指向目录项对象，又指向索引节点。<br>file结构体在 &lt;linux/fs.h&gt;中</p><p>常见的ioctl()、read（）、write()等都是在文件操作对象中定义的</p></li><li><p>其他</p><ul><li><p>vfsmount 当文件系统被安装时，将有一个vfsmount结构体在安装时被创建，用来代表文件系统的实例–也就是代表一个安装点</p></li><li><p>进程相关的数据结构<br>file_struct:进程与文件对象的关联，像是中间表那样<br>fs_struct：进程当前的工作目录(pwd)和根目录<br>namespace: 它使得没一个进程在系统中都看到唯一的安装文件系统（不仅是唯一的根目录，而且是唯一的文件系统层次结构）。</p></li></ul></li></ul><h1 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h1><p>linux采用虚拟内存技术，系统中的所有进程以虚拟方式共享内存。对于一个进程而言，它好像可以访问整个系统的所有物理内存。更重要的是，即使单独一个进程，它拥有的地址空间也可以远远大于系统物理内存。</p><ul><li><p>地址空间<br>每个进程都有一个32或者64位独立、连续的平台地址空间。尽管一个进程可以寻址4GB虚拟内存（32位），但并不代表它就有权访问所有的虚拟地址，进程只能访问有效内存区域内的内存地址。如果进程访问了无效的内存区域，内核会终止进程，并返回段错误。可被访问的有效地址被称为内存区域(memory areas)</p><p>内存区域包含各种内存对象：<br> – 可执行文件代码的内存映射：代码段<br> – 可执行文件已初始化全局变量的内存映射：数据段<br> – 包含未初始化全局变量的内存映射：bss<br> – 用于进程用户空间栈的内存映射：栈，局部变量<br> – 匿名的内存映射，malloc()分配的内存： 堆，<br> – 任何共享内存段<br> – 任何内存映射文件<br> – 动态链接程序等共享库的代码段、数据段、bss</p></li><li><p>内存描述符mm_struct<br>mm_struct结构体，定义在&lt;linux/sched.h&gt;中，内核使用mm_struct表示进程的地址空间，该结构包含了和进程地址空间有关的全部信息。<br>内存描述符mm_struct与进程一一对应，描述的是进程各段使用的地址，而各段使用的地址用vm_area_struct结构体来表示，各段的起止地址在mm_struct中都有属性来记录，还保存虚拟页到实际物理地址的映射：pgd_t</p><p>fork() =&gt; copy_mm()函数来完成创建mm_struct</p><p>内核线程的使用不一样，因为内核线程没有进程地址空间，也就没有内存描述符，所以在进程描述符中，mm域为空。<br>当一个进程被调度时，该进程的mm域指向的地址空间被装载到内存，进程描述符中的active_mm域会被更新，指向新的地址空间。内核县城没有地址空间，mm域为NULL，当一个内核线程被调度的时候，内核发现mm域为NULL，会保留前一个进程的地址空间，随后内核更新内核县城对应的进程描述符中的active_mm域，使其只想前一进程的内存描述符。<br>内核线程如此使用，是因为内核线程是需要使用页表的（虚拟内存到物理内存的映射）。</p></li><li><p>虚拟内存区域vm_area_struct(VMA)<br>vm_area_struct结构体描述了制定地址空间内连续区间上的一个独立内存范围。内核将每个内存区域作为一个单独的内存对象管理，每个内存区域都拥有一致的属性，如访问权限等。<br>vm_area_struct在&lt;linux/mm_types.h&gt;中。<br>主要就是区间的首尾地址，VMA形成的链表，访问权限，mm_struct指针<br>使用中可以使用pmap <pid> 打印出进程的各个VMA。<br>比如C库中的物理内存1212KB空间，内存中只映射一份，将这些地址空间以只读的方式映射进每个引用的进程中即可.某个vm_area_struct就可以映射一份即可。</pid></p><p>mmap() 和 do_mmap（）创建地址空间。其实如果是地址空间跟一个已经存在的地址空间相邻，并且访问权限相同，两个空间就合并（类似与扩展）。反之就创建一新的VMA，并把地址加到进程的地址空间中。</p></li><li><p>页表<br>应用程序操作的是虚拟内存，但CPU直接操作确是物理内存，所以当程序访问虚拟内存时，必须将虚拟内存转换成物理内存，CPU才能解析地址访问请求。地址转换工作通过查询页表完成。<br>linux中使用三级页表完成地址转换：<br>顶层页表PGD（页全局目录），它包含了一个pgd_t类型数组<br>二级页表PMD(页中间目录)，是一个pmd_t类型数组<br>底层页表PTE，包含了pte_t类型的页表，指向物理页面<br>搜索页面的工作一部分是由硬件完成的，对应的结构提依赖具体的体系结构，定义在&lt;asm/page.h&gt;中<br><img src="页表.png" alt=""> </p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本博文从《linux内核设计与实现》第三版的笔记，主要是任务调度、终端、内存管理、虚拟文件系统等部分。作为导读来存在，为以后看源码做点准备。&lt;/p&gt;
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>对js中{}的思考</title>
    <link href="http://yoursite.com/2018/11/29/%E5%AF%B9js%E4%B8%AD&#39;%7B%7D&#39;%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://yoursite.com/2018/11/29/对js中&#39;{}&#39;的思考/</id>
    <published>2018-11-29T08:31:47.000Z</published>
    <updated>2019-02-15T08:01:26.530Z</updated>
    
    <content type="html"><![CDATA[<p>这次在现场对于新给的工程量的解析与存储时，又发现对于js中”{}”的使用又存在着疑惑，这个疑惑在以前分析过，但记录确实找不到了，现对它再次进行分析。<br><a id="more"></a></p><h1 id="js中的”-”与C-中的map"><a href="#js中的”-”与C-中的map" class="headerlink" title="js中的”{}”与C++中的map"></a>js中的”{}”与C++中的map</h1><p>  c++中的map与js中的”{}”都是一种键值对的结构，键是唯一的，可以通过键快速的访问value。</p><p>  在c++的STL的map中，我们可以将一个类的对象作为键值放在key的位置，value的位置可以放任意数据，key位置的数据需要实现&lt;的比较运算即可，但”{}”的键值对是片面的键值对，因为其只能是字符串-值的。</p><p>  这里可以再引申一下js中的Map，这个Map号称是键值对，它也确实可以将对象存在key的位置上，但它是巨坑的实现，因为它的key位置的唯一不是按key对象的值来判断的，而是按地址来判断的。</p><h1 id="js中的”-”与C-中的struct"><a href="#js中的”-”与C-中的struct" class="headerlink" title="js中的”{}”与C++中的struct"></a>js中的”{}”与C++中的struct</h1><p>  前文说到”{}”其实是字符串-值的一种结构，它的名字叫对象，那它与静态语言中的对象有什么异同呢？ 拿c++的struct来与”{}”来做个对比</p><p>  struct与”{}”都可以仅放数据，也可以放数据与函数，在C++使用时一般沿用C的方式，将struct只放数据，而用class来当类来使用。</p><p>  比如在做一个Student对象时：<br>  C++中需要先声明一个Strudent的结构体：<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">  <span class="built_in">string</span> name;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  <span class="built_in">string</span> sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 然后用这个结构体来实例化对象：<br> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student s1 = &#123;<span class="string">"张三"</span>,<span class="number">13</span>,<span class="string">"男"</span>&#125;</span><br><span class="line">Student s2 = &#123;<span class="string">"李四"</span>，<span class="number">14</span>,<span class="string">"男"</span>&#125;</span><br></pre></td></tr></table></figure></p><p> 而在js中的”{}”需要：<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = &#123;<span class="string">"name"</span>:<span class="string">"张三"</span>, <span class="string">"age"</span>:<span class="number">13</span>, <span class="string">"sex"</span>:<span class="string">"男"</span>&#125;</span><br><span class="line"><span class="keyword">let</span> s2 = &#123;<span class="string">"name"</span>:<span class="string">"李四"</span>, <span class="string">"age"</span>:<span class="number">14</span>, <span class="string">"sex"</span>:<span class="string">"男"</span>&#125;</span><br></pre></td></tr></table></figure></p><p> 这样我们看到，js中的对象由于没有类型，所以需要把变量信息也包含在对象内部。数据效率相对低一些。<br> 访问时都是： s1.name</p><h1 id="对”-”的理解"><a href="#对”-”的理解" class="headerlink" title="对”{}”的理解"></a>对”{}”的理解</h1><p>前便说到”{}”中是变量信息放在了key的位置上，这句话需要再解释一下。<br>我们完全可以创建一个这样的对象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> zs = &#123;<span class="string">"张三"</span>:<span class="number">13</span>&#125;</span><br></pre></td></tr></table></figure></p><p>这样的结果是key的位置上，其实是一个之前的name，是一个信息，而不是简单的变量名的概念。访问时可以是zs.张三。（当然，也可以认为变量名是汉字，虽然一般人都不会这样玩，但C++的变量名确实也可以是汉字。） </p><p>综上： 对”{}”的理解最到位的就是 字符串-值结构的对象。</p><p>既然只能是字符串，那对象如何来做key值，方法呼之欲出，将对象转换成string来使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s3 = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> keyObj = &#123;<span class="string">"张三"</span>:<span class="string">"3班"</span>&#125;</span><br><span class="line"><span class="keyword">let</span> k = <span class="built_in">JSON</span>.stringify(keyObj)</span><br><span class="line">s3[k] = <span class="number">14</span></span><br></pre></td></tr></table></figure><h1 id="js中的”-”与python中的”-”"><a href="#js中的”-”与python中的”-”" class="headerlink" title="js中的”{}”与python中的”{}”"></a>js中的”{}”与python中的”{}”</h1><p>“{}”在js与python中的差异性更不明显一些。”{}”在python中叫字典，在js中叫对象。</p><p>在使用上它们都可以如此使用：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">"a"</span>:<span class="number">1</span>&#125;</span><br><span class="line">a[<span class="string">"a"</span>]      // <span class="number">1</span></span><br><span class="line">a.get(<span class="string">"a"</span>)  // <span class="number">1</span></span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;<span class="string">"a"</span>:<span class="number">1</span>&#125;</span><br><span class="line">a[<span class="string">"a"</span>]   <span class="comment">// 1</span></span><br><span class="line">a.a      <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>但他们在深层次上是不同的，python中的””更像是动态语言中的map，因为它不能包括函数，而是当作一种数据结构来使用。而js中的”{}”更接近与动态语言中的struct，因为它不仅可以包含函数，更可以通过”.”来访问数据。<br>如在js中<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.fun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">111</span>)&#125;</span><br><span class="line">a.fun()</span><br></pre></td></tr></table></figure></p><p>但在python中则不能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次在现场对于新给的工程量的解析与存储时，又发现对于js中”{}”的使用又存在着疑惑，这个疑惑在以前分析过，但记录确实找不到了，现对它再次进行分析。&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>android开发记录</title>
    <link href="http://yoursite.com/2018/11/28/android%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2018/11/28/android开发记录/</id>
    <published>2018-11-28T10:25:37.000Z</published>
    <updated>2019-02-15T08:01:26.530Z</updated>
    
    <content type="html"><![CDATA[<p> 随着开发深入，又要开始用Java来开发android了，上次没有总结出一篇像样的android博客出来，这次补上，随着开发陆续完善。</p><a id="more"></a><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="对于android与react开发的对比"><a href="#对于android与react开发的对比" class="headerlink" title="对于android与react开发的对比"></a>对于android与react开发的对比</h2><ul><li><p>相同：<br>android在开发时，最基础的过程是布局、activity、view，其中布局用于确定一个页面中有哪些组件以及他们之间的位置关系; activity通过findViewById得到布局中的view(组件)，来进行控制，包括获取数据已经控制显示数据; 对于view的事件（如button的点击），可以在布局中去指定，也可以在activity中去指定响应函数。 </p><p>对比react中的开发，布局对应着app.js中对不同组件组合以及css中布局的控制; activity中内容像是组件中的控制，包括document.getElementById()来获取元素，以及onClick（）响应等，包括组件之间的通信，以及与后端的通信，都可以在activity中去实现（不过大多都将module层抽象出来）; android中的view跟标签有些类似，当然可以自建view 对应着fragment，对应着react中的component(组建)</p></li><li><p>区别：<br>react的数据流是自上而下的流动， 而android中数据流可以自由流动;<br>react中大的封装用页面，且页面之间基本无法通信， 页面之间的封装用component; 在android中教为自由，毕竟大家都在一个进程中，数据是共享的，封装用布局来完成，页面控制由activity来完成。<br>react中component封装了view与对view的控制，而且本身也当作view来使用，是一种组合模式; 在android中将显示由基本的view与布局来完成，控制由activity来完成。</p><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2></li></ul><h2 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h2><p>application的创建在MainActivity之前</p><h2 id="activity"><a href="#activity" class="headerlink" title="activity"></a>activity</h2><ul><li><p>问题<br>在返回401时去强制登录时，发现由于一个activity中相应调用了2次network，结果会启动2次LoginActivity，结果是启动了2次?<br>LoginActivity中使用android:launchMode=”singleTask”配置解决。</p></li><li><p>lanchMode<br>lanchMode规定了activity创建时的方式:<br>1.standard ,每次都会重新创建activity<br>2.singleTop, 在堆栈Top时，按理应该只创建一次，正符合现在的情况，但不好使<br>3.singleTask， 每个Task只有一个<br>4.singleInstance， 只有一个</p></li></ul><h2 id="task"><a href="#task" class="headerlink" title="task"></a>task</h2><p>task是一个具有栈结构的对象，一个task可以管理多个Activity，启动一个应用，也就是创建一个与之对应的task</p><h2 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h2><ul><li>方式<ol><li>显式</li><li>隐式</li></ol></li></ul><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><h2 id="fragment"><a href="#fragment" class="headerlink" title="fragment"></a>fragment</h2><h2 id="切换动画"><a href="#切换动画" class="headerlink" title="切换动画"></a>切换动画</h2><p>overridePendingTransition<br><a href="https://blog.csdn.net/bufanni12/article/details/26453725" target="_blank" rel="noopener">切换动画</a></p><h1 id="活动栈与生命周期"><a href="#活动栈与生命周期" class="headerlink" title="活动栈与生命周期"></a>活动栈与生命周期</h1><p><img src="活动栈.png" alt="活动栈"></p><p><img src="activity生命周期.png" alt="栈的结构"></p><h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h2 id="组件的继承结构"><a href="#组件的继承结构" class="headerlink" title="组件的继承结构"></a>组件的继承结构</h2><p><img src="常用控件的继承结构.png" alt="常用控件的继承结构"></p><h2 id="向上按钮"><a href="#向上按钮" class="headerlink" title="向上按钮"></a>向上按钮</h2><h2 id="下拉框-Spinner"><a href="#下拉框-Spinner" class="headerlink" title="下拉框 Spinner"></a>下拉框 Spinner</h2><h2 id="弹窗-AlertDialog"><a href="#弹窗-AlertDialog" class="headerlink" title="弹窗 AlertDialog"></a>弹窗 AlertDialog</h2><h2 id="BottomNavigation"><a href="#BottomNavigation" class="headerlink" title="BottomNavigation"></a>BottomNavigation</h2><ul><li><p>activity方式<br>一般的BottomNavigation在使用过程中，都是用fragment来切换界面，而现在是在activity中实现的，使用过程中，在每一个activity中，都增加一个BottomNavigation视图，在每一个BottomNavigation中，都去写startActivity()。但这样就带来一个问题：每次点击返回时，返回页面的底部导航不会复位。</p><p>从stockoverflow中，找到了一种处理方案:</p><ol><li>在布局xml中，将BottomNavigation独立到一个xml中，其他的xml通过include的方式来引入此xml</li><li>抽象出一个BaseActivity,封装对BottomNavigation的操作： 选择item，更新item，主要是将content对应的ViewId，以及NavigationMenuId,封装成抽象函数，由具体的Activity来实现。</li><li>具体的Acivity 从BaseActivity中继承，并实现2个接口，即可实现操作。</li></ol><p>ps： 从根本上解决问题的是include方式来引入BottomNavigation， 并通过继承的方式来完成操作的封装，这里使用的模式，类似于模板模式。</p><p>原文如下：<br><a href="https://stackoverflow.com/questions/48479505/fragments-or-activities-with-persistent-bottomnavigationview" target="_blank" rel="noopener">BottomNavigation</a> </p></li><li><p>超过3个按钮的处理</p></li></ul><h2 id="WebView"><a href="#WebView" class="headerlink" title="WebView"></a>WebView</h2><p>很多App内置了Web网页，如淘宝、京东，这些实现都是使用WebView的组件来实现的。原文：<br><a href="https://blog.csdn.net/carson_ho/article/details/52693322" target="_blank" rel="noopener">WebView</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li>显示和渲染Web页面</li><li>直接使用html作布局</li><li>可和JavaScript交互调用</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><h1 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h1><p>requestPermissions<br><a href="https://www.jianshu.com/p/33a31c967d5e" target="_blank" rel="noopener">requestPermissions</a></p><p><img src="权限申请.png" alt="权限申请"></p><ul><li><p>背景<br>安装时权限<br>运行时权限</p></li><li><p>分类<br>正常权限<br>危险权限</p></li><li><p>适配API<br>在Android M的SDK中，在Activity中新增了进行运行时权限适配的三个API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">requestPermissions</span><span class="params">(String[] permissions, <span class="keyword">int</span> requestCode)</span><span class="comment">//请求权限，参数可以是一个权限或者是多个。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onRequestPermissionsResult</span><span class="params">(<span class="keyword">int</span> requestCode, String[] permissions, <span class="keyword">int</span>[] grantResults)</span><span class="comment">//请求权限之后的回调。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">shouldShowRequestPermissionRationale</span><span class="params">(String permission)</span><span class="comment">//是否有必要 告诉用户我们需要这个权限的原因。</span></span></span><br></pre></td></tr></table></figure><p>Context中添加了一个API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkSelfPermission</span><span class="params">(String permission)</span><span class="comment">//用来检测当前应用是否具有某个权限。</span></span></span><br></pre></td></tr></table></figure></li><li><p>官方版本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 检查是否已经具有权限</span></span><br><span class="line"><span class="keyword">if</span> (ContextCompat.checkSelfPermission(thisActivity,Manifest.permission.READ_CONTACTS)</span><br><span class="line">    != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">    <span class="comment">// 是否需要告诉用户我们为什么需要这个权限</span></span><br><span class="line">    <span class="keyword">if</span> (ActivityCompat.shouldShowRequestPermissionRationale(thisActivity,</span><br><span class="line">     Manifest.permission.READ_CONTACTS)) &#123;</span><br><span class="line">     <span class="comment">//弹出信息，告诉用户我们为啥需要权限</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//直接获取权限</span></span><br><span class="line">    ActivityCompat.requestPermissions(thisActivity,</span><br><span class="line">            <span class="keyword">new</span> String[]&#123;Manifest.permission.READ_CONTACTS&#125;,</span><br><span class="line">            MY_PERMISSIONS_REQUEST_READ_CONTACTS);</span><br><span class="line">    <span class="comment">//用户授权的结果会回调到FragmentActivity的onRequestPermissionsResult</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="comment">//已经拥有授权</span></span><br><span class="line"> readContacts();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在onRequestPermissionsResult中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestPermissionsResult</span><span class="params">(<span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">   String permissions[], <span class="keyword">int</span>[] grantResults)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">switch</span> (requestCode) &#123;</span><br><span class="line">   <span class="keyword">case</span> MY_PERMISSIONS_REQUEST_READ_CONTACTS: &#123;</span><br><span class="line">       <span class="keyword">if</span> (grantResults.length &gt; <span class="number">0</span></span><br><span class="line">           &amp;&amp; grantResults[<span class="number">0</span>] == PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">           readContacts();</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//权限没能授权通过，可以考虑弹个toast告诉用户</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><p><a href="https://www.jianshu.com/p/904042f8211c" target="_blank" rel="noopener">存储</a></p><p><a href="https://blog.csdn.net/nugongahou110/article/details/48154859" target="_blank" rel="noopener">存储</a></p><h1 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a>SQLite</h1><h2 id="onCreate与onUpgrade"><a href="#onCreate与onUpgrade" class="headerlink" title="onCreate与onUpgrade"></a>onCreate与onUpgrade</h2><h1 id="Retrifit"><a href="#Retrifit" class="headerlink" title="Retrifit"></a>Retrifit</h1><h2 id="Interceptor"><a href="#Interceptor" class="headerlink" title="Interceptor"></a>Interceptor</h2><h2 id="Call同步与异步"><a href="#Call同步与异步" class="headerlink" title="Call同步与异步"></a>Call同步与异步</h2><h2 id="http通信的转换器"><a href="#http通信的转换器" class="headerlink" title="http通信的转换器"></a>http通信的转换器</h2><h1 id="图表：MPAndroidChart"><a href="#图表：MPAndroidChart" class="headerlink" title="图表：MPAndroidChart"></a>图表：MPAndroidChart</h1><h2 id="引入MPAndroidChart"><a href="#引入MPAndroidChart" class="headerlink" title="引入MPAndroidChart"></a>引入MPAndroidChart</h2><p>在工程中引入MPAndroidChart模块，需要注意2点：</p><p>在外层的build.gradle下的allprojects中增加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">        maven &#123; url &quot;https://jitpack.io&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在内层app的build.gradle下的denpendencies下增加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation &apos;com.github.PhilJay:MPAndroidChart:v3.0.3&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里用imlementation或者api，不用compile， compile已经弃用，并且与现在的api相同，imlementation只在引入的包里有用，而在其上层里，无用。</p><h2 id="图表的使用"><a href="#图表的使用" class="headerlink" title="图表的使用"></a>图表的使用</h2><ul><li><p>布局</p><p>在activity或者fragment的布局文件中，引入图表，如下图，引入了柱状图：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.github.mikephil.charting.charts.BarChart</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/chart_single_month"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br></pre></td></tr></table></figure><p>坐标轴的处理，下边的使用就将BarChart当成view使用即可，调整坐标轴、图例等，并将数据放入，触发更新即可。</p></li><li><p>坐标轴的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> BarChart mBarChart;</span><br><span class="line">mBarChart = findViewById(R.id.chart_single_month);</span><br><span class="line"></span><br><span class="line">XAxis xAxis = mBarChart.getXAxis();             <span class="comment">// 获取横轴</span></span><br><span class="line">xAxis.setPosition(XAxis.XAxisPosition.BOTTOM);  <span class="comment">// 设置位置</span></span><br><span class="line"></span><br><span class="line">IAxisValueFormatter xAxisFormatter = <span class="keyword">new</span> DayAxisValueFormatter();</span><br><span class="line">xAxis.setValueFormatter(xAxisFormatter);       <span class="comment">// 设置横轴的标志</span></span><br></pre></td></tr></table></figure><p>横轴的标志，是通过IAxisValueFormatter接口来实现的，需要实现getFormattedValue()接口，它传入的值是数值中的x坐标值。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DayAxisValueFormatter</span> <span class="keyword">implements</span> <span class="title">IAxisValueFormatter</span></span></span><br><span class="line"><span class="class">  </span>&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">getFormattedValue</span><span class="params">(<span class="keyword">float</span> value, AxisBase axis)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> String.valueOf((<span class="keyword">int</span>) value + <span class="string">"月"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>点击事件的处理<br>点击事件，显示的就是MarkerView</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">XYMarkerView mv = <span class="keyword">new</span> XYMarkerView(<span class="keyword">this</span>, xAxisFormatter);</span><br><span class="line">mv.setChartView(mBarChart); <span class="comment">// For bounds control</span></span><br><span class="line">mBarChart.setMarker(mv); <span class="comment">// Set the marker to the chart</span></span><br></pre></td></tr></table></figure><p>这个XYMarkView中需要填充view，并实现 refreshContent（）接口,在这个接口中，实现点击内容显示的调整。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XYMarkerView</span> <span class="keyword">extends</span> <span class="title">MarkerView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XYMarkerView</span><span class="params">(Context context, IAxisValueFormatter xAxisValueFormatter)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(context, R.layout.custom_marker_view);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refreshContent</span><span class="params">(Entry e, Highlight highlight)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>图例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Legend l = mBarChart.getLegend();</span><br><span class="line">l.setVerticalAlignment(Legend.LegendVerticalAlignment.TOP);</span><br><span class="line">l.setHorizontalAlignment(Legend.LegendHorizontalAlignment.CENTER);</span><br><span class="line">l.setOrientation(Legend.LegendOrientation.HORIZONTAL);</span><br><span class="line">l.setForm(Legend.LegendForm.SQUARE);</span><br></pre></td></tr></table></figure><p>设置图例, 水平位置等。</p></li><li><p>设置数据</p><h1 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h1><h1 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h1><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1></li><li><p>弱引用<br>在其他util中持有activity 时，使用弱引用，解决内存泄漏问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> WeakReference&lt;Activity&gt; mWeakActivity;</span><br></pre></td></tr></table></figure></li><li><p>尾调用<br>在单例中， 相应函数最后都返回instance即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KbPermission <span class="title">with</span><span class="params">(@NonNull Activity activity)</span> </span>&#123;</span><br><span class="line">     instance.setActivity(activity);</span><br><span class="line">     <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="开发记录"><a href="#开发记录" class="headerlink" title="开发记录"></a>开发记录</h1><h2 id="关于打包成apk"><a href="#关于打包成apk" class="headerlink" title="关于打包成apk"></a>关于打包成apk</h2><p><a href="https://www.jianshu.com/p/7e5b1bacc35c" target="_blank" rel="noopener">打包</a></p><h2 id="关于高德地图key值的处理"><a href="#关于高德地图key值的处理" class="headerlink" title="关于高德地图key值的处理"></a>关于高德地图key值的处理</h2><p><a href="https://lbs.amap.com/faq/top/hot-questions/249" target="_blank" rel="noopener">高德地图key</a></p><h2 id="外部存储的使用与照片"><a href="#外部存储的使用与照片" class="headerlink" title="外部存储的使用与照片"></a>外部存储的使用与照片</h2><p><a href="https://www.jianshu.com/p/904042f8211c" target="_blank" rel="noopener">照片</a></p><p><a href="https://blog.csdn.net/nugongahou110/article/details/48154859" target="_blank" rel="noopener">照片</a></p><h2 id="android崩溃的处理方式"><a href="#android崩溃的处理方式" class="headerlink" title="android崩溃的处理方式"></a>android崩溃的处理方式</h2><p><a href="https://blog.csdn.net/l_lhc/article/details/52108474" target="_blank" rel="noopener">android崩溃的处理方式</a></p><h2 id="MVVM模型：databinding"><a href="#MVVM模型：databinding" class="headerlink" title="MVVM模型：databinding"></a>MVVM模型：databinding</h2><p><a href="https://www.jianshu.com/p/a898ef83f38c" target="_blank" rel="noopener">MVVM模型</a></p><p><a href="https://developer.android.com/topic/libraries/data-binding/" target="_blank" rel="noopener">MVVM模型</a></p><p><a href="http://connorlin.github.io/2016/07/02/Android-Data-Binding-%E7%B3%BB%E5%88%97-%E4%B8%80-%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">MVVM模型</a></p><h2 id="RxBus的使用"><a href="#RxBus的使用" class="headerlink" title="RxBus的使用"></a>RxBus的使用</h2><p><a href="https://juejin.im/post/5b5ac0825188251acd0f3777" target="_blank" rel="noopener">RxBus的使用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 随着开发深入，又要开始用Java来开发android了，上次没有总结出一篇像样的android博客出来，这次补上，随着开发陆续完善。&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>CSS布局总结</title>
    <link href="http://yoursite.com/2018/11/28/css%E6%A0%B7%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/11/28/css样式总结/</id>
    <published>2018-11-28T08:00:00.000Z</published>
    <updated>2019-02-15T08:01:26.530Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要汇总开发中前端布局，遇到的小问题以及对小问题的研究</p><a id="more"></a><h1 id="框模型：元素本身大小的控制"><a href="#框模型：元素本身大小的控制" class="headerlink" title="框模型：元素本身大小的控制"></a>框模型：元素本身大小的控制</h1><h2 id="关于width-heigh-padding-border-margin的关系"><a href="#关于width-heigh-padding-border-margin的关系" class="headerlink" title="关于width,heigh,padding,border,margin的关系"></a>关于width,heigh,padding,border,margin的关系</h2><p>  <img src="框模型.png" alt=""></p><p>  对于框模型已经较为熟悉了，但有一点height与width属性都是内容部分的属性，而不是整个元素的属性。元素的宽度 = width + 2<em>padding + 2</em>border + 2*margin<br>  <img src="框模型宽度计算.png" alt=""></p><ul><li><p>100%的设置尺寸问题<br>子元素继承父元素的width是content，子元素尺寸100%的设置时，不能再设置padding、border、magin等宽度，否则就会超出限制</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="selector-class">.child</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">50px</span> solid green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的child元素的尺寸会超出父元素parent，因为child元素的尺寸已经是100%父元素的内容了，父元素没有设置border，而子元素增加border的宽度，这样就会超出了100px。</p></li><li><p>居中的一种实现：<br>.center-me { margin: 0 auto; }</p></li></ul><h2 id="子元素与父元素尺寸（width，-height）关系"><a href="#子元素与父元素尺寸（width，-height）关系" class="headerlink" title="子元素与父元素尺寸（width， height）关系"></a>子元素与父元素尺寸（width， height）关系</h2><p>若父元素与子元素都设置了尺寸，则各自按照自己的设置进行。</p><p>height展现了一种自下向上的尺寸影响路线：子元素设置的height,会决定父元素的height；父元素的height不会影响子元素的height。</p><p>width展示了从上而下的影响路线：父元素设置的width，会决定子元素的width；子元素的width设置不会影响父元素的width。</p><h1 id="position-元素位置的控制"><a href="#position-元素位置的控制" class="headerlink" title="position: 元素位置的控制"></a>position: 元素位置的控制</h1><h2 id="关于position-top-right-bottom-left的使用"><a href="#关于position-top-right-bottom-left的使用" class="headerlink" title="关于position,top,right,bottom,left的使用"></a>关于position,top,right,bottom,left的使用</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">position: relative/absolute/fixed </span><br><span class="line"><span class="selector-tag">top</span>: 10<span class="selector-tag">px</span></span><br><span class="line"><span class="selector-tag">right</span>: 10<span class="selector-tag">px</span></span><br><span class="line"><span class="selector-tag">bottom</span>: 10<span class="selector-tag">px</span></span><br><span class="line"><span class="selector-tag">left</span>: 10<span class="selector-tag">px</span></span><br></pre></td></tr></table></figure><h2 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h2><p>将窗体自上而下分成一行行, 并在每行中按从左至右的顺序排放元素,即为文档流。<br>只有三种情况会使得元素脱离文档流，分别是：浮动、相对定位和固定定位。</p><ul><li><p>静态定位<br>static，无特殊定位，它是html元素默认的定位方式，即我们不设定元素的position属性时默认的position值就是static，它遵循正常的文档流对象，对象占用文档空间，该定位方式下，top、right、bottom、left、z-index等属性是无效的。</p></li><li><p>相对定位相对的是它在文档流中的位置而进行偏移，且不脱离文档流</p></li><li><p>绝对定位：absolute</p><p>使用absoult定位的元素脱离文档流后，就只能根据祖先类元素(父类以上)进行定位，而这个祖先类还必须是以postion非static方式定位的</p><p>relative和static方式在最外层时是以body标签为定位原点的，而absoulte方式在无父级是position非static定位时是以html作为原点定位。html和body元素相差9px左右</p><p>absoulte定位要加 top:0; left:0。因为我们如果使用absoulte或fixed定位的话，必须指定 left、right、 top、 bottom 属性中的至少一个，否则left/right/top/bottom属性会使用它们的默认值 auto，简单讲就是都变成relative。</p><p>少了left/right/top/bottom属性不行，那如果我们多设了呢？例如，我们同时设置了top和bottom的属性值，那元素又该往哪偏移好呢？记住下面的规则：<br>如果top和bottom一同存在的话，那么只有top生效。<br>如果left和right一同存在的话，那么只有left生效。</p><p>absoulte是根据祖先类的border进行的定位</p></li><li><p>固定定位：fixed</p><p>fixed定位，又称为固定定位，它和absoult定位一样，都脱离了文档流，并且能够根据top、right、left、bottom属性进行定位，但不同的是fixed是根据窗口为原点进行偏移定位的，也就是说它不会根据滚动条的滚动而进行偏移。</p></li><li><p>z-index属性</p><p>z-index，又称为对象的层叠顺序，它用一个整数来定义堆叠的层次，整数值越大，则被层叠在越上面，当然这是指同级元素间的堆叠，如果两个对象的此属性具有同样的值，那么将依据它们在HTML文档中流的顺序层叠，写在后面的将会覆盖前面的。需要注意的是，父子关系是无法用z-index来设定上下关系的，一定是子级在上父级在下。</p><p>使用static 定位z-index属性是无效的</p></li></ul><h1 id="flex-浮动"><a href="#flex-浮动" class="headerlink" title="flex: 浮动"></a>flex: 浮动</h1><p>  display: flex<br>  待整理…<br>  <a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">阮一峰：Flex 布局教程</a></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul><li><p>屏幕适应<br>待整理</p></li><li><p>css文档流与DOM树<br>待整理<br>css是按DOM树的叶子节点还是根节点进行样式的刷新的。<br>屏幕宽度与文档宽度的差异</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要汇总开发中前端布局，遇到的小问题以及对小问题的研究&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>js中的模块</title>
    <link href="http://yoursite.com/2018/11/28/js%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2018/11/28/js中的模块/</id>
    <published>2018-11-28T02:00:00.000Z</published>
    <updated>2019-02-15T08:01:26.530Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要汇总开发中后端、语言，遇到的小问题以及对小问题的研究</p><a id="more"></a><h1 id="require"><a href="#require" class="headerlink" title="require"></a>require</h1><p>   node使js可以运行于后台，于是就有了对模块的需要。<br>   require的解决方式是将模块中的所有对象（变量、函数、类）都成为一个对象module.exports对象的子对象，然后在其他模块中直接通过require模块名来引用导出的molule.exports对象，来直接访问。<br>   使用：</p><p>   test.js<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123; </span><br><span class="line">    a : function()&#123;&#125;,</span><br><span class="line">    b : &apos;test&apos;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var t = require(&apos;./test&apos;);</span><br><span class="line">t.a();</span><br></pre></td></tr></table></figure><h1 id="AMD与CMD"><a href="#AMD与CMD" class="headerlink" title="AMD与CMD"></a>AMD与CMD</h1><p>  require在服务端优势明显，因为加载的模块在服务器硬盘上，而在浏览器端确需要等待网络传输，加载完成后才可以使用模块中的对象，这种同步方式不符合js异步的理念，于是就有了AMD与CMD两种异步加载方式。<br>  AMD: Asynchronous Module Definition<br>  CMD: Common Module Definition<br>  AMD是将对依赖加载模块部分都放到异步函数中完成</p><p>  math.js<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define([&apos;Lib&apos;], function(Lib)&#123;</span><br><span class="line">　　　　function foo()&#123;</span><br><span class="line">　　　　　　Lib.doSomething();</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　return &#123;</span><br><span class="line">　　　　　　foo : foo</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require([&apos;math&apos;], function (math) &#123;</span><br><span class="line">　      math.add(2, 3);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="ES6的import"><a href="#ES6的import" class="headerlink" title="ES6的import"></a>ES6的import</h1><p>  ES6应该也是一种异步加载方式，具体原理没有深入了解<br>  它是通过解构的方式来导入、到处，这样就可以不用引用所有对象。另外有一个default语法糖，每个模块都有只一个default，这样在import时可以不写解构的过程。<br>  与default语法糖相关的是as关键字，像是SQL的as，起一个别名，default就是这个别名。<br>  export还是的到处可以放在每个对象上定义，而不是放在一个exports对象里。</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export &#123; name1, name2, …, nameN &#125;;</span><br><span class="line">export &#123; variable1 as name1, variable2 as name2, …, nameN &#125;;</span><br><span class="line">export default expression;</span><br><span class="line"></span><br><span class="line">import &#123; member &#125; from &quot;module-name&quot;;</span><br><span class="line">import &#123; member as alias &#125; from &quot;module-name&quot;;</span><br><span class="line">import defaultMember from &quot;module-name&quot;</span><br></pre></td></tr></table></figure></code></pre><h1 id="module-与-namespace"><a href="#module-与-namespace" class="headerlink" title="module 与 namespace"></a>module 与 namespace</h1><p>下边先来看看Namespace 与 Modules</p><p>原文:<a href="https://www.typescriptlang.org/docs/handbook/namespaces-and-modules.html" target="_blank" rel="noopener">namespace</a><br>开篇的Note：ES2015开始，internal moludes = namespaces, external modules 是modules</p><ul><li><p>namespace<br>namespace是一个在全局命名空间里的对象而已，只不过这个对象定义在多个文件中，通过使用 –outFile 连接在一起。</p></li><li><p>modules<br>与namespace一样，mudule也是既可以包括代码跟声明，最大的区别是modules声明了了依赖。<br>modules依赖与module loader(如 CommonJs/Require.js),使其更适应于大应用，Module提供更好的代码复用、更强的隔离。</p><p>编译器会先去找.ts, .tsx然后 .d.ts， 如果都没有，就去找 module声明。<br>myModules.d.ts</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">declare <span class="built_in">module</span> <span class="string">"SomeModule"</span> &#123;</span><br><span class="line"> <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>): <span class="title">string</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>myOtherModule.ts</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m <span class="keyword">from</span> <span class="string">"SomeModule</span></span><br></pre></td></tr></table></figure></li><li><p>socket.io的引入<br>在index.d.ts中，</p><p> 先定义了SocketIO对象，它是一个SocketIOStatic的类型<br> export = SocketIO ,这块就有点费解， 私下任务，可能就是requrie的modules那种形式。</p><p> 然后再 export as namespace SocketIO,还是不太明了，因为一个变量与一个namespace是重名的，下面也有对 declare namespace SocketIO</p><p> 最奇怪的是这个index.d.ts中，全是声明，没有一个实现，这中lib如何使用？</p></li></ul><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://www.cnblogs.com/libin-1/p/7127481.html" target="_blank" rel="noopener">彻底搞清楚javascript中的require、import和export</a></p><p><a href="http://imweb.io/topic/582293894067ce9726778be9" target="_blank" rel="noopener">Node中没搞明白require和import，你会被坑的很惨</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要汇总开发中后端、语言，遇到的小问题以及对小问题的研究&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>js中this的理解</title>
    <link href="http://yoursite.com/2018/11/28/js%E4%B8%ADthis%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/11/28/js中this的理解/</id>
    <published>2018-11-28T02:00:00.000Z</published>
    <updated>2019-02-15T08:01:26.530Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要汇总开发中后端、语言，遇到的小问题以及对小问题的研究</p><a id="more"></a><h1 id="一句话"><a href="#一句话" class="headerlink" title="一句话"></a>一句话</h1><p> 一句话： this是函数的运行时环境<br> 解释： 谁调用的函数，this就是谁</p><p> 例如：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> var a = 1</span><br><span class="line"></span><br><span class="line"> function test() &#123;</span><br><span class="line">   console.log(this.a)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;&#125;</span><br><span class="line">obj.a = 2</span><br><span class="line">obj.t = test</span><br><span class="line"></span><br><span class="line">obj.t()           // 2</span><br><span class="line">t()               // 1</span><br></pre></td></tr></table></figure></p><h1 id="两个注意"><a href="#两个注意" class="headerlink" title="两个注意"></a>两个注意</h1><h2 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h2><p>函数的this可以通过bind来绑定，使其不受调用者的影响</p><p>function test (){}<br>test.bind(this)</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>箭头函数() =&gt; {}，this始终指向定义者，而不受调用者的影响。</p><h1 id="内存解释"><a href="#内存解释" class="headerlink" title="内存解释"></a>内存解释</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; foo:  5 &#125;;</span><br></pre></td></tr></table></figure><p>它在内存中先创建一个 {foo:5} 对象，然后再将这个对象的地址用obj来表示</p><p><img src="变量-2.png" alt=""></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;foo: funciton()&#123;&#125;&#125;</span><br></pre></td></tr></table></figure><p>函数与变量捎有不同，它先将函数独立存储在内存中（应该在代码段里），然后再将函数的地址赋值给foo属性的value值，也就是说foo那里存储的是函数的地址。</p><p><img src="函数.png" alt=""></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="http://www.ruanyifeng.com/blog/2018/06/javascript-this.html" target="_blank" rel="noopener">阮一峰： JavaScript的this原理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要汇总开发中后端、语言，遇到的小问题以及对小问题的研究&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>React基础</title>
    <link href="http://yoursite.com/2018/11/08/2018-11-8React%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/11/08/2018-11-8React基础/</id>
    <published>2018-11-08T05:00:35.000Z</published>
    <updated>2019-02-15T08:01:26.530Z</updated>
    
    <content type="html"><![CDATA[<p>主要介绍React基础：包括React元素、React组件、React数据流、表单、列表等内容<br> <a href="https://react.docschina.org/docs/introducing-jsx.html" target="_blank" rel="noopener">React官方文档</a><br><a id="more"></a></p><h1 id="React基础"><a href="#React基础" class="headerlink" title="React基础"></a>React基础</h1><h2 id="React元素"><a href="#React元素" class="headerlink" title="React元素"></a>React元素</h2><h3 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">&lt;h1 className=<span class="string">"greeting"</span>&gt;</span><br><span class="line">   Hello, world</span><br><span class="line">)</span><br><span class="line">&lt;<span class="regexp">/h1&gt;</span></span><br></pre></td></tr></table></figure><p>Babel转译器把JSX转换成:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = React.createElement(</span><br><span class="line"><span class="string">"h1"</span>,</span><br><span class="line"> &#123;<span class="attr">className</span>:<span class="string">"greeting"</span>&#125;,</span><br><span class="line"> <span class="string">"Hello, world!"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>createElement会返回一个类似于下面的对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line"> type: <span class="string">'h1'</span>,</span><br><span class="line"> props: &#123;</span><br><span class="line">   className: <span class="string">'greeting'</span>,</span><br><span class="line">   children: <span class="string">'Hello, world'</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将React元素渲染到根DOM节点中,通常使用ReactDOM.render()<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">ReactDOM.render(element, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>))</span><br></pre></td></tr></table></figure></p><p>ReactDOM的渲染只会更新渲染文本节点中发生变化的内容.</p><h3 id="JSX-和-HTML-的区别"><a href="#JSX-和-HTML-的区别" class="headerlink" title="JSX 和 HTML 的区别"></a>JSX 和 HTML 的区别</h3><ul><li><p>class<br>在JSX中不能使用class，因为是ES6的关键字，而使用className</p></li><li><p>style 属性<br> style属性接受一个对象，而不是分号分割的字符串。CSS使用驼峰命名发</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> styles = &#123;</span><br><span class="line">  fontSize = <span class="string">'2em'</span>,</span><br><span class="line">  lineHeight: <span class="string">'1.6'</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> em = <span class="xml"><span class="tag">&lt;<span class="name">em</span> <span class="attr">style</span>=<span class="string">&#123;styles&#125;</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>JSX 中所有标签都需要闭合</p></li><li><p>用驼峰明明属性，像onClick<br>所有以data-与aria-开头的属性例外</p></li></ul><h3 id="子代"><a href="#子代" class="headerlink" title="子代"></a>子代</h3><p>在包含开始和结束标签的JSX表达式中，标记之间的内容作为特殊的参数传递：props:children。</p><ul><li><p>字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent&gt;Hello world!<span class="xml"><span class="tag">&lt;/<span class="name">MyComponent</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>props.children就是字符串</p></li><li><p>JSX<br>你可以通过子代嵌入更多的 JSX 元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyContainer&gt;</span><br><span class="line"> &lt;MyFirstComponent /&gt;</span><br><span class="line"> &lt;MySecondComponent /&gt;</span><br><span class="line">&lt;<span class="regexp">/MyContainer&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>javascript表达式</p></li><li>函数</li></ul><h2 id="React组件"><a href="#React组件" class="headerlink" title="React组件"></a>React组件</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>组件可以将UI切分成一些独立的、可复用的部件，它可以接受任意的输入值(称之为”props”)，并返回一个在页面上显示的React元素</p><p>函数定义<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>类定义<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">   render() &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span> Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>React元素，除了是DOM标签，也可以是用户自定义的组件<br>const element = <welcom name="Sara"><br>而且一个组件可以包含其他组建作为React元素<br>由此可见，我们React其实是一种组合模式，组件与组件的组合是一致对待的。<br>而且定义组件像是定义一个类，而组为React元组时，就是实例化的过程（CreateElement）</welcom></p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="react生命周期.png" alt=""></p><h3 id="props与state"><a href="#props与state" class="headerlink" title="props与state"></a>props与state</h3><p>组件内部绝不能修改它自己的的props。props保存了由父元素传递进来的数据，这些数据不可以在props中进行修改。</p><p>state可以根据用户操作、网络响应、或其他状态变化，使组件动态的响应并改变组件的输出。<br>state其实就是保存组件内部的数据变化，在使用中，可以通过生命成员变量的方式来使用。</p><p>内部的状态一般就是通过用户的操作（action），以及网络请求来触发状态的变化。action操作时，需要注意响应函数的this问题，一般用箭头函数来避免直接bind。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this is:'</span>， <span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;button onClick = &#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">  Click me</span><br><span class="line">&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">handleClick()&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this is:'</span>,<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;button onClick = &#123;(e) =&gt; <span class="keyword">this</span>.handleClick(e)&#125;&gt;</span><br><span class="line">  Click Me</span><br><span class="line">&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><h2 id="React组件间数据流"><a href="#React组件间数据流" class="headerlink" title="React组件间数据流"></a>React组件间数据流</h2><h3 id="自顶向下数据流"><a href="#自顶向下数据流" class="headerlink" title="自顶向下数据流"></a>自顶向下数据流</h3><p>React是一种自顶向下的数据传输,从父组件传递数据到子组件，因为从父组件传递给子组件的数据存放在props中，不能修改。</p><h3 id="反向数据流"><a href="#反向数据流" class="headerlink" title="反向数据流"></a>反向数据流</h3><p>但为什么还有反向数据流呢？ 因为可以从父组件传递回调函数进去，子组件通过回调函数，将数据作为参数传递，而达到反向数据传输的目的。这样其实需要把数据的存储从子组件提升到父组件中去。这在React中称谓状态提升（因为react喜欢把数据放在state中）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TemperatureInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.props.onTemperatureChange(e.target.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> temperature = <span class="keyword">this</span>.props.temperature;</span><br><span class="line">    <span class="keyword">const</span> scale = <span class="keyword">this</span>.props.scale;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;fieldset&gt;</span><br><span class="line">        &lt;legend&gt;在&#123;scaleNames[scale]&#125;:中输入温度数值&lt;<span class="regexp">/legend&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input value=&#123;temperature&#125;</span></span><br><span class="line"><span class="regexp">               onChange=&#123;this.handleChange&#125; /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/fieldset&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h2><ul><li><p>map<br>用来遍历数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> listItems = numbers.map(<span class="function">(<span class="params">number</span>) =&gt;</span></span><br><span class="line">  &lt;li&gt;&#123;number&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  &lt;ul&gt;&#123;listItems&#125;&lt;/u</span>l&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>&amp;&amp;<br>false、null、undefined 和 true 都是有效的子代，但它们不会直接被渲染。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Mailbox</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> unreadMessages = props.unreadMessages;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">      &#123;unreadMessages.length &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        &lt;h2&gt;</span><br><span class="line">          You have &#123;unreadMessages.length&#125; unread messages.</span><br><span class="line">        &lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>三目运算符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line"> <span class="keyword">const</span> isLoggedIn = <span class="keyword">this</span>.state.isLoggedIn;</span><br><span class="line"> <span class="keyword">return</span> (</span><br><span class="line">   &lt;div&gt;</span><br><span class="line">     &#123;isLoggedIn ? (</span><br><span class="line">       &lt;LogoutButton onClick=&#123;<span class="keyword">this</span>.handleLogoutClick&#125; /&gt;</span><br><span class="line">     ) : (</span><br><span class="line">       &lt;LoginButton onClick=&#123;<span class="keyword">this</span>.handleLoginClick&#125; /&gt;</span><br><span class="line">     )&#125;</span><br><span class="line">   &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"> );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p> 列表的key属性，在DOM中的某些元素增加或删除的时候帮助React识别哪些元素发生了变化，因此应当给数组中的每一元素赋予一个确定的标识。<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> listItems = numbers.map(<span class="function">(<span class="params">n</span>) =&gt;</span> </span><br><span class="line"> &lt;li key=&#123;n.toString()&#125;&gt;</span><br><span class="line">   n</span><br><span class="line"> &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure></p><p>  元素的key只有在它和它的兄弟节点对比时才有意义,而且应该唯一。 比如上例中，将<li>封装到一个组件ListItem中，那么key就不能放到li中了，而是放在ListItem下<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ListItem key=&#123;n.toString()&#125; value=&#123;n&#125; /&gt;</span><br></pre></td></tr></table></figure></li></p><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><h3 id="受控组件与非受控组件"><a href="#受控组件与非受控组件" class="headerlink" title="受控组件与非受控组件"></a>受控组件与非受控组件</h3><p>在HTML中，像<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>和<code>&lt;select&gt;</code>这类的表单元素会自己维持自身的状态，并根据用户输入自动进行刷新，这在React中被称谓非受控组件。<br>但在React中，可变的状态通常都保存在足组件的state中，并只能通过setState()方法控制其更新。这就称谓受控组建。</p><ul><li><p>受控组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameForm</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">value</span>: <span class="string">''</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.handleSubmit = <span class="keyword">this</span>.handleSubmit.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(event) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: event.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    alert(<span class="string">'A name was submitted: '</span> + <span class="keyword">this</span>.state.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          Name:</span><br><span class="line">          &lt;input type=<span class="string">"text"</span> value=&#123;<span class="keyword">this</span>.state.value&#125; onChange=&#123;<span class="keyword">this</span>.handleChange&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input type="submit" value="Submit" /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>由于 value 属性是在我们的表单元素上设置的，因此显示的值将始终为 React数据源上this.state.value 的值。由于每次按键都会触发 handleChange 来更新当前React的state，所展示的值也会随着不同用户的输入而更新。<br>它可以对每次的输入进行检验,需要设置value属性来完成，并在每次的点击时使用onChange（）来进行处理，并在onChange()通过setState（）进行重新渲染。</p></li><li><p>非受控组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">NameForm</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">   <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleSubmit = <span class="keyword">this</span>.handleSubmit.bind(<span class="keyword">this</span>);</span><br><span class="line">   </span><br><span class="line">   handleSubmit(event) &#123;</span><br><span class="line">    alert(<span class="string">'A name was submitted: '</span> + <span class="keyword">this</span>.input.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">   </span><br><span class="line">   render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          Name:</span><br><span class="line">          &lt;input type=<span class="string">"text"</span> ref=&#123;(input) =&gt; <span class="keyword">this</span>.input = input&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input type="submit" value="Submit" /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">   </span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>在 React 的生命周期中，表单元素上的 value 属性将会覆盖 DOM 中的值。使用非受控组件时，通常你希望 React 可以为其指定初始值，但不再控制后续更新。要解决这个问题，你可以指定一个 defaultValue 属性而不是 value。value值总是与文本框的最新内容保持一</p></li></ul><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p> Refs 提供了一种方式，用于访问在 render 方法中创建的 DOM 节点或 React 元素。<br> 通过ref将render中DOM节点或React元素进行指向。<br> 当一个 ref 属性被传递给一个 render 函数中的元素时，可以使用 ref 中的 current 属性对节点的引用进行访问。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomTextInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">   <span class="keyword">super</span>(props);</span><br><span class="line">   <span class="comment">// 创建 ref 存储 textInput DOM 元素</span></span><br><span class="line">   <span class="keyword">this</span>.textInput = React.createRef();</span><br><span class="line">   <span class="keyword">this</span>.focusTextInput = <span class="keyword">this</span>.focusTextInput.bind(<span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> focusTextInput() &#123;</span><br><span class="line">   <span class="comment">// 直接使用原生 API 使 text 输入框获得焦点</span></span><br><span class="line">   <span class="comment">// 注意：通过 "current" 取得 DOM 节点</span></span><br><span class="line">   <span class="keyword">this</span>.textInput.current.focus();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> render() &#123;</span><br><span class="line">   <span class="comment">// 告诉 React 我们想把 &lt;input&gt; ref 关联到构造器里创建的 `textInput` 上</span></span><br><span class="line">   <span class="keyword">return</span> (</span><br><span class="line">     &lt;div&gt;</span><br><span class="line">       &lt;input</span><br><span class="line">         type=<span class="string">"text"</span></span><br><span class="line">         ref=&#123;<span class="keyword">this</span>.textInput&#125; /&gt;</span><br><span class="line"></span><br><span class="line">         </span><br><span class="line">       &lt;input</span><br><span class="line">         type=<span class="string">"button"</span></span><br><span class="line">         value=<span class="string">"Focus the text input"</span></span><br><span class="line">         onClick=&#123;<span class="keyword">this</span>.focusTextInput&#125;</span><br><span class="line">       /&gt;</span><br><span class="line">     &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">   );</span></span><br><span class="line"><span class="regexp"> &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p> 回调Refs：<br> 不同于传递 createRef() 创建的 ref 属性，你会传递一个函数。这个函数接受 React 组件的实例或 HTML DOM 元素作为参数，以存储它们并使它们能被其他地方访问。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">CustomTextInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.textInput = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.setTextInputRef = <span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.textInput = element;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.focusTextInput = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 直接使用原生 API 使 text 输入框获得焦点</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.textInput) <span class="keyword">this</span>.textInput.focus();</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// 渲染后文本框自动获得焦点</span></span><br><span class="line">    <span class="keyword">this</span>.focusTextInput();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 使用 `ref` 的回调将 text 输入框的 DOM 节点存储到 React</span></span><br><span class="line">    <span class="comment">// 实例上（比如 this.textInput）</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"text"</span></span><br><span class="line">          ref=&#123;<span class="keyword">this</span>.setTextInputRef&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"button"</span></span><br><span class="line">          value=<span class="string">"Focus the text input"</span></span><br><span class="line">          onClick=&#123;<span class="keyword">this</span>.focusTextInput&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="React理念"><a href="#React理念" class="headerlink" title="React理念"></a>React理念</h2><ul><li>把UI划分出组件层级</li><li>用React创建一个静态版本</li><li>定义UI状态的最小且完整表示</li><li>确定State应该位于哪里</li><li>添加反向数据流</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要介绍React基础：包括React元素、React组件、React数据流、表单、列表等内容&lt;br&gt; &lt;a href=&quot;https://react.docschina.org/docs/introducing-jsx.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;React官方文档&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>HeadFirst设计模式</title>
    <link href="http://yoursite.com/2018/10/24/HeadFirst%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/10/24/HeadFirst设计模式/</id>
    <published>2018-10-24T01:00:00.000Z</published>
    <updated>2019-02-15T08:01:26.510Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍12种的设计模式，包括策略模式、装饰器模式、适配器模式、外观模式、模板模式、代理模式; 观察者模式、命令模式; 工厂模式、组合模式；状态模式、迭代器模式。<br>本文是学习《Head First设计模式》整理的博客。<br><a id="more"></a></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="OO基础"><a href="#OO基础" class="headerlink" title="OO基础"></a>OO基础</h2><ul><li>封装</li><li>继承</li><li>多态<h2 id="OO原则"><a href="#OO原则" class="headerlink" title="OO原则"></a>OO原则</h2></li><li><p>封装变化<br>找出应用中可能需要变化之处，把它们独立出来，不要和那不需要变化的代码混在一起</p></li><li><p>针对接口编程，不针对实现编程</p></li><li><p>多用组合，少用继承<br>继承是一种Is-A行为，而组合是一种Has-A行为<br>is-A比Has-A有更强的关系<br>has-A可以通过has接口，来实现has具体内容的多态，比is有更好的灵活性</p></li><li><p>类应该对扩展开发，对修改关闭<br>允许类容易扩展，在不修改现有代码的情况下，就可搭配新的行为<br>遵循开发-关闭原则，通常会引入新的抽象层次，增加代码复杂度。需要把注意力集中在设计中，最有可能改变的地方，然后应用，而不是每个部分都这样设计。</p></li></ul><h2 id="UML规定"><a href="#UML规定" class="headerlink" title="UML规定"></a>UML规定</h2><ul><li><p>继承： 实线空箭头</p></li><li><p>实现： 虚线空箭头</p></li><li><p>组合： 实线实箭头</p></li></ul><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>鸭子的故事：<br>绿头鸭：会飞行， 叫起来呱呱叫<br>红头鸭：会飞行, 叫起来吱吱叫<br>普通鸭：不会飞行，叫起来呱呱叫<br>橡皮鸭：不会飞行，叫起来唧唧叫<br>…</p><p>首先看到了鸭子，以及不同种类的鸭子<br>其次是看到了鸭子的2种行为，飞行与叫;<br>具体的飞行与叫声并不一一对应，不同的鸭子可能有相同的飞行行为与叫的行为</p><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="策略模式.png" alt=""></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>策略模式本质本质上是对动作、函数、算法等变化时的一种封装，将算法封装成算法族，一方面使之可以相互替换，另一方面增加了复用。<br>这里看到了一种n-m的情况，将n抽象,将m也抽象，然后前者组合后者。<br>也可降维使用，只有1-m的情况</p><h1 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h1><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><h2 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h2><p><img src="装饰器模式-1.png" alt=""></p><p><img src="装饰器模式-2.png" alt=""></p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><ul><li><p>装饰器(Decorator)在使用上有2个抽象维度，1个分类维度看作主维度（横向维度），另一个是次维度（纵向维度），在第二个维度上的各个量，是修饰第一个维度上的各个量，并且第二个维度上的各个量之间，没有先后次序，且可以累加使用。第二个维度上也应该是多个量，如果是单个量，也没必要如此使用</p></li><li><p>装饰器(Decorator)与代理有一些相似之处：</p><ul><li><p>相同之处：<br>首先对于装饰类与代理类都从一个父类来继承，拥有相同的接口，<br>而且都持有被装饰类与被代理类的引用。在调用接口时分不清代理与被代理或者装饰器与被装饰器。</p></li><li><p>不同之处：<br>装饰器模式，装饰类与被装饰类都有多个，是多对多的关系，而代理被代理一般是一对一的使用。<br>装饰器可以累加的使用，且没有先后关系的限制； 代理是在一个代理类中完成访问控制，至于控制的先后顺序，应该有关。</p></li></ul></li><li><p>应用：<br>感觉在预处理模块中，也可以使用，但需要写死被装饰的顺序，这点有些耦合过高。</p></li></ul><h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><p>适配器模式示例现实生活中有很多，比如前几天买的手机USB接口与PC的USB接口的转换器;或者head first中的不同插座之间的适配器。<br><img src="适配器模式-1.png" alt=""></p><h2 id="类图-2"><a href="#类图-2" class="headerlink" title="类图"></a>类图</h2><p><img src="适配器模式-2.png" alt=""></p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>适配器模式将一个类的接口，转换成客户期望的另一接口。让原本不兼容的类可以兼容。<br>适配器就涉及3个对象，被适配者、适配器、使用方，正对应于图1的三个部分。<br>系统出了新的接口，并面先行的接口编程，但为了兼容老的接口，便生成adapter，来转换老的接口。</p><h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><p>外观模式head first给出的实例是家庭影院，买了很多的设备，为了设置家庭影院，需要调灯光、调音箱，调投影仪，爆米花，关闭的时候还需要进行相反的关闭操作。</p><h2 id="类图-3"><a href="#类图-3" class="headerlink" title="类图"></a>类图</h2><p><img src="外观模式.png" alt=""></p><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>外观模式就是增加一个外观类，来完成对这些对象的调用配置，其实就是一个封装。</p><p>提出了与适配器模式不同的对比：<br>适配器模式中，只做接口的转换，而外观模式是封装对多个对象的调用，为客户提供统一的接口而已。</p><p>还提出一个原则：<br>最少知识原则：即，只和你的密友交谈。对于用户，涉及的对象越少越好。</p><h1 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h1><h2 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h2><p>head first给出了例子是煮咖啡与沏茶的例子：他俩的的过程相同，需要烧水，冲泡，倒到杯子里，加调料。他们的不同之处是冲泡的内容不同，添加的提案不同。<br>这样就设计了一个抽象类，用于将算法的逻辑写好，然后实现烧水、倒到杯子，将冲泡与加调料设置为抽象方法，而咖啡与茶只要去实现冲泡与加调料，就可以完成整个过程。</p><h2 id="类图-4"><a href="#类图-4" class="headerlink" title="类图"></a>类图</h2><p><img src="模板模式.png" alt=""></p><p>模板模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的步骤。</p><h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>从类图上看，模板模式很简单，就是一个继承结构，它的思想却挺有趣，首先一个算法是分几个步骤（函数）来实现的，在父类中将这个步骤的调用过程固定下来，并将需要子类实现的步骤定义为abstract类型，子类只需实现这些接口，就可以完成真个算法。</p><p>这样存在一个问题，即所有的步骤调用太固定，若有差异不够灵活，后来有了一些变易，它可以提前准备一些hook函数，子类通过实现不同的hook，来使整个算法的逻辑发生一点改变。</p><p>在应用上，像是sort函数需要传入compareaTo，就是这种思想的一种体现。</p><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><p>好莱坞原则：高层对待低层组建的方式，别调用我们，我们调用你。<br><img src="好莱坞原则.png" alt=""></p><p>我们在抽象工厂模式中，见过这种高层与低层组建关系的原则：依赖颠倒原则，即分离高层与低层的组件，让他们都以来接口。那时候的高层是工厂类，而低层是产品类接口。</p><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><h2 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h2><p>代理模式中，head first给出了3种：远程代理、虚拟代理、保护代理<br>远程代理： 远程代理指的是用一个电脑上的类、代理另外一台电脑上的一个类。例子是想统计想统计在经历的机器上来显示其他电脑上各糖果机器的情况。</p><p>虚拟代理： 就是缓存代理，对于大的对象，在对象时候的时候再去创建它。例子是从网络加载图像，通过虚拟代理，创建一个新的线程来加载图像，在没有加载完成一直使用虚拟带来应答，加载完成后，将请求再交给真实对象。</p><p>保护代理： 也就是动态代理，这里是把Java的动态代理讲的最明白的。动态代理意思是在运行时，才生成的代理对象。</p><h2 id="类图-5"><a href="#类图-5" class="headerlink" title="类图"></a>类图</h2><p><img src="代理模式-1.png" alt=""></p><p>代理模式为另一个对象提供一个替身或者占位符以控制对这个对象的访问。使用代理模式创建代表对象，让代表对象控制某对象的访问，被代理的对象可以是远程的对象、创建开销大的对象或需要安全控制的对象。</p><h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><ul><li><p>远程代理<br><img src="代理模式-远程代理.png" alt=""><br>Java提供远程代理的实现，由Java的命令（工具）自动实现客户辅助对象与服务辅助对象的创建，也就封装了代理对象（客户对象）与被代理对象（服务对象）之间的通讯。但还需要程序员去实现代理对象与被代理对象。<br>Java用的比较少一些，对于远程代理没用用过，而且现在的使用场合也不太确定，如果是BS或者CS之间的通信，用http、tcp/ip就可以完成通信；如果是S与S之间的通信，可以通过数据库+数据总线的方式来实现。</p></li><li><p>动态代理<br><img src="代理模式-动态代理.png" alt=""><br>这里是我觉得对Java的动态代理讲的最清楚的地方。它将代理包含在两个类中：Proxy以及InvocationHandler中，其中Proxy提供访问被代理类的接口，InvocationHandler真正访问被代理类，控制对被代理类的访问。<br>在使用上，先创建InvocationHandler类，并传入被代理的对象，在实现的Invoke接口中进行控制，通过控制的调用被代理对象的方法，在使用是，通过new Proxy对象（Proxy的创建会传入被代理类的接口，即他俩接口相同），并将InvocationHandler类来传入来实现真正的控制访问。</p></li></ul><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h2><h2 id="类图-6"><a href="#类图-6" class="headerlink" title="类图"></a>类图</h2><p><img src="观察者模式-2.png" alt=""></p><h2 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h2><p>  <img src="观察者模式-1.png" alt=""></p><ul><li><p>观察者模式是一方对多方单方发送数据的模型。<br>首先它是一方对多方，其中一的一方是Subject(或者Observable)，多的一方是Observer.<br>Subject中有一个Observer的列表， 当数据发生变化时，调用Observer的接口函数，将数据发送给列表中的各个Observer</p><p>其次它是单方发送据的，Observer只负责接收数据。<br>这里隐含一个变化，如果一个Observer要把数据发送给其他的Observer，是可以再调用Suject的set数据的函数，来完成数据分发的。</p></li><li><p>应用：<br>一个是flux中的pub与sub<br>另一个是android里的与后端通信，获取数据，然后使用数据的情况。</p></li></ul><h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><h2 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h2><p>Head First给出的示例是多功能遥控器<br>遥控器有一个插槽，可以插不同的遥控器，比如电视的、电灯的、风扇的等，最多有7种。<br>对于这些遥控器，预留出7对按钮，分别控制on与off</p><h2 id="类图-7"><a href="#类图-7" class="headerlink" title="类图"></a>类图</h2><p><img src="命令模式.png" alt=""></p><h2 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h2><ul><li><p>解析<br>命令模式中，由4种角色组成，命令执行者（命令接收者 receiver）、命令(commond)、命令的创建者、命令调用者(invoker)<br>命令本身封装了命令执行者，以及较固定的函数（exec()、undo()等）<br>命令的创建者创建命令以及执行者，并将执行者set进命令的地方。创建者是一个隐含的地方，可以是一个函数，并一定是类。<br>命令调用者负责调用命令的执行（exec）函数。</p><p>命令模式真正是通过对命令与命令执行者的封装，完成了命令创建者与命令调用者的解耦， 其实也完成了调用者与执行者的解耦。<br>在命令模式的例子中，执行者是电视、电灯，创建者是在main函数中，调用者是遥控器</p><p>这样，命令的调用者既可以用单个命令变量来存放命令，也可以用一个数组来存放多个命令，然后在执行时，便利去执行。在这种情况下涉及到一个问题，如果一个问题的处理需要一连串的命令，按顺序执行来完成，后一个命令的执行依赖于前一个命令执行的数据，这种情况下，是否适合使用命令模式？</p></li><li><p>应用<br>队列请求：<br>创建者将命令创建后，放如一个队列中，执行者在多个线程中快速并行调用这行命令。</p><p>重做日志：<br>命令模式还用于数据库的重做日志，将命令实现序列化的方法，store/load等接口进行持久化，然后在发生故障时，load命令进行执行，即可。</p></li><li><p>对比<br>其实有些像观察者模式，与观察者模式最大的不同在于，观察者模式中发布与订阅是一个一对多的关系，而在命令中，命令的创建者与调用者是一对一的关系。<br>另一个不同是，观察者模式中发送的只是一个小对象，比如一个字符串，或者一个bean。而在命令模式中，确是封装了执行者的命令。</p></li></ul><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><h2 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h2><p>批萨店做批萨;<br>不同地区的批萨店，对于同款产品，区域特点不一样;<br>同一批萨店，对于同款产品，有不同风味的做饭，采用的原料有一些差异</p><h2 id="类图-8"><a href="#类图-8" class="headerlink" title="类图"></a>类图</h2><ul><li><p>工厂模式<br><img src="工厂模式.png" alt=""><br>工厂模式：定义一个创建对象的接口，但由子类决定要实例化的类是哪一个，把类的实例化推迟到子类。</p></li><li><p>抽象工厂模式<br><img src="抽象工厂模式.png" alt=""><br>抽象工厂模式： 提用一个接口，用于创建相关或者以来对象的家族，而不需要指定具体类</p><h2 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h2><p>以前看的应该是抽象工厂模式，工厂模式较之类图结构更简单一些<br>工厂模式是抽象出了2个层级： 第一是创建者或者工厂，第二是产品类，由工厂来创建产品。产品类全部都继承自产品类本身，这样其实是把隐含的系列给隐掉了。</p></li></ul><p>抽象工厂也是有2个层级：创建者与产品。 创建者的层级与工厂模式类似，不同的是产品层级，产品层级细分，细分基本是依据创建者来分开的（具体情况下，不同工厂也会用相同的产品）。 其实在各个原料上，如Dough、Sauce、Cheese它们可以抽象成Ingredient（原料）类。这样以来，就会看出跟工厂模式更多的相似之处。创建者与产品之间的关系也必须是具体的，或者写死的。</p><p>另外一个不同可以看到，它将工厂变成的接口，是一个大的接口，必须包含所有的创建者的行为，即使在某个工厂中不需要这种行为，也得实现。</p><h2 id="原则-1"><a href="#原则-1" class="headerlink" title="原则"></a>原则</h2><p>依赖倒置原则：要依赖抽象，不要以来具体类。不能让高层组件依赖具体的低层组件，高层与低层组件，两者都应该依赖于抽象。</p><ul><li><p>变量不可以持有具体类的引用。<br>使用new事，就会持有具体的引用，可以使用工厂来避开这种做法</p></li><li><p>不要让类派生自具体的类。<br>如果派生自具体类，就会以来具体类，应该派生自一个接口</p></li><li><p>尽量不要覆盖基类中已实现的方法<br>基类中已实现的方法，应该由所有的子类共有。</p></li></ul><p>PS： 应该在有封装变化的时候，尽量靠近这些原则，而不是随时都要使用这些原则<br>    如一个不会改变的类，就可以在代码中直接实例化。</p><h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><h2 id="示例-9"><a href="#示例-9" class="headerlink" title="示例"></a>示例</h2><p>组合模式的实例也是与菜单相关，除了上边提到的3餐的菜单，餐厅想提供一份单独的甜点菜单，比如加到晚餐里。<br>这样菜单的结构发生了改变，它使得咖啡厅的晚餐菜单包括一个子菜单<br><img src="组合模式-1.png" alt=""></p><h2 id="类图-9"><a href="#类图-9" class="headerlink" title="类图"></a>类图</h2><p><img src="组合模式-2.png" alt=""></p><p><img src="组合模式-3.png" alt=""></p><p>组合模式允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。</p><h2 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h2><p>组合模式可以认为是将树在类中去实现。使用者对是组合还是单个对象而透明。</p><h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><h2 id="示例-10"><a href="#示例-10" class="headerlink" title="示例"></a>示例</h2><p>糖果售货机，投入硬币，摇动把手，出货;<br>若没有货，也会提示没货，然后退出硬币;<br>投入硬币后也可以直接退回硬币</p><p>这样有这样几种状态：无货， 未投币， 已投币， 出货<br><img src="状态模式-1.png" alt=""></p><h2 id="类图-10"><a href="#类图-10" class="headerlink" title="类图"></a>类图</h2><p><img src="状态模式-2.png" alt=""></p><p>状态模式允许对象在内部状态发生改变时，改变它的行为，对象看起来好像修改了它的类。</p><h2 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h2><p><img src="状态模式-3.png" alt=""></p><p><img src="状态模式-4.png" alt=""><br>在实现上，Context类中有所有的状态类（这里有4个），还有一个当前状态变量。State接口包括着所有可以执行的操作（引起状态变化的动作），具体状态实现所有的接口，然后在自己状态对应的操作里实现功能代码，并在这个操作里调用Context的设置状态函数，设置下一个状态。</p><p>这样状态转换的逻辑是放在状态中去掌握的，其实可以放在Context中去把握，我感觉更好一些。因为如果有别的Contex时，可以复用这些状态，而他们的状态转换逻辑可以放在自己的代码中。</p><h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><h2 id="示例-11"><a href="#示例-11" class="headerlink" title="示例"></a>示例</h2><p>不同餐厅的菜单用不同的数据结构来实现的，早点摊位用的是数组，午餐食堂用的是List，晚餐咖啡厅用的是HashMap。<br>现在有一个服务员，需要根据这些不同的菜单提供服务，非迭代器方式下，服务员需要对这些不同的菜单定义不同的遍历方法。而迭代器模式会使用使遍历使用相同的接口。</p><h2 id="类图-11"><a href="#类图-11" class="headerlink" title="类图"></a>类图</h2><p><img src="迭代器模式.png" alt=""></p><p>迭代器模式提供一种方法，能够顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。</p><h2 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h2><p>从类图上看，迭代器模式有些像工厂模式，毕竟每一个具体的Aggregate对象都对应唯一的Iterator对象。为不同的数据结构提供了统一的遍历接口。</p><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>一个类应该只有一个引起变化的原因。<br>类的每个职责都有改变的潜在区域。超过一个责任，意味着超过一个改变的区域。<br>内聚：当一个模块或者类被设计成只支持一组相关的功能时，我们说它具有高内聚，单一职责的原则的类，很容易就有高内聚，比低内聚的更容易维护。</p><p>可看作成封装的粒度建议。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍12种的设计模式，包括策略模式、装饰器模式、适配器模式、外观模式、模板模式、代理模式; 观察者模式、命令模式; 工厂模式、组合模式；状态模式、迭代器模式。&lt;br&gt;本文是学习《Head First设计模式》整理的博客。&lt;br&gt;
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://yoursite.com/2018/10/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/10/23/设计模式/</id>
    <published>2018-10-23T06:46:09.000Z</published>
    <updated>2019-02-15T08:01:26.510Z</updated>
    
    <content type="html"><![CDATA[<p>本文是在写C++时，看的可复用面向对象软件的基础部分的前几种模式，放在这里只做一种对比<br><a id="more"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="设计应支持变化"><a href="#设计应支持变化" class="headerlink" title="设计应支持变化"></a>设计应支持变化</h2><p> – 封装变化的概念</p><h2 id="变化的方向把握"><a href="#变化的方向把握" class="headerlink" title="变化的方向把握"></a>变化的方向把握</h2><h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p> – 各种模式其实就像是各种套路，在不同具体问题上，封装着变化。<br> – 对于各种模式的学习，应该注重其封装适的变化，适用于什么场景，到最后应该是什么场景应该使用哪种模式。<br> – 招式的最后，是随心所欲使用各种模式。<br> – 模式学习不在于快，而在于领悟，分析与整合</p><h1 id="前8种模式"><a href="#前8种模式" class="headerlink" title="前8种模式"></a>前8种模式</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p> – 本章通过Lexi的学习来介绍8中模式的使用，对于每种模式，记录其story，其封装了怎样的变化，适用于怎样的场景。</p><h2 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h2><ul><li>文档结构：Lexi操作的对象是什么，这些对象之间的关系是什么，如何来封装这些关系，如何来去异存同；定数据 </li><li>格式化：格式的调整都有哪些？如何支持显示与数据的分离？如何支持各种格式调整的策略？定显示</li><li>修饰用户界面：</li><li>多视感支持：就是风格，显示上存在着2种定位：是按钮/下拉框；是什么风格的按钮/下拉框。这风格与部件之间，是一种怎么样的关系，应该如何来封装</li><li>多窗口系统支持：如何封装不同硬件、不同平台的影响</li><li>用户操作：每次点击等操作，如何处理，如何定义每种部件与操作、实现之间的关系</li><li><p>拼音检索和连字符：怎样来实现基于数据的算法实现，算法与数据之间的关系应该如何，注意与格式化之间的关系。</p></li><li><p>总结：<br>  – 数据、显示、操作、分析（多视感其实是显示的同一风格，多窗口系统其实是封装跨平台）</p></li></ul><h2 id="1、composite：组合模式"><a href="#1、composite：组合模式" class="headerlink" title="1、composite：组合模式"></a>1、composite：组合模式</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p> – 文档是对字符、线条、多边形与其他图形元素的一种安排。这些元素记录了文档的整个信息内容。使用者的角度是文档的物理结构-行、列 、图形、表和其他结构，这些结构也可能有自己的子结构。<br> – 使用者直接操作的是这些子结构，对图表、图片、行、列进行操作，而不是非物理结构以文本和图形。</p><p> – 元素与物理结构的概念，即可通过元素显示物理结构，也可通过物理结构映射内部的元素。<br> – 一致性对待各种元素，文本、图形、多边形。<br> – 一致性对待元素与元素组合</p><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p> – 层次结构信息的表述通常是通过一种被称为“递归组合”的技术来实现，递归组合可以由较简单的元素逐渐建立复杂的元素，是我们通过简单图形元素构造文档的方法之一。<br> – 如：将字符和图形从左到右排列成文档的一行，然后由多行形成一列，再用多列形成一页。<br>    见图：2-3递归组合对象结构</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p> – 将文档结构中对象定义为一个抽象的类图元。它的子类既定义了基本的图形元素（如字符与图像=数据），又定义结构元素（如行和列=显示）。<br>    见图：2-4部分图元层次</p><p> – 图元有三个基本责任：1）怎样画出自己，2）他们占用多大空间，3）他们的父图元与子图元的访问。</p><h3 id="评鉴"><a href="#评鉴" class="headerlink" title="评鉴"></a>评鉴</h3><p> – 递归组合不仅用来表示文档，可以用来表示任何层次性的结构，组合模式描述了面向对象的递归组合的本质。 </p><p> – 封装元素与元素组合之间的包含关系。<br> – 感觉应该叫递归组合更合适一些<br> – 物理结构与数据元素的表示问题</p><h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><p> – 结构型模式涉及到如何组合类和对象以获得更大的结构。<br> – 结构型类模式采用继承机制来组合接口或实现。<br> – 结构型对象模式描述了如何对一些对象进行组合，从而实现新功能的一些方法。</p><p> – Compostie模式是结构型对象模式的一个实例。它描述了如何构造一个类层次式结构，这一结构由两种类型的对象（基元对象与组合对象）所对应的类构成，其中组合对象使得你可以组合基元对象以及其他的组合对象，从而形成任意复杂的结构。</p><h3 id="Composite（组合）–-对象结构型模式"><a href="#Composite（组合）–-对象结构型模式" class="headerlink" title="Composite（组合）– 对象结构型模式"></a>Composite（组合）– 对象结构型模式</h3><p>  1、意图<br>  将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。</p><p>  2、使用性<br>  – 想表示对象的部分-整体层次结构<br>  – 却希望忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</p><p>  3、对象结构<br>  – 见图4-3 组合对象结构</p><p>  4、协作<br>  用户使用Component类结构与组合结构中的对象进行交互。如果接受者是由一个叶子节点，直接处理请求。如果接受者是Composite，它通常将请求发送给它子部件，在转发请求之前/之后可能执行一些辅助操作。</p><p>  5、实现<br>  在实现组合模式时，需要考虑以下几个问题：<br>  1）显示的父部件引用  保持从子部件到父部件的引用能简化组合结构的遍历与管理。通常在Component类中定义父部件引用。Leaf和Composite类可以继承这个引用以及管理这个引用的那些操作。<br>  2）最大化Component接口  Composite模式的目的之一就是使得用户不知道他们使用的是Leaf还是Composite。为达到这一目的，Composite类应该为Leaf与composite类尽可能多的定义一些公共操作。<br>  3）声明管理子部件的操作 </p><h2 id="2、strategy：策略模式"><a href="#2、strategy：策略模式" class="headerlink" title="2、strategy：策略模式"></a>2、strategy：策略模式</h2><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p> – 在图元基础上，需要将进一步对文档的格式进行设置，如：指定边界宽度、缩进大小、表格形式、是否隔行显示等格式限制条件。<br> – 格式化设置可以被认为是一种如何将图元分行的策略或者算法</p><p> – 分行算法有很多种，要求在增加一个图元子类，而不用考虑分行算法，反之，增加一个分行算法不应要求修改已有的图元类。分行算法应独立与文档结构之外。<br> – 分行算法用来操作图元类的显示，其与图元的关系应该是不相关的。</p><p> – 在运行时刻可以随便改变算法。</p><h3 id="方案-1"><a href="#方案-1" class="headerlink" title="方案"></a>方案</h3><p> – 分行算法操作的应该是图元的组合，是整个文档被选中的部分，或者整个文档。所以需要一个对象承载着图元组合。另外对于各种算法，应该有同一的调用的接口，封装不同的算法。<br> – 首先用一个Composition类来包含被创建并带格式化的图元，然后用一个Compositor类用来封装各种分行算法。当需要格式化时，Compositor一次遍历Compostion的各个图元，根据分行算法插入新行和列图元。<br>  见图2-6：对象结构反映Compositor制导的分析</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>  见图2-5Compostion 与 Compositor类间关系</p><h3 id="评鉴-1"><a href="#评鉴-1" class="headerlink" title="评鉴"></a>评鉴</h3><p> – 在对象中封装算法，是策略模式的目的。模式的主要参与者是Strategy对象（这些对象封装了不同的算法）和它们的操作环境（其调用者）。关键点在于为Strategy和它的环境设计足够通用的接口，以支持一些列的算法，不必为支持一个新的算法而改变Srategy或它的环境。</p><p> – 就是封装不同算法，以及他们调用者。其实可能他们的调用者也并不是必须的，若本例中的调用者是图元，及算法的对象是图元，则可以在图元类中去调用它们。【一般会封装对于他们的调用】</p><h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><p> – 行为模式涉及到算法和对象间职责的分配。行为模式不仅描述对象或类的模式，还描述他们之间的通讯模式。这些模式刻画了在运行时刻难以追踪的复杂控制流。它们将你的注意力从控制流转移到对象的联系方式上来。【对于控制流的模式】</p><p> – 行为类模式使用继承机制在类间分派任务<br> – 行为对象模式使用对象复合而不是继承。其中一些行为对象模式描述了一组对等的对象怎样相互协作以完成其中任一对象都无法单独完成的任务。一些行为对象将行为封装在一个对象中，并将请求指派给它。Strategy模式将算法封装在对象中，这样可以方便的制定和改变一个对象所使用的算法。</p><h3 id="Strategy（策略）-–-对象行为模式"><a href="#Strategy（策略）-–-对象行为模式" class="headerlink" title="Strategy（策略） – 对象行为模式"></a>Strategy（策略） – 对象行为模式</h3><p>  1、意图<br>  定义一系列的算法，把他们一个个封装起来，并且可以使他们相互替换。本模式可以使算法独立于使用它们的客户。</p><p>  2、适用性<br>  当存在以下情况时使用Strategy模式<br>  – 许多相关的类仅仅是行为有异。策略提供了一种用多个行为中的一个行为来配置一个类的方法<br>  – 需要使用一个算法的不同变体。<br>  – 算法使用客户不知道的数据。避免暴露复杂的，与算法相关的数据结构外漏<br>  – 一个类定义了多种行为，并且通过许多条件语句的形式出现。将相关的条件分支一直到各自的 strategy类中。</p><p>  3、结构<br>  见图：5-9策略模式结构说明.png</p><p>  4、实现<br>  1）定义Strategy和Context接口 Strategy和Context接口必须使得ConcreteStrategy能够有效的访问它所需要的Context中的任何数据, 反之亦然。<br>  2）将Strategy作为模板参数，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">AStrategy</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Context</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123;theStrategy.DoAlgorithm();&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        AStrategy theStrategy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStrategy</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoAlgorithm</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Context&lt;MySgtrategy&gt; aContext;</span><br></pre></td></tr></table></figure><h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h3><pre><code>目的在于降低算法与系统之间的耦合。可以使用的前提在与所有的算法应该提供相同的接口。</code></pre><h2 id="3、Decorator：装饰模式"><a href="#3、Decorator：装饰模式" class="headerlink" title="3、Decorator：装饰模式"></a>3、Decorator：装饰模式</h2><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><p> – 对于界面我们还学需要考虑2种修饰，第一种是在文本编辑区域周围增加边界，第二种是加滚动条让永辉看到同一页的不同部分。<br> – 从设计角度,需要扩充已存在的代码，但各种装饰是变化的，若每次扩充现有代码一定很不方便</p><h3 id="方案-2"><a href="#方案-2" class="headerlink" title="方案"></a>方案</h3><p> – 对象组合提供一种更灵活的机制，图元可以认为是固定的，而修饰是变化的将修饰本身看作对象。这样就有了两个组合候选对象：图元与边界。a<em>b+a</em>c+a<em>d = a</em>(b+c+d)，这种方式来完成。<br> – 我们将画边界的代码完全保存的Border类中，而独立于其他类。</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p> – 见2-7 修饰模式实现。<br> MonoGlyph的子类重新实现一个传递工作，Border类首先激活父类的Draw，让组件做部分工作-画出边界之外的其他东西。而Border:Draw通过调用私有操作DrawBorder来画出边界。</p><h3 id="评鉴-2"><a href="#评鉴-2" class="headerlink" title="评鉴"></a>评鉴</h3><p> – 在Decorator模式中，修饰指给一个对象增加职责的事务。我们可以想到用语义动作修饰抽象语法树、用新的转化修饰有穷状态自动机或者以属性标签修饰持久对象网等离子。</p><h3 id="Decorator-装饰-–-对象结构型模式"><a href="#Decorator-装饰-–-对象结构型模式" class="headerlink" title="Decorator(装饰) – 对象结构型模式"></a>Decorator(装饰) – 对象结构型模式</h3><p>  1、意图<br>  动态地给一个对象增加一些额外的职责。就增加功能来说， Decorator模式相比生成子类更为灵活。<br>  2、动机<br>  有时我们希望给某些对象而不是整个类增加一些功能。例如上例的边框。<br>  使用继承机制是添加功能的一种有效途径，从其他类继承过来的边框特性可以被多个子类的实例所使用。但这种方法不够灵活，因为边框的选择是静态的，用户不能控制对组件加边框的方式和动机。<br>  一种较为灵活的 方式是将组件嵌入到另一个对象中，有这个对象田间边框。我们称这个嵌入的对象为装饰。</p><p>  3、适用性<br>  – 在不影响其他对象的情况细心啊，以动态、透明的方式给单个对象添加职责。<br>  – 处理那些可以撤销的职责。<br>  – 当不能采用生成你子类的方法进行扩充的时候，可能是由于类爆炸。</p><p>  4、结构<br>  见：4-5装饰模式的结构。<br> component<br>  – 定义一个对象接口，可以给这些对象动态的增加职责。</p><p>  concreteComponent<br>  – 定义一个对象，可以给这个对象添加一些职责。</p><p>  decorator<br>  – 维持一个指向Compent对象的指针，并定义一个与Compnent接口一直的接口。<br>  ConcretDecorator<br>  – 向组件添加的职责。</p><p>  5、注意<br>  1）接口的一致性，装饰对象的接口必须与它所装修的Coponent的接口是一致的。因子所有的ConcreteDecorator类必须有一个共同的父类。<br>  2）忽略抽象的Decorator类 当近添加一个职责时，没必要定义Decorator类<br>  3）保持Component类的简单性 为了保证接口的一致性，组件和装饰必须有一个共同的父类。因此保证这个类的简单性是很重要的：即，它应集中于定义接口而不是存储数据。</p><h2 id="4、Abstract-Factory：工厂模式"><a href="#4、Abstract-Factory：工厂模式" class="headerlink" title="4、Abstract Factory：工厂模式"></a>4、Abstract Factory：工厂模式</h2><h3 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h3><p> – 移植到多平台时，各平台的视感标准是不一样的，我们设计的标准是使Lexi与视感无关。<br> – 确定创建适合窗口组件所需要的视感标准，不仅必须避免显示的构造器调用， 还必须能够很容易的替换整个窗口组件集合。可以通过抽象对象创建过程来达到目的。</p><p> – 部件 与 视感；无法像修饰模式一般，a<em>b + a</em>c + a*d = a(b+c+d)，因为部件与视感无法分离，部件依赖视感来画出。</p><h3 id="方案-3"><a href="#方案-3" class="headerlink" title="方案"></a>方案</h3><p> – 视感与部件的2维表结构：同一视感对应有多种部件，同一部件对应多种视感，同时只能使用一种视感。<br> – 工厂模式：以部件为父类来构建各中视感下的部件（产品），同时将每一种视感封装成工厂，每一种视感（工厂）只生产指定的部件（产品）。<br> 层次见：图2-9 工厂类层次，与产品类层次。</p><p> – 将构建与具体的实现分离</p><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><p> – 各种工厂从GUIFactory父类来派生。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (styleName == <span class="string">"Moti"</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  guiFactory = <span class="keyword">new</span> MotiFactory;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (styleName == <span class="string">"PM"</span>)</span><br><span class="line">&#123;</span><br><span class="line">  guiFacotry = <span class="keyword">new</span> PMFactory;</span><br><span class="line">&#125;</span><br><span class="line">eles</span><br><span class="line">&#123;</span><br><span class="line">  guiFactory = <span class="keyword">new</span> DefaultFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> – 各种部件使用时</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ScollBar *sb = guiFactory-&gt;CreateScrollBar();</span><br><span class="line">Button *btn = guiFactory-&gt;CreateButton();</span><br></pre></td></tr></table></figure><h3 id="评鉴-3"><a href="#评鉴-3" class="headerlink" title="评鉴"></a>评鉴</h3><p>  – 工厂 与 产品是Abstract Factory模式的主要参与者。该模式描述了怎样在不直接实例化类的情况下，构建一些列相关的产品对象。它最适合与产品的数目和种类不便，而具体的产品系列之间存在不同的情况。</p><p>  – 与修饰类似，也是一种二维关系，但不同之处是，修饰模式是可以将修饰与部件分开，而且是可以分开的。而工厂模式是不可以分开的，且每种视感对应一整套的部件，种类固定，同时只能使用一种工厂。</p><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><p> – 创建型模式抽象了实例化过程。它们用于一个系统独立于如何创建、组合和表示它的那些的对象。（使系统独立与它的数据对象，将数据对象的访问封装相同的接口）<br> – 一个类创建型模式使用继承改变被实例化的类，而一个对象型创建模式将实例化委托给另一个对象。<br> – 这类模式中有两个主旋律。第一，它们都将封装系统使用的某些类的信息。 第二，它们隐藏了这些类的实例是如何创建和放在一起的。</p><h3 id="Abstract-Factory-–-对象构造型模式"><a href="#Abstract-Factory-–-对象构造型模式" class="headerlink" title="Abstract Factory – 对象构造型模式"></a>Abstract Factory – 对象构造型模式</h3><h4 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h4><p> – 提供一个创建一系列相关或者相互依赖对象的接口，无需指定它们具体的类。</p><h4 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h4><p> – 无法分离的二维关系，一次只能构造一些列。将系列属性构造成工厂，部件根据系列属性来分别创建。</p><h4 id="适用"><a href="#适用" class="headerlink" title="适用"></a>适用</h4><p> – 一个系统要独立与它的产品的创建、组合和表示时。<br> – 一个系统要有多个产品系列中的一个系列来表示时。<br> – 当你强调一系列相关的产品对象的设计 以便进行联合使用时。<br> – 当你提供一个产品类库，而它只想显示它们的接口而不是现实时。</p><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p> 见”3-1工厂模式的结构图“</p><p> – AbstractFactory:声明一个创建抽象产品对象的操作接口<br> – ConcreteFactory:实现创建具体产品对象的操作。<br> – AbstractProduct:为一类产品对象声明一个接口<br> – ConcreteProduct:定义一个将被相应的具体工厂创建的产品对象</p><p> – Client：仅适用由AbstractFactory与AbstractProduct类声明的接口。</p><h2 id="5、Bridge：桥接模式"><a href="#5、Bridge：桥接模式" class="headerlink" title="5、Bridge：桥接模式"></a>5、Bridge：桥接模式</h2><h3 id="问题-4"><a href="#问题-4" class="headerlink" title="问题"></a>问题</h3><p> – 目前存在一些相互不兼容的重要的窗口系统如Windows、X等，我们希望Lexi可以在尽可能多的窗口系统上运行，与上一个视感类似。</p><p> – 硬件的无关性，或者底层的无关性应该独立与应用程序，如果引入到部件的构建中，则会造成这种高耦合。<br> – 由于底层各系统的差异比较大，所以我们无法抽象出Abstract Factory类，故也无法使用。</p><h3 id="方案-4"><a href="#方案-4" class="headerlink" title="方案"></a>方案</h3><p> – Windows类 封装了窗口要各窗口系统都要做的一些事情：<br>   它们提供了画基本几何图形的操作。<br>   它们能变成图标或还原成窗口<br>   它们能改变自己的大小<br>   它们能根据需要画出窗口内容。<br> – 主要集成了窗口管理与图形管理两大功能群。</p><p> – Windows类的窗口功能必须跨越不同的窗口系统。<br> – Window类将提供一个支持大多数窗口系统的方便的接口。不是交集也不是并集。因为Lexi中直接处理Window类，所以它还必须支持Lexi的图元。着意味着windows接口必须包括让图元可以在窗口中画出自己的基本图形操作集合。<br> – 无法对各自窗口平台派生各自的Window类</p><p> 对变化的概念封装。<br> – 现在变化的是窗口系统实现，我们在一个对象中封装窗口系统的功能，那么我们就能根据对象接口实现Window类及其子类。更进一步讲，如果那个窗口能提供我们所感兴趣的所有窗口系统服务，我们无需改变window类或者其子类，也能支持窗口的系统。我们可以通过简单传递合适的窗口系统封装对象，来给我们想要的 窗口系统设定窗口对象。</p><p> – 说白了，就是对个窗口系统的功能进行封装，使他们独立于window类。<br> – 用对象组合的形式来替代继承的实现方式。</p><h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><p>  – </p><h3 id="评鉴-4"><a href="#评鉴-4" class="headerlink" title="评鉴"></a>评鉴</h3><p> – WindowImp类定义个一个公共窗口系统设施的接口，但它的设计是受不同于Window接口的限制条件驱动。应用程序不再直接处理WindowImp接口，它们只处理Window对象。所以WindowImp不必与应用程序员的客观世界视图一直，WindowImp接口更能如是反应是市场提供的是什么窗口系统。</p><p> – Window 和 WindowImp的关系就是Bridge模式，Bridge模式的目的就是允许分离的类层次一起工作，即使它们是独立演化的。我们的设计准则是我们构建了两个分离的类层次，一个支持窗口的逻辑概念，另一个描述窗口的不同实现。</p><h3 id="Bridge-–-对象结构型模式"><a href="#Bridge-–-对象结构型模式" class="headerlink" title="Bridge – 对象结构型模式"></a>Bridge – 对象结构型模式</h3><h4 id="意图-1"><a href="#意图-1" class="headerlink" title="意图"></a>意图</h4><p> – 将抽象部分与它的实现部分分离，使它们都可以独立的变化。</p><h4 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h4><p> – 当一个抽象可能有多个实现时，通常继承来协调它们。抽象类定义对该抽象的接口，具体子类则用不同方式加以实现。但此方法有时不够灵活。继承机制将抽象部分与它的实现部分固定在一起，使得难以对抽象和实现部分独立的进行修改、扩充和重用。<br> – Bride模式解决继承实现的问题方法是,将抽象和它的实现部分分别放在独立的类层次结构中.其中一个类层次结构指针对窗口接口(Window\IconWindow)另一个独立的类层次结构针对平台相关的窗口实现部分,这个类层次的根类为WindowImp.不同平台派生一个WindowImmp来提供一个具体平台的实现.</p><h4 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h4><p> – 不希望抽象和它实现部分之间有一个固定的绑定关系.(多态)<br> – 类的抽象以及它的实现都可以通过派生子类的方法加以扩充.<br> – 对于一个抽象的实现部分的修改应对客户不产生影响,即客户的代码不必重编译(dll形式)<br> – 对客户完全隐藏抽象的实现部分.</p><p> – 其实是有2个方向的变化:窗口类别的变化,窗口实现的变化,使他们独立哦变化.</p><h4 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h4><p> 见图4-2-3bridge的结构。</p><p> – abstraction：定义抽象类的接口，并维护一个指向实现的指针。<br> – redefinedAbstraction：扩充由Abstraction定义的接口。<br> – Implementor：定义实现类的接口，该接口不应与抽象类的接口完全一致，可以完全一致。一般来讲实现类仅提供基本操作，而抽象类定义基于这些基本操作的较高层次的操作。<br> – concreteImplemmentor：实现实现类的具体实现。</p><h4 id="评价-1"><a href="#评价-1" class="headerlink" title="评价"></a>评价</h4><p> – 本模式是使用了继承与对象组合2种方式来完成。<br> – 并且对同一个对象（窗口）封装2个方向上的变化。</p><h2 id="6、Commond：命令模式"><a href="#6、Commond：命令模式" class="headerlink" title="6、Commond：命令模式"></a>6、Commond：命令模式</h2><h3 id="问题-5"><a href="#问题-5" class="headerlink" title="问题"></a>问题</h3><p> – 关注与用户的操作与用户界面，我们不希望一个特定的用户操作就联系一个特定的用户界面。而是多个用户界面对应一个操作。设计上不希望界面类与用户操作之间是一种紧耦合的关系，否则难以维护、扩充。</p><p> – 如果继承的方法将用户请求和菜单项连接起来，我们必须同样对待页图标或其他类似发送该用户请求的窗口组件，这样生成的类是窗口组件×请求数的乘积。<br> – 现在缺少一种允许我们用菜单项所执行的请求对菜单项进行参数化的机制。这种方法可以避免子类的剧增。我们可以应用对象来参数化MenuItem，可以通过继承扩充和复用请求实现。这里另一个封装变化概念的例子，及封装请求。</p><h3 id="方案-5"><a href="#方案-5" class="headerlink" title="方案"></a>方案</h3><p> – 首先，我们定义一个Command抽象类，以提供发送请求的接口。这个接口由一个抽象操作“Execute”组成。Command的子类以不同方式实现Execute操作，以满足不同请求。一些子类可以将部分或全部工作委托给其他对象。另一些子类可以完全由他们自己满足。对于请求者来说，一个Command对象就是一个command对象，他们都是一致的。<br> – MenuItem可以保存一个封装请求的Command对象。我们给每一个菜单项一个适合该该菜单的Command子类实现，就像我们为每个菜单项制定一个文本字符串。当用户选中一个特定菜单项时，菜单项只是调用Command对象的Execute操作去执行请求。</p><p> – 也是使用组合对象的方式来代替继承来实现。</p><p> – 在交互应用中，撤销和重做能力是很重要的，为了撤销和重做一个命令，我们在Command接口中，增加Unexecute操作。Unexecute操作是Execute的逆操作，它使用上一次Execute操作所保存的取消信息来消除Execute操作的影响。</p><p> – Command命令链表。来实现重做与做。</p><h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><p>  实现见图2-8-1Command模式。</p><h3 id="评鉴-5"><a href="#评鉴-5" class="headerlink" title="评鉴"></a>评鉴</h3><pre><code>该模式描述了怎样封装请求，也描述了一致性的发送请求的接口，云溪你配置客户端以处理不同请求。该接口保护了客户青牛的实现。有一个命令可以将所有有货部分的请求实现委托给其他对象，也可以不委托。</code></pre><h3 id="Commond-–-对象行为模式"><a href="#Commond-–-对象行为模式" class="headerlink" title="Commond – 对象行为模式"></a>Commond – 对象行为模式</h3><h4 id="1、意图"><a href="#1、意图" class="headerlink" title="1、意图"></a>1、意图</h4><p>  将一个请求封装成一个对象,从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作</p><h4 id="2、动机"><a href="#2、动机" class="headerlink" title="2、动机"></a>2、动机</h4><p>  有时必须向某对象提交请求，但并不知道关于被请求的操作或请求的接收者的任何信息。如同界面的工具箱，点工具箱时，并不知道要完成什么操作。<br>  命令模式通过将请求本身变成一个对象来使工具箱对象可向未指定的应用对象提出请求。这个对象可悲存储并像其他的对象一样被传递。这一模式的关键是一个抽象的Command类，它定义了一个执行操作的接口，其最简单的形式是一个Execute操作。具体的Command子类将接收者作为一个实例变量，并执行Execute操作，指定接收者采取的动作。而接收者有执行该请求所需要的具体信息。</p><h4 id="3、适用性"><a href="#3、适用性" class="headerlink" title="3、适用性"></a>3、适用性</h4><p>  – 像MenuItem对象那样，抽象出待执行的动作以参数化某对象。<br>  – 在不同的时刻指定、排序和执行请求。一个Command对象可以有一个与初始请求无关的生存期。如果一个请求的接收者可用一种与地址空间无关的方式表达，那么就可将负责该请求的命令对象传递给另一个不同的进程，并在那儿实现该请求。【回调函数】<br>  – 支持取消操作。Command的Execute操作可在实施操作前将状态存储起来，在取消操作时，这个状态用来消除该操作的影响。Command接口必须添加一个Unexecute操作。<br>  –支持修改日志，这样当系统崩溃时，这些修改可以被重做一遍。在Command接口中添加装载操作和存储操作，可以用来保持变动的一个一直的修改日志。</p><h4 id="4、结果"><a href="#4、结果" class="headerlink" title="4、结果"></a>4、结果</h4><p> 见5-2-1Command模式结构<br> – Command<br>    声明执行操作的接口<br> – ConcreteCommand(PasteCommand, OpenCommand)<br>    将一个接收者对象绑定于有一个动作。<br>    调用接收者相应的操作，以实现Execute。<br> – Client<br>    创建一个具体命令对象并设定它的接收者。<br> – Invoker<br>    要求该命令执行这个请求。<br> – Receiver<br>    知道如何实施与执行一个请求相关的操作。任何类都可以作为一个接收者。</p><h2 id="7、Iterator：迭代器模式"><a href="#7、Iterator：迭代器模式" class="headerlink" title="7、Iterator：迭代器模式"></a>7、Iterator：迭代器模式</h2><h3 id="问题-6"><a href="#问题-6" class="headerlink" title="问题"></a>问题</h3><p>  – 许多分析要求访问不同的数据，而数据是分散在图元对象的层次结构中的。而数据的保存形式可能不同：数组、vecotr等等。并且遍历的方式也会不同，如前、中、后序。我们的访问机制应该能必须能容纳不同的数据结构，并且我们会还必须支持不同的遍历方法，如前序、中序、后序。</p><h3 id="方案-6"><a href="#方案-6" class="headerlink" title="方案"></a>方案</h3><p> – 封装访问和遍历：<br> – 只用图元自己知道它所使用的数据结构。可以有这样的推理：图元接口不应该依赖于某个数据结构。但将遍历机制完全放到图元类层次中，将会导致修改和扩充时不得不改变一些类。使得复用遍历机制遍历其他对象结构时很困难，并且在一个结构中，不能使用多个遍历。<br> – 我们引入一类称为iterators的对象，它们的目的是定义这些机制的不同集合。我们可以通过继承来统一访问不同的数据结构和支持新的遍历方式，同时不改变图元接口或打乱已有的图元实现。</p><p> – 将抽象类Iterator为访问和遍历定义一个通用的接口。由具体子类，如ArrayIterator 和 ListIterator等，负责实现接口一提供对数据和列表的访问。而PreorderIterator和 PostorderIterator以及类似的类在指定结构上实现不同的遍历方式。每个Iterator子类有一个它所遍历的结构的引用，在创建子类实例时，需用这个引用进行初始化。</p><p> – 见图 2-13 Iterator类和它的子类。<br> – Iterator接口提供了First、Next和IsDone、CurrentItem操作来控制遍历。<br> – 在访问上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Glyph *p;</span><br><span class="line">Iterator&lt;Glyph *&gt;* i= g-&gt;CreateIterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i-&gt;First(); !i-&gt;IsDone(); i-&gt;Next())</span><br><span class="line">&#123;</span><br><span class="line">  Glyph *child = i-&gt;CurrentItem();</span><br><span class="line">  <span class="comment">// 对当前图元的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在缺省情况下CreateIterator返回一个NullIterator。它适合于叶子节点。对的IsDone操作总返回true。</p><p> – 在图元内部的创建Iterator</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> Iterator&lt;Glyph *&gt; Row::CreateIterator()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ListIterator&lt;Glyph *&gt;(_children);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> –用于先序和中序遍历的Iterator是各图元自身特定的iterator实现的。这些遍历的Iterator还要保存对它们所遍历的结构的根图元的引用。它们调用结构中的图元CreateIterator，并用栈来保存返回的Iterator。<br> 例如：类PreorderIterator从根图元得到Iterator，将它初始化为指向的第一个元素，然后将压如栈中。</p><h3 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h3><p> 见图2-13 Iterator类和它的子类</p><h3 id="评鉴-6"><a href="#评鉴-6" class="headerlink" title="评鉴"></a>评鉴</h3><p>  – Iterator模式描述了那些支持访问和遍历对象结构的技术，它不仅可用于组合结构也可用于集合。该模式抽象了遍历算法，对客户隐藏了它所遍历对象的内部结构。</p><p>  –Iterator模式其实就是封装了不同容器（List、vector等）与它们访问方式（前、中、后）的变化。</p><h3 id="Iterator-–-对象行为模式"><a href="#Iterator-–-对象行为模式" class="headerlink" title="Iterator  – 对象行为模式"></a>Iterator  – 对象行为模式</h3><h4 id="1、意图-1"><a href="#1、意图-1" class="headerlink" title="1、意图"></a>1、意图</h4><p>  提供一种方法，顺序访问一个聚合对象中各各个元素，而又不需暴露该对象的内部表示。</p><h4 id="2、动机-1"><a href="#2、动机-1" class="headerlink" title="2、动机"></a>2、动机</h4><p>  一个聚合对象，如list，应该提供一种方法让别人可以访问它的元素，而又不需暴露它的内部结构，此外，针对不同的需要，可能要以不同的方式遍历这个list。<br>   这一模式的关键思想是将对list的访问和遍历从list对象中分离出来并放入一个Iterator对象中。Iterator类定义一个访问该list元素的接口。Iterator对象负责跟踪当前的元素，即，它知道哪些元素已经遍历过了。<br>   在实例化Iterator之前，必须有List，一旦有了Iterator的实例，便可以顺序的访问该List的元素。CurrentItem操作返回List当前的元素，First操作初始化Iterator，使当前元素指向列表的第一个元素，Next操作将当前元素指向前推一步，指向下一个元素。IsDone检查是否已经超越了最后一个元素。<br>    余下的问题是如何创建迭代器。既然要让这些代码不依赖具体的List，就不能简单的实例化一个特定的类，而要让List对象负责创建相应的Iterator。这需要List对象有CreateIterator这样的操作，客户请求调用该操作以获得一个Iterator对象。</p><h4 id="适用性-1"><a href="#适用性-1" class="headerlink" title="适用性"></a>适用性</h4><p>  – 访问一个聚合对象的内容而无需暴露它的内部表示。<br>  – 支持对聚合对象的多种遍历<br>  – 为遍历不同的聚合结构提供一个统一的接口。</p><h4 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h4><p>  见图：5-4-3Iterator的构结</p><p> – Iterator<br>    迭代器定义访问和遍历元素的接口</p><p> – ConcreteIterator<br>    具体迭代器实现<br>    对该聚合遍历时跟踪当前位置</p><p> – Aggregate（聚合）<br>    聚合的接口，定义创建相应迭代对象的接口</p><p> – ConcreteAggregate<br>    具体聚合实现创建相应迭代器的接口，该操作返回ConcreteIterator一个适当的实例。</p><h2 id="8、visitor：访问者模式"><a href="#8、visitor：访问者模式" class="headerlink" title="8、visitor：访问者模式"></a>8、visitor：访问者模式</h2><h3 id="问题-7"><a href="#问题-7" class="headerlink" title="问题"></a>问题</h3><p> – 分析依赖与遍历，分析的对象也是图元，不能将分析放在遍历中，因为遍历与分析的依存关系太紧密会造成混乱，也不能将分析放在图元类中，因为会是图元爆炸。</p><p> – 对于检查拼写而言，一般的行为是 分析类 操作 图元，但图元的类型不确定，容易写成如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SpellingCheckr::check (Glyph *glyph)</span><br><span class="line">&#123;</span><br><span class="line"> Character *c;</span><br><span class="line"> Row *r;</span><br><span class="line"> Image *i;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span>(c = <span class="keyword">dynamic_cast</span>&lt;Character *&gt;(glyph))</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="comment">// 分析字符</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(r = <span class="keyword">dynamic_cast</span>&lt;Row *&gt;(glyph))</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="comment">// 准备分析r的chlidren</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(i = <span class="keyword">dynamic_cast</span>&lt;Image *&gt;(glyph))</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="comment">// 空操作</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 原话为：这段代码相当拙劣。它依赖与动态转换的能力，难以扩展。无论何时当我们修改Glyph类层次时，都要记住修改这个函数，事实上这是面向对象与语言力图消灭的代码。</p><p> – 对于上述问题的一种替代为动作互转： 图元 被 分析类 操作。<br> 定义类似于如下代码<br> void GlyphSubclass::CheckMe(SpellingCheck &amp;checkr)<br> {<br>   checkr.CheckGlyphSubclass(this);<br> }</p><p> 在分析类里</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Class SpellingChecker</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SpellingChecker();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CheckCharacter</span><span class="params">(Character *)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CheckRow</span><span class="params">(Row *)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CheckImage</span><span class="params">(Image *)</span></span>;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在使用上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SpellingChecher spellingChecker;</span><br><span class="line">Composition *c;</span><br><span class="line"></span><br><span class="line">Glyph * g;</span><br><span class="line"><span class="function">PerorderIterator <span class="title">i</span><span class="params">(c)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(i.First(); !i.IsDone(); i.Next())</span><br><span class="line">&#123;</span><br><span class="line">g = i.CurrentItem();</span><br><span class="line">g-&gt;CheckMe(spellingChecker);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这种做法适合于找出拼写错误，却不能支持多种分析。有点每增加一种分析，就不得不为Glyph及其子类增加一个类似与CheckMe(SpellChecker &amp;)的操作。如果我们坚持每一种分析对应一个独立的类的话，确实如此。但我们可以给所有的分析类型定义一个相同的接口，允许我们多态使用各种分析。</p><h3 id="方案-7"><a href="#方案-7" class="headerlink" title="方案"></a>方案</h3><p> 我们使用术语访问者来泛指在遍历过程中“访问”被遍历对象并做当前适当操作的一类对象，即各种分析的统一接口。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Visitor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> pulic:</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">VisitCharacter</span><span class="params">(Character *)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">VisitRow</span><span class="params">(Row *)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">VisitImage</span><span class="params">(Image *)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// ……等等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 访问者的具体子类做不同的分析。<br> 在图元方面，也要做一定的修改，我们使用一个更通用的名字:Accept,其参数变成Visitor &amp;，以反映它能接受任何访问者。</p><h3 id="评鉴-7"><a href="#评鉴-7" class="headerlink" title="评鉴"></a>评鉴</h3><p> Visitor模式分离了分析与图元两种变化，在使用Visitor模式之前，你要问自己一个重要问题是：哪个类层次变化的更厉害？该模式最适合于当你相对一个稳定类结构的对象做许多不同的操作/处理的情况。增加一种新的访问者，而不需要改变现有的图元结构，这对很大的类结构尤其红药。</p><h3 id="visitor-–-对象行为模式"><a href="#visitor-–-对象行为模式" class="headerlink" title="visitor – 对象行为模式"></a>visitor – 对象行为模式</h3><h4 id="1、意图-2"><a href="#1、意图-2" class="headerlink" title="1、意图"></a>1、意图</h4><p>  表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p><h4 id="2、动机-2"><a href="#2、动机-2" class="headerlink" title="2、动机"></a>2、动机</h4><p>  如果将结构元素中的这些操作分散到各种结构中，会导致整个系统难以理解、难以维护和修改，而且尤其是上述问题，单独的图元也未必能实现。此外，每次增加新的操作也需要重新修改、编译这些类。如何可以独立的增加新的操作，并且使这些节点类独立于作用其上的从操作，将会更好。<br>  使用Vistor模式，必须定义两个类层次，一个对应于接受操作的元素，另一个对应于定义元素的操作的访问者。给访问者类层次增加一个新的子类，即可创建一个新的从操作。</p><h4 id="3、适用性-1"><a href="#3、适用性-1" class="headerlink" title="3、适用性"></a>3、适用性</h4><p>  – 一个对象结构包含很多类对象，他们有不同的接口，而你想对这些对象实施一些基于其他具体类的操作。<br>  – 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而你想避免让这些操作“污染”这些对象的类。<br>  – 定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。</p><h4 id="4、结构"><a href="#4、结构" class="headerlink" title="4、结构"></a>4、结构</h4><p>  见5-11-1Visitor模式结构。</p><p>  – Visitor<br>     为该对象结构中的ConcreteElement的每一个类声明一个Visit操作。访问者类的接口。</p><p>  – ConcreteVisitor<br>     实现每个由Visitor声明的操作，每个操作实现本算法的一部分，而该算法片段乃是对应于结构中对象的类。</p><p>  – Element<br>     定义个Accecpt操作，它以一个访问者为参数。</p><p>  – ConcreteElement<br>     实现Accept操作，也是一个访问者为参数</p><p>  – ObjectStructure<br>     能枚举它的元素<br>     可以提供一个高层的接口，以允许该访问者访问它的元素。<br>     可以是一个负荷结合（Composite）</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在完成上述8种模式的学习后，我构建了一个新的服务：预处理服务，以及预想构建新的研判服务。预处理服务完成的是针对某一故指YX动作，需要结合YC判断YX动作是否误报，其中判断的策略有5种之多。故障研判服务是针对电网发生故障后，一系列的YX/YC动作来判断发生跳闸的开关。在对这两个模块的构造过程中，对设计模式的使用有了一些新的认知。</p><p>1、在预处理设计时，首先考虑的是2方面变化，即预处理设备的变化、预处理策略的变化，它们之间的关系是【设备执行预处理策略、预处理策略被设备执行】。于是设计了2个类层次结构，设备类、策略类，设备类以对象组合的模式来包含策略类。【结构类模式】</p><p>2、其次是考虑如何让系统运行起来，即对线程的组织上，本方面的内容应该不属于模式设计。对线程的组织分析要明确的是对流程的把握，可借鉴生产线的模式：每个流程，可能有多个步骤。<br>可以从横向的将每个步骤组织成线程，当生产一批产品时，每个线程对所有的产品进行处理，类似于每个生产过程都有一个工人负责；<br>也可以纵向的将每个流程组织成一线程，该线程包含了所有步骤，当生产一批产品是，需要实例化多个线程来完成，类似于一个工人完成一个产品的所有步骤，有多个工人来完成多个产品的；<br>前一种适合与大量情况，并且有延时的情况，不能sleep，后一种模式适用于并不大量的情况。巨量情况可以考虑两种流派的组合（2种组合方式，以前一种为主与以后一种为主）。<br>从使用手段上可以有线程池方式、现New的方式、以及本次使用的带有缓存空间的方式。</p><p>3、接着是对整个数据处理的把握，在设计预处理时，开始时对于数据在整个流程的输入、输出处理不当，对于取走的数据如何处置、每种策略结果与整个预处理的结论上，都没有考虑设计到位，指导中途修改使用在整个预处理过程中一直存在的结构才完美完成。</p><p>4、最后是对核心逻辑的把握，这个与2类似，2是流程的控制，4更注重的是整体的核心逻辑。像故障研判，核心逻辑是将配变分成刚刚停电、可疑停电、早已停电、未停电，然后根据刚刚停电配变，从叶子节点寻找故障子节点，直到刚刚停电配变集合为空。依此逻辑，会出现多跳闸点的情况，之后对3个及以上跳闸点进行了强制合并。从设计上，我们要兼容变化，但是否应该肯定不变化。一个代码总要有肯定的东西才能成为代码，如同耦合一样，只听过低耦合，从来不会有无耦合的代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是在写C++时，看的可复用面向对象软件的基础部分的前几种模式，放在这里只做一种对比&lt;br&gt;
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>CSS基础</title>
    <link href="http://yoursite.com/2018/08/30/2018-8-30css/"/>
    <id>http://yoursite.com/2018/08/30/2018-8-30css/</id>
    <published>2018-08-30T03:29:35.000Z</published>
    <updated>2019-02-15T08:01:26.574Z</updated>
    
    <content type="html"><![CDATA[<p>主要介绍css与css3<br><a id="more"></a></p><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;<span class="attribute">color</span>:black;&#125;</span><br><span class="line"><span class="selector-tag">h1</span> &#123;<span class="attribute">color</span>:blue;&#125;</span><br><span class="line"><span class="selector-tag">h2</span> &#123;<span class="attribute">color</span>:silver;&#125;</span><br><span class="line"><span class="selector-tag">body</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">p</span>, <span class="selector-tag">table</span>, <span class="selector-tag">th</span>, <span class="selector-tag">td</span>, <span class="selector-tag">pre</span>, <span class="selector-tag">strong</span>, <span class="selector-tag">em</span> &#123;<span class="attribute">color</span>:gray;&#125;</span><br></pre></td></tr></table></figure><h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器 ."></a>类选择器 .</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.important</span> &#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.important</span> &#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure><h3 id="ID选择器"><a href="#ID选择器" class="headerlink" title="ID选择器"></a>ID选择器</h3><p><code>#intro {font-weight:bold;}</code></p><h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器 []"></a>属性选择器 []</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href]</span> &#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line"><span class="selector-tag">img</span><span class="selector-attr">[alt]</span> &#123;<span class="attribute">border</span>: <span class="number">5px</span> solid red;&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href="http://www.w3school.com.cn/about_us.asp"]</span> &#123;<span class="attribute">color</span>: red;&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[class~="important"]</span> &#123;<span class="attribute">color</span>: red;&#125;</span><br></pre></td></tr></table></figure><h3 id="后代选择器-空格"><a href="#后代选择器-空格" class="headerlink" title="后代选择器 空格"></a>后代选择器 空格</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h1 em &#123;color:red;&#125;</span><br></pre></td></tr></table></figure><h3 id="子元素选择器-gt"><a href="#子元素选择器-gt" class="headerlink" title="子元素选择器 &gt;"></a>子元素选择器 &gt;</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h1 &gt; strong &#123;color:red;&#125;</span><br><span class="line">table.company td &gt; p</span><br></pre></td></tr></table></figure><p>上面的选择器会选择作为 td 元素子元素的所有 p 元素，这个 td 元素本身从 table 元素继承，该 table 元素有一个包含 company 的 class 属性。</p><h3 id="兄弟选择器"><a href="#兄弟选择器" class="headerlink" title="兄弟选择器 +"></a>兄弟选择器 +</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h1 + p &#123;margin-top:50px;&#125;</span><br></pre></td></tr></table></figure><p>选择紧接在 h1 元素后出现的段落，h1 和 p 元素拥有共同的父元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">html &gt; body table + ul &#123;margin-top:20px;&#125;</span><br></pre></td></tr></table></figure><p>这个选择器解释为：选择紧接在 table 元素后出现的所有兄弟 ul 元素，该 table 元素包含在一个 body 元素中，body 元素本身是 html 元素的子元素。</p><h3 id="伪类"><a href="#伪类" class="headerlink" title="伪类 :"></a>伪类 :</h3><p>语法selector : pseudo-class {property: value}<br>锚伪类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a:link &#123;color: #FF0000&#125;/* 未访问的链接 */</span><br><span class="line"></span><br><span class="line">a:visited &#123;color: #00FF00&#125;/* 已访问的链接 */</span><br><span class="line"></span><br><span class="line">a:hover &#123;color: #FF00FF&#125;/* 鼠标移动到链接上 */</span><br><span class="line"></span><br><span class="line">a:active &#123;color: #0000FF&#125;/* 选定的链接 */</span><br><span class="line"></span><br><span class="line">:first-child 伪类</span><br><span class="line">p:first-child &#123;font-weight: bold;&#125;</span><br><span class="line"></span><br><span class="line">:lang 伪类</span><br><span class="line">:lang 伪类使你有能力为不同的语言定义特殊的规则。在下面的例子中，:lang 类为属性值为 no 的 q 元素定义引号的类型：</span><br></pre></td></tr></table></figure><h3 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素  :"></a>伪元素  :</h3><p>selector.class:pseudo-element {property:value;}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">:first-line 伪元素</span><br><span class="line">  p:first-line</span><br><span class="line">  &#123;</span><br><span class="line">  color:#ff0000;</span><br><span class="line">  font-variant:small-caps;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">:first-letter 伪元素</span><br><span class="line">  p:first-letter</span><br><span class="line">  &#123;</span><br><span class="line">  color:#ff0000;</span><br><span class="line">  font-size:xx-large;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>:before 伪元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">:before&quot; 伪元素可以在元素的内容前面插入新内容。</span><br><span class="line">  h1:before</span><br><span class="line">  &#123;</span><br><span class="line">  content:url(logo.gif);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">:after 伪元素</span><br><span class="line">  h1:after</span><br><span class="line">  &#123;</span><br><span class="line">  content:url(logo.gif);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li><p>background-color 背景色</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">background-color</span>: gray;&#125;</span><br></pre></td></tr></table></figure></li><li><p>background-image 背景图 </p><p>background:url();</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;<span class="attribute">background-image</span>: <span class="built_in">url</span>(/i/eg_bg_04.gif);&#125;</span><br></pre></td></tr></table></figure><p>css3中支持多重背景：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="attribute">background-image</span>:<span class="built_in">url</span>(bg_flower.gif),<span class="built_in">url</span>(bg_flower_2.gif);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>background-repeat 背景重复，与背景图结合使用</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span></span><br><span class="line">&#123; </span><br><span class="line"> <span class="attribute">background-image</span>: <span class="built_in">url</span>(/i/eg_bg_03.gif);</span><br><span class="line"> <span class="attribute">background-repeat</span>: repeat-y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>background-position 背景定位</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span></span><br><span class="line">&#123; </span><br><span class="line">  <span class="attribute">background-image</span>:<span class="built_in">url</span>(<span class="string">'/i/eg_bg_03.gif'</span>);</span><br><span class="line">  <span class="attribute">background-repeat</span>:no-repeat;</span><br><span class="line">  <span class="attribute">background-position</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 属性值包括：center，top，right，bottom，left；百分比；具体数值等。</p></li><li><p>background-attachment 背景关联<br>  如果文档比较长，那么当文档向下滚动时，背景图像也会随之滚动。当文档滚动到超过图像的位置时，图像就会消失。<br>  background-attachment:fixed</p></li><li><p>background-size CSS3中增加背景大小属性<br>%,px,em,ex等。</p></li><li><p>background-origin属性<br>值为context-box,padding-box,border-box等</p></li></ul><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><ul><li><p>font-family字体系列属性</p><p>CSS定义了五种通用字体系列：</p><p>Serif字体</p><p>Sans-serif字体</p><p>Monospace字体</p><p>Cursive字体</p><p>Fantasy字体</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;<span class="attribute">font-family</span>: sans-serif;&#125;</span><br></pre></td></tr></table></figure></li><li><p>font-style字体风格</p><p>该属性有三个值：</p><p>normal - 文本正常显示</p><p>italic - 文本斜体显示</p><p>oblique - 文本倾斜显示</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.normal</span> &#123;<span class="attribute">font-style</span>:normal;&#125;</span><br></pre></td></tr></table></figure></li><li><p>font-weight字体加粗属性</p><p>100 ~ 900 为字体指定了 9 级加粗度。100 对应最细的字体变形，900 对应最粗的字体变形。数字 400 等价于 normal，而 700 等价于 bold。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.thick</span> &#123;<span class="attribute">font-weight</span>:bold;&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.thicker</span> &#123;<span class="attribute">font-weight</span>:<span class="number">900</span>;&#125;</span><br></pre></td></tr></table></figure></li><li><p>font-size字体大小属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;<span class="attribute">font-size</span>:<span class="number">60px</span>;&#125;</span><br><span class="line"><span class="selector-tag">h2</span> &#123;<span class="attribute">font-size</span>:<span class="number">40px</span>;&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">font-size</span>:<span class="number">14px</span>;&#125;</span><br></pre></td></tr></table></figure></li><li><p>CSS3 @font-face 规则</p><p>通过 CSS3，web 设计师可以使用他们喜欢的任意字体。</p><p>当您您找到或购买到希望使用的字体时，可将该字体文件存放到 web 服务器上，它会在需要时被自动下载到用户的计算机上。</p><p>您“自己的”的字体是在 CSS3 @font-face 规则中定义的。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt; </span><br><span class="line">@<span class="keyword">font-face</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">font-family</span>: myFirstFont;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">'Sansation_Light.ttf'</span>),</span><br><span class="line">    <span class="built_in">url</span>(<span class="string">'Sansation_Light.eot'</span>); <span class="comment">/* IE9+ */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">font-family</span>:myFirstFont;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><ul><li><p>text-indent首行缩进<br>p {text-indent: 5em;}</p></li><li><p>text-align水平对齐<br>left\right\center</p></li><li><p>word-spacing字间距<br>p.spread {word-spacing: 30px;}</p></li><li><p>letter-spacing 字母间距<br>h4 {letter-spacing: 20px}</p></li><li><p>text-transform 字符转换<br>uppercase<br>lowercase<br>capitalize：首字母大写</p></li><li><p>text-decoration字体装饰<br>underline<br>overline<br>line-through<br>blink</p></li><li><p>direction 文本放下<br>影响块级元素中文本的书写方向、表中列布局的方向、内容水平填充其元素框的方向、以及两端对齐元素中最后一行的位置。</p></li><li><p>text-shadow css3中支持文本阴影：与box-shadow类似</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="attribute">text-shadow</span>: <span class="number">5px</span> <span class="number">5px</span> <span class="number">5px</span> <span class="number">#FF0000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>word-wrap分词CSS3属性</p></li><li><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">word-wrap</span>:break-word;&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>针对以下四种状态设置颜色、背景、字体修饰等等</p><p>  a:link - 普通的、未被访问的链接</p><p>  a:visited - 用户已访问的链接</p><p>  a:hover - 鼠标指针位于链接的上方</p><p>  a:active - 链接被点击的时刻</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ul><li><p>list-style-type列表类型</p><p>square</p></li><li><p>list-style-image列表图像</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span> &#123;<span class="attribute">list-style-image </span>: <span class="built_in">url</span>(xxx.gif)&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><ul><li><p>border<br>设置表格边框</p><ul><li><p>边框</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">table</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">border-collapse</span>:collapse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">table</span>,<span class="selector-tag">th</span>, <span class="selector-tag">td</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有boder-collapse,table的边框与th、td的边框会分离，成为2层</p></li><li><p>其他属性</p><p>表格的宽度与高度属性：width，height;<br>表格文本对齐属性:text-align<br>背景颜色<br>内边距等等</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">table</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">th</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>:green;</span><br><span class="line">  <span class="attribute">color</span>:white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">td</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">text-align</span>:right;</span><br><span class="line">  <span class="attribute">padding</span>:<span class="number">15px</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>轮廓outline</p><ul><li>outline是在border外了一层框</li><li>outline-color</li><li>outline-style</li><li>outline-width</li></ul></li></ul></li></ul><h2 id="框模型"><a href="#框模型" class="headerlink" title="框模型"></a>框模型</h2><ul><li><p>模型</p><p>从内至外：元素element、内边距padding、边框border、外边距margin</p><p><img src="框模型.png" alt="框模型"></p></li><li><p>padding</p><p>可以按照上、右、下、左的顺序分别设置各边的内边距<br><code>h1 {padding: 10px 0.25em 2ex 20%;}</code><br>等价于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">h1 &#123;</span><br><span class="line">  padding-top: 10px;</span><br><span class="line">  padding-right: 0.25em;</span><br><span class="line">  padding-bottom: 2ex;</span><br><span class="line">  padding-left: 20%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>border</p><p>border有3个属性：类型style，颜色color，宽度width<br>每一种属性都可以从top\right\bottom\left的角度来设置。<br><code>p {border:solid red 1px}</code></p></li><li><p>border-radius</p><p>css3中新增属性，用于圆角矩形<br><code>border-radius:25px;</code></p></li><li><p>box-shadow<br>增加边框的阴影效果<br><code>box-shadow: 10px 10px 5px #888888;</code><br>边框的相对位置，虚化，颜色</p></li><li><p>margin<br>与padding类似<br><code>h1 {margin : 10px 0px 15px 5px;}</code></p></li></ul><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><h3 id="display"><a href="#display" class="headerlink" title="display"></a>display</h3><p>div、h1 或 p 元素常常被称为块级元素。这意味着这些元素显示为一块内容，即“块框”。与之相反，span 和 strong 等元素称为“行内元素”，这是因为它们的内容显示在行中，即“行内框”。</p><p>您可以使用 display 属性改变生成的框的类型。这意味着，通过将 display 属性设置为 block，可以让行内元素（比如 <code>&lt;a&gt;</code> 元素）表现得像块级元素一样。还可以通过把 display 设置为 none，让生成的元素根本没有框。这样的话，该框及其所有内容就不再显示，不占用文档中的空间。</p><h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><ul><li><p>相对定位：移动后原位置保留</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#box_relative</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="相对定位.png" alt="相对定位"></p><p>在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框</p></li><li><p>绝对定位：移动后原位置不保留</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#box_relative</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="绝对定位.png" alt="绝对定位"></p><p>相对定位是“相对于”元素在文档中的初始位置,而绝对定位是“相对于”最近的已定位祖先元素，如果不存在已定位的祖先元素，那么“相对于”最初的包含块。</p></li></ul><h3 id="float"><a href="#float" class="headerlink" title="float"></a>float</h3><ul><li><p>简介</p><p>浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。</p></li><li><p>浮动</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.news</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.news</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clear</span> &#123;</span><br><span class="line"><span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三个框都向左移动，那么框 1 向左浮动直到碰到包含框，另外两个框向左浮动直到碰到前一个浮动框。</p><p><img src="浮动框并列.png" alt="浮动框并列"></p><p>如果包含框太窄，无法容纳水平排列的三个浮动元素，那么其它浮动块向下移动，直到有足够的空间</p><p><img src="浮动框下沉.png" alt="浮动框下沉"></p></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h3><h4 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h4><ul><li><p>如何水平对齐块级元素<br>块级元素指的是占据占据全部可用宽度的元素，并在其前后都会换行。<br><code>&lt;h1&gt;</code><br><code>&lt;p&gt;</code><br><code>&lt;div&gt;</code></p></li><li><p>使用margin来水平对齐<br>可通过将左和右外边距设置为 “auto”，来对齐块元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.center</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="attribute">margin</span>:auto;</span><br><span class="line"> <span class="attribute">width</span>:<span class="number">70%</span>;</span><br><span class="line"> <span class="attribute">background-color</span>:<span class="number">#b0e0e6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用position来进行左右对齐<br>当像这样对齐元素时，对 <body> 元素的外边距和内边距进行预定义是一个好主意。这样可以避免在不同的浏览器中出现可见的差异。</body></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line"> <span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="attribute">position</span>:absolute;</span><br><span class="line"> <span class="attribute">right</span>:<span class="number">0px</span>;</span><br><span class="line"> <span class="attribute">width</span>:<span class="number">300px</span>;</span><br><span class="line"> <span class="attribute">background-color</span>:<span class="number">#b0e0e6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用float属性来对齐</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.right</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="attribute">float</span>:right;</span><br><span class="line"> <span class="attribute">width</span>:<span class="number">300px</span>;</span><br><span class="line"> <span class="attribute">background-color</span>:<span class="number">#b0e0e6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h4><ul><li><p>height:元素的高度</p></li><li><p>width：元素的宽度</p></li><li><p>line-height:行高</p></li><li><p>max-height:最大高度</p></li><li>min-height</li><li>max-width：最大宽度</li><li>min-width</li></ul><h4 id="图片浮动"><a href="#图片浮动" class="headerlink" title="图片浮动"></a>图片浮动</h4>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">float</span>:right;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">120px</span>;</span><br><span class="line"><span class="attribute">margin</span>:<span class="number">0</span> <span class="number">0</span> <span class="number">15px</span> <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">padding</span>:<span class="number">15px</span>;</span><br><span class="line"><span class="attribute">border</span>:<span class="number">1px</span> solid black;</span><br><span class="line"><span class="attribute">text-align</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/i/eg_cute.gif"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">CSS is fun!</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="首字母"><a href="#首字母" class="headerlink" title="首字母"></a>首字母</h4>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">span</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">float</span>:left;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">0.7em</span>;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">400%</span>;</span><br><span class="line"><span class="attribute">font-family</span>:algerian,courier;</span><br><span class="line"><span class="attribute">line-height</span>:<span class="number">80%</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;span&gt;T&lt;/span&gt;his is some text.</span><br></pre></td></tr></table></figure><h4 id="无表格首页"><a href="#无表格首页" class="headerlink" title="无表格首页"></a>无表格首页</h4>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type="text/css"&gt;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.container</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">border</span>:<span class="number">1px</span> solid gray;</span><br><span class="line">  <span class="attribute">line-height</span>:<span class="number">150%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.header</span>,<span class="selector-tag">div</span><span class="selector-class">.footer</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">padding</span>:<span class="number">0.5em</span>;</span><br><span class="line">  <span class="attribute">color</span>:white;</span><br><span class="line">  <span class="attribute">background-color</span>:gray;</span><br><span class="line">  <span class="attribute">clear</span>:left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-class">.header</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.left</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">float</span>:left;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">160px</span>;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>:<span class="number">1em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.content</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">margin-left</span>:<span class="number">190px</span>;</span><br><span class="line">  <span class="attribute">border-left</span>:<span class="number">1px</span> solid gray;</span><br><span class="line">  <span class="attribute">padding</span>:<span class="number">1em</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="图片库"><a href="#图片库" class="headerlink" title="图片库"></a>图片库</h3><h4 id="图片库-1"><a href="#图片库-1" class="headerlink" title="图片库"></a>图片库</h4>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.img</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">3px</span>;</span><br><span class="line">  <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#bebebe</span>;</span><br><span class="line">  <span class="attribute">height</span>:auto;</span><br><span class="line">  <span class="attribute">width</span>:auto;</span><br><span class="line">  <span class="attribute">float</span>:left;</span><br><span class="line">  <span class="attribute">text-align</span>:center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.img</span> <span class="selector-tag">img</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="attribute">display</span>:inline;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">3px</span>;</span><br><span class="line">  <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#bebebe</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.img</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">img</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#333333</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.desc</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="attribute">text-align</span>:center;</span><br><span class="line">  <span class="attribute">font-weight</span>:normal;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>:<span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">10px</span> <span class="number">5px</span> <span class="number">10px</span> <span class="number">5px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">href</span>=<span class="string">"/i/tulip_ballade.jpg"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/i/tulip_ballade_s.jpg"</span> <span class="attr">alt</span>=<span class="string">"Ballade"</span> <span class="attr">width</span>=<span class="string">"160"</span> <span class="attr">height</span>=<span class="string">"160"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"desc"</span>&gt;</span>在此处添加对图像的描述<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>div的类为class包括链接与desc说明，其中链接是以图片为链接src的。<br>最值得注意的是，将a中的img设置为inline，而不是a</p><h4 id="图片透明度"><a href="#图片透明度" class="headerlink" title="图片透明度"></a>图片透明度</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">IMG</span> <span class="selector-pseudo">:HOVER</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">OPACITY</span>:<span class="number">0.4</span>;</span><br><span class="line"><span class="attribute">FILTER</span>:<span class="built_in">ALPHA</span>(OPACITY=40); <span class="comment">/* 针对 IE8 以及更早的版本 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="透明框中的文本"><a href="#透明框中的文本" class="headerlink" title="透明框中的文本"></a>透明框中的文本</h5>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.background</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">266px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">'/i/tulip_peach_blossom_w.jpg'</span>) no-repeat;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.transbox</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">338px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">204px</span>;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">  <span class="comment">/* for IE */</span></span><br><span class="line">  <span class="attribute">filter</span>:<span class="built_in">alpha</span>(opacity=60);</span><br><span class="line">  <span class="comment">/* CSS3 standard */</span></span><br><span class="line">  <span class="attribute">opacity</span>:<span class="number">0.6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.transbox</span> <span class="selector-tag">p</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">30px</span> <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"background"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"transbox"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  This is some text that is placed in the transparent box.</span><br><span class="line">  This is some text that is placed in the transparent box.</span><br><span class="line">  This is some text that is placed in the transparent box.</span><br><span class="line">  This is some text that is placed in the transparent box.</span><br><span class="line">  This is some text that is placed in the transparent box.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对backgroud设置背景图片与大小，然后在其中设置文本框，包括边距、透明度、背景颜色为白色很重要。透明度也是在白色背景基础上完成的。</p><h3 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h3><p>导航栏 = 链接列表</p><h4 id="水平菜单"><a href="#水平菜单" class="headerlink" title="水平菜单"></a>水平菜单</h4>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">float</span>:left;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line"><span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line"><span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line"><span class="attribute">list-style-type</span>:none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">float</span>:left;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">7em</span>;</span><br><span class="line"><span class="attribute">text-decoration</span>:none;</span><br><span class="line"><span class="attribute">color</span>:white;</span><br><span class="line"><span class="attribute">background-color</span>:purple;</span><br><span class="line"><span class="attribute">padding</span>:<span class="number">0.2em</span> <span class="number">0.6em</span>;</span><br><span class="line"><span class="attribute">border-right</span>:<span class="number">1px</span> solid white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Link one<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Link two<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Link three<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Link four<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="垂直菜单"><a href="#垂直菜单" class="headerlink" title="垂直菜单"></a>垂直菜单</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line"><span class="selector-tag">ul</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">list-style-type</span>:none;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">display</span>:block;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>:<span class="number">#dddddd</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h4 id="水平菜单-1"><a href="#水平菜单-1" class="headerlink" title="水平菜单"></a>水平菜单</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line"><span class="selector-tag">ul</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">list-style-type</span>:none;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">overflow</span>:hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">float</span>:left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">display</span>:block;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>:<span class="number">#dddddd</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h1 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h1><h2 id="2D转换transform"><a href="#2D转换transform" class="headerlink" title="2D转换transform"></a>2D转换transform</h2><ul><li><p>translate()移动</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(50px,100px);</span><br><span class="line">  <span class="attribute">-ms-transform</span>: <span class="built_in">translate</span>(50px,100px);<span class="comment">/* IE 9 */</span></span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">translate</span>(50px,100px);<span class="comment">/* Safari and Chrome */</span></span><br><span class="line">  <span class="attribute">-o-transform</span>: <span class="built_in">translate</span>(50px,100px);<span class="comment">/* Opera */</span></span><br><span class="line">  <span class="attribute">-moz-transform</span>: <span class="built_in">translate</span>(50px,100px);<span class="comment">/* Firefox */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>rotate()旋转</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="attribute">transform</span>: <span class="built_in">rotate</span>(30deg);</span><br><span class="line"> <span class="attribute">-ms-transform</span>: <span class="built_in">rotate</span>(30deg);<span class="comment">/* IE 9 */</span></span><br><span class="line"> <span class="attribute">-webkit-transform</span>: <span class="built_in">rotate</span>(30deg);<span class="comment">/* Safari and Chrome */</span></span><br><span class="line"> <span class="attribute">-o-transform</span>: <span class="built_in">rotate</span>(30deg);<span class="comment">/* Opera */</span></span><br><span class="line"> <span class="attribute">-moz-transform</span>: <span class="built_in">rotate</span>(30deg);<span class="comment">/* Firefox */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>scale()拉伸</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="attribute">transform</span>: <span class="built_in">scale</span>(2,4);</span><br><span class="line"> <span class="attribute">-ms-transform</span>: <span class="built_in">scale</span>(2,4);<span class="comment">/* IE 9 */</span></span><br><span class="line"> <span class="attribute">-webkit-transform</span>: <span class="built_in">scale</span>(2,4);<span class="comment">/* Safari 和 Chrome */</span></span><br><span class="line"> <span class="attribute">-o-transform</span>: <span class="built_in">scale</span>(2,4);<span class="comment">/* Opera */</span></span><br><span class="line"> <span class="attribute">-moz-transform</span>: <span class="built_in">scale</span>(2,4);<span class="comment">/* Firefox */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>skew()倾斜</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="attribute">transform</span>: <span class="built_in">skew</span>(30deg,20deg);</span><br><span class="line"> <span class="attribute">-ms-transform</span>: <span class="built_in">skew</span>(30deg,20deg);<span class="comment">/* IE 9 */</span></span><br><span class="line"> <span class="attribute">-webkit-transform</span>: <span class="built_in">skew</span>(30deg,20deg);<span class="comment">/* Safari and Chrome */</span></span><br><span class="line"> <span class="attribute">-o-transform</span>: <span class="built_in">skew</span>(30deg,20deg);<span class="comment">/* Opera */</span></span><br><span class="line"> <span class="attribute">-moz-transform</span>: <span class="built_in">skew</span>(30deg,20deg);<span class="comment">/* Firefox */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>matrix():</p><p>需要六个参数，包含数学函数，允许您：旋转、缩放、移动以及倾斜元素。</p></li></ul><h2 id="3D转换"><a href="#3D转换" class="headerlink" title="3D转换"></a>3D转换</h2><p>就是2D转换后加X、Y、Z、3D等表示在那个轴进行</p><p>如translate3d(x,y,z),translateX(x),translateY(y),translateZ(z)</p><h2 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h2><p>CSS3 过渡是元素从一种样式逐渐改变为另一种的效果。</p><p>  要实现这一点，必须规定两项内容：</p><p>  规定您希望把效果添加到哪个 CSS 属性上</p><p>  规定效果的时长</p><h3 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h3>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt; </span><br><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>:yellow;</span><br><span class="line">  <span class="attribute">transition</span>:width <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">-moz-transition</span>:width <span class="number">2s</span>; <span class="comment">/* Firefox 4 */</span></span><br><span class="line">  <span class="attribute">-webkit-transition</span>:width <span class="number">2s</span>; <span class="comment">/* Safari and Chrome */</span></span><br><span class="line">  <span class="attribute">-o-transition</span>:width <span class="number">2s</span>; <span class="comment">/* Opera */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt; </span><br><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>:yellow;</span><br><span class="line">  <span class="attribute">transition</span>:width <span class="number">2s</span>, height <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">-moz-transition</span>:width <span class="number">2s</span>, height <span class="number">2s</span>, -moz-transform <span class="number">2s</span>; <span class="comment">/* Firefox 4 */</span></span><br><span class="line">  <span class="attribute">-webkit-transition</span>:width <span class="number">2s</span>, height <span class="number">2s</span>, -webkit-transform <span class="number">2s</span>; <span class="comment">/* Safari and Chrome */</span></span><br><span class="line">  <span class="attribute">-o-transition</span>:width <span class="number">2s</span>, height <span class="number">2s</span>, -o-transform <span class="number">2s</span>; <span class="comment">/* Opera */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">transform</span>:<span class="built_in">rotate</span>(180deg);</span><br><span class="line">  <span class="attribute">-moz-transform</span>:<span class="built_in">rotate</span>(180deg); <span class="comment">/* Firefox 4 */</span></span><br><span class="line">  <span class="attribute">-webkit-transform</span>:<span class="built_in">rotate</span>(180deg); <span class="comment">/* Safari and Chrome */</span></span><br><span class="line">  <span class="attribute">-o-transform</span>:<span class="built_in">rotate</span>(180deg); <span class="comment">/* Opera */</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h2 id="动画-keyframes及animation"><a href="#动画-keyframes及animation" class="headerlink" title="动画@keyframes及animation"></a>动画@keyframes及animation</h2><p>如需在 CSS3 中创建动画，您需要学习 @keyframes 规则。</p><p>@keyframes 规则用于创建动画。在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果。</p><p>先用@keyframes创建动画，然后用animation绑定到div元素上。动画其实是上述过渡的更进一步。需要对各个浏览器进行匹配。</p><h3 id="背景色"><a href="#背景色" class="headerlink" title="背景色"></a>背景色</h3>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt; </span><br><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line"><span class="attribute">background</span>:red;</span><br><span class="line"><span class="attribute">animation</span>:myfirst <span class="number">5s</span>;</span><br><span class="line"><span class="attribute">-moz-animation</span>:myfirst <span class="number">5s</span>; <span class="comment">/* Firefox */</span></span><br><span class="line"><span class="attribute">-webkit-animation</span>:myfirst <span class="number">5s</span>; <span class="comment">/* Safari and Chrome */</span></span><br><span class="line"><span class="attribute">-o-animation</span>:myfirst <span class="number">5s</span>; <span class="comment">/* Opera */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">keyframes</span> myfirst</span><br><span class="line">&#123;</span><br><span class="line">0%   &#123;<span class="attribute">background</span>:red;&#125;</span><br><span class="line">25%  &#123;<span class="attribute">background</span>:yellow;&#125;</span><br><span class="line">50%  &#123;<span class="attribute">background</span>:blue;&#125;</span><br><span class="line">100% &#123;<span class="attribute">background</span>:green;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-<span class="keyword">moz</span>-<span class="keyword">keyframes</span> myfirst /* Firefox */</span><br><span class="line">&#123;</span><br><span class="line">0%   &#123;<span class="attribute">background</span>:red;&#125;</span><br><span class="line">25%  &#123;<span class="attribute">background</span>:yellow;&#125;</span><br><span class="line">50%  &#123;<span class="attribute">background</span>:blue;&#125;</span><br><span class="line">100% &#123;<span class="attribute">background</span>:green;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-<span class="keyword">webkit</span>-<span class="keyword">keyframes</span> myfirst /* Safari and Chrome */</span><br><span class="line">&#123;</span><br><span class="line">0%   &#123;<span class="attribute">background</span>:red;&#125;</span><br><span class="line">25%  &#123;<span class="attribute">background</span>:yellow;&#125;</span><br><span class="line">50%  &#123;<span class="attribute">background</span>:blue;&#125;</span><br><span class="line">100% &#123;<span class="attribute">background</span>:green;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-<span class="keyword">o</span>-<span class="keyword">keyframes</span> myfirst /* Opera */</span><br><span class="line">&#123;</span><br><span class="line">0%   &#123;<span class="attribute">background</span>:red;&#125;</span><br><span class="line">25%  &#123;<span class="attribute">background</span>:yellow;&#125;</span><br><span class="line">50%  &#123;<span class="attribute">background</span>:blue;&#125;</span><br><span class="line">100% &#123;<span class="attribute">background</span>:green;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h3>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">animation</span>: myfirst <span class="number">5s</span> linear <span class="number">2s</span> infinite alternate;</span><br><span class="line"><span class="comment">/* Firefox: */</span></span><br><span class="line"><span class="attribute">-moz-animation</span>: myfirst <span class="number">5s</span> linear <span class="number">2s</span> infinite alternate;</span><br><span class="line"><span class="comment">/* Safari 和 Chrome: */</span></span><br><span class="line"><span class="attribute">-webkit-animation</span>: myfirst <span class="number">5s</span> linear <span class="number">2s</span> infinite alternate;</span><br><span class="line"><span class="comment">/* Opera: */</span></span><br><span class="line"><span class="attribute">-o-animation</span>: myfirst <span class="number">5s</span> linear <span class="number">2s</span> infinite alternate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多列"><a href="#多列" class="headerlink" title="多列"></a>多列</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>通过 CSS3，您能够创建多个列来对文本进行布局 - 就像报纸那样！</p><p>多列属性：</p><p>column-count</p><p>column-gap</p><p>column-rule </p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt; </span><br><span class="line"><span class="selector-class">.newspaper</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">-moz-column-count</span>:<span class="number">3</span>; <span class="comment">/* Firefox */</span></span><br><span class="line"><span class="attribute">-webkit-column-count</span>:<span class="number">3</span>; <span class="comment">/* Safari and Chrome */</span></span><br><span class="line"><span class="attribute">column-count</span>:<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">-moz-column-gap</span>:<span class="number">30px</span>; <span class="comment">/* Firefox */</span></span><br><span class="line"><span class="attribute">-webkit-column-gap</span>:<span class="number">30px</span>; <span class="comment">/* Safari and Chrome */</span></span><br><span class="line"><span class="attribute">column-gap</span>:<span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要介绍css与css3&lt;br&gt;
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>HTML基础</title>
    <link href="http://yoursite.com/2018/08/30/2018-8-30html/"/>
    <id>http://yoursite.com/2018/08/30/2018-8-30html/</id>
    <published>2018-08-30T03:28:35.000Z</published>
    <updated>2019-02-15T08:01:26.574Z</updated>
    
    <content type="html"><![CDATA[<p>主要整理了html，html5</p><a id="more"></a><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><ul><li>HTML意思为超文本文档，首先是“文档”，类比word文档，有标题<code>&lt;h1&gt;-&lt;h6&gt;</code>，有段落<code>&lt;p&gt;</code>，有表格<code>&lt;table&gt;</code>，有图片<code>&lt;img&gt;</code>。其次是“超文本”，会有更多的元素，包括超链接<code>&lt;a href=&quot;&quot;&gt;</code>，视频，音频等等。所有这些元素各有各的属性、内容，用于对不同元素进行充实。</li><li>元素由三部分组成：标签、属性、内容。标签用于说明元素的类型，属性用来如何展示内容，内容是显示元素。</li></ul><h2 id="头部head"><a href="#头部head" class="headerlink" title="头部head"></a>头部head</h2><ul><li>title:标题，添加到收藏夹时显示的标题，</li><li>base定义页面上所有链接的默认地址。</li><li>link本文档与外部资源『文档』的关系</li><li>style：定义文档的样式信息。</li><li>script:客户端脚本</li><li>meta：关于HTML文档的元数据，包括作者，版权，描述，关键字，可用作搜素</li></ul><h2 id="js脚本"><a href="#js脚本" class="headerlink" title="js脚本"></a>js脚本</h2><ul><li><p><code>&lt;script&gt;</code>元素type=”text/javascript”，document.write来写入</p></li><li><p>位置</p><p>可以包含在header中，这样只有等js加载完成网页才能显示</p><p>js思想中推荐放在<code>&lt;body&gt;</code>最后，这样可以加速加载，具体使用看情况</p></li></ul><h2 id="文本元素"><a href="#文本元素" class="headerlink" title="文本元素"></a>文本元素</h2><p>包括align(对齐)、bgcolor（背景色）、color（字体颜色）等，都用style(样式)来替代。样式的好处可以直接添加到HTML元素，并将可以将样式在css文件中实现。</p><ul><li>对齐 style=”text-align:center”</li><li>字体 style=”font-family:verdana;color:red;font-size:20px;”</li><li><p>背景色 style=”background-color:red”</p></li><li><p>字体修改（b粗体、i斜体、big/small大小体、del删除、ins下划线、sub/sup上下标等各式）；</p></li><li>计算机输出（编程代码：code代码,var变量，kbd输入，samp代码样本，pre预各式）；</li><li>引用和属术语定义(abbr定义缩写，acronym首字母缩写，title属性显示完全内容，address定义地址)。</li></ul><h2 id="超文本元素"><a href="#超文本元素" class="headerlink" title="超文本元素"></a>超文本元素</h2><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><ul><li>链接有2种方式：href超链接，指向另一个文档的链接；另一个指向由name元素创建的文档内的书签。</li><li>超链接可以是文本，也可以是图像。</li><li>target=”_blank”，属性可以用来在新的文档中打开。</li></ul><h3 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h3><ul><li><code>&lt;img src=&quot;boat.gif&quot; alt=&quot;Big Boat&quot;&gt;</code></li><li>属性align=”bottom” “top” “middle” “left” “right”</li><li>属性width,height </li><li><p>map area</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">map</span> <span class="attr">name</span>=<span class="string">"planetmap"</span> <span class="attr">id</span>=<span class="string">"planetmap"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">area</span></span></span><br><span class="line"><span class="tag">  <span class="attr">shape</span>=<span class="string">"circle"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">coords</span>=<span class="string">"180,139,14"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">href</span>=<span class="string">"/example/html/venus.html"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">target</span>=<span class="string">"_blank"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">alt</span>=<span class="string">"Venus"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">area</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><ul><li><code>&lt;table&gt;&lt;/table&gt;</code> :border bgcolor background frame=”above” “box” “hsizes”</li><li>tr(table row)</li><li>td(table data) &amp;nbsp</li><li>th(table head)</li><li>caption</li><li>cellpadding</li><li>cellspacing</li></ul><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ul><li>无序列表<code>&lt;ul&gt;:&lt;li&gt;</code> 属性type=”circle” “square” “disc”</li><li>有序列表<code>&lt;ol&gt;</code>属性type=”A” “a” “I” “i”</li><li>定义列表dl,<code>&lt;dt&gt;</code>定义项目<code>&lt;dd&gt;</code>定义描述。</li></ul><h2 id="块与布局"><a href="#块与布局" class="headerlink" title="块与布局"></a>块与布局</h2><h3 id="块"><a href="#块" class="headerlink" title="块"></a>块</h3><ul><li>通过<code>&lt;div&gt;</code>与<code>&lt;span&gt;</code>将HTML元素组合起来。</li><li><p>块元素其实是模块化思想的结果。同CSS一起使用,<code>&lt;div&gt;</code>元素可以用于对大的内容块设置样式属性。另一个常见的用途是文档布局，它取代了使用表格定义布局的老式方法。 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"color:#00ff00"</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>&lt;span&gt;</code>更多的是对行内的进行修改。如注：这种情况。</p></li></ul><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul><li>对块进行分类，使我们能为元素的类定义CSS样式。</li><li>div标签的class = “cities”属性</li></ul><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><ul><li><code>&lt;div&gt;</code>元素用作布局，并能轻松通过CSS对其进行定位。</li><li>在head元素中的<code>&lt;style&gt;</code>元素来定义各个类的颜色、位置等信息。</li><li>在body元素中使用定义的类来显示内容。</li><li>header,footer,nav,section</li></ul><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><h3 id="响应式设计RWD"><a href="#响应式设计RWD" class="headerlink" title="响应式设计RWD"></a>响应式设计RWD</h3><ul><li>RWD能够以可变尺寸传递网页，对于平板和移动设备是必须的。</li><li>使用现成的CSS框架，Bootstrap。</li><li>meta charset=”utf-8”</li><li><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;http://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css&quot;&gt;</code></li><li>link之后可以在div中使用类”container”,”jumbotron”,”row”,”col-md-4”等属性来控制样式。</li></ul><h3 id="frame"><a href="#frame" class="headerlink" title="frame"></a>frame</h3><ul><li>所谓框架，就是在一个页面中，使用一定的布局来显示多个html文档</li><li>frameset标签</li><li>rows/columns属性，规定了每行或者每列的占屏比例。</li><li><code>&lt;frame src=&quot;frame_a.html&quot; noresize=&quot;noresize&quot;&gt;</code></li></ul><h3 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h3><p>可以在body元素中使用，并可通过name属性命名，可通过target=””来选择内联框架使用。类似于”_blank”</p><h2 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h2><ul><li>类似于C语言中的\作用，转义：<ul><li>空格   &amp;nbsp</li><li><code>&lt;</code>   &amp;lt</li><li><code>&gt;</code>   &amp;gt</li><li><code>&amp;</code>   &amp;amp</li><li><code>&quot;</code>   &amp;quot</li><li><code>*</code>   &amp;times</li><li><code>/</code>  &amp;divides</li></ul></li></ul><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><h3 id="form"><a href="#form" class="headerlink" title="form"></a>form</h3><p>  <code>&lt;form&gt;</code>表单用于收集用户的输入</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">.</span><br><span class="line">表单元素</span><br><span class="line">.</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  表单元素指的是不同类型的输入元素、复选框、单选按钮、提交按钮等等。</p><h3 id="input"><a href="#input" class="headerlink" title="input"></a>input</h3><ul><li><p>type</p><p>| 类型      | 描述              |<br>| -        | -:                |<br>| text     | 定义常规文本输入     |<br>| radio    | 单选按钮            |<br>| checkbox | 复选框             |<br>| button   | 按钮，响应onclick   |<br>| submit   | 提交按钮           |<br>| password | 字符会被做掩码处理  |<br>| file     | 上传文档          |<br>| image    | 上传图片          |<br>| email    | html5增加，检查@   |<br>| number   | html5增加，检查数字 |<br>| range    | html5增加，滑动块   |<br>| date     | html5增加，日期     |<br>| datetime | html5增加，日期时间 |<br>| color    | html5增加，颜色 |<br>| url      | html5增加，url |</p></li></ul><pre><code><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">name</span>=<span class="string">"points"</span> <span class="attr">min</span>=<span class="string">"0"</span> <span class="attr">max</span>=<span class="string">"10"</span> <span class="attr">step</span>=<span class="string">"3"</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"male"</span> <span class="attr">checked</span>&gt;</span>Male</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"female"</span>&gt;</span>Female</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"alert('Hello World!')"</span> <span class="attr">value</span>=<span class="string">"Click Me!"</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">Birthday:</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"date"</span> <span class="attr">name</span>=<span class="string">"bday"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></code></pre><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>  下拉框</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"cars"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"volvo"</span>&gt;</span>Volvo<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"saab"</span>&gt;</span>Saab<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"fiat"</span>&gt;</span>Fiat<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"audi"</span>&gt;</span>Audi<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="textarea"><a href="#textarea" class="headerlink" title="textarea"></a>textarea</h3><p>  多行输入</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">"message"</span> <span class="attr">rows</span>=<span class="string">"10"</span> <span class="attr">cols</span>=<span class="string">"30"</span>&gt;</span></span><br><span class="line">The cat was playing in the garden.</span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="datalist"><a href="#datalist" class="headerlink" title="datalist"></a>datalist</h3><p>  datalist也是下拉框，但可以输入数据，可以看到预设的option</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"action_page.php"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">list</span>=<span class="string">"browsers"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">"browsers"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Internet Explorer"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Firefox"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Chrome"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li><p>autocomplete</p><p>表单的记忆功能，对input与form都有效，与private类似，父标签声明对子标签有用，子标签的声明大于的声明。</p></li><li><p>autofocus</p><p>自定义焦点，对于input可能会更有用一些。</p></li><li><p>表单的form属性</p><p>实现了在form外声明表单的可能。</p></li><li><p>formaction属性</p><p>为submit标签，提供了，重载action的方法。</p></li><li><p>list属性</p><ul><li>规定输入域的datalist（选项列表） </li><li>list=”url_list”</li><li><code>&lt;datalist id=&quot;url_list&quot;&gt;</code></li></ul></li><li><p>multiple属性</p><ul><li>规定输入框中可以选择多个值</li><li><code>&lt;input type=&quot;file&quot; name=&quot;img&quot; multiple=&quot;multiple&quot; /&gt;</code></li></ul></li><li><p>novalidate属性</p><ul><li>novalidate属性规定在提交表单时不应该验证form或input域</li><li><code>&lt;form action=&quot;demo_form.asp&quot; method=&quot;get&quot; novalidate=&quot;true&quot;&gt;</code></li><li>在这种情况下，type=”email”时就不再验证@</li></ul></li><li><p>pattern属性</p><ul><li>用于验证ipnut域的模式，正则表达式</li><li><code>&lt;input type=&quot;text&quot; name=&quot;country_code&quot; pattern=&quot;[A-Z]{3}&quot; title=&quot;three letter country code&quot; /&gt;</code></li></ul></li><li><p>placeholder</p><ul><li>属性提供一种提示，描述输入域所期待的值</li><li><code>&lt;input type=&quot;search&quot; name=&quot;user_search&quot; placeholder=&quot;Search W3School&quot; /&gt;</code></li></ul></li><li><p>required</p><ul><li>required属性规定必须在提交之前写输入域（不能为空）</li><li><code>&lt;input type=&quot;text&quot; name=&quot;usr_name&quot; required=&quot;required&quot; /&gt;</code></li></ul></li></ul><h1 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li>RIA技术</li><li>服务器、浏览器的交互历史：文本、图片、声音、动画、可交互游戏、游戏</li><li>flex、sliverlight、flash、html5</li></ul><h3 id="发展简史"><a href="#发展简史" class="headerlink" title="发展简史"></a>发展简史</h3><ul><li>html1.0 (1993) </li><li>html 2.0 (1994) </li><li>html4.0(1999),使用最多。</li><li>w3c组织–&gt; xhtml –&gt; xhtml2.0 (xml标准)这个版本被主流浏览器公司有意见</li><li>主流浏览器厂商组织WHATGW，2004年提出html5.0草案 –&gt; 合并成一个2008年提出html5.0</li></ul><h3 id="HTML5-约等于-HTML-CSS3-Javascript-APIs"><a href="#HTML5-约等于-HTML-CSS3-Javascript-APIs" class="headerlink" title="HTML5 约等于 HTML+CSS3+Javascript APIs"></a>HTML5 约等于 HTML+CSS3+Javascript APIs</h3><ul><li><p>HTML5支持了Css3的强大的选择器和动画等功能， 再加上支持了Javascript的新的函数API，所以就很强大了。</p></li><li><p>chrome、firefox、opera；UC、QQ、百度等</p></li></ul><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li><p>增加了<code>&lt;header&gt;&lt;footer&gt;</code>标签，做到内容与结构分离，我们很多网页都有头和尾</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span>网页的头部<span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">hell,world</span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span>网页的尾部<span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>增加了<code>&lt;canvas&gt;</code>标签，画布标签，程序员可以在这里绘制图形，在一定程度上可替代flash</p></li><li><p>增加了<code>&lt;video&gt;</code> 和 <code>&lt;audio&gt;</code>标签，用于音频和视频的嵌入功能<br>使视频与音频的嵌入变得简单<br>1、这里的video支持ogg格式与mp4格式<br>2、如果把这个html5_2.html放在apache下，就可以看这个视频。</p></li><li><p>增加离线存储功能</p></li></ul><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">width</span>=<span class="string">"320"</span> <span class="attr">height</span>=<span class="string">"240"</span> <span class="attr">controls</span>=<span class="string">"controls"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"/i/movie.ogg"</span> <span class="attr">type</span>=<span class="string">"video/ogg"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>video的属性包括</p><ul><li>autoplay </li><li>controls</li><li>height/width</li><li>loop</li><li>preload</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span>=<span class="string">"controls"</span> <span class="attr">autoplay</span>=<span class="string">"autoplay"</span> <span class="attr">loop</span>=<span class="string">"loop"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>video + dom 进行控制</p><ul><li><p><code>&lt;video&gt;</code>元素同样拥有方法、属性和事件。<br>方法用于播放、暂停以及加载等。<br>属性（时长、音量等）可以被读取或设置<br>其中的DOM事件能够通知您，如<code>&lt;video&gt;</code>元素开始播放、已暂停、已停止等。</p></li><li><p>示例：<br>先用<code>&lt;div&gt;</code>画出<code>&lt;button&gt;</code>与<code>&lt;video&gt;</code>，在<code>&lt;button&gt;</code>中指定槽函数<br>然后用<code>&lt;script&gt;</code>脚本，来获取到<code>&lt;video&gt;</code>元素，在槽函数的实现中，完成对<code>&lt;video&gt;</code>的控制如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"playPause()"</span>&gt;</span>播放/暂停<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"makeBigger"</span>&gt;</span>大<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"makeSmaller"</span>&gt;</span>小<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">video</span> <span class="attr">id</span>=<span class="string">"v1"</span> <span class="attr">controls</span>=<span class="string">"controls"</span> <span class="attr">width</span>=<span class="string">"400"</span> <span class="attr">heigh</span>=<span class="string">"400"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"/example/html5/move.bbb.mp4"</span> <span class="attr">type</span>=<span class="string">"video/mp4"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> testVedio = <span class="built_in">document</span>.getElementById(<span class="string">"v1"</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">playPause</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="undefined">  &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span>(testVedio.paused)</span></span><br><span class="line"><span class="undefined">    testVedio.play();</span></span><br><span class="line"><span class="javascript">  <span class="keyword">else</span></span></span><br><span class="line"><span class="undefined">    testVedio.pause();</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">makeBigger</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="undefined">  &#123;</span></span><br><span class="line"><span class="undefined">    testVedio.width += 20;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">makeSmaller</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="undefined">  &#123;</span></span><br><span class="line"><span class="undefined">    testVedio.width -= 20;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">scipt</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>总结：先用<code>&lt;div&gt;</code>将控件、视频等画出，在通过<code>&lt;script&gt;</code>将使用的函数实现。类似于C的全局实现</p></li><li><p>方法、属性以及事件<br>方法：play()、pause()、load()<br>  属性：paused、height、width、muted、volume、ended；可以通过对属性的控制来实现方法的控制。可以都认为是public<br>  事件：play/pause/ended等等。</p></li></ul></li></ul><h3 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h3><ul><li><p>示例1</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">"song.ogg"</span> <span class="attr">controls</span>=<span class="string">"controls"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>示例2</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>=<span class="string">"controls"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"song.ogg"</span> <span class="attr">type</span>=<span class="string">"audio/ogg"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"song.mp3"</span> <span class="attr">type</span>=<span class="string">"audio/mp3"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;audio&gt;</code>元素允许有多个source。source元素可以链接不同的音频文件。浏览器将使用第一个可视频的格式。</p></li><li><p>标签属性</p><p>与视频相同属性包括：controls/autoplay/loop/preload<br>还包括一种src</p></li></ul><h3 id="画布"><a href="#画布" class="headerlink" title="画布"></a>画布</h3><p> <code>&lt;canvas&gt;</code>使用JavaScript在网页上绘制图像。画图是一个矩形区域，您可以控制其每一个像素。canvas拥有每种绘制路径、矩形、圆形、字符以及添加图像的方法。</p><ul><li><p>基本运用</p><ul><li><p>创建Canvas元素 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"myCanvas"</span> <span class="attr">width</span>=<span class="string">"200"</span> <span class="attr">height</span>=<span class="string">"100"</span> <span class="attr">style</span>=<span class="string">"border:1px solid #c3c3c3;"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>通过JavaScript来绘制</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javacript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> c=<span class="built_in">document</span>.getElementById(<span class="string">"myCanvas"</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> cxt=c.getContext(<span class="string">"2d"</span>);</span></span><br><span class="line"><span class="javascript">cxt.fillStyle = <span class="string">"#FF0000"</span>;</span></span><br><span class="line"><span class="undefined">cxt.fillRect(0,0,150,75);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Javascript的绘制函数</p><ul><li><p>直线</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cxt.moveTo(10,10);   //移动到起始位置</span><br><span class="line">cxt.lineTo(150,50);  //画线到（150，50）</span><br><span class="line">cxt.lineTo(10,50);   //从(150,10),画到(10,50)</span><br><span class="line">cxt.stroke();</span><br></pre></td></tr></table></figure></li><li><p>画圆</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cxt.fillStyle="#FF0000";</span><br><span class="line">cxt.beginPath();</span><br><span class="line">cxt.arc(70,18,15,0,Math.PI*2,true);  // 圆心（70，18）半径15</span><br><span class="line">cxt.closePath();</span><br><span class="line">cxt.fill();    // 与stroke()等类似</span><br></pre></td></tr></table></figure></li><li><p>渐变色</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var grd=cxt.createLinearGradient(0,0,175,50);  //创建线性梯度/斜率</span><br><span class="line">grd.addColorStop(0, "#FF0000");  </span><br><span class="line">grd.addColorStop(1, "#00FF00");  // 从红色到绿色的渐进</span><br><span class="line">cxt.fillStyle=grd;</span><br><span class="line">cxt.fillRect(0,0,170,50);</span><br></pre></td></tr></table></figure></li><li><p>图像</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var img=new Image();</span><br><span class="line">img.src="flower.png";</span><br><span class="line">cxt.drawImage(img,0,0);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h3><ul><li><p>基本概念</p><ul><li>SVG可伸缩矢量图形(Scalable Vector Graphics)</li><li>用于定义网络的基于矢量的图形</li><li>使用XML格式定义图形</li><li>图像在放大或者缩小时，图形质量不会有损失</li></ul></li><li><p>优势</p><ul><li>可通过文本编辑器来创建和修改</li><li>在任何分辨率下被高质量的打印，在图像质量不下降的情况下放大。</li></ul></li><li><p>实例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/2000/svg"</span> <span class="attr">version</span>=<span class="string">"1.1"</span> <span class="attr">height</span>=<span class="string">"190"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">polygon</span> <span class="attr">points</span>=<span class="string">"100,40 40,180 190,60 10,60 160,180"</span> </span></span><br><span class="line"><span class="tag">               <span class="attr">style</span>=<span class="string">"fill:red;stroke:blue;stroke-width:3;fill-rule:evenodd;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>说明<br>// 画多边形，从一个点到另一个点</p><p>// 动词fill为填充，stroke为线</p></li><li><p>SVG VS 画布</p><ul><li><p>Canvas</p><ul><li>依赖分辨率</li><li>不支持事件处理器</li><li>弱的文本渲染能力</li><li>最适合图像密集型游戏，其中的许多对象会被频繁重绘</li></ul></li><li><p>SVG</p><ul><li>不依赖分辨率</li><li>支持事件处理器</li><li>最适合带有大型渲染区域的应用（谷歌地图）</li><li>复杂度高会减慢渲染速度</li><li>不适合游戏应用，（由于复杂度高，频繁重绘效率低下）</li></ul></li></ul></li></ul><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="地理定位"><a href="#地理定位" class="headerlink" title="地理定位"></a>地理定位</h3><ul><li><p>简介</p><p>地理定位使用navigator.geolocation.getCurrentPosition();函数来实现</p><p>航海家.地理位置.获取当前坐标。可以传递函数作为参数。</p></li><li><p>实例</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span>点击这个按钮，获得您的坐标：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"getLocation()"</span>&gt;</span>试一下<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> x=<span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">getLocation</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="undefined">&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">if</span> (navigator.geolocation)</span></span><br><span class="line"><span class="undefined">    &#123;</span></span><br><span class="line"><span class="undefined">    navigator.geolocation.getCurrentPosition(showPosition,showError);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">else</span>&#123;x.innerHTML=<span class="string">"Geolocation is not supported by this browser."</span>;&#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">showPosition</span>(<span class="params">position</span>)</span></span></span><br><span class="line"><span class="undefined">&#123;</span></span><br><span class="line"><span class="javascript">  x.innerHTML=<span class="string">"Latitude: "</span> + position.coords.latitude + </span></span><br><span class="line"><span class="javascript">  <span class="string">"&lt;br /&gt;Longitude: "</span> + position.coords.longitude;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">showError</span>(<span class="params">error</span>)</span></span></span><br><span class="line"><span class="undefined">&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">switch</span>(error.code) </span></span><br><span class="line"><span class="undefined">    &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">case</span> error.PERMISSION_DENIED:</span></span><br><span class="line"><span class="javascript">      x.innerHTML=<span class="string">"User denied the request for Geolocation."</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">case</span> error.POSITION_UNAVAILABLE:</span></span><br><span class="line"><span class="javascript">      x.innerHTML=<span class="string">"Location information is unavailable."</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">case</span> error.TIMEOUT:</span></span><br><span class="line"><span class="javascript">      x.innerHTML=<span class="string">"The request to get user location timed out."</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">case</span> error.UNKNOWN_ERROR:</span></span><br><span class="line"><span class="javascript">      x.innerHTML=<span class="string">"An unknown error occurred."</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">break</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>getCurrentPosition()方法</p><p>若成功是重返回纬度(latitude)经度(longitude)以及(accuracy)</p><p>  coords.latitude（纬度）</p><p>  coords.longitude（经度）</p><p>  coords.accuracy（经纬的精度）</p><p>  coords.altitude（海拔）</p><p>  coords.altitudeAccuracy(海拔精度)</p><p>  coords.heading（方向）</p><p>  coords.speed(速度）</p><p>  timestamp:时间戳</p></li></ul><h3 id="Web存储"><a href="#Web存储" class="headerlink" title="Web存储"></a>Web存储</h3><ul><li><p>简介</p><ul><li><p>HTML5提供两种客户端存储数据的方法：</p><p>localStorage：永久的存储</p><p>sessionStorage：基于会话的存储</p></li><li><p>对于不同网站，数据存储于不同区域，一个网站只能访问其自身的数据</p></li><li><p>HTML5使用Javascript来存储和访问数据。</p></li></ul></li><li><p>localStorage</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span>(localStorage.pagecount)</span></span><br><span class="line"><span class="undefined">&#123;</span></span><br><span class="line"><span class="javascript">    localStorage.pagecount = <span class="built_in">Number</span>(localStorage.pagecount)+<span class="number">1</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">else</span></span></span><br><span class="line"><span class="undefined">&#123;</span></span><br><span class="line"><span class="undefined">    localStorage.pagecount = 1;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="javascript">documents.write(<span class="string">"visits:"</span> + localStorage.pagecount + <span class="string">"times."</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>sessionStorage</p><p>sessionStorage与lacalStorage类似用法，只不过在关闭网页后，数据清空</p></li></ul><h3 id="应用存储"><a href="#应用存储" class="headerlink" title="应用存储"></a>应用存储</h3><ul><li><p>简介</p><ul><li><p>HTML5引入了应用程序缓存，应用可以从服务端缓存数据，在没有网络连接时，也可进行访问。</p></li><li><p>优势：</p><p>离线浏览</p><p>速度更快</p><p>减少服务器负载，浏览器只从服务器下载更新过的资源即可。</p></li></ul></li><li><p>实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html manifest=&quot;demo.appache&quot;&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p>Cache Manifest基础</p><ul><li>如需启动应用缓存，在<code>&lt;html&gt;</code>标签中包含manifest属性，并指定manifest文件，扩展 名为 .appache</li><li>浏览器根据manifest文件，对内容进行缓存</li></ul></li><li><p>Manifest文件</p><p>三部分：</p><p>  CACHE MANIFEST:首次打开后进行缓存</p><p>  NETWORK:必须联网，不缓存</p><p>  FALLBACK:断网时的回退界面</p></li><li><p>实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line"># 注释2012-02-21 v1.0.0</span><br><span class="line">/theme.css</span><br><span class="line">/logo.gif</span><br><span class="line">/main.js</span><br><span class="line"></span><br><span class="line">NETWORK:</span><br><span class="line">login.asp</span><br><span class="line"></span><br><span class="line">FALLBACK:</span><br><span class="line">/html5/ /404.html</span><br></pre></td></tr></table></figure></li></ul><h3 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h3><ul><li><p>简介</p><ul><li>当在HTML执行脚本是，页面的状态是堵塞的，知道脚本执行完成</li><li>web worker 是运行在后台的JavaScript，独立与其他脚本，不堵塞（多线程）</li></ul></li><li><p>实例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>计数：<span class="tag">&lt;<span class="name">output</span> <span class="attr">id</span>=<span class="string">"result"</span>&gt;</span><span class="tag">&lt;/<span class="name">output</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"startWorker()"</span>&gt;</span>开始Worker<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"stopWorker()"</span>&gt;</span>开始Worker<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> w;  <span class="comment">// 在此处直接定义会是定时技术延迟3个500ms</span></span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">startWorker</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="undefined">    &#123;</span></span><br><span class="line"><span class="undefined">      # 注意是否支持Woker</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span>(<span class="keyword">typeof</span>(Worker)!=<span class="string">"undefined"</span>)</span></span><br><span class="line"><span class="undefined">      &#123;</span></span><br><span class="line"><span class="undefined">      # 判断变量是否定义</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(<span class="keyword">typeof</span>(w)==<span class="string">"undefined"</span>)</span></span><br><span class="line"><span class="undefined">        &#123;</span></span><br><span class="line"><span class="undefined">          # 创建worker</span></span><br><span class="line"><span class="javascript">          w=<span class="keyword">new</span> Worker(<span class="string">"/example/html5/demo_workers.js"</span>);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        # 相应消息，注意function的写法</span></span><br><span class="line"><span class="javascript">        w.onMessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span></span></span><br><span class="line"><span class="undefined">        &#123;</span></span><br><span class="line"><span class="undefined">          # 注意内容的展示</span></span><br><span class="line"><span class="javascript">          <span class="built_in">document</span>.getElementeById(<span class="string">"result"</span>).innerHTML=event.data;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">"result"</span>).innerHTML=<span class="string">"您的浏览器不支持Worker"</span></span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">stopWorker</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="undefined">    &#123;</span></span><br><span class="line"><span class="undefined">      # 停止worker</span></span><br><span class="line"><span class="undefined">      w.terminate();</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>demo_workers.js的内容如下</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeCount</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  i=i+<span class="number">1</span>;</span><br><span class="line">  # 注意消息的发送</span><br><span class="line">  postMessage(i);</span><br><span class="line">  setTimeOut(<span class="string">"timeCount()"</span>, <span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line">timeCount();</span><br></pre></td></tr></table></figure></li><li><p>注意</p><p>由于worker存在与外部文件中，它无法访问一下的javascript对象</p><p>window对象</p><p>  document对象</p><p>  parent对象</p></li></ul><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><ul><li><p>简介</p><p>Server-Sent事件-单向消息传递</p><p>Server-Sent事件指的是网页自动获取来自服务器的更新。</p><p>  之前的做法是网页轮询是否有更新。但通过服务器发送事件，更新能自动到达</p></li><li><p>实例</p><ul><li><p>客户端</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;h1&gt;获取服务器更新&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">  &lt;div id="result"&gt;&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span>(EventSource)!==<span class="string">"undefined"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">var</span> source = <span class="keyword">new</span> EventSource(<span class="string">"/example/html5/demo_sse.php"</span>);</span><br><span class="line">      source.onmessage=<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">"result"</span>).innerHTML=event.data + <span class="string">"&lt;br /&gt;"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">"result"</span>).innerHTML=<span class="string">"您的浏览器不支持server-sent"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>服务端</p></li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">header(<span class="string">'Content-Type: text/event-stream'</span>);</span><br><span class="line">header(<span class="string">'Cache-Control: no-cache'</span>);</span><br><span class="line"></span><br><span class="line">$time = date(<span class="string">'r'</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"data: The server time is: &#123;$time&#125;\n\n"</span>;</span><br><span class="line">flush();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>疑问</p><p>在EventSource中已经定义了服务器脚本的存在，那岂不是在客户端自己这就可以产生此技术？</p><p>服务器的运行时怎样实现的？</p></li></ul></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>【控件】HTML的学习类似与Qt的学习，首先需要学习的是各个控件的使用，包括：按钮/输出/音频/视频/画布/SVG、地理定位/客户端存储/应用缓存/worker，还要学习各种表单的使用、表格/输入类型：下拉框/输入框，输入框的属性：自动完成、自动foucus、 属性提示、唯一性提示、多属性、不检查有效性等等。</li><li>【布局】除了部件的学习，还有布局的学习，布局大约使用CSS，可以等到CSS时深入学习</li><li>【操作】学习用JavaScript来实现槽函数的控制</li><li>【方式】对于前端、后端结构的理解</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要整理了html，html5&lt;/p&gt;
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>npm源修改</title>
    <link href="http://yoursite.com/2018/08/28/npm%E6%BA%90%E4%BF%AE%E6%94%B9/"/>
    <id>http://yoursite.com/2018/08/28/npm源修改/</id>
    <published>2018-08-28T10:11:05.000Z</published>
    <updated>2019-02-15T08:01:26.510Z</updated>
    
    <content type="html"><![CDATA[<p>npm安装模块，修改npm源</p><a id="more"></a><h2 id="修改代理"><a href="#修改代理" class="headerlink" title="修改代理"></a>修改代理</h2><p><code>npm --proxy http://server:port install browserfiy</code></p><h2 id="修改镜像"><a href="#修改镜像" class="headerlink" title="修改镜像"></a>修改镜像</h2><ul><li><p>命令行<br><code>npm --registry https://registry.npm.taobao.org install browserify</code></p></li><li><p>config<br><code>npm config set registry https://registry.npm.taobao.org</code></p><p><code>npm config list</code></p></li><li><p>~/.npmrc文件<br><code>registry = https://registry.npm.taobao.org</code></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;npm安装模块，修改npm源&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="npm" scheme="http://yoursite.com/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>k8s简介</title>
    <link href="http://yoursite.com/2018/08/28/2018-8-28k8s%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2018/08/28/2018-8-28k8s简介/</id>
    <published>2018-08-28T09:01:37.000Z</published>
    <updated>2019-02-15T08:01:26.574Z</updated>
    
    <content type="html"><![CDATA[<p>本篇简介了k8s，是对k8s官方文档的摘要</p><a id="more"></a><h1 id="k8s架构"><a href="#k8s架构" class="headerlink" title="k8s架构"></a>k8s架构</h1><p><img src="k8s架构.png" alt="k8s架构图"></p><p><a href="https://kubernetes.io/docs/concepts/" target="_blank" rel="noopener">k8s官方文档</a></p><h2 id="Master-Components"><a href="#Master-Components" class="headerlink" title="Master Components"></a>Master Components</h2><ul><li><p>kube-apiserver<br>k8s的前端， 向外界暴露Kubernates API</p></li><li><p>etcd<br>高可用的key-value存储，用于保存所有集群数据。</p></li><li><p>kube-scheduler<br>监视新创建的、还没有分配node的pods，并选择一个node去运行。<br>调度时考虑的因素包括： 单个及集合的资源需要、软硬件策略的限制、数据本地性等等</p></li><li><p>kube-controller-manager<br>master中运行controller的部分。逻辑上，每一个controller都是独立的进程，但为了降低复杂度，他们被编译进一个二进制文件、运行在一个进程里。</p></li></ul><table><thead><tr><th>cotroller</th><th style="text-align:right">作用</th></tr></thead><tbody><tr><td>Node Controller</td><td style="text-align:right">负责发现、响应node下线</td></tr><tr><td>Replication Controller</td><td style="text-align:right">按replication controller对象的设置，维护正确数量的pod</td></tr><tr><td>Endpoints Controller</td><td style="text-align:right">填入Endpoint对象，意味着连接Service与Pod</td></tr><tr><td>Service Account&amp;Token Controllers</td><td style="text-align:right">为一个新的namespace, 创建默认账户以及API access tokens</td></tr></tbody></table><ul><li><p>cloud-controller-manager（CCM）<br>cloud-controller-manager（CCM）是kubernets 1.6发布的功能，它主要运行与基础云提供着相关的controller。而这些controller以前是在kube-controller-manager(KCM)中。现在，我们需要在KCM中失能相关的controller。</p><p>早期版本中,k8s核心代码依赖于云提供者， CCM的出现使云提供者代码与k8s代码解耦。</p><p>CCM主要运行以下Controller(依赖于云提供者)</p></li></ul><table><thead><tr><th>controller</th><th style="text-align:right">作用</th></tr></thead><tbody><tr><td>Node Controller</td><td style="text-align:right">当node停止响应后，检查云提供者，node是否已经删除</td></tr><tr><td>Router Controller</td><td style="text-align:right">在基础的云设施中，建立路由</td></tr><tr><td></td></tr></tbody></table><h2 id="Node-Components"><a href="#Node-Components" class="headerlink" title="Node Components"></a>Node Components</h2><ul><li>kubelet</li><li>kube-proxy</li><li>container runtime</li></ul><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>  k8s包含一些可以代表当前系统状态的抽象，比如部署容器化的应用和工作符合（workloads），与网络及硬件资源的联系等等，这些抽象被定义成了api的对象，这些对象可以分成2部分：基本对象与控制对象（Controllers）</p><ul><li><p>基本对象：</p><ul><li>Pod</li><li>Service</li><li>Volume</li><li>Namespace</li></ul></li><li><p>控制对象：</p><ul><li>ReplicaSet</li><li>Deployment</li><li>StatefulSet</li><li>Job</li></ul></li></ul><h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇简介了k8s，是对k8s官方文档的摘要&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>docker基础</title>
    <link href="http://yoursite.com/2018/08/28/2018-8-28docker%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/08/28/2018-8-28docker基础/</id>
    <published>2018-08-28T07:56:35.000Z</published>
    <updated>2019-02-15T08:01:26.574Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.docker.com/get-started/" target="_blank" rel="noopener"></a><br>本文内容从docker官方文档摘抄，仅介绍基础概念，将与swarm相关的service、stack都没载入<br><a id="more"></a></p><h1 id="Docker基础"><a href="#Docker基础" class="headerlink" title="Docker基础"></a>Docker基础</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><p>image 与 container<br>A container is launched by running an image. An image is an executable package that includes everything needed to run an application–the code, a runtime, libraries, environment variables, and configuration files.<br>容器就是跑镜像的，镜像包括了程序运行的所有资源,包括代码，运行时，lib，环境变量，配置文件等</p></li><li><p>container 与 docker<br><img src="docker结构.png" alt="docker结构"><br>容器跑在docker上，每个容器之间相互独立。docker运行在host os之上</p><p><img src="纵观docker.png" alt="纵观docker"></p><p><img src="docker工作流程.png" alt="docker工作流程"></p></li></ul><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li><p>docker帮助<br>docker<br>docker COMMAND –help<br>docker container –help</p></li><li><p>docker版本<br>docker –version</p></li><li><p>docker的信息<br>docker info<br>列出docker的基本信息，包括Container状态，image个数等</p></li><li><p>运行image<br>docker run hello-world</p></li><li><p>列出image<br>docker image ls</p></li><li><p>列出container<br>docker container ls        # running<br>docker container ls –all  # all<br>docker container ls -aq    # all in quiet mode</p></li><li><p>列出云节点[对于swarms]<br>docker node ls</p></li><li><p>列出所有服务[对于swarms]<br>docker service ls</p></li><li><p>查看某个服务具体信息[对于swarms]<br> docker service ps 服务id</p></li></ul><h2 id="containers"><a href="#containers" class="headerlink" title="containers"></a>containers</h2><ul><li><p>层级结构<br>Container(底层)<br>Services: 定义container的行为[defines how containers behave in production]<br>Stack:  定义service的相互作用[defines the interacions of all the services]</p></li><li><p>Dockerfile</p><ol><li>映射容器内的资源与容器外的，如端口，磁盘等</li><li>指明需要从外部环境中copy到容器的文件</li></ol><p>创建一空目录，然后在里边创建一Dockerfile格式如下：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 引用一个官方的python镜像 Use an official Python runtime as a parent image</span><br><span class="line">FROM python:2.7-slim</span><br><span class="line"></span><br><span class="line"># 设置工作目录</span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"># 将当前目录copy到容器的/app下</span><br><span class="line">ADD . /app</span><br><span class="line"></span><br><span class="line"># 在容器内安装需要的包 Install any needed packages specified in requirements.txt</span><br><span class="line">RUN pip install --trusted-host pypi.python.org -r requirements.txt</span><br><span class="line"></span><br><span class="line"># 容器内暴露的虚拟端口80 </span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line"># 环境变量 </span><br><span class="line">ENV NAME World</span><br><span class="line"></span><br><span class="line"># 启动容器时运行命令 </span><br><span class="line">CMD [&quot;python&quot;, &quot;app.py&quot;]</span><br></pre></td></tr></table></figure><ul><li><p>app<br>在Dockerfile同级目录下创建2个文件，requirements.txt以及app.py.<br>其中requirements.txt是依赖包，而app.py可以拓展为应用代码<br>这样在Dockerfile被创建为image时，requirements.txt，以及app.py都会被copy到容器内部，由于ADD . /app命令，同时，也可以用80来访问了。<br>pip  install -r requirements.txt只是为python安装了Flask与Redis库，redis本身并没有运行。</p><p>requirements.txt  #依赖包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Flask </span><br><span class="line">Redis</span><br></pre></td></tr></table></figure><p>app.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">from redis import Redis, RedisError</span><br><span class="line">import os</span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line"># Connect to Redis</span><br><span class="line">redis = Redis(host=&quot;redis&quot;, db=0, socket_connect_timeout=2, socket_timeout=2)</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&quot;/&quot;)</span><br><span class="line">def hello():</span><br><span class="line">    try:</span><br><span class="line">        visits = redis.incr(&quot;counter&quot;)</span><br><span class="line">    except RedisError:</span><br><span class="line">        visits = &quot;&lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;&quot;</span><br><span class="line"></span><br><span class="line">    html = &quot;&lt;h3&gt;Hello &#123;name&#125;!&lt;/h3&gt;&quot; \</span><br><span class="line">           &quot;&lt;b&gt;Hostname:&lt;/b&gt; &#123;hostname&#125;&lt;br/&gt;&quot; \</span><br><span class="line">           &quot;&lt;b&gt;Visits:&lt;/b&gt; &#123;visits&#125;&quot;</span><br><span class="line">    return html.format(name=os.getenv(&quot;NAME&quot;, &quot;world&quot;), hostname=socket.gethostname(), visits=visits)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    app.run(host=&apos;0.0.0.0&apos;, port=80)</span><br></pre></td></tr></table></figure></li><li><p>构建app镜像<br>在同目录下执行：<br>docker build -t firendlshello </p></li><li><p>查看镜像<br>docker image ls</p></li><li><p>运行镜像<br>docker run -p 4000:80 friendlyhello<br>这样在外部需要用4000来访问，<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></p></li><li><p>查看运行中的container<br>docker container ls</p></li><li><p>停止container<br>docker container stop “CONTATINER ID”</p></li><li><p>分享镜像[暂时略过]<br>类似于github，有个dockerhub，可以通过docker push 来上传镜像</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://docs.docker.com/get-started/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;/a&gt;&lt;br&gt;本文内容从docker官方文档摘抄，仅介绍基础概念，将与swarm相关的service、stack都没载入&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>git配置</title>
    <link href="http://yoursite.com/2018/08/28/2018-8-28git%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/08/28/2018-8-28git配置/</id>
    <published>2018-08-28T04:02:35.000Z</published>
    <updated>2019-02-15T08:01:26.574Z</updated>
    
    <content type="html"><![CDATA[<p>主要就是git的配置，包括代理、多个git账户使用配置。</p><a id="more"></a><h1 id="git代理"><a href="#git代理" class="headerlink" title="git代理"></a>git代理</h1><h2 id="启动代理"><a href="#启动代理" class="headerlink" title="启动代理"></a>启动代理</h2><h2 id="http方式设置"><a href="#http方式设置" class="headerlink" title="http方式设置"></a>http方式设置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global https.proxy http://127.0.0.1:1080</span><br><span class="line">git config --global https.proxy https://127.0.0.1:1080</span><br></pre></td></tr></table></figure><p>其他设置（待验证）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy socks5://127.0.0.1:1080</span><br><span class="line">git config --global https.proxy socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure></p><h2 id="取消http设置"><a href="#取消http设置" class="headerlink" title="取消http设置"></a>取消http设置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure><h2 id="ssh方式设置"><a href="#ssh方式设置" class="headerlink" title="ssh方式设置"></a>ssh方式设置</h2><p>使用 <a href="mailto:git@xxoo.com" target="_blank" rel="noopener">git@xxoo.com</a> 这种方式，是用的 SSH 协议。需要在 ~/.ssh/config 目录下配置<br>Host xxoo.com(改成你的站点)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ProxyCommand connect -H 127.0.0.1:1080 %h %p</span><br></pre></td></tr></table></figure></p><h1 id="多个git账户使用"><a href="#多个git账户使用" class="headerlink" title="多个git账户使用"></a>多个git账户使用</h1><h2 id="生成新的ssh"><a href="#生成新的ssh" class="headerlink" title="生成新的ssh"></a>生成新的ssh</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"for duoda"</span></span><br></pre></td></tr></table></figure><h2 id="执行ssh-agent让ssh识别新的私钥"><a href="#执行ssh-agent让ssh识别新的私钥" class="headerlink" title="执行ssh-agent让ssh识别新的私钥"></a>执行ssh-agent让ssh识别新的私钥</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-agent bash</span><br><span class="line">ssh-add ~/.ssh/id_rsa_duoda</span><br></pre></td></tr></table></figure><h2 id="将新的ssh-pub放到gitlab的ssh下"><a href="#将新的ssh-pub放到gitlab的ssh下" class="headerlink" title="将新的ssh-pub放到gitlab的ssh下"></a>将新的ssh-pub放到gitlab的ssh下</h2><h2 id="配置-ssh-config"><a href="#配置-ssh-config" class="headerlink" title="配置.ssh/config"></a>配置.ssh/config</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Host jiangjunyouling.gitlab.com</span><br><span class="line">HostName gitlab.com</span><br><span class="line">User jiangyunyouling</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line"></span><br><span class="line"><span class="comment"># second </span></span><br><span class="line">Host duodasunyanfeng.gitlab.com</span><br><span class="line">HostName gitlab.com</span><br><span class="line">User duodasunyanfeng</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_duoda</span><br></pre></td></tr></table></figure><p>这一步花费了很多功夫，现解释一下：</p><p>Host类似与一个key值，用来代表其下的内容<br>HostName 这里需要写仓库的地址，gitlab.com才可，使用账号名是不好使的<br>User有人写的是git，这里我写的都是账号名，经过测试，并不影响结果<br>IndentityFile是私钥的位置</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>使用时可以先用ssh -T 进行测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@jiangjunyouling.gitlab.com</span><br><span class="line">ssh -T git@duodasunyanfeng.gitlab.com</span><br></pre></td></tr></table></figure><p>这里需要注意2点：</p><ul><li>要使用git@的形式才可，直接使用git -T jiangjunyouling.gitlab.com不可以</li><li>git@后面的值为Host的值，也就是key值，若Host为 duodasunyanfeng 则 ssh -T git@duodasunyanfeng 即可</li></ul><h2 id="clone代码库"><a href="#clone代码库" class="headerlink" title="clone代码库"></a>clone代码库</h2><p>在clone时，原来的地址：<a href="mailto:git@gitlab.com" target="_blank" rel="noopener">git@gitlab.com</a>:duobang/xxxx.git<br>要修改为：<a href="mailto:git@duodasunyanfeng.gitlab.com" target="_blank" rel="noopener">git@duodasunyanfeng.gitlab.com</a>:duobang/xxxx.git来指明使用那个进行clone</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要就是git的配置，包括代理、多个git账户使用配置。&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
</feed>
