<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>思 见</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-25T02:04:32.132Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>sun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>redis基础</title>
    <link href="http://yoursite.com/2018/07/21/redis/"/>
    <id>http://yoursite.com/2018/07/21/redis/</id>
    <published>2018-07-21T03:59:23.000Z</published>
    <updated>2018-07-25T02:04:32.132Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍redis的基础，包括redis的数据结构，发布订阅，事务，数据持久化，主从结构等内容。<br>本文是学习《redis实战》整理的博客。<br><a id="more"></a></p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>redis存储的本身就是key:value形式的数据，所说的数据结构，指的是value的结构。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>key: string<br><img src="字符串类型.png" alt=""></p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ul><li>基本操作</li></ul><table><thead><tr><th>命令</th><th style="text-align:center">行为</th><th style="text-align:right">使用</th></tr></thead><tbody><tr><td>set</td><td style="text-align:center">设置存储在给定key中的值</td><td style="text-align:right">set name sun</td></tr><tr><td>get</td><td style="text-align:center">获取存储在给定key中的值</td><td style="text-align:right">get name</td></tr><tr><td>del</td><td style="text-align:center">删除存储在给定key中的值</td><td style="text-align:right">del name</td></tr></tbody></table><ul><li>数值操作<br>其实这个不应该说字符串，因为它的value值可以是数值，包括整数与浮点数。</li></ul><table><thead><tr><th>命令</th><th style="text-align:center">行为</th><th style="text-align:right">使用</th></tr></thead><tbody><tr><td>incr</td><td style="text-align:center">将键对应的值+1</td><td style="text-align:right">incr age</td></tr><tr><td>decr</td><td style="text-align:center">将键对应的值-1</td><td style="text-align:right">decr age</td></tr><tr><td>incrby</td><td style="text-align:center">将键对应值+amount</td><td style="text-align:right">incrby age 10</td></tr><tr><td>decrby</td><td style="text-align:center">将键对应值-amount</td><td style="text-align:right">decrby age 10</td></tr><tr><td>incrbyfloat</td><td style="text-align:center">将键对应值加浮点amount</td><td style="text-align:right">incrbyfloat height 5.6</td></tr></tbody></table><p>  对一个不存在的键或者一个保存了空串的键执行自增或者自减操作，那么redis在执行操作时，会将这个键的值当作0来处理。如果对无法转换成数值的字符串进行操作，那么返回一个错误。</p><ul><li>字串操作</li></ul><table><thead><tr><th>命令</th><th style="text-align:center">行为</th><th style="text-align:right">使用</th></tr></thead><tbody><tr><td>append</td><td style="text-align:center">将value追加给定键的值的末尾</td><td style="text-align:right">append key value</td></tr><tr><td>getrange</td><td style="text-align:center">获取一个由偏移量start-end的字串</td><td style="text-align:right">getrange key start end</td></tr><tr><td>setrange</td><td style="text-align:center">将从offset偏移量设置为定值</td><td style="text-align:right">setrange key offset value</td></tr><tr><td>getbit</td><td style="text-align:center">将字符串堪称二进制位串，返回offset的二进制</td><td style="text-align:right">getbit key offset</td></tr><tr><td>setbit</td><td style="text-align:center">将offset的二进制设为value</td><td style="text-align:right">setbit key offset value</td></tr><tr><td>bitcount</td><td style="text-align:center">统计二进制位串中1的数量</td><td style="text-align:right">bitcount key [start end]</td></tr><tr><td>bitop</td><td style="text-align:center">按位操作，包括and/or/xor/not</td><td style="text-align:right">bitop operation dest-key key-name</td></tr></tbody></table><p>  个人而言这些操作并没有什么用</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p>key：list<br><img src="列表类型.png" alt=""><br>这个列表可以认为是双向的队列，左边与右边都能push与pop</p><h3 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h3><ul><li>基本操作</li></ul><table><thead><tr><th>命令</th><th style="text-align:center">行为</th><th style="text-align:right">使用</th></tr></thead><tbody><tr><td>rpush</td><td style="text-align:center">将value推入列表右端</td><td style="text-align:right">rpush students wang</td></tr><tr><td>lpush</td><td style="text-align:center">将value推入列表的左端</td><td style="text-align:right">lpush students liu</td></tr><tr><td>rpop</td><td style="text-align:center">从右端弹出一个值，并返回此值</td><td style="text-align:right">rpop students</td></tr><tr><td>lpop</td><td style="text-align:center">从左端弹出一个值，并返回此值</td><td style="text-align:right">lpop students</td></tr><tr><td>lrange</td><td style="text-align:center">从左端切片</td><td style="text-align:right">lrange students 0 -1</td></tr><tr><td>lindex</td><td style="text-align:center">左端的下标操作</td><td style="text-align:right">lindex students 1</td></tr><tr><td>ltrim</td><td style="text-align:center">对列表进行剪裁，只保留start-end</td><td style="text-align:right">ltrim students 2 -1</td></tr></tbody></table><ul><li>阻塞操作</li></ul><table><thead><tr><th>命令</th><th style="text-align:center">行为</th><th style="text-align:right">使用</th></tr></thead><tbody><tr><td>blpop</td><td style="text-align:center">从第一个非空类表中弹出元素，或者为空在timeout内阻塞</td><td style="text-align:right">blpop key1 [key2…] timeout</td></tr><tr><td>brpop</td><td style="text-align:center">右端的阻塞pop</td><td style="text-align:right">brpop key1 [key2..] timeout</td></tr><tr><td>rpoplpush</td><td style="text-align:center">从source-key列表弹出元素，然后推入dest-key的左端</td><td style="text-align:right">rpoplpush source-key dest-key</td></tr><tr><td>brpoplpush</td><td style="text-align:center">阻塞的brpoplbush</td><td style="text-align:right">brpoplpush source-key dest-key timeout</td></tr></tbody></table><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h3><p>key: set<br><img src="集合类型.png" alt=""></p><h3 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a>操作</h3><ul><li>基本操作</li></ul><table><thead><tr><th>命令</th><th style="text-align:center">行为</th><th style="text-align:right">使用</th></tr></thead><tbody><tr><td>sadd</td><td style="text-align:center">往集合中添加元素</td><td style="text-align:right">sadd family father</td></tr><tr><td>smembers</td><td style="text-align:center">返回所有元素</td><td style="text-align:right">smembers family</td></tr><tr><td>sismember</td><td style="text-align:center">检测给定元素是否在集合中</td><td style="text-align:right">sismember family mother</td></tr><tr><td>srem</td><td style="text-align:center">如果元素在，则移除</td><td style="text-align:right">srem family thief</td></tr><tr><td>scard</td><td style="text-align:center">返回集合包括的元素数量</td><td style="text-align:right">scard family</td></tr><tr><td>srandmember</td><td style="text-align:center">从集合中随机返回一个或多个元素</td><td style="text-align:right">srandmember key [count]</td></tr><tr><td>spop</td><td style="text-align:center">随机移除一个元素，并返回</td><td style="text-align:right">spop key</td></tr><tr><td>smove</td><td style="text-align:center">如果一个移动到另一个</td><td style="text-align:right">smove source-key dest-key item</td></tr></tbody></table><ul><li>集合操作</li></ul><table><thead><tr><th>命令</th><th style="text-align:center">行为</th><th style="text-align:right">使用</th></tr></thead><tbody><tr><td>sinter</td><td style="text-align:center">两个集合取交集</td><td style="text-align:right">sinter family1 family2</td></tr><tr><td>sunion</td><td style="text-align:center">两个集合取并集</td><td style="text-align:right">sunion family1 family2</td></tr><tr><td>sdiff</td><td style="text-align:center">两个集合取差集</td><td style="text-align:right">sdiff family1 family2</td></tr><tr><td>sinterstore</td><td style="text-align:center">交集然后存储到另一集合</td><td style="text-align:right">sinterstore dest-key key1 [key2..]</td></tr><tr><td>sunionstore</td><td style="text-align:center">并集然后转存到另一集合</td><td style="text-align:right">suninstore dest-key key1 [key2..]</td></tr><tr><td>sdiffstore</td><td style="text-align:center">差集然后转存到另一集合</td><td style="text-align:right">sdiffstore dest-key key1 [key2..]</td></tr></tbody></table><h2 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h2><h3 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h3><p>key：hash(Map)<br><img src="散列类型.png" alt=""><br>散列类型其实就是字典类型</p><h3 id="操作-3"><a href="#操作-3" class="headerlink" title="操作"></a>操作</h3><ul><li>基本操作</li></ul><table><thead><tr><th>命令</th><th style="text-align:center">行为</th><th style="text-align:right">使用</th></tr></thead><tbody><tr><td>hset</td><td style="text-align:center">添加键值对</td><td style="text-align:right">hset family father yanfeng</td></tr><tr><td>hget</td><td style="text-align:center">获取指定键的值</td><td style="text-align:right">hget family father</td></tr><tr><td>hgetall</td><td style="text-align:center">获取所有键值对</td><td style="text-align:right">hgetall family</td></tr><tr><td>hdel</td><td style="text-align:center">如果键存在则删除</td><td style="text-align:right">hdel family father</td></tr><tr><td>hlen</td><td style="text-align:center">返回键值对数量</td><td style="text-align:right">hlen key</td></tr></tbody></table><ul><li>其他操作</li></ul><table><thead><tr><th>命令</th><th style="text-align:center">行为</th><th style="text-align:right">使用</th></tr></thead><tbody><tr><td>hexists</td><td style="text-align:center">检查键是否存在</td><td style="text-align:right">hexists family father</td></tr><tr><td>hkeys</td><td style="text-align:center">获取散列包含的所有键</td><td style="text-align:right">hkeys family</td></tr><tr><td>hvals</td><td style="text-align:center">获取散列包含的所有值</td><td style="text-align:right">kvals family</td></tr><tr><td>hincrby</td><td style="text-align:center">与incrby类似</td><td style="text-align:right">hincrby course english 10</td></tr><tr><td>hincrbyfloat</td><td style="text-align:center">与incrbyfloat类似</td><td style="text-align:right">hincrbyfloat height wang 5.4</td></tr></tbody></table><h2 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h2><h3 id="结构-4"><a href="#结构-4" class="headerlink" title="结构"></a>结构</h3><p>key: zset<br><img src="有序集合.png" alt=""><br>有序集合是一种特殊的散列，它能通过value值排序</p><h3 id="操作-4"><a href="#操作-4" class="headerlink" title="操作"></a>操作</h3><ul><li>基本操作</li></ul><table><thead><tr><th>命令</th><th style="text-align:center">行为</th><th style="text-align:right">使用</th></tr></thead><tbody><tr><td>zadd</td><td style="text-align:center">将给定分值的成员添加到有序集合</td><td style="text-align:right">zadd enScore 98 sun   [96 wang]</td></tr><tr><td>zrem</td><td style="text-align:center">如果元素存在则删除</td><td style="text-align:right">zrem enScore sun [wang]</td></tr><tr><td>zincrby</td><td style="text-align:center">同incrby</td><td style="text-align:right">zincry enScore 1 sun</td></tr><tr><td>zrange</td><td style="text-align:center">切片</td><td style="text-align:right">zrange enScore 0 -1 [withscores]</td></tr><tr><td>zrangebyscore</td><td style="text-align:center">获取在给定分值范围内的所有元素</td><td style="text-align:right">zrangebyscore enScore 90 100 [withsores]</td></tr><tr><td>zcount</td><td style="text-align:center">获取在给定分值范围内的元素数量</td><td style="text-align:right">zcount enScore 90 100</td></tr><tr><td>zcard</td><td style="text-align:center">返回包含的元素数量</td><td style="text-align:right">zcard enScore</td></tr><tr><td>zscore</td><td style="text-align:center">返回member的分数</td><td style="text-align:right">zrank enScore sun</td></tr><tr><td>zrank</td><td style="text-align:center">返回成员的排名</td><td style="text-align:right">zrank enScore sun</td></tr></tbody></table><ul><li>其他操作</li></ul><table><thead><tr><th>命令</th><th style="text-align:center">行为</th><th style="text-align:right">使用</th></tr></thead><tbody><tr><td>zrevrank</td><td style="text-align:center">返回成员member的排名，由大到小</td><td style="text-align:right">zrevrank enScore sun</td></tr><tr><td>zrevrange</td><td style="text-align:center">同zrange,由大到小</td><td style="text-align:right">zrevrange enScore 0 -1 [withscores]</td></tr><tr><td>zrevrangebyscore</td><td style="text-align:center">同zrangebyscore，由大到小</td><td style="text-align:right">zrevrangebyscore enScore 90 100 [with scores]</td></tr><tr><td>zremrangebyrank</td><td style="text-align:center">移除排名start-end间元素</td><td style="text-align:right">zremrangebyrank enScore 10 20</td></tr><tr><td>zremrangebyscore</td><td style="text-align:center">移除分值介于min-max间的元素</td><td style="text-align:right">zremrangebyscore enScore 90 100</td></tr><tr><td>zinterstore</td><td style="text-align:center">同sinterstore，执行的是+</td><td style="text-align:right">zinterstore dest-key  key1 [key2..]</td></tr><tr><td>zunionstore</td><td style="text-align:center">同sunionstore，执行的是min</td><td style="text-align:right">zunionstore dest-key  key1 [key2..]</td></tr></tbody></table><p>  zinterstore<br>  <img src="zinterstore.png" alt=""></p><p> zuninstore<br>  <img src="zunionstore.png" alt=""></p><h2 id="键的过期时间"><a href="#键的过期时间" class="headerlink" title="键的过期时间"></a>键的过期时间</h2><table><thead><tr><th>命令</th><th style="text-align:center">示例</th><th style="text-align:right">描述</th></tr></thead><tbody><tr><td>expire</td><td style="text-align:center">expire key seconds</td><td style="text-align:right">让键在指定seconds秒后过期</td></tr><tr><td>expireat</td><td style="text-align:center">expireat key timestamp</td><td style="text-align:right">让键在指定时间戳过期</td></tr><tr><td>pexpire</td><td style="text-align:center">pexpire key milliseconds</td><td style="text-align:right">让键在指定milliseconds毫秒后过期</td></tr><tr><td>pexpireat</td><td style="text-align:center">pexpireat key timestamp</td><td style="text-align:right">让键在指定的毫秒级时间戳上过期</td></tr><tr><td>ttl</td><td style="text-align:center">ttl key</td><td style="text-align:right">查看给定键距离过期还有多少秒</td></tr><tr><td>pttl</td><td style="text-align:center">pttl key</td><td style="text-align:right">查看给定键距离过期时间有多少毫秒</td></tr></tbody></table><h1 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h1><p>发送者向频道发送二进制字符串消息。每当有消息被发送至频道时，频道的所有订阅者都会收到消息。<br>使用上发布订阅用于在不同进程之间传递数据。</p><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><table><thead><tr><th>命令</th><th style="text-align:center">用例</th><th style="text-align:right">描述</th></tr></thead><tbody><tr><td>SUBSCRIBE</td><td style="text-align:center">SUBSCRIBE CHANNEL1 [CHANNEL2]</td><td style="text-align:right">订阅给定的一个或多个频道</td></tr><tr><td>UNSUBSCRIBE</td><td style="text-align:center">UNSUBSCRIBE [CHANNEL1 [CHANNEL2]]</td><td style="text-align:right">退订给定频道或全部频道</td></tr><tr><td>PSUBSCIBE</td><td style="text-align:center">PSUBSCIBE PATTERN1 [PATTERN2]</td><td style="text-align:right">订阅与模式匹配的所有频道</td></tr><tr><td>punsubscibe</td><td style="text-align:center">punsubscibe pattern1 [pattern2]</td><td style="text-align:right">退订与模式匹配的所有频道</td></tr><tr><td>publish</td><td style="text-align:center">publish channel message</td><td style="text-align:right">向给定频道发送消息</td></tr></tbody></table><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>发布订阅会存在2个问题:</p><ul><li><p>redis系统的稳定性<br>如果客户端订阅某个频道,但读取消息的速度很慢,那么会使redis输出缓冲区越来越大,这导致redis数度变慢,甚至直接崩溃.<br>此问题与redis版本有关,新版本会控制输出缓冲区的大小,过慢就会断开订阅</p></li><li><p>数据传输的可靠性<br>客户端在执行订阅操作的过程中断线,会使其丢失在断线期间的所有消息.<br>这个会可以在后边去处理.</p></li></ul><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="multi-exec"><a href="#multi-exec" class="headerlink" title="multi/exec"></a>multi/exec</h2><p>和关系数据库那种可以在执行过程中进行回滚的事物不同.在Redis中，被multi和exec命令包围的所有命令会一个接一个执行，直到所有命令都执行完毕为止。直到一个事务执行完毕之后，Redis才会处理其他客户端的命令。<br>当Redis从一个客户端接受到multi命令时，Reis会将这个客户端之后发送的所有命令都放到一个队列中，直到这个客户端发送exec命令为止，然后redis在不被打断的情况下，一个接一个的执行队列中的命令。</p><h1 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>redis提供了两种不同的持久化方法。<br>一种叫快照(snapshotting)，它可以将存在于某一时刻的所有数据都写到硬盘里。<br>另一种叫追加(append-only file)AOF,它会在执行命令写命令时，将被执行的写命令复制到硬盘里。（类似与oracle的重写日志）</p><p>持久化一方面可以防止系统而将数据备份到另一个远程位置，另一方面也是将长时间运算的结果保留下来（类似与spark的图运算）</p><p><img src="redis持久化选项.png" alt=""></p><h2 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h2><ul><li><p>快照存储位置<br>快照被写入DBFILENAME选项指定的文件里，并存在DIR选项指定的路径上。</p></li><li><p>创建快照方法</p><ul><li><p>客户端可以向REDIS发送BGSAVE命令来创建一个快照。<br>REDIS会调用FORK来创建一个子进程，负责将快照写入硬盘，而父进程继续处理命令【所有WINDOWS不支持】</p></li><li><p>客户端可以向REDIS发送SAVE命令来创建快照。<br>REDIS服务接到SAVE命令在快照创建完毕之前，不再相应其他命令，也就是单线程完成的。</p></li><li><p>设置了SAVE选项<br>SAVE 60 10000。从REDIS最近一次创建快照开始算，当满足60秒内有10000次写入，REDIS自动触发BGSAVE</p></li><li><p>关闭<br>当REDIS通过SHUTDOWN命令接收到关闭服务器的请求时，或者TERM信号时，会执行一个SAVE命令。</p></li><li><p>同步<br>当一个REDIS服务连接到另一个REDIS服务，并向对方发送SYNC命令开始一次复制操作的时候</p></li></ul></li></ul><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><ul><li><p>APPENDONLY<br>通过将APPENDONLY YES选项来打开，简单说AOF持久化会将被执行的写命令写到AOF文件末尾，以此来记录数据发生的变化。因此，REDIS只要从头到尾执行一次AOF文件所包括的写命令，就可以恢复。</p></li><li><p>APPENDFSYNC配置</p><p>| 选项     | 同步频率                 |<br>| - | -: |<br>| ALWAYS   | 每个写命令都立即写入硬盘 |<br>| EVERYSEC | 每秒执行一次写           |<br>| NO       | 让操作系统来决定何时写   |</p><p>对应NO选项，如果磁盘处理写的操作不快，当缓冲区被顶戴写入硬盘的数据填满时，REDIS写操作会被阻塞，并导致REDIS处理命令请求速度变慢。一般不用NO</p></li><li><p>BGREWRITEAOF<br>对于AOF，一些情况下AOF文件会不断的增大，这时，用户可以向REDIS发送BGREWRITEAOF命令。这个命令会通过移除AOF文件中冗余命令来重写AOF，以减小它。<br>BGREWRITEAOF原理跟BGSAVE类似：REDIS会创建一个子进程，然后有子进程负责AOF文件的重写。<br>可以通过AUTO-AOF-REWRITE-PERCENTAGE选项与AUTO-AOF-REWRITE-MIN-SIZE选项来自动执行BGREWRITEAOF。例如设置AUTO-AOF-REWRITE-PERCENTAGE 100 AUTO-AOF-REWITE-MIN-SIZE 64M当AOF文件的大于64MB并且AOF的体积比上一次重写之后的体积大至少（100%）1倍时候，REDIS执行。 </p></li></ul><h1 id="集群结构"><a href="#集群结构" class="headerlink" title="集群结构"></a>集群结构</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>关系型数据库通常会使用一个主服务器向多个从服务器发送更新，并使用从服务器来处理所有读请求，来增加扩展。redis也采用相同的方法来实现自己的复制特性，并作为扩展性能的一种手段。</p><h2 id="主辅同步"><a href="#主辅同步" class="headerlink" title="主辅同步"></a>主辅同步</h2><ul><li><p>开启<br>开启从服务的必须选项只有slaveof一个。当redis服务启动时，指定一个包括slaveof host port选项的配置，那么redis会根据配置来连接主服务器。<br>对已一个正财运行的redis服务器，可以通过发送SLAVEOF no one /SLAVEOF host port来终止或者开启从服务。</p></li><li><p>过程<br><img src="从服务连接主服务的步骤.png" alt=""><br>从服务在进行同步时，会清空自己的所有数据。<br>redis不支持主主复制</p></li></ul><h2 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h2><ul><li><p>主从链<br>主服务和从服务并没有特别不同之处，所以从服务也可以拥有自己的从服务，并由此形成了主从链。<br><img src="主从链.png" alt=""></p></li><li><p>检验硬盘写入<br>为了验证主服务是否已经将写数据发送到从服务，用户需要向主服务写入真正数据之后，再向主服务写入一个唯一的虚构值（哨兵），然后通过检查虚构值是否存在来判断写数据是否已经到达从服务。<br>检查数据是否保存到硬盘要困难多。检查info命令的输出结果中aof_pending_bio_fsync属性的值是否为0，如果是，则表明服务器已经将所有已知数据保存到硬盘上了。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍redis的基础，包括redis的数据结构，发布订阅，事务，数据持久化，主从结构等内容。&lt;br&gt;本文是学习《redis实战》整理的博客。&lt;br&gt;
    
    </summary>
    
      <category term="数据" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Mongo进阶</title>
    <link href="http://yoursite.com/2018/07/18/mongo%E8%BF%9B%E9%98%B6/"/>
    <id>http://yoursite.com/2018/07/18/mongo进阶/</id>
    <published>2018-07-18T03:59:23.000Z</published>
    <updated>2018-07-19T06:08:11.240Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客根据船长原文件整理</p><h1 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h1><p>  所谓的游标就是指的数据可以一行行的进行操作，类似于关系型数据库处理。在MongoDB数据库里面对于游标的控制非常的简 单，只需要使用find()函数就可以返回游标了。对于返回的游标如果要想进行操作，使用两个函数。</p><p>  <code>hasNext()</code></p><p>  <code>next()</code></p><p>  相当于每一个数据都单独拿出来进行逐行的控制。当游标数据取出来之后，实际上每行数据返回的都是一个Object型的内容</p><p>  exp:</p><pre><code>`var cursor = db.students.find()while(cursor.hasNext()){var student = cursor.next()print(student.name)printjson(student)}`</code></pre><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在任何的数据库之中，索引都是一种提升数据库检索性能的手段，这一点在MongoDB数据库之中同样是存在的，在MongoDB数据库里面依然会存在有两种的索引创建：是自动创建的，另外一种索引是手工创建的。</p><p>exp：重新准备一个新的简单集合</p><pre><code>db.students.drop()db.students.insert({&apos;name&apos;:&apos;张三&apos;,&apos;sex&apos;:&apos;男&apos;,&apos;age&apos;:19,&apos;score&apos;: 89,&apos;address&apos;: &apos;海淀区&apos;})db.students.insert({&apos;name&apos;:&apos;李四&apos;,&apos;sex&apos;:&apos;女&apos;,&apos;age&apos;:20,&apos;score&apos;: 100,&apos;address&apos;: &apos;朝阳区&apos;})db.students.insert({&apos;name&apos;:&apos;王五&apos;,&apos;sex&apos;:&apos;男&apos;,&apos;age&apos;:22,&apos;score&apos;: 50,&apos;address&apos;: &apos;西城区&apos;})</code></pre><p>  查询默认状态下的students集合的索引内容<br>  db.students.getIndexes()</p><p>  创建一个索引，在age字段上设置一个降序索引<br>  db.students.ensureIndex({‘age’:-1})<br>  此时并没有设置索引的名字，所以名字是自动命名的。命名规范：“字段名称_索引的排序模式”。</p><p>  针对于当前的age字段上的索引做一个分析<br>  db.students.find({‘age’:19}).explain()<br>  此时的查询使用了索引的技术</p><p>  针对于score字段上设置查询<br>  db.students.find({score:{$gt:60}}).explain()<br>  此时在score字段上并没有设置索引，所以当前的索引形式就变为了全集合扫描的模式.</p><p>  复合索引：<br>  db.students.ensureIndex({age:1,score:-1},{name:’age_1_score_1_index’})</p><p>  删除一个索引：<br>  db.students.dropIndex({age:1})</p><p>  删除全部索引：<br>  db.students.dropIndexes()</p><h2 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h2><p>唯一索引的主要目的是用在某一个字段上，使该字段的内容不重复.</p><p>创建唯一索引<br> db.students.ensureIndex({name:1},{unique:true})<br>此时若在name中添加重复数据，会报错。</p><h2 id="过期索引"><a href="#过期索引" class="headerlink" title="过期索引"></a>过期索引</h2><p>在一些程序站点会出现若干秒之后信息被删除的情况，例如：手机信息验证码，在MongoDB里面就可以轻松的实现过期索引，但是这个时间往往不怎么准确。必须要有时间，否则没法实现过期。</p><p>设置过期索引<br>db.phones.ensureIndex({time:1},{expireAfterSeconds:10})<br>如果要想实现过期索引，需要保存一个时间信息；<br>db.phones.insert({tel:110,code:110,time:new Date()})<br>db.phones.insert({tel:111,code:111,time:new Date()})</p><h2 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h2><p>在一些信息管理平台上经常需要进行信息模糊查询，最早的时候是利用了某个字段上实现的模糊查询，但是这个时候返回的信息并不会很准确，因为只能够查A字段或者是B字段，而在MongoDB里面实现了非常简单的全文检索。</p><p>定义一个新的集合<br>db.news.insert({‘title’:’gyh’,content:’sfq’})<br>db.news.insert({‘title’:’gyh’,content:’gry’})<br>db.news.insert({‘title’:’sfq’,content:’gry’})</p><p>设置全文检索<br>db.news.ensureIndex({title:’text’,content:’text’})</p><p>实现数据的模糊查询<br>如果要想表示出全文检索，则使用“$text”判断符，而要想进行数据的查询则使用“$search”运算符：</p><p>查询单个内容<br> db.news.find({$text:{$search:’gry’}})</p><p>包含有“gry”与“sfq”的信息<br> db.news.find({$text:{$search:’gry gyh’}})</p><p>同时包含有“mldn”与“lxh”的内容<br>db.news.find({$text:{$search:’\’mldn\’ \’lxh\’’}})</p><p>在进行全文检索操作的时候还可以使用相似度的打分来判断检索成果。<br> db.news.find({$text:{$search:’gyh’}},{‘score’:{$meta:’textScore’}})<br>db.news.find({$text:{$search:’gyh’}},{‘score’:{$meta:’textScore’}}).sort({‘score’:{$meta:’textScore’}})</p><p>但是在这里面还有一个小问题，如果一个集合的字段太多了，那么每一个字段都分别设置全文检索麻烦点，所以简单一些，可以为所有的字段设置全文检索。<br>为所有字段设置全文检索<br>db.news.ensureIndex({‘$**’:’text’})</p><h2 id="地理信息索引"><a href="#地理信息索引" class="headerlink" title="地理信息索引"></a>地理信息索引</h2><p>地理信息索引分为两类：2D平面索引，另外就是2DSphere球面索引。在2D索引里面基本上能够保存的信息都是坐标，而且坐标保存的就是经纬度坐标。</p><p>定义一个商铺的集合</p><pre><code>db.shop.insert({loc:[10,10]})db.shop.insert({loc:[11,10]})db.shop.insert({loc:[10,11]})</code></pre><p>为shop的集合定义2D索引<br>db.shop.ensureIndex({loc:’2d’})</p><p>这个时候shop集合就可以实现坐标位置的查询了，而要进行查询有两种查询方式：<br>·“$near”查询，查询距离某个点最近的坐标点；<br>·“$geoWithin”查询：查询某个形状内的点；</p><p>假设我的现在的坐标是：[11,11]<br>db.shop.find({loc:{$near:[11,11]}})</p><p>db.shop.find({loc:{$near:[11,11],$maxDistance:5}})</p><p>但是需要注意一点，在2D索引里面虽然支持最大距离，但是不支持最小距离。<br>但是也可以设置一个查询的范围，使用“$geoWithin”查询，而可以设置的范围：<br>·矩形范围（$box）：{“$box”:[[x1,y1],[x2,y2]]}；<br>·圆形范围（$center）：{“$center” : [[x1,y1],r]}；<br>·多边型（$polygon）：{“$polygon” :[[x1,y1],[x2,y2][x3,y3] , …]}</p><p>查询矩形<br>db.shop.find({loc:{$geoWithin:{$box:[[9,9],[12,12]]}}})</p><p>查询圆形<br> db.shop.find({loc:{$geoWithin:{$center:[[10,10],2]}}})</p><h1 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇博客根据船长原文件整理&lt;/p&gt;
&lt;h1 id=&quot;游标&quot;&gt;&lt;a href=&quot;#游标&quot; class=&quot;headerlink&quot; title=&quot;游标&quot;&gt;&lt;/a&gt;游标&lt;/h1&gt;&lt;p&gt;  所谓的游标就是指的数据可以一行行的进行操作，类似于关系型数据库处理。在MongoDB数据库里面
      
    
    </summary>
    
      <category term="数据" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Mongo" scheme="http://yoursite.com/tags/Mongo/"/>
    
  </entry>
  
  <entry>
    <title>Mongo基础</title>
    <link href="http://yoursite.com/2018/07/18/mongo%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/07/18/mongo基础/</id>
    <published>2018-07-18T03:59:23.000Z</published>
    <updated>2018-07-19T04:49:33.778Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客从船长那摘抄，原始位置：<a href="https://github.com/zxhyJack/MyBlog/blob/master/mongodb/mongodb.md" target="_blank" rel="noopener">Jack博客链接</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul><li>MongoDB 是一个基于分布式文件存储的数据库</li><li>属于NoSQL数据库，是介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的</li><li>旨在为WEB应用提供可扩展的高性能数据存储解决方案</li><li><p>数据结构： 键值对（key-value），类似JSON对象</p><pre><code>{  name：&apos;Paul&apos;,  age:21,  gender:&apos;man&apos;}</code></pre></li></ul><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><ul><li><p>创建</p><pre><code>use database_name</code></pre></li></ul><p>如果数据库存在，则进入指定数据库，否则，创建数据库<br>此时需要写入数据，数据库才能真正创建成功</p><ul><li><p>查看所有数据库</p><pre><code>show databases | dbs</code></pre></li><li><p>创建集合</p><pre><code>db.createCollection(collection_name)</code></pre></li><li><p>删除数据库<br>先进入要删除的数据库，然后执行命令</p><pre><code>db.dropDatabase()</code></pre></li><li><p>删除集合</p><pre><code>db.collection_name.drop()</code></pre></li></ul><h2 id="数据表操作"><a href="#数据表操作" class="headerlink" title="数据表操作"></a>数据表操作</h2><ul><li><p>增</p><pre><code>db.collection_name.insert(document)</code></pre></li><li><p>查</p><pre><code>db.collection.find(&lt;query&gt;,&lt;projection&gt;)- query: 查询条件- projection: 投影操作</code></pre></li><li><p>改</p><pre><code>db.collection.updateOne(&lt;query&gt;,&lt;update&gt;) // 更新第一个符合条件的集合db.collection.updateMany(&lt;query&gt;,&lt;update&gt;)  // 更新所有符合条件的集合- query: 查询条件- update： 更新的内容</code></pre></li><li><p>删</p><pre><code>db.collection_name.deleteOne(&lt;query&gt;) // 删除第一个符合条件的集合db.collection_name.deleteMany(&lt;query&gt;) // 删除所有符合条件的集合</code></pre></li></ul><h1 id="数据操作（重点）"><a href="#数据操作（重点）" class="headerlink" title="数据操作（重点）"></a>数据操作（重点）</h1><p>数据库的核心——CRUD，增加和删除较为简单，查询和修改较复杂</p><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><ul><li><p>$gt 大于</p></li><li><p>$lt 小于</p></li><li><p>$gte  大于等于</p></li><li><p>$lte  小于等于</p></li><li><p>$eq | (key: value)  等于</p></li><li><p>$ne 不等于</p></li></ul><p>先往数据库中添加一些数据</p><pre><code>db.students.insert({&apos;name&apos;:&apos;张三&apos;,&apos;sex&apos;:&apos;男&apos;,&apos;age&apos;:19,&apos;score&apos;: 89,&apos;address&apos;: &apos;海淀区&apos;})db.students.insert({&apos;name&apos;:&apos;李四&apos;,&apos;sex&apos;:&apos;女&apos;,&apos;age&apos;:20,&apos;score&apos;: 100,&apos;address&apos;: &apos;朝阳区&apos;})db.students.insert({&apos;name&apos;:&apos;王五&apos;,&apos;sex&apos;:&apos;男&apos;,&apos;age&apos;:22,&apos;score&apos;: 50,&apos;address&apos;: &apos;西城区&apos;})db.students.insert({&apos;name&apos;:&apos;赵六&apos;,&apos;sex&apos;:&apos;女&apos;,&apos;age&apos;:21,&apos;score&apos;: 60,&apos;address&apos;: &apos;东城区&apos;})</code></pre><p>exp:</p><ol><li><p>查询姓名是张三的学生信息</p><pre><code>db.students.find({name:’张三’}).pretty()</code></pre></li><li><p>查询年龄大于19岁的学生</p><pre><code>db.students.find({age:{$gt:19}}).pretty()</code></pre></li><li><p>查询成绩大于等于60分的学生</p><pre><code>db.students.find({score:{$gte:60}}).pretty() </code></pre></li></ol><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ul><li><p><code>$and</code>   与</p></li><li><p><code>$or</code>   或</p></li><li><p><code>$not | $nor</code>  非</p></li></ul><p>exp:</p><ol><li><p>查询年龄在19 ~ 22岁的学生信息</p><pre><code>db.students.find({age:{$gte:19,$lte:22}}).pretty()</code></pre></li></ol><p>逻辑运算中与连接是最容易的，只需要利用<code>,</code>分割多个条件即可</p><ol start="2"><li><p>查询年龄小于20岁，或者成绩大于90分的学生信息</p><pre><code>db.students.find({$or:    [     {age:{$lt:20}},    {score:{$gt:90}}    ]}).pretty()</code></pre></li><li><p>查询年龄大于等于20岁，且成绩小于等于90分的学生信息</p><pre><code>db.students.find({$and:    [     {age:{$gte:20}},    {score:{$lte:90}}    ]}).pretty()</code></pre></li></ol><h3 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h3><p>$in: 在范围之中<br>$nin: 不在范围之中</p><p>exp:</p><ol><li><p>查询姓名是”张三“、”李四、”王五“的学生</p><pre><code>db.students.find({name: {$in:[&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;]}}).pret ty()</code></pre></li><li><p>查询姓名不是”张三“、”李四、”王五“的学生</p><pre><code>db.students.find({name: {$nin:[&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;]}}).pretty()</code></pre></li></ol><h3 id="数组查询"><a href="#数组查询" class="headerlink" title="数组查询"></a>数组查询</h3><ul><li><p>$all </p></li><li><p>$size </p></li><li><p>$slice </p></li><li><p>$elemMatch</p></li></ul><p>首先在数据库中新增一些数据</p><pre><code>db.students.insert({name:&apos;a&apos;,sex:&apos;男&apos;,age:19,score:89,address:&apos;海淀区&apos;,course:[&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;,&apos;音乐&apos;,&apos;政治&apos;]})db.students.insert({name:&apos;b&apos;,sex:&apos;男&apos;,age:19,score:89,address:&apos;海淀区&apos;,course:[&apos;语文&apos;,&apos;数学&apos;]})db.students.insert({name:&apos;c&apos;,sex:&apos;男&apos;,age:19,score:89,address:&apos;海淀区&apos;,course:[&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;]})db.students.insert({name:&apos;d&apos;,sex:&apos;男&apos;,age:19,score:89,address:&apos;海淀区&apos;,course:[&apos;英语&apos;,&apos;音乐&apos;,&apos;政治&apos;]})db.students.insert({name:&apos;e&apos;,sex:&apos;男&apos;,age:19,score:89,address:&apos;海淀区&apos;,course:[&apos;语文&apos;,&apos;政治&apos;]})</code></pre><p><code>$all</code>: 表示全都包括，用法：</p><pre><code>{$all:[内容1,内容2]}</code></pre><p>exp:</p><p>查询同时参加语文和数学的学生</p><pre><code>db.students.find({course:{$all:[&apos;语文&apos;,&apos;数学&apos;]}}).pretty()</code></pre><p>数组的操作，可以利用索引，使用<code>key.index</code>的方式来定义索引</p><p>查询数组中第二个内容是数学的学生(sh)</p><pre><code>db.students.find({&apos;course.1&apos;:&apos;数学&apos;}).pretty()</code></pre><p><code>$size</code>: 控制数组元素数量</p><p>exp:</p><p>查询只有两门课程的学生</p><pre><code>db.students.find({course:{$size: 2}}).pretty()</code></pre><p><code>$slice</code>: 控制查询结果的返回数量</p><p>exp:</p><p>查询年龄是19岁的学生，要求之显示两门参加的课程</p><pre><code>db.students.find({age:19},{course:{$slice:2}}).pretty()</code></pre><p>此时查询返回的是前两门课程，可以设置参数来取出想要的内容</p><pre><code>$slice:-2   //后两门$slice: [1,2]   // 第一个参数表示跳过的数据量，第二个参数表示返回的数据量</code></pre><h3 id="嵌套集合运算"><a href="#嵌套集合运算" class="headerlink" title="嵌套集合运算"></a>嵌套集合运算</h3><p>对象里面套对象</p><p>在数据库中新增数据</p><pre><code>db.students.insert({    name:&apos;A&apos;,sex:&apos;男&apos;,age:19,score:89,address:&apos;海淀区&apos;,    course:[&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;,&apos;音乐&apos;,&apos;政治&apos;],    parents:[        {name:&apos;A(father)&apos;,age:50,job:&apos;工人&apos;},        {name:&apos;A(mother)&apos;,age:50,job:&apos;职员&apos;}    ]})db.students.insert({    name:&apos;B&apos;,sex:&apos;男&apos;,age:19,score:89,address:&apos;海淀区&apos;,    course:[&apos;语文&apos;,&apos;数学&apos;],    parents:[        {name:&apos;B(father)&apos;,age:50,job:&apos;处长&apos;},        {name:&apos;B(mother)&apos;,age:50,job:&apos;局长&apos;}    ]})db.students.insert({    name:&apos;C&apos;,sex:&apos;男&apos;,age:19,score:89,address:&apos;海淀区&apos;,    course:[&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;],    parents:[        {name:&apos;C(father)&apos;,age:50,job:&apos;工人&apos;},        {name:&apos;C(mother)&apos;,age:50,job:&apos;局长&apos;}        ]})</code></pre><p>对于嵌套的集合中数据的判断只能通过<code>$elemMatch</code>完成</p><p>语法：<code>{ &lt;field&gt;: { $elemMatch: { &lt;query1&gt;, &lt;query2&gt;, ... } } }</code></p><p>exp:</p><p>查询父母中有人是局长的信息</p><pre><code>db.students.find({parents: {$elemMatch: {job: &apos;局长&apos;}}}).pretty()</code></pre><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p><code>sort({ field: value })</code> value是1表示升序，-1表示降序</p><p>exp:</p><p>学生信息按照分数降序排列</p><pre><code>db.students.find().sort({score:-1}).pretty()</code></pre><h3 id="分页显示"><a href="#分页显示" class="headerlink" title="分页显示"></a>分页显示</h3><p><code>skip(n)</code>: 跳过n条数据</p><p><code>limit(n)</code>: 返回n条数据</p><p>exp:</p><ol><li><p>分页显示，第一页，每页显示5条数据</p><pre><code>db.students.find({}).skip(0).limit(5).pretty()</code></pre></li><li><p>分页显示，第二页，每页显示5条数据</p><pre><code>db.students.find({}).skip(5).limit(5).pretty()</code></pre></li></ol><h3 id="判断某个字段是否存在"><a href="#判断某个字段是否存在" class="headerlink" title="判断某个字段是否存在"></a>判断某个字段是否存在</h3><p><code>{$exists:flag}</code>  flag为true表示存在，false表示不存在</p><p>exp:</p><ol><li><p>查询具有parents成员的学生</p><pre><code>db.students.find({parents:{$exists: true}}).pretty()</code></pre></li><li><p>查询不具有course成员的学生</p><pre><code>db.students.find({course: {$exists: false}}).pretty()</code></pre></li></ol><h3 id="取模"><a href="#取模" class="headerlink" title="取模"></a>取模</h3><p><code>$mod:[除数，余数]</code></p><p>exp: 查询年龄除以20余1的学生信息</p><pre><code>db.students.find({age:{$mod:[20,1]}}).pretty()</code></pre><h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p><code>updateOne()</code>     修改匹配的第一条数据</p><p><code>updateMany()</code>    修改所有匹配的数据</p><p>格式：<code>updateOne(&lt;filter&gt;,&lt;update&gt;)</code></p><h3 id="修改器"><a href="#修改器" class="headerlink" title="修改器"></a>修改器</h3><ul><li><code>$inc</code></li><li><code>$set</code></li><li><code>$unset</code></li><li><code>$push</code></li><li><code>$addToSet</code></li><li><code>$pop</code></li><li><code>$pull</code></li><li><code>$pullAll</code></li><li><code>$rename</code></li></ul><p><strong><code>$inc</code>：操作数字字段的数据内容</strong></p><p>语法: <code>{&quot;$inc&quot; : {成员 : 内容}}</code></p><p>exp: 将所有年龄为19岁的学生成绩一律减少30分，年龄增加1</p><pre><code>db.students.updateMany({age:19},{$inc:{score:-30,age:1}})</code></pre><p><strong><code>$set</code>：更新内容</strong></p><p>语法：<code>{$set: :{属性: 新内容}}</code></p><p>exp: 将20岁学生的成绩修改为89</p><pre><code>db.students.updateMany({age: 20},{$set: {score: 89}})</code></pre><p><strong><code>$unset</code>：删除某个属性及其内容</strong></p><p>语法：<code>{$unset: {属性: 1}}</code></p><p>exp:删除张三的年龄和成绩信息</p><pre><code>db.students.updateOne({name:&apos;张三&apos;},{$unset: {age: 1,score: 1}})</code></pre><p><strong><code>$push</code>：向数组中添加数据</strong></p><p>语法：<code>{$push: {属性: value}}</code></p><p>exp:在李四的课程中添加语文</p><pre><code>db.students.updateOne({name: &apos;李四&apos;},{$push: {course: &apos;语文&apos;}})</code></pre><p>如果需要向数组中添加多个数据，则需要用到<code>$each</code></p><p>exp: 在李四的课程中添加数学、英语</p><pre><code>db.students.updateOne(    {name:&apos;李四&apos;},    {$push:        {            course:{$each: [&apos;数学&apos;,&apos;英语&apos;]}        }    })</code></pre><p><strong><code>$addToSet</code>：向数组里面添加一个新的数据</strong></p><p>与<code>$push</code>的区别，<code>$push</code>添加的数据可能是重复的，<code>$addToSet</code>只有这个数据不存在时才会添加（去重）</p><p>语法：<code>{$addToSet: {属性：value}}</code></p><p>exp:王五新增一门舞蹈课程</p><pre><code>db.students.updateOne(    {name:&apos;王五&apos;},    {$addToSet: {course:&apos;舞蹈&apos;}})</code></pre><p><strong><code>$pop</code>：删除数组内的数据</strong></p><p>语法：<code>{$pop: {field: value}}</code>,value为-1表示删除第一个，value为1表示删除最后一个</p><p>exp:删除王五的第一个课程</p><pre><code>db.students.updateOne({name:&apos;王五&apos;},{$pop:{course:-1}})</code></pre><p>只是删除属性的内容，属性还在</p><p><strong><code>$pull</code>：从数组中删除一个指定内容的数据</strong></p><p>语法：<code>{$pull: {field：value}}</code> 进行数据比对，如果是该数据则删除</p><p>exp:删除李四的语文课程</p><pre><code>db.students.updateOne({name: &apos;李四&apos;},{$pull:{course:&apos;语文&apos;}})</code></pre><p><strong><code>$pullAll</code>：一次删除多个数据</strong></p><p>语法：<code>{$pullAll:{field:[value1,value2...]}}</code></p><p>exp:删除a的语文数学英语课程</p><pre><code>db.students.updateOne({name:&apos;a&apos;},{$pullAll:{course:[&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;]}})</code></pre><p><strong><code>$rename</code>：属性重命名</strong></p><p>语法： <code>{$rename: {旧属性名：新属性名}}</code></p><p>exp:把张三的name属性名改为姓名</p><pre><code>db.students.updateOne({name:&apos;张三&apos;},{$rename:{name:&apos;姓名&apos;}})</code></pre><h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><p>remove函数是有两个可选项：<br>·删除条件：满足条件的数据被删除；<br>·是否只删除一个数据，如果设置为true或者是1表示只删除一个</p><p>exp：删除所有姓名里面带有“谷”的信息，默认情况下会全部删除<br>        db.students.remove({name: /谷/})</p><p>范例：删除姓名带有“高”的信息，要求只删除一个<br>        db.students.remove({name: /高/},true)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇博客从船长那摘抄，原始位置：&lt;a href=&quot;https://github.com/zxhyJack/MyBlog/blob/master/mongodb/mongodb.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Jack博客链接&lt;/a&gt;&lt;/
      
    
    </summary>
    
      <category term="数据" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Mongo" scheme="http://yoursite.com/tags/Mongo/"/>
    
  </entry>
  
  <entry>
    <title>http网络结构</title>
    <link href="http://yoursite.com/2018/07/18/http%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2018/07/18/http网络结构/</id>
    <published>2018-07-18T02:13:26.129Z</published>
    <updated>2018-07-18T02:13:26.129Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h1><a id="more"></a><h2 id="web服务器："><a href="#web服务器：" class="headerlink" title="web服务器："></a>web服务器：</h2><h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h3><p>Web服务器逻辑实现了HTTP协议，管理着Web资源，并负责提供Web服务器的管理功能。</p><h3 id="小实现-跟tcp服务端编写一样"><a href="#小实现-跟tcp服务端编写一样" class="headerlink" title="小实现:跟tcp服务端编写一样"></a>小实现:跟tcp服务端编写一样</h3><p><img src="Web服务器.png" alt=""></p><ul><li>建立连接：接受一个客户端连接</li><li>接收请求：从网络中读取一条HTTP请求报文</li><li>处理请求：对请求报文进行解释，并采取行动</li><li>访问资源：访问报文中指定的资源</li><li>构建响应：构建带有正确首部的HTTP响应报文</li><li>发送响应：将相应报文发送给的客户端</li><li>记录事务处理过程：将事务有关的内容记录在日志文件中<h2 id="中间商"><a href="#中间商" class="headerlink" title="中间商"></a>中间商</h2><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3></li><li><p>代理位于客户端与服务器之间，于是它既是服务器也是客户端。Http客户端会向代理发生报文，代理必须像Web服务器一样，正确地处理请求和连接，然后返回响应。同时，代理自身要向服务器发送请求。<br>攻守兼备^_^</p></li><li><p>代理vs网关<br>严格说，代理连接的是2个使用相同协议的应用程序，而网关是不同协议，但其实人为设定，它们从设计模式上看，都是代理。</p></li></ul><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><ul><li><p>出口代理<br>本地网络的出口，便于控制本地网络与外部网络之间的流量。小学使用出口代理防止早熟的少年浏览不该浏览的内容。</p></li><li><p>反向代理<br>部署在Web服务器前，处理所有传送给Web服务器的求，并只在必要时间向Web服务器请求资源。如：Nginx。感觉这才是入口代理。</p></li><li><p>网络交换代理（中间代理）<br>可以将具有足够能力的代理放在网络之间的对等交换点上，通过缓存在减轻因特网节点的拥堵，并对流量进行监视。<br>PS：这一块书上表述不清，它的入口代理感觉就是缓存，也就是这里的交换代理，故删掉。</p></li></ul><h4 id="代理获取流量的方式"><a href="#代理获取流量的方式" class="headerlink" title="代理获取流量的方式"></a>代理获取流量的方式</h4><ul><li><p>修改客户端<br>手动修改浏览器的代理配置</p></li><li><p>修改网络【拦截】<br>通过网络基础设施（交换机、路由器），通过技术手段在没有客户端参与情况下，拦截网络流量并将其导入代理。</p></li><li><p>修改DNS的命名空间【反向代理】<br>反向代理会直接加班Web服务器的名字和IP。可以手动编辑DNS名称列表，或者用特殊的动态DNS服务器根据需要来确定适当的代理或者服务器。</p></li><li><p>修改Web服务器<br>重定向命令到代理上</p></li></ul><h4 id="与代理相关问题"><a href="#与代理相关问题" class="headerlink" title="与代理相关问题"></a>与代理相关问题</h4><ul><li>代理请求URI与服务器uri差异<br>客户端向web服务器发送请求，请求行只包括部分URI；而向代理发送，会包含全部<br><img src="URI差异.png" alt=""></li><li>拦截和反向代理对主机信息的隐藏<h4 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h4><img src="追踪.png" alt=""></li><li>TRACE方法</li><li>Via首部<h4 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h4>由于客户端、服务器、代理实现不同版本HTTP规范，以及对特性支持各不相同，可能会存在一些棘手问题。<br>可以通过OPTIONS方法，客户端（代理）可以发现Web服务器或者某个特定资源所支持的功能（所支持的方法）。这样在正式交互之前，确定服务器的能力。</li><li>Allow首部<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><h4 id="代理解决的问题：慢"><a href="#代理解决的问题：慢" class="headerlink" title="代理解决的问题：慢"></a>代理解决的问题：慢</h4></li><li>冗余数据传输</li><li>带宽瓶颈</li><li>瞬时拥塞</li><li>距离延时<h4 id="处理问题所用的方法"><a href="#处理问题所用的方法" class="headerlink" title="处理问题所用的方法"></a>处理问题所用的方法</h4><img src="缓存命中.png" alt=""><br>如图即可，采用的方法与电脑的缓存相同。<h4 id="代理的处理步骤：对比服务器7步骤"><a href="#代理的处理步骤：对比服务器7步骤" class="headerlink" title="代理的处理步骤：对比服务器7步骤"></a>代理的处理步骤：对比服务器7步骤</h4><img src="缓存步骤.png" alt=""></li><li>接收：缓存请求报文</li><li>解析：解析报文，提出URL与首部</li><li>查询：查询是否有本地副本可用，没有就获取一份，并存在本地</li><li>新鲜度检测：就是确定数据一致性</li><li>创建响应</li><li>发送响应</li><li>日志</li></ul><p>则合理用过If-Modified-Since/If-None-Match等首部</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>为了保证新鲜度（数据一致性）采用了很多的算法，这里不在叙述了</li><li>缓存和广告：这个挺有意思<br>ISP的很多收益通过广告来实现，每次点击广告就收取一定的收益。而代理会隐藏实际的次数，这样就使服务器收益降低。^_^<h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><h4 id="网关要解决的问题"><a href="#网关要解决的问题" class="headerlink" title="网关要解决的问题"></a>网关要解决的问题</h4>网络上的资源太多了，这些资源的获取使用不同的协议来访问，于是通过http就不能实现对资源的访问。从一个角度上看，网关就是协议的转换，将http转换成其他协议来实现资源的访问，从另一个角度看，网关就是把其他协议访问资源做http代理，使其能被共有的http协议访问。<h4 id="几种网关"><a href="#几种网关" class="headerlink" title="几种网关"></a>几种网关</h4></li><li>协议网关：HTTP/FTP服务器端FTP网关<br><img src="HTTP_FTP网关.png" alt=""><br>网关接收到请求后，会打开一条与FTP服务器端口（21）的FTP连接，通过FTP协议获取对象。</li><li><p>协议网关：HTTPS/HTTP客户端安全网关<br><img src="http_https网关.png" alt=""><br>对http进行加密，对https进行解密完成协议转换。</p></li><li><p>资源网关：HTTP/CGI服务器端应用程序网关<br>资源网关其实就是服务器，这时候它不是返回文件，而是调用应用程序。<br>CGI（Common Gateway Interface）:其实就是Web服务器调用应用程序的接口，Web服务用它来装载程序以响应URL的请求，并收集程序的输出数据，将其在http响应中回送。</p><h3 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h3></li><li><p>概述<br>web隧道允许用户通过HTTP连接发送非HTTP流量，这样可以在http上稍带其他协议数据。使用web隧道最常见的原因是在http连接中嵌入非http流量，这样，这些流量就可以穿过只允许web流量穿过的防火墙。<br><img src="隧道.png" alt=""><br>隧道就是用http报文发送ssl协议报文，来穿过防火墙。</p></li><li><p>SSL与http/https网关对比<br>网关需要完整的ssl实现，来完成http/https的转换<br>隧道连接本质是ssl，只是中间一段用http报文来传输。</p><h2 id="Web客户端：爬虫"><a href="#Web客户端：爬虫" class="headerlink" title="Web客户端：爬虫"></a>Web客户端：爬虫</h2><h3 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h3></li><li><p>爬虫是一种机器人，它们会递归的对各种web站点进行遍历，获取第一个web页面，然后从那个页面中解析指向的其他页面，接着爬取那些页面，依次类推的爬取。</p></li><li><p>根集选择<br>在Web结构中，有些页面是独立的，没有任何连接指向它们。如下图：<br><img src="网络结构示意图.png" alt=""><br>要遍历整个网络，根集可以选择A、G、S</p><h3 id="爬虫面对的问题"><a href="#爬虫面对的问题" class="headerlink" title="爬虫面对的问题"></a>爬虫面对的问题</h3></li><li><p>机器人爬行时，要避免环路。环路就是几个页面相互引用成环，使爬虫一直在这些页面中重复爬行。</p></li><li><p>文件系统连接环路<br>符号链接引起:<br><img src="文件系统环路.png" alt=""></p></li><li><p>动态虚拟web空间<br>有的应用程序可以在传输中构造出包含同一服务器上虚拟URL连接的HTML。 当爬虫去请求时，这个“邪恶”的服务器会捏造出带有新的URL的新HTML来。</p><h3 id="爬虫HTTP"><a href="#爬虫HTTP" class="headerlink" title="爬虫HTTP"></a>爬虫HTTP</h3><p>鼓励爬虫加入一些识别首部，这样在追踪错误爬虫时，或者向服务器提供爬虫所能处理内容类型时，是有用的。</p></li><li><p>User-Agent<br>将爬虫的名字告知服务器</p></li><li><p>From<br>提供机器人管理者的email</p></li><li><p>accept<br>告知服务器可以发送哪些类型（文本、图片等）</p></li><li><p>referer<br>有些站点管理者尝试记录机器人是如何找到其站点的</p></li><li><p>host<br>一个主机有多个域名，若不指明host，可能获取错内容。</p><h3 id="爬虫要遵守的规范：robots-txt"><a href="#爬虫要遵守的规范：robots-txt" class="headerlink" title="爬虫要遵守的规范：robots.txt"></a>爬虫要遵守的规范：robots.txt</h3></li><li>web服务器可以在服务器文档根目录提供一个可选的、名为robots.txt的文件。这个文件说明机器人可以访问服务的哪些部分。</li><li><p>爬虫在请求页面时，要先去查看robots.txt文件，看它是否有访问的权限。</p></li><li><p>robots.txt文件的格式<br>User-Agent：slurp<br>User-Agent: webcrawler<br>Disallow:/private</p><p>User-Agent:*<br>Disallow</p><p>以一个或者多个User-Agent开始，说明哪些机器人会受此记录影响，然后跟着Disallow和Allow，说明这些机器人可以访问哪些URL</p><h3 id="爬虫的应用：搜索引擎"><a href="#爬虫的应用：搜索引擎" class="headerlink" title="爬虫的应用：搜索引擎"></a>爬虫的应用：搜索引擎</h3><p><img src="搜索引擎.png" alt=""><br>搜索引擎爬虫搜索web页面，然后将内容添加全文索引数据库中。用户引擎文章对全文索引进行查询。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;网络结构&quot;&gt;&lt;a href=&quot;#网络结构&quot; class=&quot;headerlink&quot; title=&quot;网络结构&quot;&gt;&lt;/a&gt;网络结构&lt;/h1&gt;
    
    </summary>
    
      <category term="数据" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>报文协议基础</title>
    <link href="http://yoursite.com/2018/07/18/http%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/07/18/http协议基础/</id>
    <published>2018-07-18T02:06:37.926Z</published>
    <updated>2018-07-18T02:06:37.926Z</updated>
    
    <content type="html"><![CDATA[<h1 id="报文协议基础"><a href="#报文协议基础" class="headerlink" title="报文协议基础"></a>报文协议基础</h1><a id="more"></a><h2 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h2><h3 id="起始行"><a href="#起始行" class="headerlink" title="起始行"></a>起始行</h3> <!-- ![test](/images/curiosity.jpg) --><p><img src="Http报文.png" alt="test"><br>如图：<br>请求报文起始行：方法 url 协议类型<br>响应报文起始行：协议类型 响应码 响应码的说明</p><h3 id="首部"><a href="#首部" class="headerlink" title="首部"></a>首部</h3><p>部首就是一系列键值对组合，用来说明连接及主体的数据的意义。下边会着重介绍请求与响应报文的相应首部。</p><h3 id="主体"><a href="#主体" class="headerlink" title="主体"></a>主体</h3><p>由任意数据组成的数据块。如上可以直接是字符串，上传的文件，表单等数据。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><table><thead><tr><th>方法</th><th style="text-align:center">描述</th><th style="text-align:right">是否包含主体</th></tr></thead><tbody><tr><td>GET</td><td style="text-align:center">从服务器获取资源</td><td style="text-align:right">N</td></tr><tr><td>HEAD</td><td style="text-align:center">只获取资源的首部</td><td style="text-align:right">N</td></tr><tr><td>POST</td><td style="text-align:center">发送需要处理的数据</td><td style="text-align:right">Y</td></tr><tr><td>PUT</td><td style="text-align:center">将主体部分存储在服务器上</td><td style="text-align:right">Y</td></tr><tr><td>TRACE</td><td style="text-align:center">追踪报文路径</td><td style="text-align:right">N</td></tr><tr><td>OPTIONS</td><td style="text-align:center">在服务器上可以执行哪些方法</td><td style="text-align:right">N</td></tr><tr><td>DELETE</td><td style="text-align:center">从服务器上删除文件.与put相对</td><td style="text-align:right">N</td></tr></tbody></table><ul><li>HEAD<br>与GET行为类似，但服务器只返回首部。一般用于：<ul><li>通过状态码，查看资源是否存在</li><li>在不获取资源情况下了解资源的类型</li><li>通过首部，测试资源是否被修改？【这个还不明白，难道是对比资源的长度】</li></ul></li><li><p>PUT与POST<br>put方法与post方法都是往服务器上传数据。put语义是让服务器用请求主体数据来创建一个由所请求url命名的新文档。如果已经存在，则替换它。<br>post将表单数据发送的服务器。<br>现在这里文件上传时，一般也是用post表单的方式上传。<br>put区分？</p></li><li><p>TRACE<br><img src="TRACE方法.png" alt="test"><br>如上图所示，主要用于验证请求穿过的代理</p></li><li><p>OPTIONS<br><img src="OPTIONS方法.png" alt="test"><br>用于请求服务器告知其支持的各种方法.</p><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2></li><li><p>组成部分<br><img src="URL组成.png" alt="test"></p><ul><li>URL的sheme，也就是协议类型，https/http/ftp等等</li><li>服务器位置</li><li>资源路径</li></ul></li><li><p>格式<br><img src="url格式.png" alt="test"></p></li><li><p>相对url</p><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2></li></ul><h3 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h3><table><thead><tr><th>整体范围</th><th style="text-align:center">已定义范围</th><th style="text-align:right">分类</th></tr></thead><tbody><tr><td>100-199</td><td style="text-align:center">100-101</td><td style="text-align:right">信息提示</td></tr><tr><td>200-299</td><td style="text-align:center">200-206</td><td style="text-align:right">成功</td></tr><tr><td>300-399</td><td style="text-align:center">300-305</td><td style="text-align:right">重定向</td></tr><tr><td>400-499</td><td style="text-align:center">400-415</td><td style="text-align:right">客户端错误</td></tr><tr><td>500-599</td><td style="text-align:center">500-505</td><td style="text-align:right">服务器错误</td></tr></tbody></table><h3 id="常见："><a href="#常见：" class="headerlink" title="常见："></a>常见：</h3><table><thead><tr><th>状态码</th><th style="text-align:center">原因</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>200</td><td style="text-align:center">OK</td><td style="text-align:right"></td></tr><tr><td>201</td><td style="text-align:center">Created</td><td style="text-align:right">创建成功</td></tr><tr><td>202</td><td style="text-align:center">Accepted</td><td style="text-align:right">请求被接受</td></tr><tr><td>300</td><td style="text-align:center">Multiple Choices</td><td style="text-align:right">url指向多个资源，Location</td></tr><tr><td>301</td><td style="text-align:center">Moved Permanently</td><td style="text-align:right">URL被移到Location</td></tr><tr><td>302</td><td style="text-align:center">Found</td><td style="text-align:right">URL临时定位资源到Location</td></tr><tr><td>400</td><td style="text-align:center">Bad Requese</td><td style="text-align:right">错误请求</td></tr><tr><td>401</td><td style="text-align:center">Unauthorized</td><td style="text-align:right">未授权，未登录</td></tr><tr><td>403</td><td style="text-align:center">Forbidden</td><td style="text-align:right">禁止访问</td></tr><tr><td>404</td><td style="text-align:center">Not Found</td><td style="text-align:right">没有url对应资源</td></tr><tr><td>405</td><td style="text-align:center">Method Not Allowed</td><td style="text-align:right"></td></tr><tr><td>406</td><td style="text-align:center">Not Acception</td><td style="text-align:right">客户端指令资源类型，服务器没有</td></tr><tr><td>500</td><td style="text-align:center">InternelServerErro</td><td style="text-align:right">服务器内部错误</td></tr><tr><td>502</td><td style="text-align:center">Bad Gateway</td><td style="text-align:right">代理无法连接到父网关</td></tr><tr><td>503</td><td style="text-align:center">Service Unavailabe</td><td style="text-align:right">服务器无法提供服务</td></tr></tbody></table><h2 id="首部Header"><a href="#首部Header" class="headerlink" title="首部Header"></a>首部Header</h2><h3 id="通用首部"><a href="#通用首部" class="headerlink" title="通用首部"></a>通用首部</h3><p>客户端与服务端通用的首部，常见如下</p><table><thead><tr><th>首部</th><th style="text-align:right">描述</th></tr></thead><tbody><tr><td>Connection</td><td style="text-align:right">指定请求/响应连接有关选项</td></tr><tr><td>Date</td><td style="text-align:right">报文创建时间</td></tr><tr><td>Transfer-Encoding</td><td style="text-align:right">报文编码的方式</td></tr><tr><td>Trailer</td><td style="text-align:right">报文采用分块传输编码时，列出报trailer信息</td></tr><tr><td>via</td><td style="text-align:right">trace方法时，经过的中间节点</td></tr><tr><td>Cache-Control</td><td style="text-align:right">随报文传送缓存指示</td></tr></tbody></table><h3 id="请求首部"><a href="#请求首部" class="headerlink" title="请求首部"></a>请求首部</h3><p>客户端特有首部，为服务器提供一些额外的（客户端）信息。</p><table><thead><tr><th>首部</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>Client-IP</td><td style="text-align:center">客户端ip</td></tr><tr><td>From</td><td style="text-align:center">客户端email</td></tr><tr><td>Host</td><td style="text-align:center">请求服务器的ip与端口（一般是url）</td></tr><tr><td>Referer</td><td style="text-align:center">提供了当前uri文档的url</td></tr><tr><td>User-Agent</td><td style="text-align:center">浏览器名</td></tr><tr><td>Accept</td><td style="text-align:center">告知服务器应该发送那些类型</td></tr><tr><td>Accept-Charset</td><td style="text-align:center">告知服务器字符集</td></tr><tr><td>Accept-Encoding</td><td style="text-align:center">告知服务器编码方式</td></tr><tr><td>If-Match</td><td style="text-align:center">条件请求：标记匹配，则请求</td></tr><tr><td>Authorization</td><td style="text-align:center">安全请求：认证数据</td></tr><tr><td>Cookie</td><td style="text-align:center">安全请求：cookie</td></tr></tbody></table><h3 id="响应首部"><a href="#响应首部" class="headerlink" title="响应首部"></a>响应首部</h3><p>服务器特有首部，为客户的提供信息</p><table><thead><tr><th>首部</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>Age</td><td style="text-align:center">响应持续时间</td></tr><tr><td>Public</td><td style="text-align:center">服务器为其资源提供的请求方法列表</td></tr><tr><td>Proxy-Authenticate</td><td style="text-align:center">安全响应：代理对客户端的质询列表</td></tr><tr><td>Set-Cookie</td><td style="text-align:center">安全响应：设置cookie</td></tr><tr><td>WWW-Authenticate</td><td style="text-align:center">安全响应：服务器对客户端的质询列表</td></tr></tbody></table><h3 id="实体首部"><a href="#实体首部" class="headerlink" title="实体首部"></a>实体首部</h3><p>用于对应主体部分的首部</p><table><thead><tr><th>首部</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>Content-Type</td><td style="text-align:center">主体类型</td></tr><tr><td>Content-Length</td><td style="text-align:center">主体长度或尺寸</td></tr><tr><td>Content-Location</td><td style="text-align:center">资源实际所处位置</td></tr><tr><td>Content-Encoding</td><td style="text-align:center">主体编码方式</td></tr><tr><td>Content-MD5</td><td style="text-align:center">主体MD5校验和</td></tr><tr><td>Content-Base</td><td style="text-align:center">相对URL的基URL</td></tr><tr><td>Last-Modified</td><td style="text-align:center">实体最后一次被修改的时间</td></tr><tr><td>Expires</td><td style="text-align:center">实体过期，要从源端再次获取时间与日期</td></tr></tbody></table><h1 id="连接："><a href="#连接：" class="headerlink" title="连接："></a>连接：</h1><h2 id="Connection首部"><a href="#Connection首部" class="headerlink" title="Connection首部"></a>Connection首部</h2><p>  浏览器与服务器之间，可以经过很多层代理，整个连接被分成了好多块小的连接。Connection首部由一个逗号分隔的标签列表，这些标签指定了在小连接之间的选项，不会传播到其它小连接上去。<br>  接收端接收到Connection首部时，首先会解析这些选线，并将其应用。然后在此报文转发给下一跳之前，删除Connection首部及列表中的所有首部。</p><p>  http首部字段名标签包括：<br>  Http首部字段名，列出只与此连接相关的首部<br>  任意标签值，用于描述此连接的非标准选项<br>  close，说明操作完成之后需关这条连接。</p><h2 id="串行加载"><a href="#串行加载" class="headerlink" title="串行加载"></a>串行加载</h2><p><img src="串行连接.png" alt="test"><br>如上图，一个网页有3个图片，串行加载需要4个http事物来显示页面，每个事物都需要建立一个新的连接，这样整个网页加载的速度就会累加起来。</p><h2 id="并行连接"><a href="#并行连接" class="headerlink" title="并行连接"></a>并行连接</h2><p><img src="并行连接.png" alt="test"><br>如图，并行连接就是并发4个连接去请求资源，这样加载速度就会提升。<br>并行连接受到带宽、内存的影响，会引起很多问题。<br>一般浏览器确实使用并行连接，但连接数会很小（通常4个）。</p><h2 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h2><p><img src="并行连接.png" alt="test"><br>如图，持久连接就是4个资源在一个连接中去请求，这样就避免了重新建立连接带来的延时。</p><ul><li><p>Keep-Alive操作<br>客户端通过Connection:Keep-Alive首部请求持久连接<br>服务器如果愿意建立持久连接，就在相应首部中返回Connection:Keep-Alive，反之没有<br>客户端若接收到Keep-Alive，则建立持久连接，反之就会关闭连接。</p></li><li><p>哑代理<br><img src="哑连接.png" alt="test"><br>哑代理就是一些老代理，他们不支持持久连接，而且会转发所有的首部，包括Connection:Keep-Alive。这样就造成浏览器与服务器都认为可以建立持久连接，而哑代理却忽略与客户端连接上的再次请求(半关闭)，造成持久连接失败。</p><p>一种解决方案：Proxy-Connection。这里就不展开了，这种方案也存在问题，仅当服务器与浏览器之间存在一个代理时可用。反之不可。</p></li><li><p>http/1.1持久连接<br>http/1.1用Persistent Connection来代替Keep-Alive.Http/1.1持久连接在默认情况下是激活的，需要关闭时显示添加Connection:close首部来关闭。</p></li></ul><h2 id="管道化连接"><a href="#管道化连接" class="headerlink" title="管道化连接"></a>管道化连接</h2><p><img src="管道化持久连接.png" alt="test"><br>HTTP/1.1允许在建立可选的请求管道。在相应到达之前，经多条请求放入发送队列。</p><ul><li><p>连接关闭<br>任何一种技术都会有其要解决的问题，也有其带来的问题，如管道连接。管道连接带来的问题是由于服务器可以随意关闭连接，客户端发送出的连接还未到达，连接就关闭了，这样就造成了客户端并不知道发送的数据到了没有。另外服务器永远无法确定在关闭“空闲”连接那一刻，在线路另一端有没有数据要发送。<br>这个挺费解的，tcp关闭是4次握手，一端关闭会发送关闭，等待ack后才进入半关闭状态？</p><p>每条HTTP响应都应有精确的Content-Length首部。这样接收端可以根据若实体长度与Content-Length匹配来确定连接是否完成。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;报文协议基础&quot;&gt;&lt;a href=&quot;#报文协议基础&quot; class=&quot;headerlink&quot; title=&quot;报文协议基础&quot;&gt;&lt;/a&gt;报文协议基础&lt;/h1&gt;
    
    </summary>
    
      <category term="数据" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>http识别、认证</title>
    <link href="http://yoursite.com/2018/07/17/http%E8%AF%86%E5%88%AB%E3%80%81%E8%AE%A4%E8%AF%81/"/>
    <id>http://yoursite.com/2018/07/17/http识别、认证/</id>
    <published>2018-07-17T10:35:33.383Z</published>
    <updated>2018-07-17T10:35:33.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="客户端识别"><a href="#客户端识别" class="headerlink" title="客户端识别"></a>客户端识别</h1><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>无状态<br>HTTP最初是一个匿名、无状态的请求/响应协议。服务器处理来自客户的请求，然后向客户回送一条响应。web服务器几乎没有什么信息可以判断是哪个用户发送的请求，也无法记录访问用户的请求序列。</li><li><p>有状态<br>现在，他们需要对客户端有更多的了解，并在用户浏览页面时，对其进行跟踪。<br>如今一般在用的技术有：用户登录、胖url、cookie（ip技术已经基本淘汰）</p><h2 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h2><p>早期开发者曾尝试将客户端的ip地址作为一种标识形式使用。web服务器可以找到http对应的tcp连接，调用类似与getpeername(tcp_socket,…)函数来获取ip</p></li><li><p>存在问题：<br>1.ip记录的是机器，而不是用户，在多人共享一台机器时就无法区分。<br>2.动态分配ip</p><ol start="3"><li>NAT防火墙会隐藏后边那些实际客户端的ip</li><li>代理的存在，web服务看到的是代理的ip<h2 id="用户登录：Authorization首部，即认证"><a href="#用户登录：Authorization首部，即认证" class="headerlink" title="用户登录：Authorization首部，即认证"></a>用户登录：Authorization首部，即认证</h2></li></ol></li><li>用户访问服务器</li><li>服务器返回401</li><li>浏览器显示登录框</li><li>在请求时用Authorization首部在下一条对服务器请求提供这些信息<br>这个部分就是基本认证部分：<br>[[../image/http/基本认证.png]]</li></ul><h2 id="胖url"><a href="#胖url" class="headerlink" title="胖url"></a>胖url</h2><ul><li><p>web服务器为每个用户生成特定版本的URL来追踪用户的身份。通常会对真正的URL进行扩展，在URL路径结束的地方添加一些状态信息。用户浏览网页时，web服务器动态生成一些超连接，继续维护URL中的状态信息。</p></li><li><p>存在问题：<br>丑陋的url<br>无法共享URL，共享时可能泄密<br>破坏缓存，不再有可供公共访问的url需要缓存<br>额外的服务器负荷</p></li></ul><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><ul><li><p>cookie如何工作<br>[[../image/http/cookie.png]]<br>首次访问时，web服务器给用户“拍上”一个独有的cookie，浏览器记住服务器返回Set-Cookie首部中cookie内容，并将cookie存储在浏览器的cookie数据库中。将来用户访问同一站点时，浏览器会挑中那个服务器用户上的cooike，将其传送回去。</p></li><li><p>cookie组成<br>网景的cookie会将cookie存在一个cookies.txt文本文件中如：<br>| 名称       | 值            | 说明                           |<br>| domain     | <a href="http://www.fedex.com" target="_blank" rel="noopener">www.fedex.com</a> | 域                             |<br>| allh       | FALSE         | 是域中所有的主机都获取cookie？ |<br>| path       | /             | 域中与cookie相关的路径前缀     |<br>| secure     | FALSE         | 是否只有SSL才发送这个cookie    |<br>| expiration | 1136109676    | 过期时间间隔                   |<br>| name       | cc            | cookie变量的名字               |<br>| value      | /us/          | cookie变量的值                 |</p><p>domain:<br>告诉浏览器，只有往这个域访问时才使用此cookie<br>set-cookie: user=”mary17”; domain=”airtravelbargains.com”</p><p>path:<br>告诉浏览器，只有往域的这个路径访问时，才是有此cookie<br>set-cookie: user=”mary17”; domain=”airtravelbargains.com”; path=/autos/</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;客户端识别&quot;&gt;&lt;a href=&quot;#客户端识别&quot; class=&quot;headerlink&quot; title=&quot;客户端识别&quot;&gt;&lt;/a&gt;客户端识别&lt;/h1&gt;
    
    </summary>
    
      <category term="数据" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
</feed>
