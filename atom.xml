<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>思 见</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-06T07:01:53.743Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>sun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js构建工具</title>
    <link href="http://yoursite.com/2019/05/05/js%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2019/05/05/js构建工具/</id>
    <published>2019-05-05T14:45:39.000Z</published>
    <updated>2019-05-06T07:01:53.743Z</updated>
    
    <content type="html"><![CDATA[<p>前一段时间搭建Isomorphic过程中，对js的构建工具接触比较多，也做了一些记录但都不够系统，这里对接触的构建工具做一些较系统的整理，包括：webpack、gulp、babel</p><a id="more"></a>  <h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><ul><li><p>webpack的用途<br>webpack是一个打包工具，打包又是为什么呢？对于前端，用react写了很多组件，如果直接编译成js会有很多的文件，也就需要很多的script来做引用，这样会极为不方便，webpack就是自动的寻找依赖关系，将这些文件打包到一起的工具。<br>起初它只做这个，这样对于非js的文件就不太好处理，这样它通过自己的插件（loader）来对这些非js文件进行支持。这样对于css、ts、stylus等文件，都可以通过webpack来进行处理了。</p></li><li><p>webpack基本概念</p><p>  <a href="https://webpack.js.org/concepts#loaders" target="_blank" rel="noopener">原文</a><br>  4大概念：Entry、Output、Loaders、Plugins</p><ul><li><p>Entry:<br>An entry point indicates which module webpack should use to begin building out its internal dependency graph. webpack will figure out which other modules and libraries that entry point depends on</p></li><li><p>Output:<br>The output property tells webpack where to emit the bundles it creates and how to name these files  </p></li><li><p>Loaders:<br>Out of the box, webpack only understands JavaScript and JSON files. Loaders allow webpack to process other types of files and convert them into valid modules that can be consumed by your application and added to the dependency graph.  </p></li><li><p>Plugins:<br>While loaders are used to transform certain types of modules, plugins can be leveraged to perform a wider range of tasks like bundle optimization, asset management and injection of environment variables.</p></li></ul></li><li><p>使用<br>对于Ts与stylus的loader配置如下:</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123; </span><br><span class="line">            test: /\.tsx$/, </span><br><span class="line">            use: ['awesome-typescript-loader'],</span><br><span class="line">            exclude: /node_modules/</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            test: /\.styl$/,</span><br><span class="line">            use: [ </span><br><span class="line">                &#123;</span><br><span class="line">                    loader: 'style-loader'</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    loader: 'css-loader',</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        modules: true</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    loader: 'stylus-loader'</span><br><span class="line">                &#125; </span><br><span class="line">            ],</span><br><span class="line">            exclude: /node_modules/</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>其他<br>webpack像是一个家族，对于同构它们提供webpack-isomorphic-tools，但在gitlab库的说明上： It allowed many projects to set up basic isomorphic (universal) rendering in the early days but is now considered deprecated and new projects shouldn’t use it. This library can still be found in legacy projects. For new projects use either universal-webpack or all-in-one frameworks like Next.js.</p></li></ul><h1 id="gulp"><a href="#gulp" class="headerlink" title="gulp"></a>gulp</h1><ul><li><p>gulp的用途<br>gulp是一个流式任务运行器，换句话说，我们通过命令行执行的操作，可以通过gulp定义成任务，然后对任务进行编排（指定运行顺序）、运行。<br>gulp的任务执行，从触发方式上看可以是手动执行，也可以通过watch检测文件变化自动执行。</p></li><li><p>gulp基本概念<br><a href="https://www.gulpjs.com.cn/docs/api/" target="_blank" rel="noopener">原文</a><br>输出（Emits）符合所提供的匹配模式（glob）或者匹配模式的数组（array of globs）的文件。 将返回一个 Vinyl files 的   stream 它可以被 piped 到别的插件中。</p><ul><li><p>pipe<br>管道，任务流</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gulp.src(<span class="string">'client/templates/*.jade'</span>)</span><br><span class="line">.pipe(jade())</span><br><span class="line">.pipe(minify())</span><br><span class="line">.pipe(gulp.dest(<span class="string">'build/minified_templates'</span>));</span><br></pre></td></tr></table></figure></li><li><p>task<br>这里采用的是函数编程范式  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">'somename'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> stream = gulp.src(<span class="string">'client/**/*.js'</span>)</span><br><span class="line">    .pipe(minify())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'build'</span>));</span><br><span class="line"><span class="keyword">return</span> stream;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>任务编排：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个 callback，因此系统可以知道它什么时候完成</span></span><br><span class="line">gulp.task(<span class="string">'one'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 做一些事 -- 异步的或者其他的</span></span><br><span class="line">    cb(err); <span class="comment">// 如果 err 不是 null 或 undefined，则会停止执行，且注意，这样代表执行失败了</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个所依赖的 task 必须在这个 task 执行之前完成</span></span><br><span class="line">gulp.task(<span class="string">'two'</span>, [<span class="string">'one'</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 'one' 完成后</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'one'</span>, <span class="string">'two'</span>]);</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>watch<br>监视文件变化  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> watcher = gulp.watch(<span class="string">'js/**/*.js'</span>, [<span class="string">'uglify'</span>,<span class="string">'reload'</span>]);</span><br><span class="line">watcher.on(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'File '</span> + event.path + <span class="string">' was '</span> + event.type + <span class="string">', running tasks...'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>其他<br>gulp其实也提供了一些插件，比如<code>gulp-typescript</code>，可以Ts直接编译成js，它与webpack中的ts-loader应该有类似的作用，只不过webpack中将所有的文件都打包到一起了。</p></li></ul><h1 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h1><ul><li><p>babel的用途<br>babel是转码器，这个转码器是将不同版本的js进行转换。目前有的浏览器并不支持 ES6，而我们又用ES6来编码，那就用babel进行处理，自动转换成相应的版本。<br>而且babel支持React的JSX语法转换，对于Ts，babel也有所支持，比如退去所有的annotation，以及类型  </p></li><li><p>使用<br><a href="https://babeljs.io/docs/en/" target="_blank" rel="noopener">官方文档</a><br>babel部分摘自：<a href="http://www.ruanyifeng.com/blog/2016/01/babel.html" target="_blank" rel="noopener">阮一峰：Babel 入门教程</a>  </p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 转码结果输出到标准输出</span></span><br><span class="line">$ babel example.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转码一个文件：--out-file 或 -o 参数指定输出文件</span></span><br><span class="line">$ babel example.js --out-file compiled.js</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">$ babel example.js -o compiled.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转码整个目录： --out-dir 或 -d 参数指定输出目录</span></span><br><span class="line">$ babel src --out-dir lib</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">$ babel src -d lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># -s 参数生成source map文件</span></span><br><span class="line">$ babel src -d lib -s</span><br></pre></td></tr></table></figure></li><li><p>babel全家桶  </p><ul><li><p>babel-cli<br>上文使用cli运行，需要安装babel-cli：<code>npm install --global babel-cli</code></p></li><li><p>babel-core<br>我们在用的使用更多的是通过gulp来调用，就需要babel-core，<code>npm install babel-core --save</code>  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> babel = <span class="built_in">require</span>(<span class="string">'babel-core'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串转码</span></span><br><span class="line">babel.transform(<span class="string">'code();'</span>, options);</span><br><span class="line"><span class="comment">// =&gt; &#123; code, map, ast &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件转码（异步）</span></span><br><span class="line">babel.transformFile(<span class="string">'filename.js'</span>, options, <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">result; <span class="comment">// =&gt; &#123; code, map, ast &#125;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件转码（同步）</span></span><br><span class="line">babel.transformFileSync(<span class="string">'filename.js'</span>, options);</span><br><span class="line"><span class="comment">// =&gt; &#123; code, map, ast &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>babel-polyfill<br>Babel默认只转换新的JavaScript句法（syntax），而不转换新的API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。 在使用上，就需要babel-ployfill来完成对这些内容的支持。</p><p>安装：<br><code>npm install --save babel-polyfill</code></p><p>在脚本的头部，加入：<br><code>import &#39;babel-polyfill&#39;</code>;</p></li></ul></li></ul><h1 id="webpack-isomorphic-tools"><a href="#webpack-isomorphic-tools" class="headerlink" title="webpack-isomorphic-tools"></a>webpack-isomorphic-tools</h1><ul><li><p>前言<br>在搭建同构应用中，几次都遇到这个工具，在这里对这个工具进行一个整理  </p></li><li><p>webpack-isomorphic-tools的用途<br>webpack做的事情，是将文件进行打包，方便浏览器去获取原本这些分散的js，但对于isomorphic，事情变的不同。node.js的后端并不需要webpack打包，而不经过打包，对于有些类型的文件(图片类、CSS类)，后端没法直接支持。这也正是在前面<a href="https://sunyanfeng.cn/2019/04/14/SSR%E3%80%81CSR%E4%B8%8E%E5%90%8C%E6%9E%84/#more" target="_blank" rel="noopener">SSR、CSR与同构</a>中对stylus文件处理时遇到的问题。</p><p><a href="https://github.com/catamphetamine/webpack-isomorphic-tools#api" target="_blank" rel="noopener">官网</a>  </p></li><li><p>使用  </p><ul><li><p>安装<br>npm install webpack-isomorphic-tools –save</p></li><li><p>将<code>webpack-isomorphic-tools</code>嵌入webpack的配置中  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> WebpackIsomorphicToolsPlugin = <span class="built_in">require</span>(<span class="string">'webpack-isomorphic-tools/plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> webpackIsomorphicToolsPlugin = </span><br><span class="line"><span class="comment">// webpack-isomorphic-tools settings reside in a separate .js file </span></span><br><span class="line"><span class="comment">// (because they will be used in the web server code too).</span></span><br><span class="line"><span class="keyword">new</span> WebpackIsomorphicToolsPlugin(<span class="built_in">require</span>(<span class="string">'./webpack-isomorphic-tools-configuration'</span>))</span><br><span class="line"><span class="comment">// also enter development mode since it's a development webpack configuration</span></span><br><span class="line"><span class="comment">// (see below for explanation)</span></span><br><span class="line">.development()</span><br><span class="line"></span><br><span class="line"><span class="comment">// usual Webpack configuration</span></span><br><span class="line"><span class="built_in">module</span>.exports =</span><br><span class="line">&#123;</span><br><span class="line">context: <span class="string">'(required) your project path here'</span>,</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>:</span><br><span class="line">&#123;</span><br><span class="line">    loaders:</span><br><span class="line">    [</span><br><span class="line">    ...,</span><br><span class="line">    &#123;</span><br><span class="line">        test: webpackIsomorphicToolsPlugin.regularExpression(<span class="string">'images'</span>),</span><br><span class="line">        loader: <span class="string">'url-loader?limit=10240'</span>, <span class="comment">// any image below or equal to 10K will be converted to inline base64 instead</span></span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">plugins:</span><br><span class="line">[</span><br><span class="line">    ...,</span><br><span class="line"></span><br><span class="line">    webpackIsomorphicToolsPlugin</span><br><span class="line">]</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官网在这里也说明了一下为什么要.development()。对于开发模式，它让asset缓存失效，而让asset hot reload使能。</p></li><li><p>isomorphic自己的配置文件：webpack-isomorphic-tools-configuration.js  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> WebpackIsomorphicToolsPlugin <span class="keyword">from</span> <span class="string">'webpack-isomorphic-tools/plugin'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span></span><br><span class="line">&#123;</span><br><span class="line">  assets:</span><br><span class="line">  &#123;</span><br><span class="line">    images:</span><br><span class="line">    &#123;</span><br><span class="line">      extensions: [<span class="string">'png'</span>, <span class="string">'jpg'</span>, <span class="string">'gif'</span>, <span class="string">'ico'</span>, <span class="string">'svg'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>服务端运行入口 main.js配置  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> WebpackIsomorphicTools = <span class="built_in">require</span>(<span class="string">'webpack-isomorphic-tools'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// this must be equal to your Webpack configuration "context" parameter</span></span><br><span class="line"><span class="keyword">var</span> projectBasePath = <span class="built_in">require</span>(<span class="string">'path'</span>).resolve(__dirname, <span class="string">'..'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// this global variable will be used later in express middleware</span></span><br><span class="line">global.webpackIsomorphicTools = <span class="keyword">new</span> WebpackIsomorphicTools(<span class="built_in">require</span>(<span class="string">'./webpack-isomorphic-tools-configuration'</span>)  )</span><br><span class="line">.server(projectBasePath, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// webpack-isomorphic-tools is all set now.</span></span><br><span class="line">  <span class="comment">// here goes all your web application code:</span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./server'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>后端渲染页面  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// clear require() cache if in development mode</span></span><br><span class="line"><span class="comment">// (makes asset hot reloading work)</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>)</span><br><span class="line">&#123;</span><br><span class="line">    webpackIsomorphicTools.refresh()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for react-router example of determining current page by URL take a look at this:</span></span><br><span class="line"><span class="keyword">const</span> pageComponent = [determine your page component here using request.path]</span><br><span class="line"></span><br><span class="line"><span class="comment">// render the page to string and send it to the browser as text/html</span></span><br><span class="line">response.send(<span class="string">'&lt;!doctype html&gt;\n'</span> +</span><br><span class="line">        React.renderToString(&lt;Html assets=&#123;webpackIsomorphicTools.assets()&#125; component=&#123;pageComponent&#125; /&gt;))</span><br></pre></td></tr></table></figure><p>这里它传了fluxstore，在我们那并没有引入，故这个可以不用</p></li><li><p>Html中的使用<br>Html中接收传入的assets const { assets, component, store } = this.props<br>然后从asset中去获取资源，即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> picture = <span class="built_in">require</span>(<span class="string">'../assets/images/cat.jpg'</span>)</span><br><span class="line"><span class="keyword">const</span> icon = <span class="built_in">require</span>(<span class="string">'../assets/images/icon/32x32.png'</span>)</span><br></pre></td></tr></table></figure><p>在header中，也可有直接去引入styles  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="comment">/* styles (will be present only in production with webpack extract text plugin) */</span>&#125;</span><br><span class="line">&#123;<span class="built_in">Object</span>.keys(assets.styles).map(<span class="function">(<span class="params">style, i</span>) =&gt;</span></span><br><span class="line">&lt;link href=&#123;assets.styles[style]&#125; key=&#123;i&#125; media=<span class="string">"screen, projection"</span></span><br><span class="line">        rel=<span class="string">"stylesheet"</span> type=<span class="string">"text/css"</span>/&gt;)&#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="comment">/* resolves the initial style flash (flicker) on page load in development mode */</span>&#125;</span><br><span class="line">&#123; <span class="built_in">Object</span>.keys(assets.styles).length === <span class="number">0</span> ? &lt;style dangerouslySetInnerHTML=&#123;&#123;__html: require('../assets/styles/main_style.css')&#125;&#125;/&gt; : null &#125;</span><br></pre></td></tr></table></figure><p>asserts是由webpack-isomorphic-tools创建的webpack-asset.json中的内容 </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"javascript"</span>:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"main"</span>: <span class="string">"/assets/main-d8c29e9b2a4623f696e8.js"</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="attr">"styles"</span>:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"main"</span>: <span class="string">"/assets/main-d8c29e9b2a4623f696e8.css"</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="attr">"assets"</span>:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"./assets/images/cat.jpg"</span>: <span class="string">"http://localhost:3001/assets/9059f094ddb49c2b0fa6a254a6ebf2ad.jpg"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>推荐阅读：<a href="http://www.siguoya.name/pc/home/article/271" target="_blank" rel="noopener">思过崖</a>  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一段时间搭建Isomorphic过程中，对js的构建工具接触比较多，也做了一些记录但都不够系统，这里对接触的构建工具做一些较系统的整理，包括：webpack、gulp、babel&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>产品反思</title>
    <link href="http://yoursite.com/2019/05/04/%E4%BA%A7%E5%93%81%E5%8F%8D%E6%80%9D/"/>
    <id>http://yoursite.com/2019/05/04/产品反思/</id>
    <published>2019-05-04T02:10:39.000Z</published>
    <updated>2019-05-04T03:50:30.185Z</updated>
    
    <content type="html"><![CDATA[<p>整个4月大部分时间都处在产品重构的思考与设计中，牺牲了一些正在坚持的习惯，一方面是时间紧张，另一方面自己很大的精力都投入在这些思考与设计中，没有分心的心思。作为一个由设计到开发的转折点，我觉得有必要对这个过程进行一些反思。</p><a id="more"></a><h1 id="开场白"><a href="#开场白" class="headerlink" title="开场白"></a>开场白</h1><p>回顾4月，先是产品的定位的思考，包括其提供给用户的核心价值。后又用了不太到2个周的时间，对前端的框架进行了探索，包括SPA与MPA、SSR与CSR与同构。后来产品设计、架构设计尤其后端服务的拆分通信、最后对界面进行了讨论与设计。下面反思一下整个过程，一方面为了总结经验，另一方面通过回顾也找一下不足与提升空间。</p><h1 id="产品设计"><a href="#产品设计" class="headerlink" title="产品设计"></a>产品设计</h1><p>产品本身是一个重构，并不是完全从无到有去设计一个产品。从旧的产品中，发现了一些不足。这些不足表现为：  </p><ul><li>原产品中，最初的想法是将项目管理整个从线下搬到线上，这个出发点没有具体表达出产品的核心价值;  </li><li>项目管理是一个整体，同时整体搬迁到线上的难度很高，可行性差;  </li><li>原产品中，虽然有很多角色，但对这些角色如何使用产品，并没有进行设计;  </li><li>原系统中，功能开发出来，但这个功能本身能为用户提供什么帮助，或者设想用户怎么使用并没有思考清楚;  </li></ul><p>所以这次的重构，超越了代码层面、服务架构，是一个从旧产品中重新构思新产品的过程。这个过程：  </p><ul><li><p>首先是归纳了旧产品的价值，提出了3个核心价值：控制、协同、知识。<br>控制指的是项目管理者，对项目进度、产值、成本的控制<br>协同指的是项目成员为完成项目所进行的沟通、交互、审核、汇报等协同<br>知识指的是由数据涌现的对工程的计划、施工、设计等的辅助功能、预警功能  </p></li><li><p>接着制定了3个使用场景<br>第一个场景是控制场景，其包括4种角色，这4种角色以什么样的工作流程、什么样的操作来使用系统，使用后为各角色以及整体产生怎样的价值<br>第二个场景是协同场景，业务上是一个用料申请的场景，这个场景本身其实可以分成4个子场景，每个子场景都是一种用料申请，每个子场景中，都是一种1v1的交互<br>第三个场景也是协同场景，是一个巡查的场景，涉及2个人物也是1v1的交互  </p></li><li><p>从场景中抽象功能<br>从第一场景开始，想象每个角色需要如何使用产品，为了满足其需要，系统要提供什么的功能<br>借鉴旧系统，将这些功能分解、聚合这也就就自然过度到了服务设计  </p></li></ul><h1 id="服务设计"><a href="#服务设计" class="headerlink" title="服务设计"></a>服务设计</h1><p>这里的服务指的是业务层微服务的设计，不能算是整个系统架构的设计。<br>服务的设计过程中，是根据功能分解、聚合之后的结构，尽量达到高内聚，低耦合。另外，一些公共的业务低相关度的功能抽离到独立的微服务中完成<br>后来发现，业务服务竟然大约可以与角色相对应，很大程度上达到的多租户的隔离方式。<br>服务间的通信，大部分采用消息队列来做事件驱动，一部分采用通过redis来共享数据，最小的一部分采用Restful的方式来调用。<br>这种业务服务设计，由于用户的使用频率不同，对应的服务的流量要求就不同，部署的使用也就要有所差异，当然后边可以通过整个架构的监控、devops等设施来完成</p><h1 id="交互设计与界面"><a href="#交互设计与界面" class="headerlink" title="交互设计与界面"></a>交互设计与界面</h1><p>交互的设计上也对比着旧系统，旧系统的组织方式是以部分来划分，原本是可以的，但存在的问题是，现有情况多个部门对于主要的个功能的要求相同，造成前端好几处写了多遍。<br>在这次设计中，并不是从上而下的设计方式，是根据功能使用，自下而上的设计，即先想这个小场景中的功能，应该如何表达，然后画出草图，全部场景设计完全后，将他们聚合在一起的方式。<br>整个设计过程也与队友进行过多次讨论，吸取了他们的意见。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>由产品核心价值定义产品使用场景  </li><li>由产品使用场景定义需求  </li><li>由需求来定义功能，由功能定义业务服务  </li><li>同样由产品使用场景定义交互  </li><li>产品的使用场景亦可以验证交互与需求  </li></ul><p>除此之外，本次的产品，很大程度上是借鉴了旧产品，这方面的空间还有很多，比如现场管理分析、各用户分析，比如竞品分析等</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整个4月大部分时间都处在产品重构的思考与设计中，牺牲了一些正在坚持的习惯，一方面是时间紧张，另一方面自己很大的精力都投入在这些思考与设计中，没有分心的心思。作为一个由设计到开发的转折点，我觉得有必要对这个过程进行一些反思。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Matrix PositivDefinite</title>
    <link href="http://yoursite.com/2019/05/03/Matrix-PositiveDefinite/"/>
    <id>http://yoursite.com/2019/05/03/Matrix-PositiveDefinite/</id>
    <published>2019-05-03T14:02:34.000Z</published>
    <updated>2019-05-04T01:57:37.684Z</updated>
    
    <content type="html"><![CDATA[<p>本部分主要研究的是正定，课程包括Lesson25~Lesson28<br>包括：Symmetric matrices and positive definite­ness、Complex matrices and fast Fourier transform、Positive definite matrices and minima、Similar matrices and Jordan form</p><a id="more"></a><h1 id="对称矩阵与正定"><a href="#对称矩阵与正定" class="headerlink" title="对称矩阵与正定"></a>对称矩阵与正定</h1><h2 id="对称矩阵的性质"><a href="#对称矩阵的性质" class="headerlink" title="对称矩阵的性质"></a>对称矩阵的性质</h2><p>A = A<sup>T</sup></p><p>性质：  </p><ul><li>the eigenvalues are real</li><li>the eigenvector are perpendicular even orthonormal</li></ul><p>由此，若A对称，则 A =Q Λ Q<sup>−1</sup> = Q Λ Q<sup>T</sup></p><p>why real eigenvalues?<br>证明思路是从：AX = λX开始，一方面都取共轭，另一方面将原式乘以X的共轭，通过变换，得到λ = λ共轭，得证</p><p>Symmetric matrices with real entries have A =A<sup>T</sup>,  real eigenvalues, and perpendicular eigenvectors.<br>If A has complex entries, then it  will have real eigenvalues and perpendicular eigenvectors if and only if <img src="共轭转置.png" alt="共轭转置"></p><h2 id="对阵矩阵的解释"><a href="#对阵矩阵的解释" class="headerlink" title="对阵矩阵的解释"></a>对阵矩阵的解释</h2><p>A = Q Λ Q<sup>T</sup><br>Q = [q<sub>1</sub>, q<sub>2</sub>… q<sub>n</sub>]<br>展开后得到A = λ<sub>1</sub>q<sub>1</sub>q<sub>1</sub><sup>T</sup> + λ<sub>2</sub>q<sub>2</sub>q<sub>2</sub><sup>T</sup> +…+ λ<sub>n</sub>q<sub>n</sub>q<sub>n</sub><sup>T</sup></p><p>由于q正交，所以q<sub>1</sub>q<sub>1</sub><sup>T</sup>其实是投影矩阵，如此得到，每一个对称阵，其实都是投影的组合。</p><h2 id="关于特征值的符号"><a href="#关于特征值的符号" class="headerlink" title="关于特征值的符号"></a>关于特征值的符号</h2><p>number of positive pivots = number of positive eigenvalues.<br>主元的符号与特征值的符号相同</p><h2 id="正定的定义"><a href="#正定的定义" class="headerlink" title="正定的定义"></a>正定的定义</h2><p>A positive definite matrix is a symmetric matrix A for which all eigenvalues are positive.正定矩阵是所有特征值都是正数的对称矩阵。</p><p>=&gt;  </p><ul><li>所有特征值都是正数  </li><li>所有主元都是正数  </li><li>所有的子行列式(1<em>1,2</em>2..n*n形成的行列式)都是正数</li></ul><h1 id="复数矩阵与FFT"><a href="#复数矩阵与FFT" class="headerlink" title="复数矩阵与FFT"></a>复数矩阵与FFT</h1><h2 id="复数矩阵的特性"><a href="#复数矩阵的特性" class="headerlink" title="复数矩阵的特性"></a>复数矩阵的特性</h2><p>  对于复数向量，取转置运算要变成取共轭转置，或者交Hermite，简写H</p><ul><li><p>复向量的长度<br><img src="复向量长度.png" alt="复向量长度"><br><img src="Hermite.png" alt="Hermite"></p></li><li><p>内积<br>y<sup>T</sup>x =&gt; y<sup>H</sup>x</p></li><li><p>正交<br>Q<sup>H</sup>Q = I，这时候正交Orthogonal 要用 unitary来表达，单位化。</p></li></ul><h2 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h2><ul><li><p>基础形式<br><img src="傅里叶变换1.png" alt="傅里叶变换1"></p></li><li><p>复数矩阵形式<br><img src="傅里叶变换2.png" alt="傅里叶变换2"><br><img src="w定义.png" alt="w定义"></p></li><li><p>n=4例子<br><img src="F4.png" alt="F4"><br><img src="F4结论.png" alt="F4结论">  </p></li></ul><h2 id="FFT"><a href="#FFT" class="headerlink" title="FFT"></a>FFT</h2><p>FFT将傅里叶计算从n<sup>2 =&gt; nlogn  </sup></p><p><img src="FFT.png" alt="FFT"><br>其中<img src="P.png" alt="P">,其作用是将奇数行拿到偶数行的前面<br><img src="D.png" alt="D">  </p><h1 id="正定矩阵性质"><a href="#正定矩阵性质" class="headerlink" title="正定矩阵性质"></a>正定矩阵性质</h1><ul><li><p>最小值<br>对于正定，除了，特征值&gt;0，主元&gt;0，子行列式&gt;0，还有一个X<sup>T</sup>AX &gt; 0<br><img src="正定分析.png" alt="正定分析"><br>如果二次方程一定 &gt; 0，则A正定</p><p><img src="非正定.png" alt="非正定"><br><img src="正定.png" alt="正定">  </p><p>由此得出，正定 =&gt; 有最小值</p><p><img src="Hessian矩阵.png" alt="Hessian矩阵"><br>首先它是对阵的，Its determinant is positive when the matrix is positive definite</p><p><img src="正定多维推广.png" alt="正定多维推广"><br>一个多维的向上的碗，而且全是正的</p></li><li><p>加法<br>if A,B 正定  =&gt; A+B正定</p></li><li><p>推论<br>A<sup>T</sup>A 一定正定， 这里A是m×n 且 rank(A) = n 的矩阵<br>应为其多项式：<img src="正定的一个推理.png" alt="正定的一个推理"></p></li></ul><h1 id="相似矩阵与Jordan式"><a href="#相似矩阵与Jordan式" class="headerlink" title="相似矩阵与Jordan式"></a>相似矩阵与Jordan式</h1><ul><li><p>定义<br>对于A，B两个矩阵，若A = M<sup>-1</sup>BM，则A、B相似</p></li><li><p>性质<br>相似矩阵，拥有相同的特征值，相同数量的独立特征向量（一般不同）</p></li><li><p>重特征值问题<br>以λ<sub>1</sub> = λ<sub>2</sub> = 4 为例<br>可以分成两个famliy:  </p><ol><li><img src="重特征值-1.png" alt="重特征值-1">,这一族比较大  </li><li><img src="重特征值-2.png" alt="重特征值-2">，这一族只有这一个矩阵，因为它与任何M相乘都会返回自身  </li></ol></li><li><p>Jordan matrix<br>简单的说，对于重特征值问题，它们需要有相同的Jordan blocks的形式.<br><img src="Jordan-blocks.png" alt="Jordan-blocks"><br><img src="Jordan-blocks一般形式.png" alt="Jordan-blocks一般形式"><br>其中<img src="Jordan-blocks一般形式2.png" alt="Jordan-blocks一般形式2">，这里，对角线上都是特征值，下方都是0，上方跟随一层1.</p><p><img src="概括Jordan.png" alt="概括Jordan"><br>这样，不同的特征值情况可以认为是一种特殊的Jordan Matrix，它们的Jordan Block都是为1*1的特征值本身</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本部分主要研究的是正定，课程包括Lesson25~Lesson28&lt;br&gt;包括：Symmetric matrices and positive definite­ness、Complex matrices and fast Fourier transform、Positive definite matrices and minima、Similar matrices and Jordan form&lt;/p&gt;
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Matrix" scheme="http://yoursite.com/tags/Matrix/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>nest.js记录</title>
    <link href="http://yoursite.com/2019/05/03/nest%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/05/03/nest记录/</id>
    <published>2019-05-03T06:45:39.000Z</published>
    <updated>2019-05-03T10:59:26.185Z</updated>
    
    <content type="html"><![CDATA[<p>本文为理解nest.js而做记录，内容为官网中的基础部分，目的是为了理解、记忆，所以不会抄原文的例子。<br><a href="https://docs.nestjs.com/" target="_blank" rel="noopener">官网</a>  </p><a id="more"></a><h1 id="骨架"><a href="#骨架" class="headerlink" title="骨架"></a>骨架</h1><p>骨架部分主要介绍：Controllers、Providers、Modules，他们组成了nest应用的最基础部分，可以认为Route Handler部分</p><h2 id="Controllers"><a href="#Controllers" class="headerlink" title="Controllers"></a>Controllers</h2><ul><li><p>定义<br>Controllers are responsible for handling incoming requests and returning responses to the client.</p></li><li><p>路由<br>分层的定义方法，在类上定义的，被其下的方法所继承，如在类上定义<code>@Controller(&#39;customers&#39;)</code>，在类方法中定义<code>@Get(&#39;profile&#39;)</code>，则其路由为<code>GET /customers/profile</code></p></li><li><p>两种模式<br>一种是标准模式，也是推荐模式，通过nest的装饰器来使用各种参数;<br>另一种原生模式（Library-specific），通过@Res(),@Req()获取库原生的request与response对象，来直接进行操作。<br>这两种方式不能同时使用，当然nest推荐前者。</p></li><li><p>装饰器  </p><p>| 装饰器 | 介绍 |<br>|:——|:—-:|<br>|@Req() | 获取Request对象(express) |<br>|@Res() | 获取Response对象(express) |<br>|@Session() | 获取req.session |<br>|@Param(key?: string) | req.params / req.params[key],param是路由中的参数 |<br>|@Body(key?: string) | req.body / req.body[key] |<br>|@Query(key?: string) | req.query / req.query[key],query是?后的参数 |<br>|@Headers(name?: string) | req.headers / req.headers[name] |<br>|@HttpCode(201) | 指定response中的返回值 |</p></li></ul><h2 id="Providers"><a href="#Providers" class="headerlink" title="Providers"></a>Providers</h2><ul><li><p>定义<br>Many of the basic Nest classes may be treated as a provider – services, repositories, factories, helpers, and so on. A provider is simply a class annotated with an @Injectable() decorator  </p></li><li><p>理解<br>这里说的很明白的，provider可以理解成功能的提供者了,任何可以注入的类都可以认为是provider。原文中也说，provider不仅仅是@Injectable(),它可以是数值、类、同步或异步工厂(plain values, classes, and either asynchronous or synchronous factories)，这个在后边的Custom Provider中会做更多介绍  </p></li></ul><h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h2><ul><li><p>定义<br>A module is a class annotated with a @Module() decorator. The @Module() decorator provides metadata that Nest makes use of to organize the application structure.  </p></li><li><p>理解<br>Module要做一点解释，Nest是Module来组织的，不论是Controller还是Provider都需要注册到Module中才能被Nest托管。还有一点比较有趣的，在Module中可以imports其他Module，而imports的内容，其实是被引用Module中exports出的内容</p></li><li><p>属性<br>@Module装饰器接收一个对象，其属性包括</p><p>| 属性 | 介绍 |<br>|:——|:—-:|<br>| providers | 被Nest injector实例化的providers |<br>| controllers | 被Nest injector实例化的controllers |<br>| imports | 引入这些moludes export 的providers |<br>| exports | providers的子集，被其他模块可以import |</p></li></ul><h1 id="经脉"><a href="#经脉" class="headerlink" title="经脉"></a>经脉</h1><p>经脉介绍中间件(Middleware)、异常过滤器(Exception filters)、管道(Pipes)、哨兵(Guards)、拦截器(Interceptors)。我觉得广义上看，他们都可以被称为拦截器，他们要么在拦截request（Middleware,Pipe，Guard），要么在拦截response(Exception filter)，要么双方都拦截（Interceptors）。<br>它们有着类似的scope，包括：全局(global)、控制器（controller）、路由函数(router)，其实隐藏着模块（module）等范围</p><h2 id="Middleware"><a href="#Middleware" class="headerlink" title="Middleware"></a>Middleware</h2><ul><li><p>定义<br>Middleware is a function which is called before the route handler. Middleware functions have access to the request and response objects, and the next() middleware function in the application’s request-response cycle.<br><img src="middleware.png" alt="middleware"></p></li><li><p>理解<br>中间件常见的场景包括，Log，cors，helmet等，中间件的使用上，主要在routers,controllers,module范围内，原文中没有在全局使用中间件。</p></li></ul><h2 id="Exception-filters"><a href="#Exception-filters" class="headerlink" title="Exception filters"></a>Exception filters</h2><ul><li><p>定义<br>Nest comes with a built-in exceptions layer which is responsible for processing all unhandled exceptions across an application. When an exception is not handled by your application code, it is caught by this layer, which then automatically sends an appropriate user-friendly response.</p><p><img src="pipe与filter.png" alt="filter"></p></li><li><p>理解<br>从定义中可以看出，它是在request上，进行filter，当服务端有异常抛出，对异常进行捕获、处理，并返回给客户端。<br>异常过滤器4种使用方式都支持，这部分可以写一些异常处理的代码，定义好Exception 与 exception 与 filter，然后在代码中可以方便的抛异常了。</p><p><a href="https://docs.nestjs.com/exception-filters#exception-filters-1" target="_blank" rel="noopener">Exception filters</a></p></li></ul><h2 id="Pipes"><a href="#Pipes" class="headerlink" title="Pipes"></a>Pipes</h2><ul><li><p>定义<br>A pipe is a class annotated with the @Injectable() decorator. Pipes should implement the PipeTransform interface.<br>原文可能觉得pipe真不用定义了，所以也没有定义，就是函数编程范式pipe，其实跟中间件、拦截器都一样.<br><img src="pipe与filter.png" alt="pipe"></p></li><li><p>使用场景  </p><ul><li>transformation: transform input data to the desired output  </li><li>validation: evaluate input data and if valid, simply pass it through unchanged; otherwise, throw an exception when the data is incorrect</li></ul><p>就是数据转换与有效性检验。这一部分集成化比较高，通过class-validator and class-transformer可以直接使用ValidationPipe，ParseIntPipe了，支持4种使用方式</p></li></ul><h2 id="Guards"><a href="#Guards" class="headerlink" title="Guards"></a>Guards</h2><ul><li><p>定义<br>A guard is a class annotated with the @Injectable() decorator. Guards should implement the CanActivate interface.<br><a href="guard.png">guard</a><br>Guards have a single responsibility. They determine whether a given request will be handled by the route handler or not, depending on certain conditions (like permissions, roles, ACLs, etc.) present at run-time. This is often referred to as authorization。<br>在express中，认证由中间件来做，原文中有对为什么用guard而不用middleware的解释，大约就是middleware你需要控制next，并且不知道next的下一步是什么，而guard由于有执行环境（ExecutionContext），可以清楚的知道下一步执行什么。</p></li><li><p>理解<br>4种使用方式都支持。<br>这里使用了reflect，因为对于guard，它需要知道定义在每个router的角色<br><a href="https://docs.nestjs.com/guards#putting-it-all-together" target="_blank" rel="noopener">实例</a><br>这个部分要好好写一下，与原文中的例子略有不同，原文中认证的角色，我们要认证权限  </p></li></ul><h2 id="Interceptors"><a href="#Interceptors" class="headerlink" title="Interceptors"></a>Interceptors</h2><ul><li><p>定义<br>An interceptor is a class annotated with the @Injectable() decorator. Interceptors should implement the NestInterceptor interface.<br><img src="Interceptors.png" alt="Interceptors">  </p></li><li><p>理解<br>支持4种使用方式。通过next.handle()来调用主体，然后在pipe中对返回进行处理。在piple中可以对response进行处理，可以对异常进行处理等。<br>应用场景比如通过记录每个调用的入口、出口时间来计算响应时间，对response中数据的处理，对异常的处理等。<br>Interceptor可以对前后两端的处理，由于入口侧的验证、转换、认证都有特殊的解决方案了，所以我觉得它更注重出口侧一些，以及更注重业务逻辑一些。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 中间件的实现可能与其他略有不同，Exception filter，pipe,guard简直就是interception在各应用场景的细化。<br> 在使用上，需要对异常处理(Exception Filter)、参数验证(Pipe)、权限认证(Guard)、日志(Middleware/Interceptor)、监控(Interceptor)等，都可以用到.</p><h1 id="套路"><a href="#套路" class="headerlink" title="套路"></a>套路</h1><h2 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h2><p>这里的认证，并不是权限认证，而是主要是对客户端的认证，这里只记录jwt方式，认证主要使用Passport模块</p><ul><li><p>过程<br>客户端进行登录，后端核对完用户名、密码之后，创一个token给浏览器，浏览器之后在header(cookie与Authorization其实都行)中一直带着，来做http状态的认证。</p></li><li><p>理解<br>因为后端要验证用户名、密码，以及生成token，就需要一个Service来做这件事情，而passport本身支持‘bearer’,‘jwt’等不同策略，也就需要一个Strategy来解耦不同策略，而这个策略本身要依赖那个验证的Service。Strategy完成的是对token的解析，调用Service去验证，其统一的接口应该validate()函数。<br>在Strategy的使用上，即Strategy如何被nest使用，这里只能做一个推测，其通过Module的providers属性注入到nest中，nest在注册PassportModule时，自动将注册的Strategy注册到Passport当中，并完成jwt认证过程。<br>在使用上，通过Passport提供的AuthGuard来使用，这样就与Guard联系到了一起。</p><p>本质上讲，Passport也是一种Guard，更本质，就是一前置拦截器。</p></li></ul><h2 id="Database-ORM"><a href="#Database-ORM" class="headerlink" title="Database/ORM"></a>Database/ORM</h2><p>这里的ORM使用的TypeORM<br><a href="https://typeorm.io/" target="_blank" rel="noopener">ypeORM</a></p><ul><li><p>概念<br>这里需要注意的概念包括：  </p><ul><li><p>连接(Connection)<br>在这里连接的建立，使用过在ApplicationModule中，import TypeOrmModule.forRoot()来建立的，forRoot的参数就是一个数据库连接必备的字段。连接本身有name属性，缺省为’default’，这在多连接建立时会需要。</p></li><li><p>实体(Entity)<br>实体就是Model层，需要指定类属性对应的表结构，并指定one2Many/Many2One等与其他实体的关系</p></li><li><p>实体管理器(EntityManager)<br>Using EntityManager you can manage (insert, update, delete, load, etc.) any entity. EntityManager is just like a collection of all entity repositories in a single place  </p><p>实体管理器是对所有实体进行管理，它是Repository的一个集合</p></li><li><p>库(Repository)<br>Repository is just like EntityManager but its operations are limited to a concrete entity</p><p>Repository是对单个实体进行管理</p></li></ul></li><li><p>使用<br>需要在Module中imports TypeOrmModule.forFeature([Photo])，这个forFeature应该是获取Photo实体所对应的Repository，进而在Service中就可以使用Repository来操作实体了。<br>在TypeORM官网中，可以通过Connection来直接获取Repository，在nest中介绍的并不详细。<br>应该是在forRoot时，指明连接的名字，然后在Service中通过InjectConnection(‘连接名’)，来注入连接，通过@InjectEntityManager(‘连接名’)来注入实体管理器entityManager。</p></li></ul><h1 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h1><h2 id="Custom-providers"><a href="#Custom-providers" class="headerlink" title="Custom providers"></a>Custom providers</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为理解nest.js而做记录，内容为官网中的基础部分，目的是为了理解、记忆，所以不会抄原文的例子。&lt;br&gt;&lt;a href=&quot;https://docs.nestjs.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网&lt;/a&gt;  &lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>最长字符串问题</title>
    <link href="http://yoursite.com/2019/04/22/%E6%9C%80%E9%95%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/04/22/最长字符串问题/</id>
    <published>2019-04-21T22:45:14.000Z</published>
    <updated>2019-04-23T04:37:46.995Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>分布式系统设计模式</title>
    <link href="http://yoursite.com/2019/04/19/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/04/19/分布式系统设计模式/</id>
    <published>2019-04-18T23:25:35.000Z</published>
    <updated>2019-04-22T06:23:50.098Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章来整理《左耳听风》栏目的分布式设计模式弹力设计、管理设计、性能设计篇，并根据当下情况，借鉴一二</p><a id="more"></a><h1 id="弹力设计"><a href="#弹力设计" class="headerlink" title="弹力设计"></a>弹力设计</h1><h2 id="隔离设计-Bulkheads"><a href="#隔离设计-Bulkheads" class="headerlink" title="隔离设计 Bulkheads"></a>隔离设计 Bulkheads</h2><ul><li><p>背景<br>这个设计借鉴了船舱通过隔板来把船隔成几个独立空间，防止一点进水蔓延到整个船只。</p></li><li><p>2种隔离方法  </p><ul><li><p>按服务的种类来做隔离<br>如用户注册、商品中心、社交服务，将他们独立成各自的服务，并独占各自自己的DB<br>总会面对获取多个板块数据的情况，这样会调用多个服务，对于这样的问题，一般来说，我们需要小心地设计用户交互，最好不要让用户在一个页面上获得所有的数据。对。<br>业务跨板块时，控制就有点复杂。对此我们需要一个类似于 Pub/Sub 的高可用的并可以持久化的消息订阅通知的中间件来打通各个版块的数据和信息交换。最后还会有在多个版块中分布式事务的问题。对此，我们需要“二阶段提交”这样的方案。在亚马逊中，使用的是 Plan – Reserve – Commit/Cancel 模式。  </p></li><li><p>多租户：按用户的请求来分离<br>将用户分成不同的组，并把后端的同一个服务根据这些不同的组分成不同的实例。让同一个服务对于不同的用户进行冗余和隔离，这样一来，当服务实例挂掉时，只会影响其中一部分用户，而不会导致所有的用户无法访问。<br>做法有：<br>完全独立的设计。每个租户有自己完全独立的服务和数据。<br>独立的数据分区，共享的服务。多租户的服务是共享的，但数据是分开隔离的。<br>共享的服务，共享的数据分区。每个租户的数据和服务都是共享的。<br>一般会选择折中方案，服务是共享的，数据通过分区来隔离。</p></li></ul></li><li><p>重点<br>隔离模式需要配置一些高可用、重试、异步、消息中间件，流控、熔断等设计模式的方式配套使用。</p></li><li><p>课外<br>在虚拟化技术非常成熟的今天，我们完全可以使用“完全独立”（完全隔离）的方案，通过底层的虚拟化技术（Hypervisor 的技术，如 KVM，或是 Linux Container 的技术，如 Docker）来实现物理资源的共享和成本的节约。</p></li></ul><h2 id="异步通讯设计-Asynchronous"><a href="#异步通讯设计-Asynchronous" class="headerlink" title="异步通讯设计 Asynchronous"></a>异步通讯设计 Asynchronous</h2><ul><li><p>异步通讯的3种方式  </p><ul><li><p>请求响应式<br>直接REST调用  </p></li><li><p>通过订阅的方式<br>订阅者模式，接收方（receiver）会来订阅发送方（sender）的消息，发送方会把相关的消息或数据放到接收方所订阅的队列中，而接收方会从队列中获取数据。<br>这种情况下接收方需要想发送方订阅事件</p></li><li><p>通过中间人的方式<br>这是完整版的订阅者模式，发送方（sender）和接收方（receiver）都互相看不到对方，它们看得到的是一个 Broker，发送方向 Broker 发送消息，接收方向 Broker 订阅消息。如下图所示。<br><img src="broker方式.png" alt="broker方式"></p></li></ul></li><li><p>事件驱动  </p><p><img src="时间驱动.png" alt="时间驱动"><br>每个服务都是“自包含”的。所谓“自包含”也就是没有和别人产生依赖。而要把整个流程给串联起来，我们需要一系列的“消息通道（Channel）”。各个服务做完自己的事后，发出相应的事件，而又有一些服务在订阅着某些事件来联动。<br>这好处与遇到问题，与隔离设计其实是相同的。</p><p>需要消息跟踪：异步通讯会导致业务处理流程不那么直观，因为像接力一样，所以在 Broker 上需要有相关的服务消息跟踪机制，否则出现问题后不容易调试。<br>需要工作流引擎：因为服务间只通过消息交互，所以业务状态最好由一个总控方来管理，这个总控方维护一个业务流程的状态变迁逻辑，以便系统发生故障后知道业务处理到了哪一步，从而可以在故障清除后继续处理。  </p></li></ul><h2 id="幂等设计-Idempotency"><a href="#幂等设计-Idempotency" class="headerlink" title="幂等设计 Idempotency"></a>幂等设计 Idempotency</h2><ul><li><p>定义<br>所谓幂等性设计，就是说，一次和多次请求某一个资源应该具有同样的副作用。用数学的语言来表达就是：f(x)  = f(f(x))。<br>为什么我们需要这样的操作？说白了，就是在我们把系统解耦隔离后，服务间的调用可能会有三个状态，一个是成功（Success），一个是失败（Failed），一个是超时（Timeout）。前两者都是明确的状态，而超时则是完全不知道是什么状态。因为系统超时，而调用户方重试一下，会给我们的系统带来不一致的副作用。</p></li><li><p>全局ID<br>要做到幂等性的交易接口，需要有一个唯一的标识，来标志交易是同一笔交易。而这个交易 ID 由谁来分配是一件比较头疼的事。因为这个标识要能做到全局唯一。<br>算法详见： Twitter 的开源项目 Snowflake</p></li><li><p>处理流程<br>对于幂等性的处理流程来说，说白了就是要过滤一下已经收到的交易。要做到这个事，我们需要一个存储来记录收到的交易。于是，当收到交易请求的时候，我们就会到这个存储中去查询。如果查找到了，那么就不再做查询了，并把上次做的结果返回。如果没有查到，那么我们就记录下来。<br>所以，最好是当这个存储出现冲突的时候会报错。也就是说，我们收到交易请求后，直接去存储里记录这个 ID（相对于数据的 Insert 操作），如果出现 ID 冲突了的异常，那么我们就知道这个之前已经有人发过来了，所以就不用再做了。比如，数据库中你可以使用。<br>对于更新的场景来说，如果只是状态更新，可以使用如下的方式。如果出错，要么是非法操作，要么是已被更新，要么是状态不对，总之多次调用是不会有副作用的。</p></li><li><p>HTTP幂等性<br>Post不具备幂等性，处理如下：<br>首先，在表单中需要隐藏一个 token，这个 token 可以是前端生成的一个唯一的 ID。用于防止用户多次点击了表单提交按钮，而导致后端收到了多次请求，却不能分辨是否是重复的提交。这个 token 是表单的唯一标识。（这种情况其实是通过前端生成 ID 把 POST 变成了 PUT。）<br>然后，当用户点击提交后，后端会把用户提示的数据和这个 token 保存在数据库中。如果有重复提交，那么数据库中的 token 会做排它限制，从而做到幂等性。<br>当然，更为稳妥的做法是，后端成功后向前端返回 302 跳转，把用户的前端页跳转到 GET 请求，把刚刚 POST 的数据给展示出来。如果是 Web 上的最好还把之前的表单设置成过期，这样用户不能通过浏览器后退按钮来重新提交。这个模式又叫做。[对于前端渲染的方式，需要前端来控制]</p></li></ul><h2 id="重试设计-Retry"><a href="#重试设计-Retry" class="headerlink" title="重试设计 Retry"></a>重试设计 Retry</h2><ul><li><p>场景<br>“重试”的语义是我们认为这个故障是暂时的，而不是永久的，所以，我们会去重试<br>我认为，设计重试时，我们需要定义出什么情况下需要重试，例如，调用超时、被调用端返回了某种可以重试的错误（如繁忙中、流控中、维护中、资源不足等）。<br>而对于一些别的错误，则最好不要重试，比如：业务级的错误（如没有权限、或是非法数据等错误），技术上的错误（如：HTTP 的 503 等，这种原因可能是触发了代码的 bug，重试下去没有意义）。</p></li><li><p>策略<br>关于重试的设计，一般来说，都需要有个重试的最大值，经过一段时间不断的重试后，就没有必要再重试了，应该报故障了。在重试过程中，每一次重试失败时都应该休息一会儿再重试，这样可以避免因为重试过快而导致网络上的负担加重。<br>在重试的设计中，我们一般都会引入，Exponential Backoff 的策略，也就是所谓的 “ 指数级退避 “。在这种情况下，每一次重试所需要的休息时间都会成倍增加。这种机制主要是用来让被调用方能够有更多的时间来从容处理我们的请求。这其实和 TCP 的拥塞控制有点像。  </p><p>例如，我们定义一个调用返回的枚举类型，其中包括了 5 种返回错误——成功 SUCCESS、维护中 NOT_READY、流控中 TOO_BUSY、没有资源 NO_RESOURCE、系统错误 SERVER_ERROR。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Results &#123;</span><br><span class="line">  SUCCESS,</span><br><span class="line">  NOT_READY,</span><br><span class="line">  TOO_BUSY,</span><br><span class="line">  NO_RESOURCE,</span><br><span class="line">  SERVER_ERROR</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>spring的重试方法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Retryable</span>(</span><br><span class="line">    value = &#123; SQLException.class &#125;,</span><br><span class="line">    maxAttempts = <span class="number">2</span>,</span><br><span class="line">    backoff = <span class="meta">@Backoff</span>(delay = <span class="number">5000</span>))</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">retryService</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设计重点<br>重试的代码比较简单也比较通用，完全可以不用侵入到业务代码中。这里有两个模式。一个是代码级的，像 Java 那样可以使用 Annotation 的方式（在 Spring 中你可以用到这样的注解），如果没有注解也可以包装在底层库或是 SDK 库中不需要让上层业务感知到。另外一种是走 Service Mesh 的方式（关于 Service Mesh 的方式，我会在后面的文章中介绍）。<br>对于有事务相关的操作。我们可能会希望能重试成功，而不至于走业务补偿那样的复杂的回退流程。对此，我们可能需要一个比较长的时间来做重试，但是我们需要保存请求的上下文，这可能对程序的运行有比较大的开销，因此，有一些设计会先把这样的上下文暂存在本机或是数据库中，然后腾出资源来做别的事，过一会再回来把之前的请求从存储中捞出来重试。</p></li></ul><h2 id="补偿设计-Compensating-Transaction"><a href="#补偿设计-Compensating-Transaction" class="headerlink" title="补偿设计 Compensating Transaction"></a>补偿设计 Compensating Transaction</h2><ul><li>前沿<br>既然要分布式，必须要分离，隔离的服务之间通信要用异步的来解耦开，然后可能会存在通信异常，就需要重试，重试时不想被重试操作多次，也就需要幂等，更重要的一个问题是如果业务走不下去怎么办？那就是本节的补偿，如果前边几种是正流程，那么补偿就是逆流程。  </li><li><p>ACID 和 BASE<br>这里先做一点解释，这两个概念其实是tradeoff，严格必然不会繁荣，繁荣必然存在瑕疵。<br>有必要先说一下 ACID 和 BASE 的差别。传统关系型数据库系统的事务都有 ACID 属性，即原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。<br>为了提高性能，出现了 ACID 的一个变种 BASE。可以看到，BASE 系统是允许或是容忍系统出现暂时性问题的，这样一来，我们的系统就能更有弹力。因为我们知道，在分布式系统的世界里，故障是不可避免的，我们能做的就是把故障处理当成功能写入代码中，这就是 Design for Failure。</p></li><li><p>业务补偿<br>一般来说，业务的事务补偿都是需要一个工作流引擎的。亚马逊是一个超级喜欢工作流引擎的公司，这个工作流引擎把各式各样的服务给串联在一起，并在工作流上做相应的业务补偿，整个过程设计成为最终一致性的。<br>对于业务补偿来说，首先需要将服务做成幂等性的，如果一个事务失败了或是超时了，我们需要不断地重试，努力地达到最终我们想要的状态。然后，如果我们不能达到这个我们想要的状态，我们需要把整个状态恢复到之前的状态。另外，如果有变化的请求，我们需要启动整个事务的业务更新机制。</p><p>一个好的业务补偿机制需要做到下面这几点：<br>要能清楚地描述出要达到什么样的状态（比如：请假、机票、酒店这三个都必须成功，租车是可选的），以及如果其中的条件不满足，那么，我们要回退到哪一个状态。这就是所谓的整个业务的起始状态定义。<br>当整条业务跑起来的时候，我们可以串行或并行地做这些事。对于旅游订票是可以并行的，但是对于网购流程（下单、支付、送货）是不能并行的。总之，我们的系统需要努力地通过一系列的操作达到一个我们想要的状态。如果达不到，就需要通过补偿机制回滚到之前的状态。这就是所谓的状态拟合。<br>对于已经完成的事务进行整体修改，可以考虑成一个修改事务。  </p><p>我们需要小心维护和监控整个过程的状态，所以，千万不要把这些状态放到不同的组件中，最好是一个业务流程的控制方来做这个事，也就是一个工作流引擎。所以，这个工作流引擎是需要高可用和稳定的。这就好像旅行代理机构一样，我们把需求告诉它，它会帮我们搞定所有的事。如果有问题，也会帮我们回滚和补偿的。<br>下层的业务方最好提供短期的资源预留机制。就像电商中的把货品的库存预先占住等待用户在 15 分钟内支付。如果没有收到用户的支付，则释放库存。然后回滚到之前的下单操作，等待用户重新下单。</p></li></ul><h2 id="熔断设计-Circuit-Breaker"><a href="#熔断设计-Circuit-Breaker" class="headerlink" title="熔断设计 Circuit Breaker"></a>熔断设计 Circuit Breaker</h2><p>先简单描述  </p><ul><li><p>定义<br>熔断器模式可以防止应用程序不断地尝试执行可能会失败的操作，使得应用程序继续执行而不用等待修正错误，或者浪费 CPU 时间去等待长时间的超时产生。熔断器模式也可以使应用程序能够诊断错误是否已经修正。如果已经修正，应用程序会再次尝试调用操作。</p><p>由此可见，重试的次数显示实在前端的一种控制，这里的熔断实在后端，更确切说是网关的控制</p></li><li><p>示意图<br><img src="熔断示意图.png" alt="熔断示意图"></p></li><li><p>状态<br><img src="熔断状态转换.png" alt="熔断状态转换"></p><ul><li><p>closed，通畅状态<br>我们需要一个调用失败的计数器，如果调用失败，则使失败次数加 1。如果最近失败次数超过了在给定时间内允许失败的阈值，则切换到断开 (Open) 状态。此时开启了一个超时时钟，当该时钟超过了该时间，则切换到半断开（Half-Open）状态。该超时时间的设定是给了系统一次机会来修正导致调用失败的错误，以回到正常工作的状态。在 Closed 状态下，错误计数器是基于时间的。在特定的时间间隔内会自动重置。这能够防止由于某次的偶然错误导致熔断器进入断开状态。也可以基于连续失败的次数。  </p></li><li><p>open，断开状态<br>在该状态下，对应用程序的请求会立即返回错误响应，而不调用后端的服务。这样也许比较粗暴，有些时候，我们可以 cache 住上次成功请求，直接返回缓存（当然，这个缓存放在本地内存就好了），如果没有缓存再返回错误（缓存的机制最好用在全站一样的数据，而不是用在不同的用户间不同的数据，因为后者需要缓存的数据有可能会很多）。</p></li><li><p>Half-open，半开状态<br>允许应用程序一定数量的请求去调用服务。如果这些请求对服务的调用成功，那么可以认为之前导致调用失败的错误已经修正，此时熔断器切换到闭合状态，同时将错误计数器重置。</p></li></ul></li><li><p>课外<br> Netflix 的Hystrix开源项目</p></li></ul><h2 id="限流设计-Throttle"><a href="#限流设计-Throttle" class="headerlink" title="限流设计 Throttle"></a>限流设计 Throttle</h2><ul><li><p>定义<br>保护系统不会在过载的情况下出现问题，需要通过对并发访问进行限速，相关的策略一般是，一旦达到限制的速率，那么就会触发相应的限流行为。包括：拒绝服务、服务降级、特权请求、延时请求等</p></li><li><p>3种实现方式  </p><ul><li><p>计数器方式<br>最简单的限流算法就是维护一个计数器 Counter，当一个请求来时，就做加一操作，当一个请求处理完后就做减一操作。如果这个 Counter 大于某个数了（我们设定的限流阈值），那么就开始拒绝请求以保护系统的负载了。可以增加对特权用户增加新的队列，来完成对不同用户的控制。<br><img src="计数限流.png" alt="计数限流"><br><img src="队列限流.png" alt="队列限流"></p></li><li><p>漏斗方式<br>我们可以看到，就像一个漏斗一样，进来的水量就好像访问流量一样，而出去的水量就像是我们的系统处理请求一样。当访问流量过大时这个漏斗中就会积水，如果水太多了就会溢出。<br>一般来说，这个“漏斗”是用一个队列来实现的，当请求过多时，队列就会开始积压请求，如果队列满了，就会开拒绝请求。很多系统都有这样的设计，比如 TCP。当请求的数量过多时，就会有一个 sync backlog 的队列来缓冲请求，或是 TCP 的滑动窗口也是用于流控的队列。<br><img src="漏斗限流方式.png" alt="漏斗限流方式">  </p></li><li><p>令牌桶方式<br>关于令牌桶算法，主要是有一个中间人。在一个桶内按照一定的速率放入一些 token，然后，处理程序要处理请求时，需要拿到 token，才能处理；如果拿不到，则不处理。<br><img src="令牌桶限流方式.png" alt="令牌桶限流方式"></p></li><li><p>基于响应时间的动态限流<br>这其实是将限流加了负反馈回路<br>上面的算法有个不好的地方，就是需要设置一个确定的限流值。这就要求我们每次发布服务时都做相应的性能测试，找到系统最大的性能值。<br>我们想使用一种动态限流的方式。这种方式，不再设定一个特定的流控值，而是能够动态地感知系统的压力来自动化地限流。这方面设计的典范是 TCP 协议的拥塞控制的算法。TCP 使用 RTT - Round Trip Time 来探测网络的延时和性能，从而设定相应的“滑动窗口”的大小，以让发送的速率和网络的性能相匹配。这个算法是非常精妙的，我们完全可以借鉴在我们的流控技术中。</p></li></ul></li><li><p>课外<br>tcp的限流方式</p></li></ul><h2 id="降级设计-Degradation"><a href="#降级设计-Degradation" class="headerlink" title="降级设计 Degradation"></a>降级设计 Degradation</h2><ul><li><p>定义<br>所谓的降级设计（Degradation），本质是为了解决资源不足和访问量过大的问题。当资源和访问量出现矛盾的时候，在有限的资源下，为了能够扛住大量的请求，我们就需要对系统进行降级操作。也就是说，暂时牺牲掉一些东西，以保障整个系统的平稳运行。  </p></li><li><p>方法</p><ul><li><p>停止次要功能<br>停止次要的功能也是一种非常有用的策略。把一些不重要的功能给暂时停止掉，让系统释放出更多的资源来。比如，电商中的搜索功能，用户的评论功能，等等。等待访问的峰值过去后，我们再把这些功能给恢复回来。  </p></li><li><p>简化功能<br>关于功能的简化上，上面的下单流程中已经提到过相应的例子了。而且，从缓存中返回数据也是其中一个。这里再提一个，就是一般来说，一个 API 会有两个版本，一个版本返回全量数据，另一个版本只返回部分或最小的可用的数据。  </p></li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>分布式核心就是分，就是隔离服务<br>联系起来整理，才发现这一系列的脉络，整个分布式系统有两条流程，一条是正向流程、一条是反向流程。<br>正向流程中包括，分解服务、异步通讯、重试、幂等<br>反向流程指的是补偿设计<br>为了保护正反向流程不被流量压跨，又有了3个保护设计：熔断、限流、降级</p><h1 id="管理设计"><a href="#管理设计" class="headerlink" title="管理设计"></a>管理设计</h1><h2 id="分布式锁-Distributed-Lock"><a href="#分布式锁-Distributed-Lock" class="headerlink" title="分布式锁 Distributed Lock"></a>分布式锁 Distributed Lock</h2><p>先简化写了</p><ul><li><p>定义<br>我们知道，在多线程情况下访问一些共享资源需要加锁，不然就会出现数据被写乱的问题。在分布式系统下，这样的问题也是一样的。只不过，我们需要一个分布式的锁服务。对于分布式的锁服务，一般可以用数据库 DB、Redis 和 ZooKeeper 等实现。不管怎么样，分布式的锁服务需要有以下几个特点。  </p></li><li><p>redis分布式锁<br><code>SET resource_name my_random_value NX PX 30000</code></p></li><li><p>redis分布式锁的问题</p></li><li><p>解决方案</p><ul><li>版本号</li><li>fence token</li></ul></li><li><p>课外<br>细心的你一定发现了，这不就是计算机汇编指令中的原子操作 CAS（Compare And Swap）嘛，大量无锁的数据结构都需要用到这个。（关于 CAS 的话题，你可以看一下我在 CoolShell 上写的</p></li></ul><h2 id="配置中心-Configuration-Management"><a href="#配置中心-Configuration-Management" class="headerlink" title="配置中心 Configuration Management"></a>配置中心 Configuration Management</h2><p>先简写了，这个跟杨波老师的配置中心一个概念，不过引出了下边3节的内容</p><ul><li><p>配置区分<br>有一种方式是把软件的配置分成静态配置和动态配置。<br>静态配置：所谓静态配置其实就是在软件启动时的一些配置，运行时基本不会进行修改，也可以理解为是环境或软件初始化时需要用到的配置。如，操作系统的网络配置，软件运行时 Docker 进程的配置，这些配置在软件环境初始化时就确定了，未来基本不会修改了<br>动态配置：就是软件运行时的一些配置，在运行时会被修改。比如，日志级别、降级开关、活动开关。</p></li><li><p>架构<br><img src="配置中心.png" alt="配置中心"></p></li></ul><h2 id="边车模式-SideCar"><a href="#边车模式-SideCar" class="headerlink" title="边车模式 SideCar"></a>边车模式 SideCar</h2><ul><li><p>定义<br>边车就有点像一个服务的 Agent，这个服务所有对外的进出通讯都通过这个 Agent 来完成。这样，我们就可以在这个 Agent 上做很多文章了。但是，我们需要保证的是，这个 Agent 要和应用程序一起创建，一起停用。</p><p>编程的本质就是将控制和逻辑分离和解耦，而边车模式也是异曲同工，同样是让我们在分布式架构中做到逻辑和控制分离。</p></li><li><p>讨论<br>对于监视、日志、限流、熔断、服务注册、协议转换等等这些功能，其实都是大同小异，甚至是完全可以做成标准化的组件和模块的。一般来说，我们有两种方式：<br>一种是通过 SDK、Lib 或 Framework 软件包方式，在开发时与真实的应用服务集成起来。性能高，但对应用有侵入<br>另一种是通过像 Sidecar 这样的方式，在运维时与真实的应用服务集成起来。性能低，无需改应用，增加了依赖，也做到了逻辑与控制的分离。  </p><p>其实一种是在代码层面解决，一种是在服务层面解决</p></li><li><p>结构<br><img src="边车模式.png" alt="边车模式"></p></li><li><p>特点<br>我们知道，熔断、路由、服务发现、计量、流控、监视、重试、幂等、鉴权等控制面上的功能，以及其相关的配置更新，本质来上来说，和服务的关系并不大。但是传统的工程做法是在开发层面完成这些功能，这就会导致各种维护上的问题，而且还会受到特定语言和编程框架的约束和限制。<br>而随着系统架构的复杂化和扩张，我们需要更统一地管理和控制这些控制面上的功能，所以传统的在开发层面上完成控制面的管理会变得非常难以管理和维护。这使得我们需要通过 Sidecar 模式来架构我们的系统。  </p></li></ul><h2 id="服务网格-Service-Mesh"><a href="#服务网格-Service-Mesh" class="headerlink" title="服务网格 Service Mesh"></a>服务网格 Service Mesh</h2><ul><li><p>背景<br>将边车模式发扬广大，是 CNCF（Cloud Native Computing Foundation，云原生计算基金会）目前主力推动的新一代的微服务架构——Service Mesh 服务网格。<br>Service Mesh 这个服务网络专注于处理服务和服务间的通讯。其主要负责构造一个稳定可靠的服务通讯的基础设施，并让整个架构更为的先进和 Cloud Native。在工程中，Service Mesh 基本来说是一组轻量级的服务代理和应用逻辑的服务在一起，并且对于应用服务是透明的。  </p></li><li><p>示意图<br><img src="service_mesh.png" alt="service_mesh"><br><img src="server_mesh_2.png" alt="server_mesh_2">  </p></li><li><p>课外<br>Rust/Go 语言实现的 lstio 和 Conduit，后者比前者要轻很多。</p></li></ul><h2 id="网关模式-Gateway"><a href="#网关模式-Gateway" class="headerlink" title="网关模式 Gateway"></a>网关模式 Gateway</h2><ul><li><p>背景<br>这其实与service mesh是两个方向的发展了<br>它不需要为每个服务的实例都配置上一个 Sidecar。其实，一个服务集群配上一个 Gateway 就可以了，或是一组类似的服务配置上一个 Gateway。  </p></li><li><p>示意图<br><img src="网关示意图.png" alt="网关示意图"></p></li><li><p>网关的功能</p><ul><li>请求路由</li><li>服务注册</li><li>负载均衡</li><li>弹力设计：重试、幂等、流控、熔断、监视等都可以实现进去</li><li>安全方面：SSL 加密及证书管理、Session 验证、授权、数据校验等</li></ul></li></ul><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>首先，Sidecar 的方式主要是用来改造已有服务。我们知道，要在一个架构中实施一些架构变更时，需要业务方一起过来进行一些改造。然而业务方的事情比较多，像架构上的变更会低优先级处理，这就导致架构变更的“政治复杂度”太高。而通过 Sidecar 的方式，我们可以适配应用服务，成为应用服务进出请求的代理。这样，我们就可以干很多对于业务方完全透明的事情了。<br>当 Sidecar 在架构中越来越多时，需要我们对 Sidecar 进行统一的管理。于是，我们为 Sidecar 增加了一个全局的中心控制器，就出现了我们的 Service Mesh。在中心控制器出现以后，我们发现，可以把非业务功能的东西全部实现在 Sidecar 和 Controller 中，于是就成了一个网格。业务方只需要把服务往这个网格中一放就好了，与其它服务的通讯、服务的弹力等都不用管了，像一个服务的 PaaS 平台。<br>然而，Service Mesh 的架构和部署太过于复杂，会让我们运维层面上的复杂度变大。为了简化这个架构的复杂度，我认为 Sidecar 的粒度应该是可粗可细的，这样更为方便。但我认为，Gateway 更为适合，而且 Gateway 只负责进入的请求，不像 Sidecar 还需要负责对外的请求。因为 Gateway 可以把一组服务给聚合起来，所以服务对外的请求可以交给对方服务的 Gateway。于是，我们只需要用一个负责进入请求的 Gateway 来简化需要同时负责进出请求的 Sidecar 的复杂度。</p><h1 id="性能设计"><a href="#性能设计" class="headerlink" title="性能设计"></a>性能设计</h1><h2 id="缓存-Cache"><a href="#缓存-Cache" class="headerlink" title="缓存 Cache"></a>缓存 Cache</h2><h2 id="异步处理-Asynchronous"><a href="#异步处理-Asynchronous" class="headerlink" title="异步处理 Asynchronous"></a>异步处理 Asynchronous</h2><h2 id="数据库扩展"><a href="#数据库扩展" class="headerlink" title="数据库扩展"></a>数据库扩展</h2><h2 id="秒杀-Flash-Sales"><a href="#秒杀-Flash-Sales" class="headerlink" title="秒杀 Flash Sales"></a>秒杀 Flash Sales</h2><h2 id="边缘计算-Edge-Computing"><a href="#边缘计算-Edge-Computing" class="headerlink" title="边缘计算 Edge Computing"></a>边缘计算 Edge Computing</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章来整理《左耳听风》栏目的分布式设计模式弹力设计、管理设计、性能设计篇，并根据当下情况，借鉴一二&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>第四周ARTS</title>
    <link href="http://yoursite.com/2019/04/14/%E7%AC%AC%E5%9B%9B%E5%91%A8ARTS/"/>
    <id>http://yoursite.com/2019/04/14/第四周ARTS/</id>
    <published>2019-04-14T00:52:35.000Z</published>
    <updated>2019-04-15T02:27:45.963Z</updated>
    
    <content type="html"><![CDATA[<p>第四周打卡<br><a id="more"></a></p><h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><p>本题是Leetcode的56题Merge Intervals，主要来训练排序的<br><a href="https://sunyanfeng.cn/2019/04/11/合并区间问题/#more" target="_blank" rel="noopener">合并区间问题</a></p><h1 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h1><p><a href="https://medium.com/@goldybenedict/single-page-applications-vs-multiple-page-applications-do-you-really-need-an-spa-cf60825232a3" target="_blank" rel="noopener">原文</a><br>本周来review一篇SPA(Single Page Application)与MPA(Multiple Page Application)对比的文章<br>在原文中它对比了SPA与MPA的优缺点，如下图：  </p><table><thead><tr><th style="text-align:left">优缺点对比</th><th style="text-align:center">SPA</th><th style="text-align:center">MPA</th></tr></thead><tbody><tr><td style="text-align:left">优点</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left"></td><td style="text-align:center">SPA更平滑更快</td><td style="text-align:center">搜索引擎方面表现良好</td></tr><tr><td style="text-align:left"></td><td style="text-align:center">更容易开发、部署</td><td style="text-align:center">为用户提供web应用的visual map</td></tr><tr><td style="text-align:left"></td><td style="text-align:center">更容易调试</td><td style="text-align:center"></td></tr><tr><td style="text-align:left"></td><td style="text-align:center">重用一套后端开发生成手机端</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">缺点</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left"></td><td style="text-align:center">对搜索引擎表现不足(已改)</td><td style="text-align:center">相比而言开发复杂</td></tr><tr><td style="text-align:left"></td><td style="text-align:center">只提供单一链接</td><td style="text-align:center">耦合前后端</td></tr><tr><td style="text-align:left"></td><td style="text-align:center">由于跨域问题,安全性稍差</td></tr></tbody></table><p>在选择时，给出建议：<br>If your business deals with a single product, nothing can be perfect than a single page application。<br>While, if your business caters a variety of services or products, you definitely need to give importance to each of them by bifurcating them in different pages with a multi-page application.</p><p>意思是如果产品单一，SPA更好；如果服务、产品众多，更适合MPA。<br>其实这个度其实不好把握，而且感觉SPA与MPA之间的度并不是那么分明。对于单一产品先开发SPA，然后随着业务变大，然后再开发一些SPA，在网关层上做一些调整，感觉也不错。</p><h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><p>由于内容上的连贯，本周的内容继续放在了上周的博客中。<br><a href="https://sunyanfeng.cn/2019/04/08/Matrix-Eigenvalue/#more" target="_blank" rel="noopener">Matrix Eigenvalue</a></p><h1 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h1><p>本周工作中主要是想搭建一个React的前端框架出来，在SSR、CSR与同构下了一点功夫，就这个问题做一个分享。<br><a href="https://sunyanfeng.cn/2019/04/14/SSR%E3%80%81CSR%E4%B8%8E%E5%90%8C%E6%9E%84/#more" target="_blank" rel="noopener">SSR、CSR与同构</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第四周打卡&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SSR、CSR与同构</title>
    <link href="http://yoursite.com/2019/04/14/SSR%E3%80%81CSR%E4%B8%8E%E5%90%8C%E6%9E%84/"/>
    <id>http://yoursite.com/2019/04/14/SSR、CSR与同构/</id>
    <published>2019-04-14T00:51:40.000Z</published>
    <updated>2019-05-06T00:51:28.642Z</updated>
    
    <content type="html"><![CDATA[<p>为本周的前端的框架选择做一个总结</p><p>change log：<br>初次写时，概念表达不太到位，再次翻阅不能起到快速回忆的目的，这里再次进行修改，删去原来的过程部分，增加CSR与SSR的技术内容。</p><a id="more"></a><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>团队的前端同学们想探索一些新的框架，于是就跟他们一起做一些技术选择。<br>现有的前端框架分成server部分与browser部分，server中是一个node.js服务器，负责页面与路由的映射，根据路由导向不同的页面，渲染的交给了前端来完成，是一个React MPA 前端渲染的框架，设计是用的Material-UI库</p><h1 id="发展观"><a href="#发展观" class="headerlink" title="发展观"></a>发展观</h1><p>随着这篇文章来梳理一下</p><ul><li><p>html时代<br>http协议最早设计的是从服务器上获取静态的资源，其实也就是静态html  </p></li><li><p>模板渲染<br>后来Java时代，可以通过模板，将数据渲染进模板，从而生成html发送给前端，在后来的CSR出现之间，我觉得可能也没有SSR的概念。  </p><p>浏览器与服务端数据的交互通过表单来实现，浏览器将表达中的数据一次性通过表单提交，后代进行处理完成后可以再次渲染模板，然后将数据表达出来。</p></li><li><p>CSR(客户端侧渲染)<br>后来我觉得是ajax与virtual dom技术的出现，使浏览器渲染成为可能，一开始可能只是想做一点改变，感觉很平滑，后来干脆所有的dom都直接渲染，这就成成CSR  </p><p>这个CSR从过程上看，浏览器先去获取一个空模板，然后再获取js文件进行virtual dom的渲染，这个过程浏览器上会有一瞬的白屏。  </p><p>浏览器与服务端数据交互很多时候被ajax所替代，好处是比较灵活，不论是数据交互还是页面刷新，不好处容易被滥用，使通信的效率降低，后台服务压力上升。  </p></li><li><p>SSR(服务侧渲染)-追加<br>模板渲染就是一种SSR，这里针对的主要的是React所以略有不同，SSR主要是将render的操作放在了后端来执行，将数据从API Server取来，然后直接通过render函数渲染到页面上，并将页面返回浏览器。这样浏览器也不用再获取js，自己来渲染。  </p><p>不好处也比较明显，每次获取数据、渲染，对服务器的要求会比CSR高，不过模板时期也是这么玩的。另外响应感觉要比CSR慢一点。<br>这里要加一下看过next.js之后的感想，next.js是一个SSR的框架，它是一种MPA，提供的prefech与Dynamic Import等功能，在SSR方面做的更突出一些。</p></li><li><p>isomorphic(同构渲染)-修改<br>Isomorphic既是CSR也是SSR，它是服务器渲染一遍，浏览器也渲染一遍。<br>在一些实践中服务器渲染完初识界面之后就算完成任务，其余的渲染就靠浏览器来完成。这种同构渲染感觉更偏向CSR<br>想象中，SSR完成之后，通过AJAX获取数据，然后根据数据做一些render，这样的效果也会不错。这种通过感觉更偏向SSR  </p></li></ul><h1 id="CSR与SSR"><a href="#CSR与SSR" class="headerlink" title="CSR与SSR"></a>CSR与SSR</h1><p>一些文章中将Isomophic也说成SSR</p><ul><li><p>差异<br>刚开始接触花费了挺多时间来区别这两个概念，其实从名字就能做区分，对于React而言，就是是render函数是在服务器上执行还是在浏览器上执行。</p></li><li><p>SSR与CSR原理<br>原理从下边两张图中即可说明：<br><img src="CSR.png" alt="CSR"><br><img src="SSR.png" alt="SSR"><br>这里的SSR其实是Isomophic，它有2个入口，第一次是服务端的入口，第二次是客户端再次获取js文件渲染之后的浏览器入口。</p><p>推荐：<a href="https://juejin.im/post/5bc7ea48e51d450e46289eab" target="_blank" rel="noopener">React 中同构（SSR）原理脉络梳理</a></p></li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>上次根据研究，已经将一个同构的React同构框架搭建起来，期间跳过了很多的坑，采用create-react-app脚手架、Typescript、express、react-router、stylus等技术。但有还是两个问题其实没有解决：  </p><ul><li><p>服务端代码运行<br>原来的框架中，运行时将Ts写的服务端代码也编译成了js之后进行运行，但在这里没有成功，原因是，原来框架中客户端与服务端的代码完全隔离，但在同构渲染时，服务端要渲染，必须要引入React的组件，而这些组件通过webpack打包之后，里边的函数没法再被server侧导入。<br>处理这个问题时，要么全部将Ts都通过gulp-typescript来编译成js，要么直接使用Ts，而经过确认，定于使用了Ts直接运行的方式</p></li><li><p>stylus问题<br>这个延伸自上一个问题，由于CSS采用stylus，造成ts直接运行时，没办法转换其中的stylus模块，这个问题目前还没有找到。可能要退回到将Ts全部编译成js，然后用gulp-stylus来处理一下stylus的方式来实现，要是这样，感觉也有些不妥。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为本周的前端的框架选择做一个总结&lt;/p&gt;
&lt;p&gt;change log：&lt;br&gt;初次写时，概念表达不太到位，再次翻阅不能起到快速回忆的目的，这里再次进行修改，删去原来的过程部分，增加CSR与SSR的技术内容。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>合并区间问题</title>
    <link href="http://yoursite.com/2019/04/11/%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/04/11/合并区间问题/</id>
    <published>2019-04-11T15:18:06.000Z</published>
    <updated>2019-04-15T02:20:24.912Z</updated>
    
    <content type="html"><![CDATA[<p>本题是Leetcode的56题Merge Intervals，主要来训练排序的<br><a id="more"></a></p><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a collection of intervals, merge all overlapping intervals.</p><p>Example 1:</p><p>Input: [[1,3],[2,6],[8,10],[15,18]]<br>Output: [[1,6],[8,10],[15,18]]<br>Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].  </p><p>Example 2:  </p><p>Input: [[1,4],[4,5]]<br>Output: [[1,5]]<br>Explanation: Intervals [1,4] and [4,5] are considered overlapping.  </p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>本周想对排序进行练习，上周的Kth最大子数组就是用归并排序来完成的，是训练分治也是训练排序。本周从sort标签中选了第一题。<br>首先需要将各个区间按第一个起始位置排序，然后去合并这些区间即可。这里采用的是快速排序的方式，而且合并的过程也采用与快排查找中间位置类似的想法。<br>这书写上，想着用一下函数范式的一些规则，形参不改变，返回一个相同的参数，使函数无状态。  </p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * struct Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() : start(0), end(0) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;Interval&gt; merge(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;Interval&gt; sortedVals = sortInterval(intervals);</span><br><span class="line">        <span class="built_in">vector</span>&lt;Interval&gt; mergedVals = mergeInterval(sortedVals);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mergedVals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;Interval&gt; sortInterval(<span class="built_in">vector</span>&lt;Interval&gt; &amp;intervals)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Interval&gt; sortedVals = intervals;</span><br><span class="line">        quickSortInterval(sortedVals, <span class="number">0</span>, sortedVals.size()<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sortedVals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quickSortInterval</span><span class="params">(<span class="built_in">vector</span>&lt;Interval&gt; &amp;intervals, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(start &gt;= end)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = partition(intervals, start, end);</span><br><span class="line">        quickSortInterval(intervals, start, mid<span class="number">-1</span>);</span><br><span class="line">        quickSortInterval(intervals, mid+<span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;Interval&gt; &amp;intervals, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        Interval ref = intervals[end];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = start<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=start; j&lt;end; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[j].start &lt; ref.start)&#123;</span><br><span class="line">                i++;</span><br><span class="line"></span><br><span class="line">                exchange(intervals[i], intervals[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = i+<span class="number">1</span>;</span><br><span class="line">        exchange(intervals[mid], intervals[end]);</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">(Interval &amp;a, Interval &amp;b)</span></span>&#123;</span><br><span class="line">        Interval tmp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;Interval&gt; mergeInterval(<span class="built_in">vector</span>&lt;Interval&gt; &amp;intervals)&#123;</span><br><span class="line">        <span class="keyword">int</span> len = intervals.size();</span><br><span class="line">        <span class="keyword">if</span>(len &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> intervals;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;Interval&gt; mergedVals;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=j+<span class="number">1</span>; i&lt;len; ++i)&#123;</span><br><span class="line">          <span class="keyword">if</span>(intervals[j].end &lt; intervals[i].start)&#123;</span><br><span class="line">              mergedVals.push_back(intervals[j]);</span><br><span class="line">              j=i;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span>(intervals[j].end &lt; intervals[i].end)&#123;</span><br><span class="line">              intervals[j].end = intervals[i].end;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(i == len<span class="number">-1</span>)&#123;</span><br><span class="line">            mergedVals.push_back(intervals[j]);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mergedVals;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本题在合并区间的时候考虑过将合并掉的区间删除，考虑到vector删除size发生变化，就思考与快排用两个指示器来处理的方式。这种方式其实改变了传入值，其实可以做一层复制来规避，这里图简单，没有将无状态贯彻到底。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本题是Leetcode的56题Merge Intervals，主要来训练排序的&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>第三周ARTS</title>
    <link href="http://yoursite.com/2019/04/08/%E7%AC%AC%E4%B8%89%E5%91%A8ARTS/"/>
    <id>http://yoursite.com/2019/04/08/第三周ARTS/</id>
    <published>2019-04-08T02:22:36.000Z</published>
    <updated>2019-04-09T01:47:54.042Z</updated>
    
    <content type="html"><![CDATA[<p>第三周打卡<br><a id="more"></a></p><h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><p><a href="https://sunyanfeng.cn/2019/04/04/kth%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/#more" target="_blank" rel="noopener">kth最大元素</a></p><h1 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h1><p>本周主要Review了陈皓老师的编程范式</p><p><a href="https://sunyanfeng.cn/2019/04/01/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/#more" target="_blank" rel="noopener">编程范式</a></p><h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><p><a href="https://sunyanfeng.cn/2019/04/08/Matrix-Eigenvalue/#more" target="_blank" rel="noopener">Matrix Eigenvalue</a></p><h1 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h1><p>本周顺便做了一个工具的记录，就当share了，稍显薄了一点</p><p><a href="https://sunyanfeng.cn/2019/04/04/vscode%E4%B8%8Bmd%E5%AF%BCpdf/#more" target="_blank" rel="noopener">vscode下md导pdf</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第三周打卡&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Matrix Eigenvalue</title>
    <link href="http://yoursite.com/2019/04/08/Matrix-Eigenvalue/"/>
    <id>http://yoursite.com/2019/04/08/Matrix-Eigenvalue/</id>
    <published>2019-04-08T02:14:22.000Z</published>
    <updated>2019-04-15T02:20:24.908Z</updated>
    
    <content type="html"><![CDATA[<p>本周清明回家，只完成2节的Matrix学习，Lesson21～Lesson22<br>为保持博客的完整性，下周的Matrix依旧会放到本篇博客中  </p><p>第四周完成了Less23~Lesson24,继续在这里记录。<br><a id="more"></a></p><hr><h1 id="Eigenvalues-and-eigenvectors"><a href="#Eigenvalues-and-eigenvectors" class="headerlink" title="Eigenvalues and eigenvectors"></a>Eigenvalues and eigenvectors</h1><ul><li><p>定义</p><p>AX = λX</p><p>A matrix A acts on vectors x . Eigenvectors are vectors for which Axis parallel to x。</p></li><li><p>计算</p><p>det(A-λI) = 0</p></li><li><p>复数eigenvalues</p><p>对称阵的特征值为实数，反对称阵的特征值为纯虚数<br>Symmetric matrices have real eigenvalues<br>For antisymmetric matrices like Q, for which AT = −A, all eigenvalues are imaginary (λ=bi). </p></li><li><p>重复的eigenvalues</p><p>非重复的eigenvalues用于相互独立的eigenvector，重复的eigenvalues可能用于独立的，也可能不独立的eigenvector</p><p><img src="重复的eigenvalues示例.png" alt="重复的eigenvalues示例"></p></li></ul><h1 id="Diagonalization-and-powers-of-A"><a href="#Diagonalization-and-powers-of-A" class="headerlink" title="Diagonalization and powers of A"></a>Diagonalization and powers of A</h1><ul><li><p>对角化：Diagonalization</p><p><img src="对角化公式.png" alt="对角化公式"><br><img src="对角化证明.png" alt="对角化证明"></p></li><li><p>A的幂运算，Powers of A<br><img src="A的幂运算.png" alt="A的幂运算"></p><p>当A的K次幂 -&gt; 0时，说明A的特征向量绝对值&lt;1</p></li><li><p>差分方程<br><img src="差分方程.png" alt="差分方程"></p><p><img src="差分方程的解.png" alt="差分方程的解"><br>在这里，它将U0用A的特征向量来表示的，有点当成一组基在使用</p></li><li><p>菲比队列</p><p><img src="Fibonacci队列.png" alt="Fibonacci"><br><img src="构造矩阵.png" alt="构造矩阵"><br><img src="解.png" alt="解"></p></li></ul><hr><h1 id="微分方程与exp-At"><a href="#微分方程与exp-At" class="headerlink" title="微分方程与exp(At)"></a>微分方程与exp(At)</h1><p>本节可以分成3部分，解一个微分方程，稳态分析，exp(At)</p><ul><li><p>解微分方程<br><img src="微分方程实例.png" alt="微分方程实例"><br>初始状态u1=1 u2=0. </p><p><img src="微分方程.png" alt="微分方程">其中A为<img src="微分方程的A.png" alt="微分方程的A"><br>对A求解特征值与特征向量得<br>λ1=0，λ2=-3<br>对应的特征向量为<br><img src="特征向量1.png" alt="特征向量1"><br><img src="特征向量2.png" alt="特征向量2">  </p><p>微分方程对应的一般解为：<br><img src="一般解.png" alt="一般解"><br>可以看出这个一般解其实是一个线性组合，这里可以有一个证明，原因是在所有微分中，指数函数是唯一微分不变的。<br><img src="证明.png" alt="证明">  </p><p>将特征值、特征向量、初始值带入一般解，求解出c1、c2，以此得到u(t)<br><img src="u(t" alt="u(t)">.png)</p><p>以此解完了整个微分方程，同时也引出了稳态分析</p></li><li><p>稳态分析<br>可以对u(t)，尽心分析，当t趋于无穷.<br><img src="u无穷.png" alt="u无穷"></p><p>由此得到微分方程的稳态条件<br><img src="稳态.png" alt="稳态"></p></li><li><p>推广<br><img src="推广.png" alt="推广"><br>这里的推广，首先是将<img src="一般解.png" alt="一般解">写成了矩阵方式即u=Sv，这里S是A的特征向量组成的矩阵，v是变量；然后将次等式带入微分方程，求解v(t).然后将v(t)代入等式，得到u(t)，这里u(t)多了一个S逆<br>这样引出了本节最后一部分exp(At)</p></li><li><p>exp(At)<br><img src="指数的无穷级数.png" alt="指数的无穷级数"></p><p><img src="指数矩阵.png" alt="指数矩阵"></p><p><img src="指数矩阵的解释.png" alt="指数矩阵的解释"></p></li><li><p>二阶微分方程<br>这里对二阶微分方程做了引申<br><img src="二阶微分方程.png" alt="二阶微分方程"><br>与函数相同，将2阶换成2个一阶<br><img src="二阶引申.png" alt="二阶引申"></p></li></ul><h1 id="马尔科夫矩阵与傅里叶级数"><a href="#马尔科夫矩阵与傅里叶级数" class="headerlink" title="马尔科夫矩阵与傅里叶级数"></a>马尔科夫矩阵与傅里叶级数</h1><ul><li><p>马尔科夫矩阵<br>马尔科夫矩阵是这样一类矩阵：1. 矩阵每个元素都是正数；2. 矩阵每列的和为</p><p><img src="Markov矩阵.png" alt="Markov矩阵">  </p><p>它有两个属性</p><ol><li>λ=1是一个特征值，证明可以det(A-λI) = 0</li><li>其他的特征值都小于1</li></ol><p>上一节主要研究是是指数矩阵，这一节其实主要研究的是幂矩阵<br><img src="幂矩阵.png" alt="幂矩阵"><br><img src="级数矩阵.png" alt="级数矩阵"></p></li><li><p>例子<br><img src="以麻省与加州人口.png" alt="以麻省与加州人口"></p><p>λ1=1， λ2=0.7</p><p>对应特征向量<br><img src="Markov特征向量1.png" alt="Markov特征向量1"><br><img src="Markov特征向量2.png" alt="Markov特征向量2">  </p><p><img src="Markov的解.png" alt="Markov的解"></p></li><li><p>Projections with orthonormal basis<br>这个是之前章的一个复习，正交化的矩阵的一个好处是，做投影时只需与正交矩阵相乘即可。<br><img src="正交矩阵-1.png" alt="正交矩阵-1"><br><img src="正交矩阵-2.png" alt="正交矩阵-2"><br><img src="正交矩阵的解.png" alt="正交矩阵的解">  </p></li><li><p>傅里叶级数<br><img src="傅里叶级数.png" alt="傅里叶级数">  </p><p>对于向量：在R空间中<img src="向量空间.png" alt="向量空间"><br>对于函数：<img src="函数空间.png" alt="函数空间"><br>乘后加操作变成乘后积分操作，因为是周期函数，所以只积分周期即可。<br><img src="解过程.png" alt="解过程"><br><img src="傅里叶的解.png" alt="傅里叶的解"><br> 这样就解出了a1，以此可以解出an。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周清明回家，只完成2节的Matrix学习，Lesson21～Lesson22&lt;br&gt;为保持博客的完整性，下周的Matrix依旧会放到本篇博客中  &lt;/p&gt;
&lt;p&gt;第四周完成了Less23~Lesson24,继续在这里记录。&lt;br&gt;
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Matrix" scheme="http://yoursite.com/tags/Matrix/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>kth最大元素</title>
    <link href="http://yoursite.com/2019/04/04/kth%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2019/04/04/kth最大元素/</id>
    <published>2019-04-04T05:57:09.000Z</published>
    <updated>2019-04-09T01:43:59.866Z</updated>
    
    <content type="html"><![CDATA[<p>本题是 Leecode的 215.Kth Largest Element in an Array<br><a id="more"></a></p><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p><p>Example 1:</p><p>Input: [3,2,1,5,6,4] and k = 2<br>Output: 5<br>Example 2:</p><p>Input: [3,2,3,1,2,4,5,5,6] and k = 4<br>Output: 4<br>Note:<br>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>本题，想到了2种可行方式：</p><ol><li>用排序算法，对数组进行排序，然后返回地k-1个元素即可，既然是训练分治，这里可以使用归并排序的方式。</li><li>设计一个k大小的窗口，然后从数组上滑过，每个元素与这k个元素比较，根据大小做处理。类似于插入排序的方式。<br>本题准备实现一下1方式</li></ol><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sortedNums = sort(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> sortedNums[k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mergeNums;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(low == high)&#123;</span><br><span class="line">            mergeNums.push_back(nums[low]);</span><br><span class="line">            <span class="keyword">return</span> mergeNums;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> middle = (low + high)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lnums = sort(nums, low, middle);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hnums = sort(nums, middle+<span class="number">1</span>, high);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&lt;lnums.size() &amp;&amp; j&lt;hnums.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(lnums[i] &gt;= hnums[j])&#123;</span><br><span class="line">                mergeNums.push_back(lnums[i++]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mergeNums.push_back(hnums[j++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&lt;lnums.size())&#123;</span><br><span class="line">            mergeNums.push_back(lnums[i++]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(j&lt;hnums.size())&#123;</span><br><span class="line">            mergeNums.push_back(hnums[j++]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mergeNums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上边2种做法，1中对所有的数组进行了排序，2中对k个元素进行了排序，不是直接去找Kth，应该能直接找子数组与kth之间的关系来直接分治。想了一种k分的方式，取最大，然后再取这k个值的最小，但是错误的;还有2分各取k应该，排序然后取第K，也是一种做法，但受K的影响，如果K &gt; length/2，还需要作转换，衰减也并不明显。<br>暂时并未想到可行的直接分治的方法</p><p>google了一下结果，发现有用快排方式的，有用二分方式的，复杂度都是nlog(n)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本题是 Leecode的 215.Kth Largest Element in an Array&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vscode下md导pdf</title>
    <link href="http://yoursite.com/2019/04/04/vscode%E4%B8%8Bmd%E5%AF%BCpdf/"/>
    <id>http://yoursite.com/2019/04/04/vscode下md导pdf/</id>
    <published>2019-04-04T02:47:46.000Z</published>
    <updated>2019-04-04T03:17:19.548Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下通过vscode转md导成pdf的方法</p><a id="more"></a><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>用md写文档已经渐渐成为习惯，尤其可以通过hexo，直接发布成博客。<br>造成的问题呢，很多文档并不是博客，比如会议纪要、工作的一些记录，写成md分享给非技术人员看，并不太合适，尤其有图片的时候，于是就想用md转成pdf。</p><h1 id="Markdown-Pdf插件安装"><a href="#Markdown-Pdf插件安装" class="headerlink" title="Markdown Pdf插件安装"></a>Markdown Pdf插件安装</h1><p>从扩展中安装Markdown Pdf</p><p><img src="插件.png" alt="插件"></p><p>安装成功后，可以在md文件中右键看到如下菜单</p><p><img src="右键.png" alt="右键"></p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>看到很多介绍，说到这里就可以直接点击导出就能成功，但在我机器上并没有成功。</p><p>点击后，发现没有任何反应，最初以为是导出的目录可能不对，搜索了一下，发现可以通过<code>markdown-pdf.outputDirectory</code>的方式来配置导出的目录，于是进行了设置，发现还是没反应</p><p>我注意到每次启动时，vscode坐下脚的提示中，总在install chromium，于是就有数了，这个Markdown Pdf其实是调用了chromium的接口来完成转换的。也是就看一下这个插件的配置。如下</p><p><img src="ExecutablePath.png" alt="ExecutablePath"></p><p>由于本机上有chromium浏览器，就<code>whereis chromium-browser</code>，然后在进行了配置，在settings.json中增加：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"markdown-pdf.executablePath": "/usr/bin/chromium-browser"</span><br></pre></td></tr></table></figure><p>重试，导出成功。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下通过vscode转md导成pdf的方法&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>编程范式</title>
    <link href="http://yoursite.com/2019/04/01/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/04/01/编程范式/</id>
    <published>2019-04-01T09:26:14.000Z</published>
    <updated>2019-04-08T02:54:46.369Z</updated>
    
    <content type="html"><![CDATA[<p>本篇作为笔记形式存在，对左耳听风中的编程范式做笔记，便于以后去查看。<br>原文中主要用到了语言有C、C++、Python、Java、Javascript、Go、Prolog。由于我对Go语言了解不深，委托范式像是一种组合方式的应用，这里就不对这种范式进行记录了，以后有机会，再回来补充;另外Prolog的方式我觉得很有趣，以后想去研究一下再写，这里也不包括在内。</p><p>我需要找到一种合适的记录顺序：原文以一种语言发展的顺序展开，是一种不错的方式; 根据我学习语言的前后顺序，也是一种不错的方式; 再有一种是总分式展开方式。这里选用第二种吧，以我接触这些范式的先后关系来展开。</p><a id="more"></a><h1 id="过程式编程"><a href="#过程式编程" class="headerlink" title="过程式编程"></a>过程式编程</h1><p>作为学习的起点，我也是从C语言起步的，但作为使用的起点却不能算是。真正使用的起点应该是汇编语言了，那时候在学校里做课程设计，用汇编控制循环。后来第二次做的时候就用上了C语言，感觉轻松了好多，循环用for就可以了，不用来回的jump。</p><p>对C语言的特性，这里直接引用了</p><ul><li>C 语言是一个静态弱类型语言，在使用变量时需要声明变量类型，但是类型间可以有隐式转换；</li><li>不同的变量类型可以用结构体（struct）组合在一起，以此来声明新的数据类型；</li><li>C 语言可以用 typedef 关键字来定义类型的别名，以此来达到变量类型的抽象；</li><li>C 语言是一个有结构化程序设计、具有变量作用域以及递归功能的过程式语言；</li><li>C 语言传递参数一般是以值传递，也可以传递指针；</li><li>通过指针，C 语言可以容易地对内存进行低级控制，然而这引入了非常大的编程复杂度；</li><li>编译预处理让 C 语言的编译更具有弹性，比如跨平台。</li></ul><p>我这里尝试来回忆一下：</p><ul><li>从数据上看，数据本身都是二进制，类型是对这段二进制的解释，类型本身并不是数据。</li><li>从内存山看，可以分成静态区、堆区、栈区、常量区，分别用来存储存储全局、new、局部、常量字符串等数据</li><li>数据对齐方式要注意大小端的差异，尤其在传输过程中，一般都需要大小端的转换，实现方式就是按中轴进行互换。</li><li>还有一些比较有趣的结构：比如union，还记得老师写的那段代码，用union来包含两个struct，它们的长度相同，但在传输与解析时做不同的使用。</li><li>还有很多宏定义，像是去年看的，内核中使用链表时候那段宏定义就很有意义。</li><li>中断的处理，单片机上的中断口有限，需要对中断手动进行配置，包括端口以及回调函数。中断其实一种异步方式，中断方式比起轮询方式节省很多资源。</li></ul><p>C语言回忆就到这里了，说是过程式的，不如说是指令式的，你像机器发送着一些指令，这其实比汇编语言好多了，起码不需要记住每一个寄存器。另外，以前只听老师说过C语言其实可以写OO，一直无缘得见，后来看vfs时候才明白，原来面向对象是一种思想，并不一定被语言限制，在C中一样可以用这种思想。</p><h1 id="面向对象式编程"><a href="#面向对象式编程" class="headerlink" title="面向对象式编程"></a>面向对象式编程</h1><p>最早接触C++其实是在实验室里，那时候用MFC做桌面端的应用程序，当然那时候我们称桌面为上位机。对C++的认识也比较模糊，因为MFC做了好多封装，也体会不出C++的特点。工作之后，写了5年的C++，目前为止，在所有语言里使用时间也是最长的。</p><p>面向对象的3大特性：封装、继承、多态。<br>对面向对象的评价继续引用：</p><ul><li><p>优点</p><ul><li>能和真实的世界交相辉映，符合人的直觉。</li><li>面向对象和数据库模型设计类型，更多地关注对象间的模型设计。</li><li>强调于“名词”而不是“动词”，更多地关注对象和对象间的接口。</li><li>根据业务的特征形成一个个高内聚的对象，有效地分离了抽象和具体实现，增强了可重用性和可扩展性。</li><li>拥有大量非常优秀的设计原则和设计模式。S.O.L.I.D（单一功能、开闭原则、里氏替换、接口隔离以及依赖反转，是面向对象设计的五个基本原则）、IoC/DIP……</li></ul></li><li><p>缺点</p><ul><li>代码都需要附着在一个类上，从一侧面上说，其鼓励了类型。</li><li>代码需要通过对象来达到抽象的效果，导致了相当厚重的“代码粘合层”。</li><li>因为太多的封装以及对状态的鼓励，导致了大量不透明并在并发下出现很多问题。</li></ul></li></ul><p>缺点上这两点原文中，原文中的举例都是针对Java，像Spring的那些注入，导致了大量的封装，这些封装还屏蔽了细节。</p><p>这里只对自己在使用C++的时候的一些回忆吧，主要针对面向对象的3大特性来展开</p><ul><li>封装，封装其实沿用着C语言模块化编程的思维，讲究低耦合高内聚的方式，只不过面向对象是将数据与操作封装成一个类，这里的数据也就是后边说的状态。</li><li>继承，继承是代码复用的一种方式，起先比较喜欢继承，后来发现继承也是有缺点的，会出现类爆炸的情况。于是就提倡使用组合的方式来复用代码。尤其加之与后边将的多态，使对组合元素的依赖于接口，而不是具体实现，耦合程度进一步降低。</li><li>多态，就是刚才说的，依赖于接口而不是具体实现。其实后来发现那些设计模式，其实就是对继承、组合、多态的一些常见用法，直接点就是套路。</li></ul><p>还有一部分是开发过程的控制</p><ul><li>多线程及线程池的使用，重构预处理服务的时候，将不同的处理策略抽象各自的实现中，然后将整个流程又封装成了各自的过程对象，最后获取线程池中的线程运行过程对象。后来发现这种方式在Java中与runable的方式类似，而且当时各个流程是硬编码的，如果是面AOP的方式，或者装饰器的方式会更好一些。</li><li>由于各个处理步骤的只完成对数据处理的一部分，可能会new出一段数据区来，在不同的步骤之间传递引用，但当时的的情况不同，最后的结果并不是线性依赖的，而是根据各个步骤处理结果的逻辑运算。在实现的过程中将数据放到了一块contex的数据区，并将每个步骤的结果也保存在集中，最后将取结果的逻辑与结果本身解耦出来。</li><li>在多线程中处理全局数据，对锁的要求很高。</li></ul><p>感慨一下，没想到3年过去了，还能顺利记起当时的做法。</p><p>其实这隐含着这种编码方式很大的问题，在分布式系统中，状态如此之多，处理起来会加倍的困难。虽然当时从内存监控上看，并没有出现泄露的情况，但也是战战兢兢，如履薄冰的。</p><p>Java其实在面向对象方面其实比C++做的好一些，从我的基础上看，MVC、IoC、动态代理这些是接触到Java之后才真正了解，而且Java的那本Head First设计模式比C++那本更容易理解。由于Java使用并没有C++使用的深，就此作罢吧。</p><h1 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h1><p>对于泛型编程，除去比用的STL，其实自己写的时候还真的比较少，记忆中，刚开始写Qt界面的时候，3个表格数据不同，表达基本相同，我用泛型做了一个实现。这里做个引用：</p><p>理想情况下，算法应是和数据结构以及类型无关的，各种特殊的数据类型理应做好自己分内的工作。算法只关心一个标准的实现。而对于泛型的抽象，我们需要回答的问题是，如果我们的数据类型符合通用算法，那么对数据类型的最小需求又是什么呢？<br>原文中给出的方式包括3重：</p><ol><li><p>它通过类的方式来解决<br>构造函数与析构函数<br>拷贝构造函数，表示对内存的复制<br>重载操作符</p></li><li><p>通过模板达到类型和算法的妥协。</p></li><li><p>通过虚函数和运行时类型识别。</p></li></ol><p>这里想说一下STL，没有接触STL之前，培训老师出了一题，题目现在已经忘记了，记得最主要的数据结构就是动态数据了，我们自己写链表来实现，人家直接用vector，效率高出许多。如果没用vector、set、map，那C++的路还会坎坷一些。</p><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>函数式编程最早也是从coolshell中看到的，而且缺少实践，需要引用的东西更多一些了。</p><ul><li><p>定义</p><p>定义输入数据和输出数据相关的关系，数学表达式里面其实是在做一种映射（mapping），输入的数据和输出的数据关系是什么样的，是用函数来定义的。</p><p>从通篇来看，函数式编程都是在借鉴函数，y = f(x) ,在这里只定义了一种关系，而且这种关系可以替换，如 z = g(y)，这时候可以将y带入变成z = g(f(x))，由此，函数与变量本身是等价的，自然也就是懒惰的，并且，是可以嵌套的。</p></li><li><p>特点</p><p>stateless: 无状态，就像是电路，本身不能存储电荷一样，有出有入，入多少出多少<br>immutable： 输入数据是不能动的，动了输入数据就有危险，所以要返回新的数据集。这条其实是从stateless中演化而来，对与函数f(x)，进了x就要出y，且x不能变</p></li><li><p>一些技术</p><ul><li>first class function（头等函数），函数像变量一样使用，参考 z = g(f(x))</li><li>recursing(递归)， z = f(f(x))，是对上一条的加深</li><li>pipeline(管道), 原文解释：将函数实例成一个一个的 action，然后将一组 action 放到一个数组或是列表中，再把数据传给这个 action list，数据就像一个 pipeline 一样顺序地被各个函数所操作，最终得到我们想要的结果。 pipleline最早也是shell的管道操作了。在代码方面有点。这些用法其实都是基于stateless的。</li><li>tail recursion optimization(尾递归)</li><li>map &amp; reduce &amp; filter，这个不论在python还是js中都有使用<br>…</li></ul></li><li><p>一些总结</p><ul><li>函数式编程的核心就stateless，仿照y = f(x)，仿照节点不存电荷</li><li>函数可以替换，也就是函数与变量等价，因为这种等价，在多线程调用时候，也就更安全</li><li>函数可以嵌套，也就可以currying、可以recursing、可以pipeline</li></ul></li><li><p>一些问题</p><ul><li><p>关于无状态<br>联想到了http协议，本来设计是一个无状态的协议，最后却不得不加上cookie、session等的加上状态。那函数式变成处理陈老师提到的频繁复制的问题，还会有什么问题。</p><p>另一个是体系架构，都是尽量在做到无状态，但一个请求需要在不同的服务中流转来完成，这种感觉有些像pipeline，需要流转的次序可配置，并且需要记录在每个流程中的一些信息，比如日志聚合，这种方式跟http协议上加cookie是何等的相似。</p><p>需要状态才是函数编程存在的问题，无状态是一种存在，优点也是缺点。</p></li><li><p>函数编程与面向对象编程<br>面向对象基础其实是封装了，封装是将数据与操作封装在一起的思想，这些数据也就是成员变量，就是状态。但完全可以封装一个类，没有成员变量，里边的函数全是函数式的无状态。这种范式即是面向对象，也是函数编程。那其实也就没有继承的必要性了，完全组合就可以，但多态还是需要的，面向接口编程会保存下来。</p></li></ul></li></ul><h1 id="基于原型的编程"><a href="#基于原型的编程" class="headerlink" title="基于原型的编程"></a>基于原型的编程</h1><p>基于原型的编程已经单独总结过了，这里只放个链接：<br><a href="https://sunyanfeng.cn/2019/03/31/js%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B/#more" target="_blank" rel="noopener">js中的原型</a>  </p><p>基于原型的编程，其实就是用组合的方式在完成着继承。继承跟组合的界限在这里有些模糊了。<br>node.js中的异步其实是一种软中断，这一部分可以整体梳理成一个博文了，包括单片机的中断处理、linux上下部的中断处理、以及node.js异步的处理，这里就不多写了。</p><h1 id="编程的本质"><a href="#编程的本质" class="headerlink" title="编程的本质"></a>编程的本质</h1><p>陈老师给出的编程本质也是函数式的：<br>Programs = Algorithms + Data Structures<br>Algorithm = Logic + Control<br>So:<br>Promgrams = Logic + Control + DataStructures<br>其中Logic是业务逻辑，逻辑过程的抽象，加上由术语表示的数据结构的定义<br>Control与业务逻辑无关，你控制它的执行，控制一个程序执行的方式，串行or并行，以及调度不同的执行模块，数据之间的存储关系，这些和业务逻辑无关。</p><p>尤其其中给出的注册验证的代码例子，看的我有些汗颜，重构那个模块时，没有想起来，然后这块代码其实在pg测试里见过，没有联想到可以这样玩。</p><p>这里对logic与control的分离做一点简单的思考：</p><p>在代码级别上，将logic以配置的方式（json、xml）来表达出来，然后将control针对格式来做，而不是针对内容。<br>在服务级别上，跟上边的无状态服务有些类似，每个无状态的服务可以看作是logic，通过编排来control执行的服务。</p><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>本文为了自己记忆方便，做一些记录与思考的东西，所有引用都是从陈皓老师，极客时间《左耳听风》处引来。若有不妥，请联系我，联系方式，详见站内“关于”部分。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇作为笔记形式存在，对左耳听风中的编程范式做笔记，便于以后去查看。&lt;br&gt;原文中主要用到了语言有C、C++、Python、Java、Javascript、Go、Prolog。由于我对Go语言了解不深，委托范式像是一种组合方式的应用，这里就不对这种范式进行记录了，以后有机会，再回来补充;另外Prolog的方式我觉得很有趣，以后想去研究一下再写，这里也不包括在内。&lt;/p&gt;
&lt;p&gt;我需要找到一种合适的记录顺序：原文以一种语言发展的顺序展开，是一种不错的方式; 根据我学习语言的前后顺序，也是一种不错的方式; 再有一种是总分式展开方式。这里选用第二种吧，以我接触这些范式的先后关系来展开。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>第二周ARTS</title>
    <link href="http://yoursite.com/2019/03/31/%E7%AC%AC%E4%BA%8C%E5%91%A8ARTS/"/>
    <id>http://yoursite.com/2019/03/31/第二周ARTS/</id>
    <published>2019-03-31T14:00:37.000Z</published>
    <updated>2019-04-15T02:20:24.908Z</updated>
    
    <content type="html"><![CDATA[<p>第二周打卡<br><a id="more"></a></p><h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><p><a href="https://sunyanfeng.cn/2019/03/31/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98/#more" target="_blank" rel="noopener">最大子数组问题</a></p><h1 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h1><p><a href="https://codeburst.io/interfaces-in-javascript-with-es6-naive-implementation-91b703110a09" target="_blank" rel="noopener">Interfaces in JavaScript with ES6 Symbol. Naive implementation</a></p><p>在javascript中通过Symbol的方式来实现interface</p><p>这种打算通过重写一些代码，有一些东西需要依赖接口来编程，于是就探索了一下在javascript中如何使用接口。这其实与本周share中的原型继承有一定的联系了，于是找到了这篇文章。</p><p>在这篇文章中，通过es6提供的Symbol实现了接口的功能，而且使用了es6的getter与setter，主要依赖就是Symbol的唯一性,试想，如果不用Symbol而是使用string，那样如果一个类不具有这个接口实现中，而偏偏有了一个相同的属性名，这样在判断undefine时就是真，就会出现问题。</p><h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><p><a href="https://sunyanfeng.cn/2019/03/31/Matrix-Determinants/#more" target="_blank" rel="noopener">Matrix Determinants</a></p><h1 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h1><p><a href="https://sunyanfeng.cn/2019/03/31/js%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B/#more" target="_blank" rel="noopener">js中的原型</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二周打卡&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>js中的原型</title>
    <link href="http://yoursite.com/2019/03/31/js%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/03/31/js中的原型/</id>
    <published>2019-03-31T13:08:47.000Z</published>
    <updated>2019-04-02T01:59:42.229Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客主要是想总结一下js中的原型，其中包含《左耳听风》36节之后的一点思考。</p><a id="more"></a><h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><p>在去年刚看JS高程的时候，觉得javascipt这继承真麻烦，并没有去深入思考一下，在看到左耳听风这篇文章后，觉得有了一些新的认识。这里对原型再深入探索一下。</p><p><img src="原型链-1.png" alt="原型链.jpg"><br>从这个图里，可以很明白表达原型链的含义，在每个对象里都有一个<code>__proto__</code>的属性，用来指向其原型。</p><p><img src="原型链-2.png" alt="原型链.jpg"><br>这里是对<code>__proto__</code>与prototype差异的一个说明，Foo每个Function对象都会多一个prototype属性，指向一个对象，其他对象的通过<code>__proto__</code>指向Foo.prototype。</p><p><img src="原型链继承.png" alt="原型链继承"><br>这个是JS高程中原型链继承中的图片，很清楚的看出SubType的prototype对象通过<code>__proto__</code>指向SuperType的prototype来继承其中的方法，instance实例通过<code>__proto__</code>来使用subtype中的方法。</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>这引发了我对两个问题的思考：</p><ol><li><p>为什么要有prototype与<code>__proto__</code></p><p>首先原型链的本质就是通过<code>__proto__</code>来指向其他对象的方式来复用代码，典型的组合方式。那为什么会用prototype呢，我觉得是原因Function两个维度上的使用，其一直接new对象，其二被子类继承使用。因为需要直接new对象，也就需要<code>__proto__</code>；因为需要被其他子Function继承，所以将被继承、被共用的部分独立出来，放到prototype中，本质上是一种模块化思维，将可以被复用的与不能被复用的分离。</p></li><li><p>js为什么以这种方式来实现继承</p><p>js基本属于一切皆对象的语言，函数是对象、类是对象。这样的情况注定没有类型，也就注定只能是组合的方式来完成类。在静态语言中，我们生命一个Student类，然后实例化一个xiaoMing的实例，在这里Student是一个对象，它与xiaoMing本质上是一种东西。xiaoMing通过一个指定的属性依赖Student。</p><p>这其实引发另一个问题，这种组合方式是动态类型语言唯一的方式吗？python中好像并不是这样玩的，这个问题留给以后来思考。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇博客主要是想总结一下js中的原型，其中包含《左耳听风》36节之后的一点思考。&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="编程范式" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Matrix Determinants</title>
    <link href="http://yoursite.com/2019/03/31/Matrix-Determinants/"/>
    <id>http://yoursite.com/2019/03/31/Matrix-Determinants/</id>
    <published>2019-03-31T12:21:42.000Z</published>
    <updated>2019-04-08T02:37:55.934Z</updated>
    
    <content type="html"><![CDATA[<p>本周完成了Gilbert Strang线性代数的中行列式的学习，课程中的Lesson18~Lesson20.</p><p>笔记都是用课程中手记的，这里只做一个简单的记录。</p><a id="more"></a><h1 id="determinants"><a href="#determinants" class="headerlink" title="determinants"></a>determinants</h1><ol><li><p>det I = 1</p></li><li><p>交换2行的位置，符合改变。</p></li><li><p>在每一个行上，都是线性的。</p></li><li><p>A中存在2个相同的行，det A = 0</p></li><li><p>substract c*row(i) from row(j), and the det does not change</p></li><li><p>A: Row of zeros, det A = 0</p></li><li><p>U: 上三角矩阵，d1,d2…dn为主元素， det U = d1 <em> d2 ..</em> dn<br>这个说明可以通过消元法来求解行列式，而且Gilbert老师说，是matlib等求det的主要方法。</p></li><li><p>A: singular, det A = 0</p></li><li><p>det(AB) = detA <em> detB<br>det2A = 2^n </em> det A<br>其实看到这里的时候，Gilbert老师就提到过，这种样子像是求体积，自然而然就意识到det其实就是矩阵的体积，不过带有方向。</p></li><li><p>det A transpose = det A</p></li></ol><h1 id="Big-formula"><a href="#Big-formula" class="headerlink" title="Big formula"></a>Big formula</h1><p><img src="bigformular.png" alt="bigformular"></p><h1 id="cofactor"><a href="#cofactor" class="headerlink" title="cofactor"></a>cofactor</h1><p><img src="cofactor-1.png" alt="cofactor"><br><img src="cofactor-2.png" alt="cofactor"></p><h1 id="原矩阵与逆矩阵"><a href="#原矩阵与逆矩阵" class="headerlink" title="原矩阵与逆矩阵"></a>原矩阵与逆矩阵</h1><h2 id="formular-for-A-1"><a href="#formular-for-A-1" class="headerlink" title="formular for A^(-1)"></a>formular for A^(-1)</h2><p><img src="A-1.png" alt="逆矩阵"></p><h2 id="Cramer’s-Rule"><a href="#Cramer’s-Rule" class="headerlink" title="Cramer’s Rule"></a>Cramer’s Rule</h2><p><img src="cramer_rule_1.png" alt="cramer_rule"><br><img src="cramer_rule_2.png" alt="cramer_rule"><br><img src="cramer_rule_3.png" alt="cramer_rule"></p><p>这个Cramer法则好看不中用</p><h1 id="Volumn"><a href="#Volumn" class="headerlink" title="Volumn"></a>Volumn</h1><p>这个很有趣，是对行列式终极含义</p><p>|det A| is equal to the volumn of matrix</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周完成了Gilbert Strang线性代数的中行列式的学习，课程中的Lesson18~Lesson20.&lt;/p&gt;
&lt;p&gt;笔记都是用课程中手记的，这里只做一个简单的记录。&lt;/p&gt;
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Matrix" scheme="http://yoursite.com/tags/Matrix/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>最大子数组问题</title>
    <link href="http://yoursite.com/2019/03/31/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/03/31/最大子数组问题/</id>
    <published>2019-03-31T09:41:06.000Z</published>
    <updated>2019-04-04T05:58:50.355Z</updated>
    
    <content type="html"><![CDATA[<p>本题是 Leecode的53.Maximum Subarray</p><a id="more"></a><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p><p>Example:</p><p>Input: [-2,1,-3,4,-1,2,1,-5,4],<br>Output: 6<br>Explanation: [4,-1,2,1] has the largest sum = 6.<br>Follow up:</p><p>If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>与上周的主题一样，本周训练的主题还是分治，题目是最大子数组，属于分治里的例题了。</p><p>这个题目思路用暴力来求解，可以设置一个窗口，长度是length(from 1 to length-1)，然后不断的在数组中滑动，比较得到最大的数组,这个的复杂度在o(n^2).</p><p>分治的思路大概是找递归的过程，或者找f(n)与f(n-1)之间关系的过程。子问题的划分其实也与数组的分裂相关，最快的分法就是每次都均分。这个问题就可以这样来解决了，最长子数组：</p><ul><li>完全位于子数组nums[low, middle]</li><li>完全位于子数组nums[middle+1, high]</li><li>子数组跨越中点，这种情况下，需要去求middle~low的最大值以及middle~high的最大值，然后求和即可。</li></ul><p>对于完全位于的，可以继续去递归。</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> constMinInt = <span class="number">-2147483648</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = findMaxSubArray(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (low == high) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[low];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> middle = (low+high)/<span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> leftMax = findMaxSubArray(nums, low, middle);</span><br><span class="line">            <span class="keyword">int</span> rightMax = findMaxSubArray(nums, middle+<span class="number">1</span>, high);</span><br><span class="line">            <span class="keyword">int</span> crossMax = findMaxCrossSubArray(nums, low, high, middle);</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span>  getMax(leftMax, rightMax, crossMax);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxCrossSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> middle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leftMax = constMinInt;</span><br><span class="line">        <span class="keyword">int</span> rightMax = constMinInt;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// left</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=middle; i&gt;=low; --i) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; leftMax) &#123;</span><br><span class="line">                leftMax = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// right</span></span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=middle+<span class="number">1</span>; i&lt;=high; ++i) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; rightMax) &#123;</span><br><span class="line">                rightMax = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> leftMax+rightMax;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span> leftMax, <span class="keyword">int</span> rightMax, <span class="keyword">int</span> crossMax)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (leftMax&gt;=rightMax &amp;&amp; leftMax&gt;=crossMax) &#123;</span><br><span class="line">            <span class="keyword">return</span> leftMax;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (rightMax&gt;=leftMax &amp;&amp; rightMax&gt;=crossMax) &#123;</span><br><span class="line">            <span class="keyword">return</span> rightMax;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> crossMax;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个算法在写的过程中，在getMax时候出现了一点问题，即&gt;=写成了&gt;，造成在获取最大值的时候出现了一点问题，提交后问题解决。</p><p>T(n) = 2T(n/2) + O(n)，根据主定理，复杂度是nlgn.</p><p>还有一个要思考的是对最大子数组的思考。将数组每个元素位置看成横坐标，值看成纵坐标，求和的过程其实是积分的过程，这样，最大子数组，其实是在求这个数组表达的函数的定积分。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本题是 Leecode的53.Maximum Subarray&lt;/p&gt;
    
    </summary>
    
      <category term="练习" scheme="http://yoursite.com/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>第一周ARTS</title>
    <link href="http://yoursite.com/2019/03/24/%E7%AC%AC%E4%B8%80%E5%91%A8ARTS/"/>
    <id>http://yoursite.com/2019/03/24/第一周ARTS/</id>
    <published>2019-03-24T15:22:45.000Z</published>
    <updated>2019-04-15T02:20:24.908Z</updated>
    
    <content type="html"><![CDATA[<p>第一周打卡<br><a id="more"></a></p><h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><p><a href="https://sunyanfeng.cn/2019/03/24/%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/#more" target="_blank" rel="noopener">求两个排序数组的中位数</a></p><h1 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h1><p>Socket.io:优点、缺点、丑陋<br>原文地址：(Socket.io — The Good, the Bad, and the Ugly)[<a href="https://dzone.com/articles/socketio-the-good-the-bad-and-the-ugly]" target="_blank" rel="noopener">https://dzone.com/articles/socketio-the-good-the-bad-and-the-ugly]</a></p><p>本周在做一个消息服务过程中，使用了Socket.io这个模块，并对这个模块进行了简单的分析，这里不再记录，在搜索过程中，发现了这篇由James Roper发表DZone上的文章，觉得比较适合做Review。</p><p>这里抛开它对socket.io不谈，我觉得他说的价值观还不错：</p><ol><li>他强烈的支持反应式系统，这种系统相应，弹性，可扩展，并且是消息驱动的</li><li>他支持高生产率的软件开发的工具、lib以及框架</li><li>他认为好的定义标准以及接口能最大化两个解耦实现之间的兼容性</li></ol><p>这里他说的这几个特点，与陈皓老师在技术领导力以及分布式系统架构的一些观念类似，比如提高效率的事，分布式架构之间解耦的过程等</p><h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><p><a href="https://sunyanfeng.cn/2019/03/24/Matrix-Projection/#more" target="_blank" rel="noopener">Matrix Projection</a></p><h1 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h1><p><a href="https://sunyanfeng.cn/2019/03/21/%E7%94%B1%E4%B8%80%E4%B8%AASelect%E5%BC%95%E8%B5%B7%E7%9A%84%E6%8E%A2%E7%B4%A2/#more" target="_blank" rel="noopener">由一个Select引起的探索</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一周打卡&lt;br&gt;
    
    </summary>
    
      <category term="ARMS" scheme="http://yoursite.com/categories/ARMS/"/>
    
    
  </entry>
  
  <entry>
    <title>Matrix Projection</title>
    <link href="http://yoursite.com/2019/03/24/Matrix-Projection/"/>
    <id>http://yoursite.com/2019/03/24/Matrix-Projection/</id>
    <published>2019-03-24T15:08:56.000Z</published>
    <updated>2019-04-01T01:21:18.523Z</updated>
    
    <content type="html"><![CDATA[<p>本周完成了Gilbert Strang线性代数的正交、投影、正交矩阵的学习，课程中的Lesson14～Lesson17</p><p>笔记都是用课程中手记的，这里只做一个简单的记录。</p><a id="more"></a><h1 id="Orthogonal-正交"><a href="#Orthogonal-正交" class="headerlink" title="Orthogonal 正交"></a>Orthogonal 正交</h1><ol><li>两个向量正交的定义</li><li>子空间正交： row space is orthogonal to null space;<pre><code>column space is orthogonal to null space of A tranpose</code></pre></li><li><p>正交的意义：the best solution Ax=b when there is no solution</p><pre><code>which means seperate the nosize from the infomation.A^T&lt;/sup&gt;AX = A&lt;sup&gt;T&lt;/sup&gt;b</code></pre></li></ol><h1 id="Projection投影"><a href="#Projection投影" class="headerlink" title="Projection投影"></a>Projection投影</h1><ol><li>向量投影</li><li>矩阵投影</li><li>投影矩阵</li><li>最小二乘法</li></ol><p>这一部分已经充分说明了一个基本认知：矩阵就是向量。主要研究的是投影矩阵，因为任何向量与它想乘都会映射到相应的空间中。这里对最小二乘法的矩阵解释也很令人印象深刻。</p><h1 id="Orthonomal-Matrix-正交矩阵"><a href="#Orthonomal-Matrix-正交矩阵" class="headerlink" title="Orthonomal Matrix 正交矩阵"></a>Orthonomal Matrix 正交矩阵</h1><p>正交矩阵就是一个向量空间两两垂直的向量组成的一组基。<br>它的好处是简化了投影运算效率</p><ol><li>正交矩阵的定义与意义</li><li>求解正交矩阵的方法：Gramh-schmit方法，（其实就是不断减p然后归一化的过程）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周完成了Gilbert Strang线性代数的正交、投影、正交矩阵的学习，课程中的Lesson14～Lesson17&lt;/p&gt;
&lt;p&gt;笔记都是用课程中手记的，这里只做一个简单的记录。&lt;/p&gt;
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Matrix" scheme="http://yoursite.com/tags/Matrix/"/>
    
  </entry>
  
</feed>
