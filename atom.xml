<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>思 见</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-06-09T08:22:31.646Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>sun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Matrix基础</title>
    <link href="http://yoursite.com/2019/06/04/Matrix%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/06/04/Matrix基础/</id>
    <published>2019-06-04T14:27:16.000Z</published>
    <updated>2019-06-09T08:22:31.646Z</updated>
    
    <content type="html"><![CDATA[<p>初次看的时候，这一部分的笔记没有做，这次复习博客，这一部分也没有记录，现在将这一部分补上，整个课程的笔记终于全了。</p><a id="more"></a><h1 id="Ax-b"><a href="#Ax-b" class="headerlink" title="Ax=b"></a>Ax=b</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2x -  y = 0</span><br><span class="line">-x + 2y = 3</span><br></pre></td></tr></table></figure><ul><li><p>row picture<br>以行的角度来看Ax=b就是两个等式，画出的图像如下图所示。<br><img src="matrix-row-picture.png" alt="matrix-row-picture"></p></li><li><p>column picture<br>以列的角度来看，可以将等式转化成：<img src="等式的column形式.png" alt="等式的column形式">，画出的图像为：<br><img src="matrix-column-picture.png" alt="matrix-column-picture"><br>由此，成功的引入的向量。  </p></li></ul><ul><li>matrix picture<br>进一步，引入等式的矩阵形式：<img src="等式的matrix形式.png" alt="等式的matrix形式"><br>矩阵形式其实包括了row的角度与column的角度，在整个课程中，Strange老师习惯于使用column形式，感觉更矩阵化。</li></ul><h1 id="Elimination消元法"><a href="#Elimination消元法" class="headerlink" title="Elimination消元法"></a>Elimination消元法</h1><p>消元法是从行向量来看的，并且可以把消元的过程用permutation矩阵乘积的方式表达出来</p><ul><li><p>消元法<br>Ax = b，其中A与b为：<br><img src="elimination示例.png" alt="elimination示例"><br>利用行向量变化来转换A与b：<br><img src="elimination示例中A的变化.png" alt="elimination示例中A的变化"><br>同样的变化发生在b上：<img src="elimination示例中b的变化.png" alt="elimination示例中b的变化"><br>由此可求解x为[2, 1, -2]  </p></li><li><p>主元pivot<br>U的行列式等于主元元素的乘积。<br>主元不能为0，如果0在主元位置，需要交换一个非零的行。若没有零元素了，那么A是奇异的，是不可逆的</p></li><li><p>矩阵乘积与消元<br>![矩阵乘积与消元])(矩阵乘积与消元.png)<br>从矩阵row角度去看，左侧表示第二行的变换，row2 - 3*row1 得到右侧矩阵</p></li><li><p>消元法与permutation(交换矩阵)<br>如果存在pivot位置上存在0值，会用到交换，这时候就需要permutation:<br><img src="elimination中的permutation.png" alt="elimination中的permutation"><br>表示交换第1，2行</p></li><li><p>elimination逆操作<br> elimination一定是可逆的操作，由后一个矩阵通过逆操作可以变化成前一个矩阵。对于<br><img src="elimination的逆操作-1.png" alt="elimination的逆操作-1"><br>其逆操作（逆矩阵）为：<br><img src="elimination的逆操作-2.png" alt="elimination的逆操作-2">  </p></li><li><p>消元法的空间复杂度<br><img src="消元法复杂度.png" alt="消元法复杂度">  </p></li></ul><h1 id="矩阵乘法与逆"><a href="#矩阵乘法与逆" class="headerlink" title="矩阵乘法与逆"></a>矩阵乘法与逆</h1><ul><li><p>矩阵乘法<br>前文已经接触过2种矩阵的乘法了，row角度与column角度，不过都是矩阵与向量的方式在呈现，这里做引申：  </p><ul><li><p>column<br>对与 AB = C，C的第j列可以看作A与B的第j列的乘积，也就是以B<sub>j</sub>的为参数来组合A  </p></li><li><p>row<br>同样 AB = C，C的第i行可以看作A<sub>i</sub>与B的乘积，以A<sub>i</sub>来结合B的各行。  </p></li><li><p>每个元素<br><img src="矩阵乘法公式.png" alt="矩阵乘法公式">  </p></li><li><p>扩展<br>可以将矩阵乘法扩展到块上，每个块也符合矩阵乘法<br><img src="矩阵乘法block.png" alt="矩阵乘法block">  </p></li></ul></li><li><p>逆:inverse<br>有了乘法自然就有了逆，就像有了乘法就有了倒数一个道理。<br>逆是对方阵而言，左逆、右逆才是对川型阵与三型阵而言。<br>A<sup>-1</sup>A = I = AA<sup>-1</sup>  </p><p>有了逆的概念也就引出了奇异的概念首先，矩阵有逆，说明用它做线性变换，可以反变换回来，它在自己的满秩空间中是完全的，其行列式为非0值。</p></li><li><p>Gauss-Jordan消元法求逆<br>就是一个小trick，将A与I一起做elimination，当A变成I时，I也就变成A<sup>-1</sup><br><img src="Gauss-Jordan法求逆.png" alt="Gauss-Jordan法求逆">  </p></li></ul><h1 id="A-LU分解"><a href="#A-LU分解" class="headerlink" title="A=LU分解"></a>A=LU分解</h1><ul><li><p>示例<br>LU分解是从eliminate与inverse概念中产生的：<br><img src="LU示例-1.png" alt="LU示例-1"><br><img src="LU示例-2.png" alt="LU示例-2">  </p><p>由此，得出A可以分成一个下三角矩阵L与上三角矩阵U乘积</p></li><li><p>小推导<br>由eliminate得，E<sub>32</sub>E<sub>31</sub>E<sub>21</sub>A = U，然后通过逆矩阵：A=E<sub>21</sub><sup>-1</sup>E<sub>31</sub><sup>-1</sup>E<sub>32</sub><sup>-1</sup>U = LU<br>每一个E<sub>ij</sub>都是一个下三角矩阵，其乘积也是L  </p></li><li><p>用处<br>这里我觉得少点A=LU的应用，或者叫why factorization A into LU</p></li></ul><h1 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h1><ul><li><p>permutation：置换，或者叫变换<br>P<sup>-1</sup> = P<sup>T</sup>，即P<sup>T</sup>P = I </p></li><li><p>transpose: 转置，颠倒</p></li><li><p>向量空间<br>向量空间对于线性操作是闭合的，其中线性操作指的是加法与数乘，闭合指的是对向量做线性操作后的向量还在原空间中。</p><p>aV+bW</p></li><li><p>子空间<br>子空间指的是被包含在另一个空间里的空间，子空间是闭合的，要想闭合，必须包括零向量，分析一下R<sup>3</sup>的子空间：  </p><ol><li>所有的R<sup>3</sup></li><li>所有穿越原点的平面</li><li>所有穿越原点的线</li><li><p>原点(zero vector)本身  </p><p>由此可以引申出columnspace了，对于任意向量A，它的列向量可以形成一个子空间。</p></li></ol></li></ul><h1 id="columnspace"><a href="#columnspace" class="headerlink" title="columnspace"></a>columnspace</h1><ul><li><p>column space<br>column space指的是A的各列通过线性组合形成的空间。  </p><p>Ax = b<br>从列角度看，b是A各列的一种结合，反过来，b在什么情况下，Ax=b有解。答案是b在A的列空间内。  </p></li></ul><h1 id="nullspace与求解Ax-0"><a href="#nullspace与求解Ax-0" class="headerlink" title="nullspace与求解Ax=0"></a>nullspace与求解Ax=0</h1><ul><li>定义<br>null space 是Ax = 0 所有解形成的空间。<br>它满足A(x1 + x2) = Ax1 + Ax2 = 0;  A(cx) = cAx = 0<br>有null space说明 A个各列组合可以变成0，也就是A并不是满秩的，它的各列有依赖。  </li></ul><ul><li><p>计算<br>计算A的nullsapce<br>A: <img src="nullspace计算示例.png" alt="nullspace计算示例">  </p><p>首先对A进行消元，nullspace向量的个数等于自由列（非主元列）的个数<br><img src="nullspace计算示例-消元1.png" alt="nullspace计算示例-消元1"> <img src="nullspace计算示例-消元2.png" alt="nullspace计算示例-消元2"><br>其中可以看到第2列与第4列是自由列，分别假设x2=1,x4=0; x2=0,x4=1，求解得两个向量：<br><img src="nullspace计算示例-解1.png" alt="nullspace计算示例-解1">  <img src="nullspace计算示例-解2.png" alt="nullspace计算示例-解2"></p><p>更进一步：<br><img src="nullspace计算示例-提升1.png" alt="nullspace计算示例-提升1"><br><img src="nullspace计算示例-提升2.png" alt="nullspace计算示例-提升2"><br><img src="nullspace计算示例-提升3.png" alt="nullspace计算示例-提升3">  </p></li></ul><h1 id="求解Ax-b"><a href="#求解Ax-b" class="headerlink" title="求解Ax = b"></a>求解Ax = b</h1><p>有了Ax = 0 的解，就可以对Ax = b进行求解，Ax = b的求解是先求特解，再加上nullspace即可<br>同样对于上文的示例 A: <img src="nullspace计算示例.png" alt="nullspace计算示例">， b: <img src="求解Ax的b.png" alt="求解Ax的b">  </p><ul><li><p>特解<br><img src="Ax的b消元.png" alt="Ax的b消元"><br>x1 + 2x3 = 1 </p><pre><code>2x3 = 3 </code></pre><p>这样：x1=-2, x3=3/2 ，特解：<br><img src="Ax的b特解.png" alt="Ax的b特解">  </p></li><li><p>解<br>上文求出了nullspace，这样解为：<br><img src="Ax的b全解.png" alt="Ax的b全解"></p></li><li><p>Ax=b解分析<br><img src="Ax的b解分析.png" alt="Ax的b解分析"></p></li></ul><h1 id="无关、基、维度"><a href="#无关、基、维度" class="headerlink" title="无关、基、维度"></a>无关、基、维度</h1><ul><li><p>线性无关<br>前文一直在用满秩、行列式不为0等描述线性无关，这里对线程无关进行定义：<br>如果c<sub>1</sub>x<sub>1</sub> + c<sub>2</sub>x<sub>2</sub> + c<sub>n</sub>x<sub>n</sub>，仅当c<sub>1</sub>,c<sub>2</sub>,c<sub>n</sub>全部为0时成立，那么x就列向量线性无关  </p></li><li><p>基与维度<br>有了线性无关的概念，结合向量空间来做一个综合。<br>向量空间的基是这样一组向量：  </p><ol><li>它们线性无关  </li><li>它们生成了向量空间(最小包含)  </li></ol><p>向量空间基的个数称为空间的维度</p></li><li><p>columnspace与nullspace的基<br>有了基的概念，就应用到columnspace与nullspace上：<br>C(A)的维度 = A主元的个数 = rank(A)<br>N(A)的维度 = A自由向量的个数 = n - rank(A)</p></li></ul><h1 id="4个子向量空间"><a href="#4个子向量空间" class="headerlink" title="4个子向量空间"></a>4个子向量空间</h1><p>这里引出了基础部分的核心：矩阵的4个空间<br>对于m×n的矩阵A,其4个空间的关系为：</p><table><thead><tr><th>columnspace:C(A)</th><th>Nullpace:N(A)</th><th>Rowspace:C(A<sup>T</sup>)</th><th>left nullspace:N(A<sup>T</sup>)</th></tr></thead><tbody><tr><td>dim C(A)=r</td><td>dim N(A)=n-r</td><td>dim C(A<sup>T</sup>)=r</td><td>dim N(A<sup>T</sup>) = m-r</td></tr></tbody></table><p><img src="4个向量空间.png" alt="4个向量空间"></p><h1 id="空间概念引申"><a href="#空间概念引申" class="headerlink" title="空间概念引申"></a>空间概念引申</h1><h2 id="矩阵空间"><a href="#矩阵空间" class="headerlink" title="矩阵空间"></a>矩阵空间</h2><p>这里是对向量空间的引申，向量可以形成空间，同样矩阵也能形成空间，只要满足线性闭合条件：加法与数乘即可。<br>所有的3×3矩阵形成的矩阵空间M，它的几个子空间：  </p><ul><li>所有上（下）三角矩阵  </li><li>所有的对称矩阵</li><li>所有的对角矩阵</li></ul><p>3×3矩阵空间的基为： <img src="空间引申1.png" alt="空间引申1">  </p><h2 id="微分方程"><a href="#微分方程" class="headerlink" title="微分方程"></a>微分方程</h2><p><img src="空间引申2-1.png" alt="空间引申2-1"><br><img src="空间引申2-2.png" alt="空间引申2-2"><br><img src="空间引申2-3.png" alt="空间引申2-3">  </p><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>这个也可以看作一个应用，其在电路上叫基尔霍夫定律：  </p><ul><li><p>图的矩阵形式<br>一个4个node，5个edge的图：<img src="图1.png" alt="图1"><br>以列表示node，行表示edge的矩阵： <img src="图2.png" alt="图2">  </p></li><li><p>矩阵的空间在图上的含义<br>A：m×n = 5×4</p><p>rank(A) = 3，其主元列向量形成的没有环的图：树<br>N(A) = 4-3 = 1</p><p>N(A<sup>T</sup>)=5-3=2，2是A图中环的个数。<br>欧拉公式； 节点个数 - 边个数 + 环个数 = 1</p></li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>第一部分的主线是求解Ax=b，从Matrix的引出，到Ax=0，再到elimination、LU分解，再到column space，从Ax=0引出了nullspace，最后到向量空间，</p><p>这一部分的重点就是向量空间，不仅包括Matrix的4个子向量空间，也包括空间的基、维度等重要概念  </p><p>在应用上，矩阵空间、微分方程、图都是重要的应用  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;初次看的时候，这一部分的笔记没有做，这次复习博客，这一部分也没有记录，现在将这一部分补上，整个课程的笔记终于全了。&lt;/p&gt;
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Matrix" scheme="http://yoursite.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>next.js弃坑总结</title>
    <link href="http://yoursite.com/2019/05/23/next%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/05/23/next实践总结/</id>
    <published>2019-05-23T02:30:00.000Z</published>
    <updated>2019-06-03T00:29:33.096Z</updated>
    
    <content type="html"><![CDATA[<p>关键字：next.js</p><a id="more"></a><h1 id="next-js接触"><a href="#next-js接触" class="headerlink" title="next.js接触"></a>next.js接触</h1><p>接触next.js的过程在<a href="">next.js记录</a>中已经说过了，主要是在自己搭建后台渲染过程中，使用了web-isomorphic-tools，而它官网中，推荐使用其进化版本universal-tools或者使用集成了universal-tools的next.js。而自己搭建的渲染，跳过了无数坑之后，渲染Materila-Ui组件时失败，况且不知道越过这坑后边是否还有坑，索性研究一下next.js.</p><p>next.js是一个后台渲染的MPA（多页面应用）</p><h1 id="next-js优点"><a href="#next-js优点" class="headerlink" title="next.js优点"></a>next.js优点</h1><ul><li><p>后台渲染做的不错<br>对Material-Ui支持不错</p></li><li><p>代码切割做的不错<br>本身是不过加载页面中不用的component，也可以手动进行动态加载，并支持prefetch(预取)的功能，提高加载的速度。</p></li><li><p>动态数据加载做的可以<br>由前端服务器向api server获取数据使用getInitPrepoty的方式不错</p></li></ul><h1 id="next-js缺点"><a href="#next-js缺点" class="headerlink" title="next.js缺点"></a>next.js缺点</h1><p>这里的缺点是针对我们应用的场景而言</p><ul><li><p>文件系统路由的方式不太适合<br>虽然它支持定制路由，但也仅是做了as，类似于一个别名，还需要服务侧做转换。<br>并且由于文件系统路由，使它内部仅支持用query方式(url?key=value)传参，若需要param方式(/:userId)，需要使用定制url。</p></li><li><p>对componet不太友好<br>在面临选择page还是componet时，next.js偏向与page。比如通过link导向一个page，然后在page进行一些操作之后，通过component切换的形式来做一些view的切换，这时候如果想再逆操作时，没法通过点击link的方式进行切换，只能自己控制。link发现地址没变，点击不会响应。  </p></li><li><p>传参问题<br>由于更多的页面，在传值问题上存在更多的挑战。使用react的component，可以愉快的使用向下流的传值，而页面只能在地址中增加一些id，然后在页面内部再次去获取数据，这样效率比较低一些。</p></li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>与同事讨论之后，我们觉得，next.js更适合向博客、新闻等使用场景，不太适合写数据交互多的场景，这样就准备弃用了。<br>如果非要用next.js来写的话，感觉可以将next.js做一个后端渲染的活，然后在next.js之上移植react-router，由MPA转换成SPA，这方面的资料在next.js github的issue中可以找到一点，有兴趣的朋友可以考虑一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关键字：next.js&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="next.js" scheme="http://yoursite.com/tags/next-js/"/>
    
  </entry>
  
  <entry>
    <title>同构SPA应用jwt实践</title>
    <link href="http://yoursite.com/2019/05/23/%E5%90%8C%E6%9E%84SPA%E5%BA%94%E7%94%A8jwt%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2019/05/23/同构SPA应用jwt实践/</id>
    <published>2019-05-23T01:30:00.000Z</published>
    <updated>2019-06-03T00:29:33.096Z</updated>
    
    <content type="html"><![CDATA[<p>关键字：Isomorphic、SPA、Jwt</p><a id="more"></a><h1 id="Jwt简介"><a href="#Jwt简介" class="headerlink" title="Jwt简介"></a>Jwt简介</h1><p>先介绍一下Jwt:<a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener">Jwt简介</a></p><h1 id="3层过程"><a href="#3层过程" class="headerlink" title="3层过程"></a>3层过程</h1><ul><li>浏览器获取页面，前端服务器发现未登录，重定向到登录页面&lt;这个重定向由后端控制&gt;</li><li>录入用户、密码，发送给accout后端服务，验证信息，返回jwt给浏览器</li><li><p>登录成功，浏览器重定向到主页面，此时携带token&lt;这个重定向由浏览器控制&gt;</p></li><li><p>前端服务器接收到主页的请求，再次进行验证，发现已经登录，返回主页面</p></li><li>浏览器做前端渲染，向后台请求数据时，携带token。进行验证。</li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li><p>查资料说，token可以通过cookie来设置，也可以通过localStorage来设置<br>token通过Set-Cookie的方式发送给浏览器但一直没有设置成功，设置了domain、path、max-age<br><a href="http://bubkoo.com/2014/04/21/http-cookies-explained/" target="_blank" rel="noopener">cookie详解</a><br>后来通过浏览器调用document.cookie来进行设置</p></li><li><p>使用cookie设置的问题<br>token时间与cookie时间问题，token与cookie各有自己的过期时间，两个时间不一致会存在问题，不太喜欢2个源的东西。</p></li><li><p>使用localStorage的问题<br>存储在LocalStorag里的问题是，无法在向前端服务器请求页面的时候，自动携带这个token。</p></li><li><p>后端缓存token的问题<br>jwt本身设计就是stateless，如果加上缓存，就是一有状态的东西，与sessionId的使用一致。<br>需要用一些规则来包成token的安全</p></li></ul><h1 id="token安全规则"><a href="#token安全规则" class="headerlink" title="token安全规则"></a>token安全规则</h1><p>  <a href="https://stackoverflow.com/questions/30523238/best-practices-for-server-side-handling-of-jwt-tokens" target="_blank" rel="noopener">token最佳实践</a></p><h1 id="2层过程"><a href="#2层过程" class="headerlink" title="2层过程"></a>2层过程</h1><p>思维过程如下：<br>用cookie来传输jwt由于2个过期时间，所以弃用<br>=&gt; 选择localStorage来存储<br>=&gt; 无法给前端服务器携带<br>=&gt; 放弃前端服务器重定向<br>=&gt; 使用浏览器端的重定向</p><p>浏览器端的重定向通过判断localStorage中是否存在jwt来判断是否登录，判断时机是整个页面重渲染时，由于是Isomorphic的SPA，这个时机可以认为是在页面第一次从后端取之后，前端第一次渲染时做的判断。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关键字：Isomorphic、SPA、Jwt&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="jwt" scheme="http://yoursite.com/tags/jwt/"/>
    
  </entry>
  
  <entry>
    <title>Matrix-图像压缩与伪逆</title>
    <link href="http://yoursite.com/2019/05/22/Matrix-%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9%E4%B8%8E%E4%BC%AA%E9%80%86/"/>
    <id>http://yoursite.com/2019/05/22/Matrix-图像压缩与伪逆/</id>
    <published>2019-05-21T22:32:16.000Z</published>
    <updated>2019-06-05T03:24:48.934Z</updated>
    
    <content type="html"><![CDATA[<p>原课程Lessson31～Lesson32课，图像压缩是基于基变换，伪逆</p><a id="more"></a><h1 id="图像压缩"><a href="#图像压缩" class="headerlink" title="图像压缩"></a>图像压缩</h1><ul><li>图像的向量表示<br>对于一副512×512的的黑白图像，它有512<sup>2</sup>个像素，每个像素用8bit的信息来表达，<img src="图片的矩阵表示.png" alt="图片的矩阵表示"></li><li>压缩的必要性<br>如果采用标准基(I)，来表示每一张图片，每一张图片都需要512<sup>2</sup>bit的数据，那所用的带宽太高。如果根据JPEG的标准，换一种基来表达，那么可以更高效的表达、传输数据。<br>以黑板为例，如果是标准基，那每个图片，都需要那么多的数据，但如果用一种基，其中一个基向量代表亮度，那黑板图片，就可以压缩到很小。<br>下边整理一下常见的基.  </li></ul><h2 id="傅里叶基"><a href="#傅里叶基" class="headerlink" title="傅里叶基"></a>傅里叶基</h2><p><img src="傅里叶基.png" alt="傅里叶基"><br>在JPEG中，使用的是w<sup>jk</sup>的实部，也就是cos分量。<br>它将512<sup>2</sup>的向量，分裂成8×8的小块，然后进行压缩，然后剔除掉系数低于某阈值。<br><img src="傅里叶基的使用.png" alt="傅里叶基的使用"></p><h2 id="小波基"><a href="#小波基" class="headerlink" title="小波基"></a>小波基</h2><p><img src="小波基.png" alt="小波基"><br>JPEG2000中采用小波基从上图中可以看出，示例小波基中，每个向量的非零元素在折半递减。</p><h2 id="压缩与矩阵"><a href="#压缩与矩阵" class="headerlink" title="压缩与矩阵"></a>压缩与矩阵</h2><p>  线性代数用来计算从标准基到傅里叶基或者小波基的系数。<br>  <img src="图像基变换公式1.png" alt="图像基变换公式1"><br>  <img src="图像基变换公式2.png" alt="图像基变换公式2"><br>  故，可得c = W<sup>-1</sup>x.<br>  上式中，如果选择合适的基向量使W<sup>-1</sup> = W<sup>T</sup>，这样计算效率就会大大提高。</p><h1 id="基变换"><a href="#基变换" class="headerlink" title="基变换"></a>基变换</h1><p>对于一个在旧基的向量A，可以通过x=Wc关系，转换到新基体系中，转换后的向量是B。<br>A和B是相似的: B=M<sup>-1</sup>AM  </p><p>对于旧基，用v<sub>1</sub>,v<sub>2</sub>…v<sub>8</sub>来表示<br>A暂时用v来表示： <img src="v表示.png" alt="v表示"><br>转换之后表示为： T(v) = c<sub>1</sub>T(v<sub>1</sub>) + c<sub>2</sub>T(v<sub>2</sub>) + … +c<sub>8</sub>T(v<sub>8</sub>)</p><p>如果T(v<sub>i</sub>) = λ<sub>i</sub>x<sub>i</sub>，这样的变化效率是最高的，但计算一个图像的特征向量，是一件计算量很大的操作，所以不如用佛里叶变换或小波变换。  </p><h1 id="左逆"><a href="#左逆" class="headerlink" title="左逆"></a>左逆</h1><p>左逆是矩阵A：m×n rank(A) = n而言的，川型矩阵</p><p>(A<sup>T</sup>A)<sup>-1</sup>A<sup>T</sup>A = I 我们说：<br><img src="A的左逆.png" alt="A的左逆"> 是A 的左逆。</p><h1 id="右逆"><a href="#右逆" class="headerlink" title="右逆"></a>右逆</h1><p>同样的道理，来类比右逆，右逆是对A: m×n rank(A) = m而言，三型矩阵<br><img src="A的右逆.png" alt="A的右逆"> 是A的右逆。</p><h1 id="伪逆"><a href="#伪逆" class="headerlink" title="伪逆"></a>伪逆</h1><p>左右逆解决了长方形矩阵的逆的问题，但对于奇异矩阵，如何来找到最佳的逆呢？伪逆。<br>因为是奇异矩阵，Ax=0存在非0解，存在着null space，也就不可能有逆的存在。伪逆其实建立的是A的row space与column space之间对应关系。A中row space 中的向量与column space中的向量一一对应。证明略。<br>向量x在row space中 Ax转换到column space上，称之为Ax， 然后再通过A<sup>+</sup>，再转换回来。<img src="伪逆.png" alt="伪逆">  </p><p>A = UΣV<sup>T</sup>  =&gt;  A<sup>+</sup> = UΣ<sup>+</sup>V<sup>T</sup>.</p><p>Σ<sup>+</sup>:1/σ1, 1/σ2, …, 1/σ</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原课程Lessson31～Lesson32课，图像压缩是基于基变换，伪逆&lt;/p&gt;
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Matrix" scheme="http://yoursite.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>next.js记录</title>
    <link href="http://yoursite.com/2019/05/12/next%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/05/12/next记录/</id>
    <published>2019-05-12T07:35:49.000Z</published>
    <updated>2019-05-12T12:31:24.187Z</updated>
    
    <content type="html"><![CDATA[<p>本文为学习next.js而做的笔记，主要参照<a href="https://nextjs.org/docs" target="_blank" rel="noopener">官网</a> ，也会借鉴<a href="https://juejin.im/post/5b868b45e51d4538ae4db7ca" target="_blank" rel="noopener">Next.js踩坑</a>  </p><a id="more"></a><h1 id="起因与目的"><a href="#起因与目的" class="headerlink" title="起因与目的"></a>起因与目的</h1><p>最早接触next.js是在看webpack-isomorphic-tools的官网时候，其推荐新项目使用universal-tools，或者直接用next.js这样的框架。那时候基于create-react-app而搭建的同构已经走了大半，没有继续研究next.js。而搭建的系统遇到了stylus问题，一时间没有找到解决方案，就试着接触一下next.js，一方面想看一下next.js是如何解决这个问题的，另一方也看一下是否可以直接使用next.js。<br>看过之后，觉得next.js是不错的框架，值得去整理一下。</p><p>next.js是一个基于react的SSR框架，它有很多特性值得去应用，下边对这些特性进行整理  </p><p>对于SSR，首先它需要根据浏览器的路径，选择合适的页面、组件进行渲染；<br>其次，<code>&lt;head&gt;</code>中对静态文件的引用，页面中也会包含一些静态的文件，包括react、material的js，还有一些图片等；<br>接着，页面、组件加载时为了提升性能，就需要一些技术：代码切割、预取页面、动态导入等<br>然后，对于有些请求，需要从api sever中加载数据，然后再渲染到页面上；<br>再然后，对于登录，需要判断是否登录（头部判断），再进行路由的跳转；<br>最后，在同构的时候react-router有对history的使用，对于这一点有点疑问，浏览器显然是有自己的一块存储区域来存储历史，为什么在服务器也会看到history？<br>这期间还夹杂一些基础，如对css的支持、路由的参数等</p><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><h2 id="文件系统路由"><a href="#文件系统路由" class="headerlink" title="文件系统路由"></a>文件系统路由</h2><p>  next.js是一个文件系统路由，意思是，需要一个pages目录，这个目录对应’/‘路由；若存在’/home’路由，则需要page目录下有一个home目录。路由与目录结构对应。  </p><p>  这种方式跟最早接触的tomcat有些类似，也与http的静态文件形态时候形同。<br>  webship中维护一个路由与文件的映射；<br>  react-router常见的用法是SPA，只有一个页面，也就不太需要这种映射。</p><h2 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h2><p>  Next.js没有一个记录所有路由的清单，当前页面对其他页面一无所知。这样，浏览器中页面的组织、跳转是通过<code>Link</code>来完成的.与html的<code>&lt;a&gt;</code>标签很相似。  </p><p>  它有2个主要属性：<br>  <code>href</code>：a标签的href，包括路由+请求参数。<br>  <code>as</code>：在浏览器中展示的URL。这个听起来有点怪，需要多做一个说明。<code>next.js</code>本身只支持文件系统路由 与 query形式的参数传递，但为了支持制定方式，可以讲文件系统路由命名成其他的路由，展示在浏览器上。这个就是定制路由</p><p>  url参数：<br>  <code>/about?name=Zeit</code>，从根上，next只支持query形式的传参，对于param形式的传参，需要用<code>as</code></p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link href=&#123;&#123; pathname: '/about', query: &#123; name: 'Zeit' &#125; &#125;&#125;&gt;</span><br><span class="line">  &lt;a&gt;here&lt;/a&gt;</span><br><span class="line">&lt;/Link&gt;</span><br></pre></td></tr></table></figure><h2 id="定制路由"><a href="#定制路由" class="headerlink" title="定制路由"></a>定制路由</h2><ul><li>对于<code>/post/:slug</code>路由  </li><li><p>需要在<code>pages/post.js</code>  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Post</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">async</span> getInitialProps(&#123; query &#125;) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'SLUG'</span>, query.slug);</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>My blog post<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Post;</span><br></pre></td></tr></table></figure></li><li><p>在服务增加一个对<code>/post/:slug</code>路由的响应  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.get(<span class="string">'/post/:slug'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> app.render(req, res, <span class="string">'/post'</span>, &#123; <span class="attr">slug</span>: req.params.slug &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里需要将这个<code>/post/:slug</code>路由转换成内部的<code>/post</code>路由，参数通过query的方式传递。</p></li><li><p>在前端使用<code>next/link</code>  </p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link href=<span class="string">"/post?slug=something"</span> <span class="keyword">as</span>=<span class="string">"/post/something"</span>&gt;</span><br></pre></td></tr></table></figure></li></ul><h1 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h1><ul><li><p>static<br>next.js除了pages目录用于放页面，还有一个static目录用于存放静态文件，这个目录是设定死的，不能改变。路由上使用<code>/  static/</code>与之对应。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyImage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/static/my-image.png"</span> <span class="attr">alt</span>=<span class="string">"my image"</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">export default MyImage;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="加载性能"><a href="#加载性能" class="headerlink" title="加载性能"></a>加载性能</h1><h2 id="代码切割"><a href="#代码切割" class="headerlink" title="代码切割"></a>代码切割</h2><p>  代码切割不应该属于静态文件，指的是对于页面，仅会加载<code>import</code>到的组件，并不会加载其他组件。  </p><h2 id="预取页面"><a href="#预取页面" class="headerlink" title="预取页面"></a>预取页面</h2><p><code>prefetch</code>预取页面是<code>Link</code>的第三个属性，加上它，next.js会在后台自动加载这些页面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">'next/link'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;nav&gt;</span><br><span class="line">            &lt;Link prefetch href=<span class="string">"/"</span>&gt;</span><br><span class="line">                &lt;a&gt;Home&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>Link&gt;</span><br><span class="line">            &lt;Link prefetch href=<span class="string">"/about"</span>&gt;</span><br><span class="line">                &lt;a&gt;About&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>Link&gt;</span><br><span class="line">            &lt;Link prefetch href=<span class="string">"/contact"</span>&gt;</span><br><span class="line">                &lt;a&gt;Contact&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>Link&gt;</span><br><span class="line">        &lt;<span class="regexp">/nav&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default Header;</span></span><br></pre></td></tr></table></figure><h2 id="动态引用组件"><a href="#动态引用组件" class="headerlink" title="动态引用组件"></a>动态引用组件</h2><p>动态引用可以认为是另一种控制代码切割的方式。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// components/hello.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dynamic <span class="keyword">from</span> <span class="string">'next/dynamic'</span>;</span><br><span class="line"><span class="keyword">const</span> DynamicComponent = dynamic(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../components/hello'</span>));</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Header /&gt;</span><br><span class="line">      &lt;DynamicComponent /&gt;</span><br><span class="line">      &lt;p&gt;HOME PAGE is here!<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default Home;</span></span><br></pre></td></tr></table></figure><p>动态引入还支持对组件的引入不使用SSR。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dynamic <span class="keyword">from</span> <span class="string">'next/dynamic'</span>;</span><br><span class="line"><span class="keyword">const</span> DynamicComponentWithNoSSR = dynamic(</span><br><span class="line">  () =&gt; <span class="keyword">import</span>(<span class="string">'../components/hello3'</span>),</span><br><span class="line">  &#123;</span><br><span class="line">    ssr: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Header /&gt;</span><br><span class="line">      &lt;DynamicComponentWithNoSSR /&gt;</span><br><span class="line">      &lt;p&gt;HOME PAGE is here!<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Home;</span></span><br></pre></td></tr></table></figure><h1 id="动态数据加载"><a href="#动态数据加载" class="headerlink" title="动态数据加载"></a>动态数据加载</h1><p>当页面启动需要加载数据时，使用<code>getInitialProps</code>函数来完成，它可以异步获取数据，并解析成对象，并发送给<code>props</code>。注意，<code>getInitialProps</code> 仅可以在pages中使用，不能在components中使用。其仅用于渲染在页面路由中有参数，需要根据这些参数来获取数据并进行渲染的情况。对于动态的交互，还是需要ajax。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloUA</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">async</span> getInitialProps(&#123; req &#125;) &#123;</span><br><span class="line">    <span class="keyword">const</span> userAgent = req ? req.headers[<span class="string">'user-agent'</span>] : navigator.userAgent;</span><br><span class="line">    <span class="keyword">return</span> &#123; userAgent &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello World &#123;this.props.userAgent&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> HelloUA;</span><br></pre></td></tr></table></figure><h1 id="定制路由-1"><a href="#定制路由-1" class="headerlink" title="定制路由"></a>定制路由</h1><p>定制路由，next.js的文档写的有点没跟上，大体记录一下：</p><h2 id="路由修改"><a href="#路由修改" class="headerlink" title="路由修改"></a>路由修改</h2><p>  其实与link的as类似，在express中，对外展示一层，对内依然用文件系统路由。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">app.prepare().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"> createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">// Be sure to pass `true` as the second argument to `url.parse`.</span></span><br><span class="line">   <span class="comment">// This tells it to parse the query portion of the URL.</span></span><br><span class="line">   <span class="keyword">const</span> parsedUrl = parse(req.url, <span class="literal">true</span>);</span><br><span class="line">   <span class="keyword">const</span> &#123; pathname, query &#125; = parsedUrl;</span><br><span class="line">   <span class="keyword">if</span> (pathname === <span class="string">'/a'</span>) &#123;</span><br><span class="line">     app.render(req, res, <span class="string">'/b'</span>, query);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pathname === <span class="string">'/b'</span>) &#123;</span><br><span class="line">     app.render(req, res, <span class="string">'/a'</span>, query);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     handle(req, res, parsedUrl);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;).listen(<span class="number">3000</span>, err =&gt; &#123;</span><br><span class="line">   <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'&gt; Ready on http://localhost:3000'</span>);</span><br><span class="line"> &#125;);</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="后端禁用文件系统路由"><a href="#后端禁用文件系统路由" class="headerlink" title="后端禁用文件系统路由"></a>后端禁用文件系统路由</h2><p>  如果使用定制路由，文件系统路由的方式可能会导致从多个路由里边访问的内容是一样的情况，可以禁用掉文件系统路由。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// next.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  useFileSystemPublicRoutes: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  useFileSystemPublicRoutes属性会禁用掉SSR侧的文件名路由，CSR侧可能继续提供。对于CSR侧的需要<code>popstate</code></p><p>  以上是官方提供的文档，但并没有提供SSR侧禁用文件系统路由之后，服务端的渲染该如何处理的方案。</p><h2 id="前端拦截popstate"><a href="#前端拦截popstate" class="headerlink" title="前端拦截popstate"></a>前端拦截<code>popstate</code></h2><p>监听<code>popstate</code>，在router响应之前进行拦截，这样可以操作request，或者强制SSR刷新。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'next/router'</span>;</span><br><span class="line">Router.beforePopState(<span class="function">(<span class="params">&#123; url, <span class="keyword">as</span>, options &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// I only want to allow these two routes!</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">as</span> !== <span class="string">'/'</span> || <span class="keyword">as</span> !== <span class="string">'/other'</span>) &#123;</span><br><span class="line">    <span class="comment">// Have SSR render bad routes as a 404.</span></span><br><span class="line">    <span class="built_in">window</span>.location.href = <span class="keyword">as</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>返回false时，router不再处理<code>popstate</code></p><h2 id="router对象的使用"><a href="#router对象的使用" class="headerlink" title="router对象的使用"></a>router对象的使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'next/router'</span>;</span><br><span class="line"><span class="keyword">const</span> handler = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  Router.push(&#123;</span><br><span class="line">    pathname: <span class="string">'/about'</span>,</span><br><span class="line">    query: &#123; <span class="attr">name</span>: <span class="string">'Zeit'</span> &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReadMore</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      Click &lt;span onClick=&#123;handler&#125;&gt;here&lt;<span class="regexp">/span&gt; to read more</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ReadMore;</span><br></pre></td></tr></table></figure><p>这里的功能与<code>&lt;link&gt;</code>相同，但在router上可以监听很多时间，包括<code>routeChangeStart(url)</code>、<code>routeChangeComplete(url)</code>。<br>通过:  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Router.events.on(<span class="string">'routeChangeStart'</span>, handleRouteChange);</span><br></pre></td></tr></table></figure><h1 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h1><p>页面跳转其实是express的功能，只需要将res.redirect(301, ‘/new/link’)即可。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> next = <span class="built_in">require</span>(<span class="string">'next'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; join &#125; = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> dev = process.env.NODE_ENV !== <span class="string">'production'</span></span><br><span class="line"><span class="keyword">const</span> app = next(&#123; dev &#125;)</span><br><span class="line"><span class="keyword">const</span> handle = app.getRequestHandler()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> redirects = [</span><br><span class="line">  &#123; <span class="attr">from</span>: <span class="string">'/old-link-1'</span>, <span class="attr">to</span>: <span class="string">'/new-link-1'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">from</span>: <span class="string">'/old-link-2'</span>, <span class="attr">to</span>: <span class="string">'https://externalsite.com/new-link-2'</span> &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">app.prepare().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> server = express()</span><br><span class="line"></span><br><span class="line">  redirects.forEach(<span class="function">(<span class="params">&#123; <span class="keyword">from</span>, to, type = <span class="number">301</span>, method = <span class="string">'get'</span> &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    server[method](<span class="keyword">from</span>, (req, res) =&gt; &#123;</span><br><span class="line">      res.redirect(type, to)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  server.get(<span class="string">'*'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> handle(req, res)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  server.listen(<span class="number">3000</span>, err =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'&gt; Ready on http://localhost:3000'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>package.json:  </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"dev"</span>: <span class="string">"node server.js"</span>,</span><br><span class="line">  <span class="attr">"start"</span>: <span class="string">"NODE_ENV=production node server.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于登录，可以在’*’中，检查req来进行重定向</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="lt-App-gt"><a href="#lt-App-gt" class="headerlink" title="&lt;App&gt;"></a><code>&lt;App&gt;</code></h2><p>next利用App组件来初始化页面，我们可以重写它来控制页面的初始化，可以处理：</p><ul><li>在页面变换时，持久化布局  </li><li>在页面导航时，保存状态  </li><li>注入额外的数据</li><li>使用<code>componentDidCatch</code>来做定制的错误处理</li></ul><p>创建一个pages/_app.js，然后继承App来实现即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> App, &#123; Container &#125; <span class="keyword">from</span> <span class="string">'next/app'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">async</span> getInitialProps(&#123; Component, ctx &#125;) &#123;</span><br><span class="line">    <span class="keyword">let</span> pageProps = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (Component.getInitialProps) &#123;</span><br><span class="line">      pageProps = <span class="keyword">await</span> Component.getInitialProps(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; pageProps &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; Component, pageProps &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Container&gt;</span><br><span class="line">        &lt;Component &#123;...pageProps&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Container&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default MyApp;</span></span><br></pre></td></tr></table></figure><h2 id="lt-Document-gt"><a href="#lt-Document-gt" class="headerlink" title="&lt;Document&gt;"></a><code>&lt;Document&gt;</code></h2><p>用于改变初始化时候服务端渲染的document标记。处理与App类似<br>修改pages/_document.js，继承自Document</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为学习next.js而做的笔记，主要参照&lt;a href=&quot;https://nextjs.org/docs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网&lt;/a&gt; ，也会借鉴&lt;a href=&quot;https://juejin.im/post/5b868b45e51d4538ae4db7ca&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Next.js踩坑&lt;/a&gt;  &lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Matrix-SVD与线性变换</title>
    <link href="http://yoursite.com/2019/05/11/Matrix-SVD%E4%B8%8E%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/"/>
    <id>http://yoursite.com/2019/05/11/Matrix-SVD与线性变换/</id>
    <published>2019-05-11T14:44:48.000Z</published>
    <updated>2019-05-12T12:32:59.564Z</updated>
    
    <content type="html"><![CDATA[<p>原课程Lessson29～Lesson30课，svd其实是正定的延伸，正定是一种特殊的svd；线性变换是矩阵的基础与来源</p><a id="more"></a><h1 id="SVD奇异变换"><a href="#SVD奇异变换" class="headerlink" title="SVD奇异变换"></a>SVD奇异变换</h1><ul><li><p>SVD定义<br>SVD是找到A的一组行向量空间的正交基，通过线性变换，变成列空间的一组正交基的运算。用公式表达为：<br><img src="SVD分析.png" alt="SVD分析"><br>由于是行向量的变换，所有A是左乘V，得到的结果不一定是单位正交的，通过对角阵来表示。<br>这里还可以回忆一下4个基本向量空间：V<sub>1</sub>…V<sub>r</sub> 是在行向量空间，那么V<sub>r+1</sub>…V<sub>n</sub>就是在就会在Nullspace。<br><img src="SVD公式1.png" alt="SVD公式1"><br><img src="SVD公式2.png" alt="SVD公式2">  </p></li><li><p>计算<br>计算是利用的正定，通过A<sub>T</sub>A，来计算V；通过AA<sub>T</sub>来计算U。<br><img src="SVD的计算.png" alt="SVD的计算">  </p></li><li><p>示例1<br><img src="SVD示例1-1.png" alt="SVD示例1-1"><br><img src="SVD示例1-2.png" alt="SVD示例1-2"><br>求得A<sub>T</sub>A的特征值是32 与 18， 特征向量是v<sup>1</sup>=[1 1]<sup>T</sup> 与 v<sup>2</sup>=[1 -1]<sup>T</sup><br>将特征向量标准化:<br><img src="SVD示例1-3.png" alt="SVD示例1-3"><br>同样的道理来求AA<sub>T</sub><br><img src="SVD示例1-4.png" alt="SVD示例1-4"><br>这里由于正好是对角化，于是原课中，直接使用了u1=[1 0]<sup>T</sup> 与 u2=[0 1]<sup>T</sup><br>这样做造成了结果的不一致，而需要通过最原始的进行验证符号， Av<sub>2</sub> = σ<sub>2</sub>u<sub>2</sub><br>于是u2=[0 -1] 最后结果为：<br><img src="SVD示例1-5.png" alt="SVD示例1-5">  </p></li><li><p>示例2<br>原文中给出了奇异状态下的分解：<br><img src="SVD示例2-1.png" alt="SVD示例2-1"><br>由于奇异，也就只有一个行向量，只有一个特征值(另一个为0)<br>v<sup>1</sup>=[0.8 0.6]<sup>T</sup>  </p><p>同样的求法：先求A<sub>T</sub>A，再求AA<sub>T</sub>，最后得结果<br><img src="SVD示例2-2.png" alt="SVD示例2-2"><br><img src="SVD示例2-3.png" alt="SVD示例2-3">  </p><p>这里给出了结果，由于只有一个行向量，而又是2*2的矩阵，另一个V其实是nullspace的基<br><img src="SVD结尾.png" alt="SVD结尾"></p></li></ul><h1 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h1><ul><li><p>定义<br>一个公式：T(cv + dw) = cT(v) + dT(w)，其中c、d是常数，v、w是向量。<br>等同于2个公式：T(v+w) = T(v) + T(w); T(cv) = cT(v)<br>如此T(0) = 0  </p></li><li><p>线性变换与矩阵<br>理解一个线性变换最好的方式，是找到变换后面的矩阵。为此，要引入基向量与坐标。  </p><p>T(v) = Av，因为：<br>A(v+w) = A(v)+A(w)<br>A(cv) = cA(v)  </p><p>给定一个变换T，如何得到一个矩阵A能够代表它呢？<br>首先要选定2组基，如v: v: v<sub>1</sub>,v<sub>2</sub>…v<sub>n</sub>，是R<sup>n</sup>中的基，w: w<sub>1</sub>,w<sub>2</sub>…w<sub>m</sub>。是R<sup>m</sup>中的基。v是input，w是output。<br>T(v<sub>i</sub>) = a<sub>1i</sub>w<sub>1</sub> + a<sub>2i</sub>w<sub>2</sub>…+a<sub>mi</sub>w<sub>m</sub></p></li><li><p>示例1<br><img src="线性变换1-1.png" alt="线性变换1-1"><br>T(v) = Av<br>在R<sup>2</sup>空间中，对于每一个input v=[x, y]<sup>T</sup>，A会将其x值保持不变，而y值取反。结合图像，针对x轴做了对称  </p></li><li><p>示例2<br>求导也是一种线性变换<br><img src="线性变换2-1.png" alt="线性变换2-1"><br>这是一个3维空间向2维空间变换的例子，取输入的基为3维：v<sub>1</sub> = 1, v<sub>2</sub> = x, v<sub>2</sub> = x<sup>2</sup>，输出的的基为2维：w<sub>1</sub> = 1, w<sub>2</sub> = x<br>由此得到<img src="线性变换2-2.png" alt="线性变换2-2"><br>由此得到<img src="线性变换2-3.png" alt="线性变换2-3"></p></li><li><p>结论<br>对于每一个线性变换，都有一个A与之对应，使得T(v) = Av。<br>如果A是可逆的，则线性变换的逆变换 对应的矩阵就是A<sup>-1</sup><br>两个变换的乘积变换： T<sub>1</sub> : v <--> A<sub>1</sub>v ; T<sub>2</sub> : w <--> A<sub>2</sub>w。则这个变换对应的矩阵是A<sub>2</sub>A<sub>1</sub>。这是矩阵乘积的来源。</--></--></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原课程Lessson29～Lesson30课，svd其实是正定的延伸，正定是一种特殊的svd；线性变换是矩阵的基础与来源&lt;/p&gt;
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Matrix" scheme="http://yoursite.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>js构建工具</title>
    <link href="http://yoursite.com/2019/05/05/js%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2019/05/05/js构建工具/</id>
    <published>2019-05-05T14:45:39.000Z</published>
    <updated>2019-05-06T07:10:47.191Z</updated>
    
    <content type="html"><![CDATA[<p>前一段时间搭建Isomorphic过程中，对js的构建工具接触比较多，也做了一些记录但都不够系统，这里对接触的构建工具做一些较系统的整理，包括：webpack、gulp、babel</p><a id="more"></a>  <h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><ul><li><p>webpack的用途<br>webpack是一个打包工具，打包又是为什么呢？对于前端，用react写了很多组件，如果直接编译成js会有很多的文件，也就需要很多的script来做引用，这样会极为不方便，webpack就是自动的寻找依赖关系，将这些文件打包到一起的工具。<br>起初它只做这个，这样对于非js的文件就不太好处理，这样它通过自己的插件（loader）来对这些非js文件进行支持。这样对于css、ts、stylus等文件，都可以通过webpack来进行处理了。</p></li><li><p>webpack基本概念</p><p>  <a href="https://webpack.js.org/concepts#loaders" target="_blank" rel="noopener">原文</a><br>  4大概念：Entry、Output、Loaders、Plugins</p><ul><li><p>Entry:<br>An entry point indicates which module webpack should use to begin building out its internal dependency graph. webpack will figure out which other modules and libraries that entry point depends on</p></li><li><p>Output:<br>The output property tells webpack where to emit the bundles it creates and how to name these files  </p></li><li><p>Loaders:<br>Out of the box, webpack only understands JavaScript and JSON files. Loaders allow webpack to process other types of files and convert them into valid modules that can be consumed by your application and added to the dependency graph.  </p></li><li><p>Plugins:<br>While loaders are used to transform certain types of modules, plugins can be leveraged to perform a wider range of tasks like bundle optimization, asset management and injection of environment variables.</p></li></ul></li><li><p>使用<br>对于Ts与stylus的loader配置如下:</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123; </span><br><span class="line">            test: /\.tsx$/, </span><br><span class="line">            use: ['awesome-typescript-loader'],</span><br><span class="line">            exclude: /node_modules/</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            test: /\.styl$/,</span><br><span class="line">            use: [ </span><br><span class="line">                &#123;</span><br><span class="line">                    loader: 'style-loader'</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    loader: 'css-loader',</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        modules: true</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    loader: 'stylus-loader'</span><br><span class="line">                &#125; </span><br><span class="line">            ],</span><br><span class="line">            exclude: /node_modules/</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>其他<br>webpack像是一个家族，对于同构它们提供webpack-isomorphic-tools，但在gitlab库的说明上： It allowed many projects to set up basic isomorphic (universal) rendering in the early days but is now considered deprecated and new projects shouldn’t use it. This library can still be found in legacy projects. For new projects use either universal-webpack or all-in-one frameworks like Next.js.</p></li></ul><h1 id="gulp"><a href="#gulp" class="headerlink" title="gulp"></a>gulp</h1><ul><li><p>gulp的用途<br>gulp是一个流式任务运行器，换句话说，我们通过命令行执行的操作，可以通过gulp定义成任务，然后对任务进行编排（指定运行顺序）、运行。<br>gulp的任务执行，从触发方式上看可以是手动执行，也可以通过watch检测文件变化自动执行。</p></li><li><p>gulp基本概念<br><a href="https://www.gulpjs.com.cn/docs/api/" target="_blank" rel="noopener">原文</a><br>输出（Emits）符合所提供的匹配模式（glob）或者匹配模式的数组（array of globs）的文件。 将返回一个 Vinyl files 的   stream 它可以被 piped 到别的插件中。</p><ul><li><p>pipe<br>管道，任务流</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gulp.src(<span class="string">'client/templates/*.jade'</span>)</span><br><span class="line">.pipe(jade())</span><br><span class="line">.pipe(minify())</span><br><span class="line">.pipe(gulp.dest(<span class="string">'build/minified_templates'</span>));</span><br></pre></td></tr></table></figure></li><li><p>task<br>这里采用的是函数编程范式  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">'somename'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> stream = gulp.src(<span class="string">'client/**/*.js'</span>)</span><br><span class="line">    .pipe(minify())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'build'</span>));</span><br><span class="line"><span class="keyword">return</span> stream;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>任务编排：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个 callback，因此系统可以知道它什么时候完成</span></span><br><span class="line">gulp.task(<span class="string">'one'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 做一些事 -- 异步的或者其他的</span></span><br><span class="line">    cb(err); <span class="comment">// 如果 err 不是 null 或 undefined，则会停止执行，且注意，这样代表执行失败了</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个所依赖的 task 必须在这个 task 执行之前完成</span></span><br><span class="line">gulp.task(<span class="string">'two'</span>, [<span class="string">'one'</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 'one' 完成后</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'one'</span>, <span class="string">'two'</span>]);</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>watch<br>监视文件变化  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> watcher = gulp.watch(<span class="string">'js/**/*.js'</span>, [<span class="string">'uglify'</span>,<span class="string">'reload'</span>]);</span><br><span class="line">watcher.on(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'File '</span> + event.path + <span class="string">' was '</span> + event.type + <span class="string">', running tasks...'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>其他<br>gulp其实也提供了一些插件，比如<code>gulp-typescript</code>，可以Ts直接编译成js，它与webpack中的ts-loader应该有类似的作用，只不过webpack中将所有的文件都打包到一起了。</p></li></ul><h1 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h1><ul><li><p>babel的用途<br>babel是转码器，这个转码器是将不同版本的js进行转换。目前有的浏览器并不支持 ES6，而我们又用ES6来编码，那就用babel进行处理，自动转换成相应的版本。<br>而且babel支持React的JSX语法转换，对于Ts，babel也有所支持，比如退去所有的annotation，以及类型  </p></li><li><p>使用<br><a href="https://babeljs.io/docs/en/" target="_blank" rel="noopener">官方文档</a><br>babel部分摘自：<a href="http://www.ruanyifeng.com/blog/2016/01/babel.html" target="_blank" rel="noopener">阮一峰：Babel 入门教程</a>  </p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 转码结果输出到标准输出</span></span><br><span class="line">$ babel example.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转码一个文件：--out-file 或 -o 参数指定输出文件</span></span><br><span class="line">$ babel example.js --out-file compiled.js</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">$ babel example.js -o compiled.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转码整个目录： --out-dir 或 -d 参数指定输出目录</span></span><br><span class="line">$ babel src --out-dir lib</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">$ babel src -d lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># -s 参数生成source map文件</span></span><br><span class="line">$ babel src -d lib -s</span><br></pre></td></tr></table></figure></li><li><p>babel全家桶  </p><ul><li><p>babel-cli<br>上文使用cli运行，需要安装babel-cli：<code>npm install --global babel-cli</code></p></li><li><p>babel-core<br>我们在用的使用更多的是通过gulp来调用，就需要babel-core，<code>npm install babel-core --save</code>  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> babel = <span class="built_in">require</span>(<span class="string">'babel-core'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串转码</span></span><br><span class="line">babel.transform(<span class="string">'code();'</span>, options);</span><br><span class="line"><span class="comment">// =&gt; &#123; code, map, ast &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件转码（异步）</span></span><br><span class="line">babel.transformFile(<span class="string">'filename.js'</span>, options, <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">result; <span class="comment">// =&gt; &#123; code, map, ast &#125;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件转码（同步）</span></span><br><span class="line">babel.transformFileSync(<span class="string">'filename.js'</span>, options);</span><br><span class="line"><span class="comment">// =&gt; &#123; code, map, ast &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>babel-polyfill<br>Babel默认只转换新的JavaScript句法（syntax），而不转换新的API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。 在使用上，就需要babel-ployfill来完成对这些内容的支持。</p><p>安装：<br><code>npm install --save babel-polyfill</code></p><p>在脚本的头部，加入：<br><code>import &#39;babel-polyfill&#39;</code>;</p></li></ul></li></ul><h1 id="webpack-isomorphic-tools"><a href="#webpack-isomorphic-tools" class="headerlink" title="webpack-isomorphic-tools"></a>webpack-isomorphic-tools</h1><ul><li><p>前言<br>在搭建同构应用中，几次都遇到这个工具，在这里对这个工具进行一个整理  </p></li><li><p>webpack-isomorphic-tools的用途<br>webpack做的事情，是将文件进行打包，方便浏览器去获取原本这些分散的js，但对于isomorphic，事情变的不同。node.js的后端并不需要webpack打包，而不经过打包，对于有些类型的文件(图片类、CSS类)，后端没法直接支持。这也正是在前面<a href="https://sunyanfeng.cn/2019/04/14/SSR%E3%80%81CSR%E4%B8%8E%E5%90%8C%E6%9E%84/#more" target="_blank" rel="noopener">SSR、CSR与同构</a>中对stylus文件处理时遇到的问题。</p><p><a href="https://github.com/catamphetamine/webpack-isomorphic-tools#api" target="_blank" rel="noopener">官网</a>  </p></li><li><p>使用  </p><ul><li><p>安装<br>npm install webpack-isomorphic-tools –save</p></li><li><p>将<code>webpack-isomorphic-tools</code>嵌入webpack的配置中  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> WebpackIsomorphicToolsPlugin = <span class="built_in">require</span>(<span class="string">'webpack-isomorphic-tools/plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> webpackIsomorphicToolsPlugin = </span><br><span class="line"><span class="comment">// webpack-isomorphic-tools settings reside in a separate .js file </span></span><br><span class="line"><span class="comment">// (because they will be used in the web server code too).</span></span><br><span class="line"><span class="keyword">new</span> WebpackIsomorphicToolsPlugin(<span class="built_in">require</span>(<span class="string">'./webpack-isomorphic-tools-configuration'</span>))</span><br><span class="line"><span class="comment">// also enter development mode since it's a development webpack configuration</span></span><br><span class="line"><span class="comment">// (see below for explanation)</span></span><br><span class="line">.development()</span><br><span class="line"></span><br><span class="line"><span class="comment">// usual Webpack configuration</span></span><br><span class="line"><span class="built_in">module</span>.exports =</span><br><span class="line">&#123;</span><br><span class="line">context: <span class="string">'(required) your project path here'</span>,</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>:</span><br><span class="line">&#123;</span><br><span class="line">    loaders:</span><br><span class="line">    [</span><br><span class="line">    ...,</span><br><span class="line">    &#123;</span><br><span class="line">        test: webpackIsomorphicToolsPlugin.regularExpression(<span class="string">'images'</span>),</span><br><span class="line">        loader: <span class="string">'url-loader?limit=10240'</span>, <span class="comment">// any image below or equal to 10K will be converted to inline base64 instead</span></span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">plugins:</span><br><span class="line">[</span><br><span class="line">    ...,</span><br><span class="line"></span><br><span class="line">    webpackIsomorphicToolsPlugin</span><br><span class="line">]</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官网在这里也说明了一下为什么要.development()。对于开发模式，它让asset缓存失效，而让asset hot reload使能。</p></li><li><p>isomorphic自己的配置文件：webpack-isomorphic-tools-configuration.js  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> WebpackIsomorphicToolsPlugin <span class="keyword">from</span> <span class="string">'webpack-isomorphic-tools/plugin'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span></span><br><span class="line">&#123;</span><br><span class="line">  assets:</span><br><span class="line">  &#123;</span><br><span class="line">    images:</span><br><span class="line">    &#123;</span><br><span class="line">      extensions: [<span class="string">'png'</span>, <span class="string">'jpg'</span>, <span class="string">'gif'</span>, <span class="string">'ico'</span>, <span class="string">'svg'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>服务端运行入口 main.js配置  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> WebpackIsomorphicTools = <span class="built_in">require</span>(<span class="string">'webpack-isomorphic-tools'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// this must be equal to your Webpack configuration "context" parameter</span></span><br><span class="line"><span class="keyword">var</span> projectBasePath = <span class="built_in">require</span>(<span class="string">'path'</span>).resolve(__dirname, <span class="string">'..'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// this global variable will be used later in express middleware</span></span><br><span class="line">global.webpackIsomorphicTools = <span class="keyword">new</span> WebpackIsomorphicTools(<span class="built_in">require</span>(<span class="string">'./webpack-isomorphic-tools-configuration'</span>)  )</span><br><span class="line">.server(projectBasePath, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// webpack-isomorphic-tools is all set now.</span></span><br><span class="line">  <span class="comment">// here goes all your web application code:</span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./server'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>后端渲染页面  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// clear require() cache if in development mode</span></span><br><span class="line"><span class="comment">// (makes asset hot reloading work)</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>)</span><br><span class="line">&#123;</span><br><span class="line">    webpackIsomorphicTools.refresh()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for react-router example of determining current page by URL take a look at this:</span></span><br><span class="line"><span class="keyword">const</span> pageComponent = [determine your page component here using request.path]</span><br><span class="line"></span><br><span class="line"><span class="comment">// render the page to string and send it to the browser as text/html</span></span><br><span class="line">response.send(<span class="string">'&lt;!doctype html&gt;\n'</span> +</span><br><span class="line">        React.renderToString(<span class="xml"><span class="tag">&lt;<span class="name">Html</span> <span class="attr">assets</span>=<span class="string">&#123;webpackIsomorphicTools.assets()&#125;</span> <span class="attr">component</span>=<span class="string">&#123;pageComponent&#125;</span> /&gt;</span>))</span></span><br></pre></td></tr></table></figure><p>这里它传了fluxstore，在我们那并没有引入，故这个可以不用</p></li><li><p>Html中的使用<br>Html中接收传入的assets const { assets, component, store } = this.props<br>然后从asset中去获取资源，即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> picture = <span class="built_in">require</span>(<span class="string">'../assets/images/cat.jpg'</span>)</span><br><span class="line"><span class="keyword">const</span> icon = <span class="built_in">require</span>(<span class="string">'../assets/images/icon/32x32.png'</span>)</span><br></pre></td></tr></table></figure><p>在header中，也可有直接去引入styles  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="comment">/* styles (will be present only in production with webpack extract text plugin) */</span>&#125;</span><br><span class="line">&#123;<span class="built_in">Object</span>.keys(assets.styles).map(<span class="function">(<span class="params">style, i</span>) =&gt;</span></span><br><span class="line">&lt;link href=&#123;assets.styles[style]&#125; key=&#123;i&#125; media=<span class="string">"screen, projection"</span></span><br><span class="line">        rel=<span class="string">"stylesheet"</span> type=<span class="string">"text/css"</span>/&gt;)&#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="comment">/* resolves the initial style flash (flicker) on page load in development mode */</span>&#125;</span><br><span class="line">&#123; <span class="built_in">Object</span>.keys(assets.styles).length === <span class="number">0</span> ? <span class="xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">dangerouslySetInnerHTML</span>=<span class="string">&#123;&#123;__html:</span> <span class="attr">require</span>('<span class="attr">..</span>/<span class="attr">assets</span>/<span class="attr">styles</span>/<span class="attr">main_style.css</span>')&#125;&#125;/&gt;</span><span class="undefined"> : null &#125;</span></span></span><br></pre></td></tr></table></figure><p>asserts是由webpack-isomorphic-tools创建的webpack-asset.json中的内容 </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"javascript"</span>:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"main"</span>: <span class="string">"/assets/main-d8c29e9b2a4623f696e8.js"</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="attr">"styles"</span>:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"main"</span>: <span class="string">"/assets/main-d8c29e9b2a4623f696e8.css"</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="attr">"assets"</span>:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"./assets/images/cat.jpg"</span>: <span class="string">"http://localhost:3001/assets/9059f094ddb49c2b0fa6a254a6ebf2ad.jpg"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h1><p>推荐阅读：<a href="http://www.siguoya.name/pc/home/article/271" target="_blank" rel="noopener">思过崖</a>  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一段时间搭建Isomorphic过程中，对js的构建工具接触比较多，也做了一些记录但都不够系统，这里对接触的构建工具做一些较系统的整理，包括：webpack、gulp、babel&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>产品反思</title>
    <link href="http://yoursite.com/2019/05/04/%E4%BA%A7%E5%93%81%E5%8F%8D%E6%80%9D/"/>
    <id>http://yoursite.com/2019/05/04/产品反思/</id>
    <published>2019-05-04T02:10:39.000Z</published>
    <updated>2019-05-04T03:50:30.185Z</updated>
    
    <content type="html"><![CDATA[<p>整个4月大部分时间都处在产品重构的思考与设计中，牺牲了一些正在坚持的习惯，一方面是时间紧张，另一方面自己很大的精力都投入在这些思考与设计中，没有分心的心思。作为一个由设计到开发的转折点，我觉得有必要对这个过程进行一些反思。</p><a id="more"></a><h1 id="开场白"><a href="#开场白" class="headerlink" title="开场白"></a>开场白</h1><p>回顾4月，先是产品的定位的思考，包括其提供给用户的核心价值。后又用了不太到2个周的时间，对前端的框架进行了探索，包括SPA与MPA、SSR与CSR与同构。后来产品设计、架构设计尤其后端服务的拆分通信、最后对界面进行了讨论与设计。下面反思一下整个过程，一方面为了总结经验，另一方面通过回顾也找一下不足与提升空间。</p><h1 id="产品设计"><a href="#产品设计" class="headerlink" title="产品设计"></a>产品设计</h1><p>产品本身是一个重构，并不是完全从无到有去设计一个产品。从旧的产品中，发现了一些不足。这些不足表现为：  </p><ul><li>原产品中，最初的想法是将项目管理整个从线下搬到线上，这个出发点没有具体表达出产品的核心价值;  </li><li>项目管理是一个整体，同时整体搬迁到线上的难度很高，可行性差;  </li><li>原产品中，虽然有很多角色，但对这些角色如何使用产品，并没有进行设计;  </li><li>原系统中，功能开发出来，但这个功能本身能为用户提供什么帮助，或者设想用户怎么使用并没有思考清楚;  </li></ul><p>所以这次的重构，超越了代码层面、服务架构，是一个从旧产品中重新构思新产品的过程。这个过程：  </p><ul><li><p>首先是归纳了旧产品的价值，提出了3个核心价值：控制、协同、知识。<br>控制指的是项目管理者，对项目进度、产值、成本的控制<br>协同指的是项目成员为完成项目所进行的沟通、交互、审核、汇报等协同<br>知识指的是由数据涌现的对工程的计划、施工、设计等的辅助功能、预警功能  </p></li><li><p>接着制定了3个使用场景<br>第一个场景是控制场景，其包括4种角色，这4种角色以什么样的工作流程、什么样的操作来使用系统，使用后为各角色以及整体产生怎样的价值<br>第二个场景是协同场景，业务上是一个用料申请的场景，这个场景本身其实可以分成4个子场景，每个子场景都是一种用料申请，每个子场景中，都是一种1v1的交互<br>第三个场景也是协同场景，是一个巡查的场景，涉及2个人物也是1v1的交互  </p></li><li><p>从场景中抽象功能<br>从第一场景开始，想象每个角色需要如何使用产品，为了满足其需要，系统要提供什么的功能<br>借鉴旧系统，将这些功能分解、聚合这也就就自然过度到了服务设计  </p></li></ul><h1 id="服务设计"><a href="#服务设计" class="headerlink" title="服务设计"></a>服务设计</h1><p>这里的服务指的是业务层微服务的设计，不能算是整个系统架构的设计。<br>服务的设计过程中，是根据功能分解、聚合之后的结构，尽量达到高内聚，低耦合。另外，一些公共的业务低相关度的功能抽离到独立的微服务中完成<br>后来发现，业务服务竟然大约可以与角色相对应，很大程度上达到的多租户的隔离方式。<br>服务间的通信，大部分采用消息队列来做事件驱动，一部分采用通过redis来共享数据，最小的一部分采用Restful的方式来调用。<br>这种业务服务设计，由于用户的使用频率不同，对应的服务的流量要求就不同，部署的使用也就要有所差异，当然后边可以通过整个架构的监控、devops等设施来完成</p><h1 id="交互设计与界面"><a href="#交互设计与界面" class="headerlink" title="交互设计与界面"></a>交互设计与界面</h1><p>交互的设计上也对比着旧系统，旧系统的组织方式是以部分来划分，原本是可以的，但存在的问题是，现有情况多个部门对于主要的个功能的要求相同，造成前端好几处写了多遍。<br>在这次设计中，并不是从上而下的设计方式，是根据功能使用，自下而上的设计，即先想这个小场景中的功能，应该如何表达，然后画出草图，全部场景设计完全后，将他们聚合在一起的方式。<br>整个设计过程也与队友进行过多次讨论，吸取了他们的意见。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>由产品核心价值定义产品使用场景  </li><li>由产品使用场景定义需求  </li><li>由需求来定义功能，由功能定义业务服务  </li><li>同样由产品使用场景定义交互  </li><li>产品的使用场景亦可以验证交互与需求  </li></ul><p>除此之外，本次的产品，很大程度上是借鉴了旧产品，这方面的空间还有很多，比如现场管理分析、各用户分析，比如竞品分析等</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整个4月大部分时间都处在产品重构的思考与设计中，牺牲了一些正在坚持的习惯，一方面是时间紧张，另一方面自己很大的精力都投入在这些思考与设计中，没有分心的心思。作为一个由设计到开发的转折点，我觉得有必要对这个过程进行一些反思。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Matrix PositivDefinite</title>
    <link href="http://yoursite.com/2019/05/03/Matrix-PositiveDefinite/"/>
    <id>http://yoursite.com/2019/05/03/Matrix-PositiveDefinite/</id>
    <published>2019-05-03T14:02:34.000Z</published>
    <updated>2019-05-04T01:57:37.684Z</updated>
    
    <content type="html"><![CDATA[<p>本部分主要研究的是正定，课程包括Lesson25~Lesson28<br>包括：Symmetric matrices and positive definite­ness、Complex matrices and fast Fourier transform、Positive definite matrices and minima、Similar matrices and Jordan form</p><a id="more"></a><h1 id="对称矩阵与正定"><a href="#对称矩阵与正定" class="headerlink" title="对称矩阵与正定"></a>对称矩阵与正定</h1><h2 id="对称矩阵的性质"><a href="#对称矩阵的性质" class="headerlink" title="对称矩阵的性质"></a>对称矩阵的性质</h2><p>A = A<sup>T</sup></p><p>性质：  </p><ul><li>the eigenvalues are real</li><li>the eigenvector are perpendicular even orthonormal</li></ul><p>由此，若A对称，则 A =Q Λ Q<sup>−1</sup> = Q Λ Q<sup>T</sup></p><p>why real eigenvalues?<br>证明思路是从：AX = λX开始，一方面都取共轭，另一方面将原式乘以X的共轭，通过变换，得到λ = λ共轭，得证</p><p>Symmetric matrices with real entries have A =A<sup>T</sup>,  real eigenvalues, and perpendicular eigenvectors.<br>If A has complex entries, then it  will have real eigenvalues and perpendicular eigenvectors if and only if <img src="共轭转置.png" alt="共轭转置"></p><h2 id="对阵矩阵的解释"><a href="#对阵矩阵的解释" class="headerlink" title="对阵矩阵的解释"></a>对阵矩阵的解释</h2><p>A = Q Λ Q<sup>T</sup><br>Q = [q<sub>1</sub>, q<sub>2</sub>… q<sub>n</sub>]<br>展开后得到A = λ<sub>1</sub>q<sub>1</sub>q<sub>1</sub><sup>T</sup> + λ<sub>2</sub>q<sub>2</sub>q<sub>2</sub><sup>T</sup> +…+ λ<sub>n</sub>q<sub>n</sub>q<sub>n</sub><sup>T</sup></p><p>由于q正交，所以q<sub>1</sub>q<sub>1</sub><sup>T</sup>其实是投影矩阵，如此得到，每一个对称阵，其实都是投影的组合。</p><h2 id="关于特征值的符号"><a href="#关于特征值的符号" class="headerlink" title="关于特征值的符号"></a>关于特征值的符号</h2><p>number of positive pivots = number of positive eigenvalues.<br>主元的符号与特征值的符号相同</p><h2 id="正定的定义"><a href="#正定的定义" class="headerlink" title="正定的定义"></a>正定的定义</h2><p>A positive definite matrix is a symmetric matrix A for which all eigenvalues are positive.正定矩阵是所有特征值都是正数的对称矩阵。</p><p>=&gt;  </p><ul><li>所有特征值都是正数  </li><li>所有主元都是正数  </li><li>所有的子行列式(1<em>1,2</em>2..n*n形成的行列式)都是正数</li></ul><h1 id="复数矩阵与FFT"><a href="#复数矩阵与FFT" class="headerlink" title="复数矩阵与FFT"></a>复数矩阵与FFT</h1><h2 id="复数矩阵的特性"><a href="#复数矩阵的特性" class="headerlink" title="复数矩阵的特性"></a>复数矩阵的特性</h2><p>  对于复数向量，取转置运算要变成取共轭转置，或者交Hermite，简写H</p><ul><li><p>复向量的长度<br><img src="复向量长度.png" alt="复向量长度"><br><img src="Hermite.png" alt="Hermite"></p></li><li><p>内积<br>y<sup>T</sup>x =&gt; y<sup>H</sup>x</p></li><li><p>正交<br>Q<sup>H</sup>Q = I，这时候正交Orthogonal 要用 unitary来表达，单位化。</p></li></ul><h2 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h2><ul><li><p>基础形式<br><img src="傅里叶变换1.png" alt="傅里叶变换1"></p></li><li><p>复数矩阵形式<br><img src="傅里叶变换2.png" alt="傅里叶变换2"><br><img src="w定义.png" alt="w定义"></p></li><li><p>n=4例子<br><img src="F4.png" alt="F4"><br><img src="F4结论.png" alt="F4结论">  </p></li></ul><h2 id="FFT"><a href="#FFT" class="headerlink" title="FFT"></a>FFT</h2><p>FFT将傅里叶计算从n<sup>2 =&gt; nlogn  </sup></p><p><img src="FFT.png" alt="FFT"><br>其中<img src="P.png" alt="P">,其作用是将奇数行拿到偶数行的前面<br><img src="D.png" alt="D">  </p><h1 id="正定矩阵性质"><a href="#正定矩阵性质" class="headerlink" title="正定矩阵性质"></a>正定矩阵性质</h1><ul><li><p>最小值<br>对于正定，除了，特征值&gt;0，主元&gt;0，子行列式&gt;0，还有一个X<sup>T</sup>AX &gt; 0<br><img src="正定分析.png" alt="正定分析"><br>如果二次方程一定 &gt; 0，则A正定</p><p><img src="非正定.png" alt="非正定"><br><img src="正定.png" alt="正定">  </p><p>由此得出，正定 =&gt; 有最小值</p><p><img src="Hessian矩阵.png" alt="Hessian矩阵"><br>首先它是对阵的，Its determinant is positive when the matrix is positive definite</p><p><img src="正定多维推广.png" alt="正定多维推广"><br>一个多维的向上的碗，而且全是正的</p></li><li><p>加法<br>if A,B 正定  =&gt; A+B正定</p></li><li><p>推论<br>A<sup>T</sup>A 一定正定， 这里A是m×n 且 rank(A) = n 的矩阵<br>应为其多项式：<img src="正定的一个推理.png" alt="正定的一个推理"></p></li></ul><h1 id="相似矩阵与Jordan式"><a href="#相似矩阵与Jordan式" class="headerlink" title="相似矩阵与Jordan式"></a>相似矩阵与Jordan式</h1><ul><li><p>定义<br>对于A，B两个矩阵，若A = M<sup>-1</sup>BM，则A、B相似</p></li><li><p>性质<br>相似矩阵，拥有相同的特征值，相同数量的独立特征向量（一般不同）</p></li><li><p>重特征值问题<br>以λ<sub>1</sub> = λ<sub>2</sub> = 4 为例<br>可以分成两个famliy:  </p><ol><li><img src="重特征值-1.png" alt="重特征值-1">,这一族比较大  </li><li><img src="重特征值-2.png" alt="重特征值-2">，这一族只有这一个矩阵，因为它与任何M相乘都会返回自身  </li></ol></li><li><p>Jordan matrix<br>简单的说，对于重特征值问题，它们需要有相同的Jordan blocks的形式.<br><img src="Jordan-blocks.png" alt="Jordan-blocks"><br><img src="Jordan-blocks一般形式.png" alt="Jordan-blocks一般形式"><br>其中<img src="Jordan-blocks一般形式2.png" alt="Jordan-blocks一般形式2">，这里，对角线上都是特征值，下方都是0，上方跟随一层1.</p><p><img src="概括Jordan.png" alt="概括Jordan"><br>这样，不同的特征值情况可以认为是一种特殊的Jordan Matrix，它们的Jordan Block都是为1*1的特征值本身</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本部分主要研究的是正定，课程包括Lesson25~Lesson28&lt;br&gt;包括：Symmetric matrices and positive definite­ness、Complex matrices and fast Fourier transform、Positive definite matrices and minima、Similar matrices and Jordan form&lt;/p&gt;
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Matrix" scheme="http://yoursite.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>nest.js记录</title>
    <link href="http://yoursite.com/2019/05/03/nest%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/05/03/nest记录/</id>
    <published>2019-05-03T06:45:39.000Z</published>
    <updated>2019-05-28T06:55:40.698Z</updated>
    
    <content type="html"><![CDATA[<p>本文为理解nest.js而做记录，内容为官网中的基础部分，目的是为了理解、记忆，所以不会抄原文的例子。<br><a href="https://docs.nestjs.com/" target="_blank" rel="noopener">官网</a>  </p><a id="more"></a><h1 id="骨架"><a href="#骨架" class="headerlink" title="骨架"></a>骨架</h1><p>骨架部分主要介绍：Controllers、Providers、Modules，他们组成了nest应用的最基础部分，可以认为Route Handler部分</p><h2 id="Controllers"><a href="#Controllers" class="headerlink" title="Controllers"></a>Controllers</h2><ul><li><p>定义<br>Controllers are responsible for handling incoming requests and returning responses to the client.</p></li><li><p>路由<br>分层的定义方法，在类上定义的，被其下的方法所继承，如在类上定义<code>@Controller(&#39;customers&#39;)</code>，在类方法中定义<code>@Get(&#39;profile&#39;)</code>，则其路由为<code>GET /customers/profile</code></p></li><li><p>两种模式<br>一种是标准模式，也是推荐模式，通过nest的装饰器来使用各种参数;<br>另一种原生模式（Library-specific），通过@Res(),@Req()获取库原生的request与response对象，来直接进行操作。<br>这两种方式不能同时使用，当然nest推荐前者。</p></li><li><p>装饰器  </p></li></ul><table><thead><tr><th style="text-align:left">装饰器</th><th style="text-align:center">介绍</th></tr></thead><tbody><tr><td style="text-align:left">@Req()</td><td style="text-align:center">获取Request对象(express)</td></tr><tr><td style="text-align:left">@Res()</td><td style="text-align:center">获取Response对象(express)</td></tr><tr><td style="text-align:left">@Session()</td><td style="text-align:center">获取req.session</td></tr><tr><td style="text-align:left">@Param(key?: string)</td><td style="text-align:center">req.params / req.params[key],param是路由中的参数</td></tr><tr><td style="text-align:left">@Body(key?: string)</td><td style="text-align:center">req.body / req.body[key]</td></tr><tr><td style="text-align:left">@Query(key?: string)</td><td style="text-align:center">req.query / req.query[key],query是?后的参数</td></tr><tr><td style="text-align:left">@Headers(name?: string)</td><td style="text-align:center">req.headers / req.headers[name]</td></tr><tr><td style="text-align:left">@HttpCode(201)</td><td style="text-align:center">指定response中的返回值</td></tr></tbody></table><h2 id="Providers"><a href="#Providers" class="headerlink" title="Providers"></a>Providers</h2><ul><li><p>定义<br>Many of the basic Nest classes may be treated as a provider – services, repositories, factories, helpers, and so on. A provider is simply a class annotated with an @Injectable() decorator  </p></li><li><p>理解<br>这里说的很明白的，provider可以理解成功能的提供者了,任何可以注入的类都可以认为是provider。原文中也说，provider不仅仅是@Injectable(),它可以是数值、类、同步或异步工厂(plain values, classes, and either asynchronous or synchronous factories)，这个在后边的Custom Provider中会做更多介绍  </p></li></ul><h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h2><ul><li><p>定义<br>A module is a class annotated with a @Module() decorator. The @Module() decorator provides metadata that Nest makes use of to organize the application structure.  </p></li><li><p>理解<br>Module要做一点解释，Nest是Module来组织的，不论是Controller还是Provider都需要注册到Module中才能被Nest托管。还有一点比较有趣的，在Module中可以imports其他Module，而imports的内容，其实是被引用Module中exports出的内容</p></li><li><p>属性<br>@Module装饰器接收一个对象，其属性包括</p></li></ul><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:center">介绍</th></tr></thead><tbody><tr><td style="text-align:left">providers</td><td style="text-align:center">被Nest injector实例化的providers</td></tr><tr><td style="text-align:left">controllers</td><td style="text-align:center">被Nest injector实例化的controllers</td></tr><tr><td style="text-align:left">imports</td><td style="text-align:center">引入这些moludes export 的providers</td></tr><tr><td style="text-align:left">exports</td><td style="text-align:center">providers的子集，被其他模块可以import</td></tr></tbody></table><h1 id="经脉"><a href="#经脉" class="headerlink" title="经脉"></a>经脉</h1><p>经脉介绍中间件(Middleware)、异常过滤器(Exception filters)、管道(Pipes)、哨兵(Guards)、拦截器(Interceptors)。我觉得广义上看，他们都可以被称为拦截器，他们要么在拦截request（Middleware,Pipe，Guard），要么在拦截response(Exception filter)，要么双方都拦截（Interceptors）。<br>它们有着类似的scope，包括：全局(global)、控制器（controller）、路由函数(router)，其实隐藏着模块（module）等范围</p><h2 id="Middleware"><a href="#Middleware" class="headerlink" title="Middleware"></a>Middleware</h2><ul><li><p>定义<br>Middleware is a function which is called before the route handler. Middleware functions have access to the request and response objects, and the next() middleware function in the application’s request-response cycle.<br><img src="middleware.png" alt="middleware"></p></li><li><p>理解<br>中间件常见的场景包括，Log，cors，helmet等，中间件的使用上，主要在routers,controllers,module范围内，原文中没有在全局使用中间件。</p></li></ul><h2 id="Exception-filters"><a href="#Exception-filters" class="headerlink" title="Exception filters"></a>Exception filters</h2><ul><li><p>定义<br>Nest comes with a built-in exceptions layer which is responsible for processing all unhandled exceptions across an application. When an exception is not handled by your application code, it is caught by this layer, which then automatically sends an appropriate user-friendly response.</p><p><img src="pipe与filter.png" alt="filter"></p></li><li><p>理解<br>从定义中可以看出，它是在request上，进行filter，当服务端有异常抛出，对异常进行捕获、处理，并返回给客户端。<br>异常过滤器4种使用方式都支持，这部分可以写一些异常处理的代码，定义好Exception 与 exception 与 filter，然后在代码中可以方便的抛异常了。</p><p><a href="https://docs.nestjs.com/exception-filters#exception-filters-1" target="_blank" rel="noopener">Exception filters</a></p></li></ul><h2 id="Pipes"><a href="#Pipes" class="headerlink" title="Pipes"></a>Pipes</h2><ul><li><p>定义<br>A pipe is a class annotated with the @Injectable() decorator. Pipes should implement the PipeTransform interface.<br>原文可能觉得pipe真不用定义了，所以也没有定义，就是函数编程范式pipe，其实跟中间件、拦截器都一样.<br><img src="pipe与filter.png" alt="pipe"></p></li><li><p>使用场景  </p><ul><li>transformation: transform input data to the desired output  </li><li>validation: evaluate input data and if valid, simply pass it through unchanged; otherwise, throw an exception when the data is incorrect</li></ul><p>就是数据转换与有效性检验。这一部分集成化比较高，通过class-validator and class-transformer可以直接使用ValidationPipe，ParseIntPipe了，支持4种使用方式</p></li></ul><h2 id="Guards"><a href="#Guards" class="headerlink" title="Guards"></a>Guards</h2><ul><li><p>定义<br>A guard is a class annotated with the @Injectable() decorator. Guards should implement the CanActivate interface.<br><a href="guard.png">guard</a><br>Guards have a single responsibility. They determine whether a given request will be handled by the route handler or not, depending on certain conditions (like permissions, roles, ACLs, etc.) present at run-time. This is often referred to as authorization。<br>在express中，认证由中间件来做，原文中有对为什么用guard而不用middleware的解释，大约就是middleware你需要控制next，并且不知道next的下一步是什么，而guard由于有执行环境（ExecutionContext），可以清楚的知道下一步执行什么。</p></li><li><p>理解<br>4种使用方式都支持。<br>这里使用了reflect，因为对于guard，它需要知道定义在每个router的角色<br><a href="https://docs.nestjs.com/guards#putting-it-all-together" target="_blank" rel="noopener">实例</a><br>这个部分要好好写一下，与原文中的例子略有不同，原文中认证的角色，我们要认证权限  </p></li></ul><h2 id="Interceptors"><a href="#Interceptors" class="headerlink" title="Interceptors"></a>Interceptors</h2><ul><li><p>定义<br>An interceptor is a class annotated with the @Injectable() decorator. Interceptors should implement the NestInterceptor interface.<br><img src="Interceptors.png" alt="Interceptors">  </p></li><li><p>理解<br>支持4种使用方式。通过next.handle()来调用主体，然后在pipe中对返回进行处理。在piple中可以对response进行处理，可以对异常进行处理等。<br>应用场景比如通过记录每个调用的入口、出口时间来计算响应时间，对response中数据的处理，对异常的处理等。<br>Interceptor可以对前后两端的处理，由于入口侧的验证、转换、认证都有特殊的解决方案了，所以我觉得它更注重出口侧一些，以及更注重业务逻辑一些。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 中间件的实现可能与其他略有不同，Exception filter，pipe,guard简直就是interception在各应用场景的细化。<br> 在使用上，需要对异常处理(Exception Filter)、参数验证(Pipe)、权限认证(Guard)、日志(Middleware/Interceptor)、监控(Interceptor)等，都可以用到.</p><h1 id="套路"><a href="#套路" class="headerlink" title="套路"></a>套路</h1><h2 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h2><p>这里的认证，并不是权限认证，而是主要是对客户端的认证，这里只记录jwt方式，认证主要使用Passport模块</p><ul><li><p>过程<br>客户端进行登录，后端核对完用户名、密码之后，创一个token给浏览器，浏览器之后在header(cookie与Authorization其实都行)中一直带着，来做http状态的认证。</p></li><li><p>理解<br>因为后端要验证用户名、密码，以及生成token，就需要一个Service来做这件事情，而passport本身支持‘bearer’,‘jwt’等不同策略，也就需要一个Strategy来解耦不同策略，而这个策略本身要依赖那个验证的Service。Strategy完成的是对token的解析，调用Service去验证，其统一的接口应该validate()函数。<br>在Strategy的使用上，即Strategy如何被nest使用，这里只能做一个推测，其通过Module的providers属性注入到nest中，nest在注册PassportModule时，自动将注册的Strategy注册到Passport当中，并完成jwt认证过程。<br>在使用上，通过Passport提供的AuthGuard来使用，这样就与Guard联系到了一起。</p><p>本质上讲，Passport也是一种Guard，更本质，就是一前置拦截器。</p></li></ul><h2 id="Database-ORM"><a href="#Database-ORM" class="headerlink" title="Database/ORM"></a>Database/ORM</h2><p>这里的ORM使用的TypeORM<br><a href="https://typeorm.io/" target="_blank" rel="noopener">ypeORM</a></p><ul><li><p>概念<br>这里需要注意的概念包括：  </p><ul><li><p>连接(Connection)<br>在这里连接的建立，使用过在ApplicationModule中，import TypeOrmModule.forRoot()来建立的，forRoot的参数就是一个数据库连接必备的字段。连接本身有name属性，缺省为’default’，这在多连接建立时会需要。</p></li><li><p>实体(Entity)<br>实体就是Model层，需要指定类属性对应的表结构，并指定one2Many/Many2One等与其他实体的关系</p></li><li><p>实体管理器(EntityManager)<br>Using EntityManager you can manage (insert, update, delete, load, etc.) any entity. EntityManager is just like a collection of all entity repositories in a single place  </p><p>实体管理器是对所有实体进行管理，它是Repository的一个集合</p></li><li><p>库(Repository)<br>Repository is just like EntityManager but its operations are limited to a concrete entity</p><p>Repository是对单个实体进行管理</p></li></ul></li><li><p>使用<br>需要在Module中imports TypeOrmModule.forFeature([Photo])，这个forFeature应该是获取Photo实体所对应的Repository，进而在Service中就可以使用Repository来操作实体了。<br>在TypeORM官网中，可以通过Connection来直接获取Repository，在nest中介绍的并不详细。<br>应该是在forRoot时，指明连接的名字，然后在Service中通过InjectConnection(‘连接名’)，来注入连接，通过@InjectEntityManager(‘连接名’)来注入实体管理器entityManager。</p></li></ul><h1 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h1><h2 id="Custom-providers"><a href="#Custom-providers" class="headerlink" title="Custom providers"></a>Custom providers</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为理解nest.js而做记录，内容为官网中的基础部分，目的是为了理解、记忆，所以不会抄原文的例子。&lt;br&gt;&lt;a href=&quot;https://docs.nestjs.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网&lt;/a&gt;  &lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>最长字符串问题</title>
    <link href="http://yoursite.com/2019/04/22/%E6%9C%80%E9%95%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/04/22/最长字符串问题/</id>
    <published>2019-04-21T22:45:14.000Z</published>
    <updated>2019-04-23T04:37:46.995Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>分布式系统设计模式</title>
    <link href="http://yoursite.com/2019/04/19/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/04/19/分布式系统设计模式/</id>
    <published>2019-04-18T23:25:35.000Z</published>
    <updated>2019-04-22T06:23:50.098Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章来整理《左耳听风》栏目的分布式设计模式弹力设计、管理设计、性能设计篇，并根据当下情况，借鉴一二</p><a id="more"></a><h1 id="弹力设计"><a href="#弹力设计" class="headerlink" title="弹力设计"></a>弹力设计</h1><h2 id="隔离设计-Bulkheads"><a href="#隔离设计-Bulkheads" class="headerlink" title="隔离设计 Bulkheads"></a>隔离设计 Bulkheads</h2><ul><li><p>背景<br>这个设计借鉴了船舱通过隔板来把船隔成几个独立空间，防止一点进水蔓延到整个船只。</p></li><li><p>2种隔离方法  </p><ul><li><p>按服务的种类来做隔离<br>如用户注册、商品中心、社交服务，将他们独立成各自的服务，并独占各自自己的DB<br>总会面对获取多个板块数据的情况，这样会调用多个服务，对于这样的问题，一般来说，我们需要小心地设计用户交互，最好不要让用户在一个页面上获得所有的数据。对。<br>业务跨板块时，控制就有点复杂。对此我们需要一个类似于 Pub/Sub 的高可用的并可以持久化的消息订阅通知的中间件来打通各个版块的数据和信息交换。最后还会有在多个版块中分布式事务的问题。对此，我们需要“二阶段提交”这样的方案。在亚马逊中，使用的是 Plan – Reserve – Commit/Cancel 模式。  </p></li><li><p>多租户：按用户的请求来分离<br>将用户分成不同的组，并把后端的同一个服务根据这些不同的组分成不同的实例。让同一个服务对于不同的用户进行冗余和隔离，这样一来，当服务实例挂掉时，只会影响其中一部分用户，而不会导致所有的用户无法访问。<br>做法有：<br>完全独立的设计。每个租户有自己完全独立的服务和数据。<br>独立的数据分区，共享的服务。多租户的服务是共享的，但数据是分开隔离的。<br>共享的服务，共享的数据分区。每个租户的数据和服务都是共享的。<br>一般会选择折中方案，服务是共享的，数据通过分区来隔离。</p></li></ul></li><li><p>重点<br>隔离模式需要配置一些高可用、重试、异步、消息中间件，流控、熔断等设计模式的方式配套使用。</p></li><li><p>课外<br>在虚拟化技术非常成熟的今天，我们完全可以使用“完全独立”（完全隔离）的方案，通过底层的虚拟化技术（Hypervisor 的技术，如 KVM，或是 Linux Container 的技术，如 Docker）来实现物理资源的共享和成本的节约。</p></li></ul><h2 id="异步通讯设计-Asynchronous"><a href="#异步通讯设计-Asynchronous" class="headerlink" title="异步通讯设计 Asynchronous"></a>异步通讯设计 Asynchronous</h2><ul><li><p>异步通讯的3种方式  </p><ul><li><p>请求响应式<br>直接REST调用  </p></li><li><p>通过订阅的方式<br>订阅者模式，接收方（receiver）会来订阅发送方（sender）的消息，发送方会把相关的消息或数据放到接收方所订阅的队列中，而接收方会从队列中获取数据。<br>这种情况下接收方需要想发送方订阅事件</p></li><li><p>通过中间人的方式<br>这是完整版的订阅者模式，发送方（sender）和接收方（receiver）都互相看不到对方，它们看得到的是一个 Broker，发送方向 Broker 发送消息，接收方向 Broker 订阅消息。如下图所示。<br><img src="broker方式.png" alt="broker方式"></p></li></ul></li><li><p>事件驱动  </p><p><img src="时间驱动.png" alt="时间驱动"><br>每个服务都是“自包含”的。所谓“自包含”也就是没有和别人产生依赖。而要把整个流程给串联起来，我们需要一系列的“消息通道（Channel）”。各个服务做完自己的事后，发出相应的事件，而又有一些服务在订阅着某些事件来联动。<br>这好处与遇到问题，与隔离设计其实是相同的。</p><p>需要消息跟踪：异步通讯会导致业务处理流程不那么直观，因为像接力一样，所以在 Broker 上需要有相关的服务消息跟踪机制，否则出现问题后不容易调试。<br>需要工作流引擎：因为服务间只通过消息交互，所以业务状态最好由一个总控方来管理，这个总控方维护一个业务流程的状态变迁逻辑，以便系统发生故障后知道业务处理到了哪一步，从而可以在故障清除后继续处理。  </p></li></ul><h2 id="幂等设计-Idempotency"><a href="#幂等设计-Idempotency" class="headerlink" title="幂等设计 Idempotency"></a>幂等设计 Idempotency</h2><ul><li><p>定义<br>所谓幂等性设计，就是说，一次和多次请求某一个资源应该具有同样的副作用。用数学的语言来表达就是：f(x)  = f(f(x))。<br>为什么我们需要这样的操作？说白了，就是在我们把系统解耦隔离后，服务间的调用可能会有三个状态，一个是成功（Success），一个是失败（Failed），一个是超时（Timeout）。前两者都是明确的状态，而超时则是完全不知道是什么状态。因为系统超时，而调用户方重试一下，会给我们的系统带来不一致的副作用。</p></li><li><p>全局ID<br>要做到幂等性的交易接口，需要有一个唯一的标识，来标志交易是同一笔交易。而这个交易 ID 由谁来分配是一件比较头疼的事。因为这个标识要能做到全局唯一。<br>算法详见： Twitter 的开源项目 Snowflake</p></li><li><p>处理流程<br>对于幂等性的处理流程来说，说白了就是要过滤一下已经收到的交易。要做到这个事，我们需要一个存储来记录收到的交易。于是，当收到交易请求的时候，我们就会到这个存储中去查询。如果查找到了，那么就不再做查询了，并把上次做的结果返回。如果没有查到，那么我们就记录下来。<br>所以，最好是当这个存储出现冲突的时候会报错。也就是说，我们收到交易请求后，直接去存储里记录这个 ID（相对于数据的 Insert 操作），如果出现 ID 冲突了的异常，那么我们就知道这个之前已经有人发过来了，所以就不用再做了。比如，数据库中你可以使用。<br>对于更新的场景来说，如果只是状态更新，可以使用如下的方式。如果出错，要么是非法操作，要么是已被更新，要么是状态不对，总之多次调用是不会有副作用的。</p></li><li><p>HTTP幂等性<br>Post不具备幂等性，处理如下：<br>首先，在表单中需要隐藏一个 token，这个 token 可以是前端生成的一个唯一的 ID。用于防止用户多次点击了表单提交按钮，而导致后端收到了多次请求，却不能分辨是否是重复的提交。这个 token 是表单的唯一标识。（这种情况其实是通过前端生成 ID 把 POST 变成了 PUT。）<br>然后，当用户点击提交后，后端会把用户提示的数据和这个 token 保存在数据库中。如果有重复提交，那么数据库中的 token 会做排它限制，从而做到幂等性。<br>当然，更为稳妥的做法是，后端成功后向前端返回 302 跳转，把用户的前端页跳转到 GET 请求，把刚刚 POST 的数据给展示出来。如果是 Web 上的最好还把之前的表单设置成过期，这样用户不能通过浏览器后退按钮来重新提交。这个模式又叫做。[对于前端渲染的方式，需要前端来控制]</p></li></ul><h2 id="重试设计-Retry"><a href="#重试设计-Retry" class="headerlink" title="重试设计 Retry"></a>重试设计 Retry</h2><ul><li><p>场景<br>“重试”的语义是我们认为这个故障是暂时的，而不是永久的，所以，我们会去重试<br>我认为，设计重试时，我们需要定义出什么情况下需要重试，例如，调用超时、被调用端返回了某种可以重试的错误（如繁忙中、流控中、维护中、资源不足等）。<br>而对于一些别的错误，则最好不要重试，比如：业务级的错误（如没有权限、或是非法数据等错误），技术上的错误（如：HTTP 的 503 等，这种原因可能是触发了代码的 bug，重试下去没有意义）。</p></li><li><p>策略<br>关于重试的设计，一般来说，都需要有个重试的最大值，经过一段时间不断的重试后，就没有必要再重试了，应该报故障了。在重试过程中，每一次重试失败时都应该休息一会儿再重试，这样可以避免因为重试过快而导致网络上的负担加重。<br>在重试的设计中，我们一般都会引入，Exponential Backoff 的策略，也就是所谓的 “ 指数级退避 “。在这种情况下，每一次重试所需要的休息时间都会成倍增加。这种机制主要是用来让被调用方能够有更多的时间来从容处理我们的请求。这其实和 TCP 的拥塞控制有点像。  </p><p>例如，我们定义一个调用返回的枚举类型，其中包括了 5 种返回错误——成功 SUCCESS、维护中 NOT_READY、流控中 TOO_BUSY、没有资源 NO_RESOURCE、系统错误 SERVER_ERROR。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Results &#123;</span><br><span class="line">  SUCCESS,</span><br><span class="line">  NOT_READY,</span><br><span class="line">  TOO_BUSY,</span><br><span class="line">  NO_RESOURCE,</span><br><span class="line">  SERVER_ERROR</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>spring的重试方法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Retryable</span>(</span><br><span class="line">    value = &#123; SQLException.class &#125;,</span><br><span class="line">    maxAttempts = <span class="number">2</span>,</span><br><span class="line">    backoff = <span class="meta">@Backoff</span>(delay = <span class="number">5000</span>))</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">retryService</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设计重点<br>重试的代码比较简单也比较通用，完全可以不用侵入到业务代码中。这里有两个模式。一个是代码级的，像 Java 那样可以使用 Annotation 的方式（在 Spring 中你可以用到这样的注解），如果没有注解也可以包装在底层库或是 SDK 库中不需要让上层业务感知到。另外一种是走 Service Mesh 的方式（关于 Service Mesh 的方式，我会在后面的文章中介绍）。<br>对于有事务相关的操作。我们可能会希望能重试成功，而不至于走业务补偿那样的复杂的回退流程。对此，我们可能需要一个比较长的时间来做重试，但是我们需要保存请求的上下文，这可能对程序的运行有比较大的开销，因此，有一些设计会先把这样的上下文暂存在本机或是数据库中，然后腾出资源来做别的事，过一会再回来把之前的请求从存储中捞出来重试。</p></li></ul><h2 id="补偿设计-Compensating-Transaction"><a href="#补偿设计-Compensating-Transaction" class="headerlink" title="补偿设计 Compensating Transaction"></a>补偿设计 Compensating Transaction</h2><ul><li>前沿<br>既然要分布式，必须要分离，隔离的服务之间通信要用异步的来解耦开，然后可能会存在通信异常，就需要重试，重试时不想被重试操作多次，也就需要幂等，更重要的一个问题是如果业务走不下去怎么办？那就是本节的补偿，如果前边几种是正流程，那么补偿就是逆流程。  </li><li><p>ACID 和 BASE<br>这里先做一点解释，这两个概念其实是tradeoff，严格必然不会繁荣，繁荣必然存在瑕疵。<br>有必要先说一下 ACID 和 BASE 的差别。传统关系型数据库系统的事务都有 ACID 属性，即原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。<br>为了提高性能，出现了 ACID 的一个变种 BASE。可以看到，BASE 系统是允许或是容忍系统出现暂时性问题的，这样一来，我们的系统就能更有弹力。因为我们知道，在分布式系统的世界里，故障是不可避免的，我们能做的就是把故障处理当成功能写入代码中，这就是 Design for Failure。</p></li><li><p>业务补偿<br>一般来说，业务的事务补偿都是需要一个工作流引擎的。亚马逊是一个超级喜欢工作流引擎的公司，这个工作流引擎把各式各样的服务给串联在一起，并在工作流上做相应的业务补偿，整个过程设计成为最终一致性的。<br>对于业务补偿来说，首先需要将服务做成幂等性的，如果一个事务失败了或是超时了，我们需要不断地重试，努力地达到最终我们想要的状态。然后，如果我们不能达到这个我们想要的状态，我们需要把整个状态恢复到之前的状态。另外，如果有变化的请求，我们需要启动整个事务的业务更新机制。</p><p>一个好的业务补偿机制需要做到下面这几点：<br>要能清楚地描述出要达到什么样的状态（比如：请假、机票、酒店这三个都必须成功，租车是可选的），以及如果其中的条件不满足，那么，我们要回退到哪一个状态。这就是所谓的整个业务的起始状态定义。<br>当整条业务跑起来的时候，我们可以串行或并行地做这些事。对于旅游订票是可以并行的，但是对于网购流程（下单、支付、送货）是不能并行的。总之，我们的系统需要努力地通过一系列的操作达到一个我们想要的状态。如果达不到，就需要通过补偿机制回滚到之前的状态。这就是所谓的状态拟合。<br>对于已经完成的事务进行整体修改，可以考虑成一个修改事务。  </p><p>我们需要小心维护和监控整个过程的状态，所以，千万不要把这些状态放到不同的组件中，最好是一个业务流程的控制方来做这个事，也就是一个工作流引擎。所以，这个工作流引擎是需要高可用和稳定的。这就好像旅行代理机构一样，我们把需求告诉它，它会帮我们搞定所有的事。如果有问题，也会帮我们回滚和补偿的。<br>下层的业务方最好提供短期的资源预留机制。就像电商中的把货品的库存预先占住等待用户在 15 分钟内支付。如果没有收到用户的支付，则释放库存。然后回滚到之前的下单操作，等待用户重新下单。</p></li></ul><h2 id="熔断设计-Circuit-Breaker"><a href="#熔断设计-Circuit-Breaker" class="headerlink" title="熔断设计 Circuit Breaker"></a>熔断设计 Circuit Breaker</h2><p>先简单描述  </p><ul><li><p>定义<br>熔断器模式可以防止应用程序不断地尝试执行可能会失败的操作，使得应用程序继续执行而不用等待修正错误，或者浪费 CPU 时间去等待长时间的超时产生。熔断器模式也可以使应用程序能够诊断错误是否已经修正。如果已经修正，应用程序会再次尝试调用操作。</p><p>由此可见，重试的次数显示实在前端的一种控制，这里的熔断实在后端，更确切说是网关的控制</p></li><li><p>示意图<br><img src="熔断示意图.png" alt="熔断示意图"></p></li><li><p>状态<br><img src="熔断状态转换.png" alt="熔断状态转换"></p><ul><li><p>closed，通畅状态<br>我们需要一个调用失败的计数器，如果调用失败，则使失败次数加 1。如果最近失败次数超过了在给定时间内允许失败的阈值，则切换到断开 (Open) 状态。此时开启了一个超时时钟，当该时钟超过了该时间，则切换到半断开（Half-Open）状态。该超时时间的设定是给了系统一次机会来修正导致调用失败的错误，以回到正常工作的状态。在 Closed 状态下，错误计数器是基于时间的。在特定的时间间隔内会自动重置。这能够防止由于某次的偶然错误导致熔断器进入断开状态。也可以基于连续失败的次数。  </p></li><li><p>open，断开状态<br>在该状态下，对应用程序的请求会立即返回错误响应，而不调用后端的服务。这样也许比较粗暴，有些时候，我们可以 cache 住上次成功请求，直接返回缓存（当然，这个缓存放在本地内存就好了），如果没有缓存再返回错误（缓存的机制最好用在全站一样的数据，而不是用在不同的用户间不同的数据，因为后者需要缓存的数据有可能会很多）。</p></li><li><p>Half-open，半开状态<br>允许应用程序一定数量的请求去调用服务。如果这些请求对服务的调用成功，那么可以认为之前导致调用失败的错误已经修正，此时熔断器切换到闭合状态，同时将错误计数器重置。</p></li></ul></li><li><p>课外<br> Netflix 的Hystrix开源项目</p></li></ul><h2 id="限流设计-Throttle"><a href="#限流设计-Throttle" class="headerlink" title="限流设计 Throttle"></a>限流设计 Throttle</h2><ul><li><p>定义<br>保护系统不会在过载的情况下出现问题，需要通过对并发访问进行限速，相关的策略一般是，一旦达到限制的速率，那么就会触发相应的限流行为。包括：拒绝服务、服务降级、特权请求、延时请求等</p></li><li><p>3种实现方式  </p><ul><li><p>计数器方式<br>最简单的限流算法就是维护一个计数器 Counter，当一个请求来时，就做加一操作，当一个请求处理完后就做减一操作。如果这个 Counter 大于某个数了（我们设定的限流阈值），那么就开始拒绝请求以保护系统的负载了。可以增加对特权用户增加新的队列，来完成对不同用户的控制。<br><img src="计数限流.png" alt="计数限流"><br><img src="队列限流.png" alt="队列限流"></p></li><li><p>漏斗方式<br>我们可以看到，就像一个漏斗一样，进来的水量就好像访问流量一样，而出去的水量就像是我们的系统处理请求一样。当访问流量过大时这个漏斗中就会积水，如果水太多了就会溢出。<br>一般来说，这个“漏斗”是用一个队列来实现的，当请求过多时，队列就会开始积压请求，如果队列满了，就会开拒绝请求。很多系统都有这样的设计，比如 TCP。当请求的数量过多时，就会有一个 sync backlog 的队列来缓冲请求，或是 TCP 的滑动窗口也是用于流控的队列。<br><img src="漏斗限流方式.png" alt="漏斗限流方式">  </p></li><li><p>令牌桶方式<br>关于令牌桶算法，主要是有一个中间人。在一个桶内按照一定的速率放入一些 token，然后，处理程序要处理请求时，需要拿到 token，才能处理；如果拿不到，则不处理。<br><img src="令牌桶限流方式.png" alt="令牌桶限流方式"></p></li><li><p>基于响应时间的动态限流<br>这其实是将限流加了负反馈回路<br>上面的算法有个不好的地方，就是需要设置一个确定的限流值。这就要求我们每次发布服务时都做相应的性能测试，找到系统最大的性能值。<br>我们想使用一种动态限流的方式。这种方式，不再设定一个特定的流控值，而是能够动态地感知系统的压力来自动化地限流。这方面设计的典范是 TCP 协议的拥塞控制的算法。TCP 使用 RTT - Round Trip Time 来探测网络的延时和性能，从而设定相应的“滑动窗口”的大小，以让发送的速率和网络的性能相匹配。这个算法是非常精妙的，我们完全可以借鉴在我们的流控技术中。</p></li></ul></li><li><p>课外<br>tcp的限流方式</p></li></ul><h2 id="降级设计-Degradation"><a href="#降级设计-Degradation" class="headerlink" title="降级设计 Degradation"></a>降级设计 Degradation</h2><ul><li><p>定义<br>所谓的降级设计（Degradation），本质是为了解决资源不足和访问量过大的问题。当资源和访问量出现矛盾的时候，在有限的资源下，为了能够扛住大量的请求，我们就需要对系统进行降级操作。也就是说，暂时牺牲掉一些东西，以保障整个系统的平稳运行。  </p></li><li><p>方法</p><ul><li><p>停止次要功能<br>停止次要的功能也是一种非常有用的策略。把一些不重要的功能给暂时停止掉，让系统释放出更多的资源来。比如，电商中的搜索功能，用户的评论功能，等等。等待访问的峰值过去后，我们再把这些功能给恢复回来。  </p></li><li><p>简化功能<br>关于功能的简化上，上面的下单流程中已经提到过相应的例子了。而且，从缓存中返回数据也是其中一个。这里再提一个，就是一般来说，一个 API 会有两个版本，一个版本返回全量数据，另一个版本只返回部分或最小的可用的数据。  </p></li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>分布式核心就是分，就是隔离服务<br>联系起来整理，才发现这一系列的脉络，整个分布式系统有两条流程，一条是正向流程、一条是反向流程。<br>正向流程中包括，分解服务、异步通讯、重试、幂等<br>反向流程指的是补偿设计<br>为了保护正反向流程不被流量压跨，又有了3个保护设计：熔断、限流、降级</p><h1 id="管理设计"><a href="#管理设计" class="headerlink" title="管理设计"></a>管理设计</h1><h2 id="分布式锁-Distributed-Lock"><a href="#分布式锁-Distributed-Lock" class="headerlink" title="分布式锁 Distributed Lock"></a>分布式锁 Distributed Lock</h2><p>先简化写了</p><ul><li><p>定义<br>我们知道，在多线程情况下访问一些共享资源需要加锁，不然就会出现数据被写乱的问题。在分布式系统下，这样的问题也是一样的。只不过，我们需要一个分布式的锁服务。对于分布式的锁服务，一般可以用数据库 DB、Redis 和 ZooKeeper 等实现。不管怎么样，分布式的锁服务需要有以下几个特点。  </p></li><li><p>redis分布式锁<br><code>SET resource_name my_random_value NX PX 30000</code></p></li><li><p>redis分布式锁的问题</p></li><li><p>解决方案</p><ul><li>版本号</li><li>fence token</li></ul></li><li><p>课外<br>细心的你一定发现了，这不就是计算机汇编指令中的原子操作 CAS（Compare And Swap）嘛，大量无锁的数据结构都需要用到这个。（关于 CAS 的话题，你可以看一下我在 CoolShell 上写的</p></li></ul><h2 id="配置中心-Configuration-Management"><a href="#配置中心-Configuration-Management" class="headerlink" title="配置中心 Configuration Management"></a>配置中心 Configuration Management</h2><p>先简写了，这个跟杨波老师的配置中心一个概念，不过引出了下边3节的内容</p><ul><li><p>配置区分<br>有一种方式是把软件的配置分成静态配置和动态配置。<br>静态配置：所谓静态配置其实就是在软件启动时的一些配置，运行时基本不会进行修改，也可以理解为是环境或软件初始化时需要用到的配置。如，操作系统的网络配置，软件运行时 Docker 进程的配置，这些配置在软件环境初始化时就确定了，未来基本不会修改了<br>动态配置：就是软件运行时的一些配置，在运行时会被修改。比如，日志级别、降级开关、活动开关。</p></li><li><p>架构<br><img src="配置中心.png" alt="配置中心"></p></li></ul><h2 id="边车模式-SideCar"><a href="#边车模式-SideCar" class="headerlink" title="边车模式 SideCar"></a>边车模式 SideCar</h2><ul><li><p>定义<br>边车就有点像一个服务的 Agent，这个服务所有对外的进出通讯都通过这个 Agent 来完成。这样，我们就可以在这个 Agent 上做很多文章了。但是，我们需要保证的是，这个 Agent 要和应用程序一起创建，一起停用。</p><p>编程的本质就是将控制和逻辑分离和解耦，而边车模式也是异曲同工，同样是让我们在分布式架构中做到逻辑和控制分离。</p></li><li><p>讨论<br>对于监视、日志、限流、熔断、服务注册、协议转换等等这些功能，其实都是大同小异，甚至是完全可以做成标准化的组件和模块的。一般来说，我们有两种方式：<br>一种是通过 SDK、Lib 或 Framework 软件包方式，在开发时与真实的应用服务集成起来。性能高，但对应用有侵入<br>另一种是通过像 Sidecar 这样的方式，在运维时与真实的应用服务集成起来。性能低，无需改应用，增加了依赖，也做到了逻辑与控制的分离。  </p><p>其实一种是在代码层面解决，一种是在服务层面解决</p></li><li><p>结构<br><img src="边车模式.png" alt="边车模式"></p></li><li><p>特点<br>我们知道，熔断、路由、服务发现、计量、流控、监视、重试、幂等、鉴权等控制面上的功能，以及其相关的配置更新，本质来上来说，和服务的关系并不大。但是传统的工程做法是在开发层面完成这些功能，这就会导致各种维护上的问题，而且还会受到特定语言和编程框架的约束和限制。<br>而随着系统架构的复杂化和扩张，我们需要更统一地管理和控制这些控制面上的功能，所以传统的在开发层面上完成控制面的管理会变得非常难以管理和维护。这使得我们需要通过 Sidecar 模式来架构我们的系统。  </p></li></ul><h2 id="服务网格-Service-Mesh"><a href="#服务网格-Service-Mesh" class="headerlink" title="服务网格 Service Mesh"></a>服务网格 Service Mesh</h2><ul><li><p>背景<br>将边车模式发扬广大，是 CNCF（Cloud Native Computing Foundation，云原生计算基金会）目前主力推动的新一代的微服务架构——Service Mesh 服务网格。<br>Service Mesh 这个服务网络专注于处理服务和服务间的通讯。其主要负责构造一个稳定可靠的服务通讯的基础设施，并让整个架构更为的先进和 Cloud Native。在工程中，Service Mesh 基本来说是一组轻量级的服务代理和应用逻辑的服务在一起，并且对于应用服务是透明的。  </p></li><li><p>示意图<br><img src="service_mesh.png" alt="service_mesh"><br><img src="server_mesh_2.png" alt="server_mesh_2">  </p></li><li><p>课外<br>Rust/Go 语言实现的 lstio 和 Conduit，后者比前者要轻很多。</p></li></ul><h2 id="网关模式-Gateway"><a href="#网关模式-Gateway" class="headerlink" title="网关模式 Gateway"></a>网关模式 Gateway</h2><ul><li><p>背景<br>这其实与service mesh是两个方向的发展了<br>它不需要为每个服务的实例都配置上一个 Sidecar。其实，一个服务集群配上一个 Gateway 就可以了，或是一组类似的服务配置上一个 Gateway。  </p></li><li><p>示意图<br><img src="网关示意图.png" alt="网关示意图"></p></li><li><p>网关的功能</p><ul><li>请求路由</li><li>服务注册</li><li>负载均衡</li><li>弹力设计：重试、幂等、流控、熔断、监视等都可以实现进去</li><li>安全方面：SSL 加密及证书管理、Session 验证、授权、数据校验等</li></ul></li></ul><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>首先，Sidecar 的方式主要是用来改造已有服务。我们知道，要在一个架构中实施一些架构变更时，需要业务方一起过来进行一些改造。然而业务方的事情比较多，像架构上的变更会低优先级处理，这就导致架构变更的“政治复杂度”太高。而通过 Sidecar 的方式，我们可以适配应用服务，成为应用服务进出请求的代理。这样，我们就可以干很多对于业务方完全透明的事情了。<br>当 Sidecar 在架构中越来越多时，需要我们对 Sidecar 进行统一的管理。于是，我们为 Sidecar 增加了一个全局的中心控制器，就出现了我们的 Service Mesh。在中心控制器出现以后，我们发现，可以把非业务功能的东西全部实现在 Sidecar 和 Controller 中，于是就成了一个网格。业务方只需要把服务往这个网格中一放就好了，与其它服务的通讯、服务的弹力等都不用管了，像一个服务的 PaaS 平台。<br>然而，Service Mesh 的架构和部署太过于复杂，会让我们运维层面上的复杂度变大。为了简化这个架构的复杂度，我认为 Sidecar 的粒度应该是可粗可细的，这样更为方便。但我认为，Gateway 更为适合，而且 Gateway 只负责进入的请求，不像 Sidecar 还需要负责对外的请求。因为 Gateway 可以把一组服务给聚合起来，所以服务对外的请求可以交给对方服务的 Gateway。于是，我们只需要用一个负责进入请求的 Gateway 来简化需要同时负责进出请求的 Sidecar 的复杂度。</p><h1 id="性能设计"><a href="#性能设计" class="headerlink" title="性能设计"></a>性能设计</h1><h2 id="缓存-Cache"><a href="#缓存-Cache" class="headerlink" title="缓存 Cache"></a>缓存 Cache</h2><h2 id="异步处理-Asynchronous"><a href="#异步处理-Asynchronous" class="headerlink" title="异步处理 Asynchronous"></a>异步处理 Asynchronous</h2><h2 id="数据库扩展"><a href="#数据库扩展" class="headerlink" title="数据库扩展"></a>数据库扩展</h2><h2 id="秒杀-Flash-Sales"><a href="#秒杀-Flash-Sales" class="headerlink" title="秒杀 Flash Sales"></a>秒杀 Flash Sales</h2><h2 id="边缘计算-Edge-Computing"><a href="#边缘计算-Edge-Computing" class="headerlink" title="边缘计算 Edge Computing"></a>边缘计算 Edge Computing</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章来整理《左耳听风》栏目的分布式设计模式弹力设计、管理设计、性能设计篇，并根据当下情况，借鉴一二&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>第四周ARTS</title>
    <link href="http://yoursite.com/2019/04/14/%E7%AC%AC%E5%9B%9B%E5%91%A8ARTS/"/>
    <id>http://yoursite.com/2019/04/14/第四周ARTS/</id>
    <published>2019-04-14T00:52:35.000Z</published>
    <updated>2019-04-15T02:27:45.963Z</updated>
    
    <content type="html"><![CDATA[<p>第四周打卡<br><a id="more"></a></p><h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><p>本题是Leetcode的56题Merge Intervals，主要来训练排序的<br><a href="https://sunyanfeng.cn/2019/04/11/合并区间问题/#more" target="_blank" rel="noopener">合并区间问题</a></p><h1 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h1><p><a href="https://medium.com/@goldybenedict/single-page-applications-vs-multiple-page-applications-do-you-really-need-an-spa-cf60825232a3" target="_blank" rel="noopener">原文</a><br>本周来review一篇SPA(Single Page Application)与MPA(Multiple Page Application)对比的文章<br>在原文中它对比了SPA与MPA的优缺点，如下图：  </p><table><thead><tr><th style="text-align:left">优缺点对比</th><th style="text-align:center">SPA</th><th style="text-align:center">MPA</th></tr></thead><tbody><tr><td style="text-align:left">优点</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left"></td><td style="text-align:center">SPA更平滑更快</td><td style="text-align:center">搜索引擎方面表现良好</td></tr><tr><td style="text-align:left"></td><td style="text-align:center">更容易开发、部署</td><td style="text-align:center">为用户提供web应用的visual map</td></tr><tr><td style="text-align:left"></td><td style="text-align:center">更容易调试</td><td style="text-align:center"></td></tr><tr><td style="text-align:left"></td><td style="text-align:center">重用一套后端开发生成手机端</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">缺点</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left"></td><td style="text-align:center">对搜索引擎表现不足(已改)</td><td style="text-align:center">相比而言开发复杂</td></tr><tr><td style="text-align:left"></td><td style="text-align:center">只提供单一链接</td><td style="text-align:center">耦合前后端</td></tr><tr><td style="text-align:left"></td><td style="text-align:center">由于跨域问题,安全性稍差</td></tr></tbody></table><p>在选择时，给出建议：<br>If your business deals with a single product, nothing can be perfect than a single page application。<br>While, if your business caters a variety of services or products, you definitely need to give importance to each of them by bifurcating them in different pages with a multi-page application.</p><p>意思是如果产品单一，SPA更好；如果服务、产品众多，更适合MPA。<br>其实这个度其实不好把握，而且感觉SPA与MPA之间的度并不是那么分明。对于单一产品先开发SPA，然后随着业务变大，然后再开发一些SPA，在网关层上做一些调整，感觉也不错。</p><h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><p>由于内容上的连贯，本周的内容继续放在了上周的博客中。<br><a href="https://sunyanfeng.cn/2019/04/08/Matrix-Eigenvalue/#more" target="_blank" rel="noopener">Matrix Eigenvalue</a></p><h1 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h1><p>本周工作中主要是想搭建一个React的前端框架出来，在SSR、CSR与同构下了一点功夫，就这个问题做一个分享。<br><a href="https://sunyanfeng.cn/2019/04/14/SSR%E3%80%81CSR%E4%B8%8E%E5%90%8C%E6%9E%84/#more" target="_blank" rel="noopener">SSR、CSR与同构</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第四周打卡&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SSR、CSR与同构</title>
    <link href="http://yoursite.com/2019/04/14/SSR%E3%80%81CSR%E4%B8%8E%E5%90%8C%E6%9E%84/"/>
    <id>http://yoursite.com/2019/04/14/SSR、CSR与同构/</id>
    <published>2019-04-14T00:51:40.000Z</published>
    <updated>2019-05-06T00:51:28.642Z</updated>
    
    <content type="html"><![CDATA[<p>为本周的前端的框架选择做一个总结</p><p>change log：<br>初次写时，概念表达不太到位，再次翻阅不能起到快速回忆的目的，这里再次进行修改，删去原来的过程部分，增加CSR与SSR的技术内容。</p><a id="more"></a><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>团队的前端同学们想探索一些新的框架，于是就跟他们一起做一些技术选择。<br>现有的前端框架分成server部分与browser部分，server中是一个node.js服务器，负责页面与路由的映射，根据路由导向不同的页面，渲染的交给了前端来完成，是一个React MPA 前端渲染的框架，设计是用的Material-UI库</p><h1 id="发展观"><a href="#发展观" class="headerlink" title="发展观"></a>发展观</h1><p>随着这篇文章来梳理一下</p><ul><li><p>html时代<br>http协议最早设计的是从服务器上获取静态的资源，其实也就是静态html  </p></li><li><p>模板渲染<br>后来Java时代，可以通过模板，将数据渲染进模板，从而生成html发送给前端，在后来的CSR出现之间，我觉得可能也没有SSR的概念。  </p><p>浏览器与服务端数据的交互通过表单来实现，浏览器将表达中的数据一次性通过表单提交，后代进行处理完成后可以再次渲染模板，然后将数据表达出来。</p></li><li><p>CSR(客户端侧渲染)<br>后来我觉得是ajax与virtual dom技术的出现，使浏览器渲染成为可能，一开始可能只是想做一点改变，感觉很平滑，后来干脆所有的dom都直接渲染，这就成成CSR  </p><p>这个CSR从过程上看，浏览器先去获取一个空模板，然后再获取js文件进行virtual dom的渲染，这个过程浏览器上会有一瞬的白屏。  </p><p>浏览器与服务端数据交互很多时候被ajax所替代，好处是比较灵活，不论是数据交互还是页面刷新，不好处容易被滥用，使通信的效率降低，后台服务压力上升。  </p></li><li><p>SSR(服务侧渲染)-追加<br>模板渲染就是一种SSR，这里针对的主要的是React所以略有不同，SSR主要是将render的操作放在了后端来执行，将数据从API Server取来，然后直接通过render函数渲染到页面上，并将页面返回浏览器。这样浏览器也不用再获取js，自己来渲染。  </p><p>不好处也比较明显，每次获取数据、渲染，对服务器的要求会比CSR高，不过模板时期也是这么玩的。另外响应感觉要比CSR慢一点。<br>这里要加一下看过next.js之后的感想，next.js是一个SSR的框架，它是一种MPA，提供的prefech与Dynamic Import等功能，在SSR方面做的更突出一些。</p></li><li><p>isomorphic(同构渲染)-修改<br>Isomorphic既是CSR也是SSR，它是服务器渲染一遍，浏览器也渲染一遍。<br>在一些实践中服务器渲染完初识界面之后就算完成任务，其余的渲染就靠浏览器来完成。这种同构渲染感觉更偏向CSR<br>想象中，SSR完成之后，通过AJAX获取数据，然后根据数据做一些render，这样的效果也会不错。这种通过感觉更偏向SSR  </p></li></ul><h1 id="CSR与SSR"><a href="#CSR与SSR" class="headerlink" title="CSR与SSR"></a>CSR与SSR</h1><p>一些文章中将Isomophic也说成SSR</p><ul><li><p>差异<br>刚开始接触花费了挺多时间来区别这两个概念，其实从名字就能做区分，对于React而言，就是是render函数是在服务器上执行还是在浏览器上执行。</p></li><li><p>SSR与CSR原理<br>原理从下边两张图中即可说明：<br><img src="CSR.png" alt="CSR"><br><img src="SSR.png" alt="SSR"><br>这里的SSR其实是Isomophic，它有2个入口，第一次是服务端的入口，第二次是客户端再次获取js文件渲染之后的浏览器入口。</p><p>推荐：<a href="https://juejin.im/post/5bc7ea48e51d450e46289eab" target="_blank" rel="noopener">React 中同构（SSR）原理脉络梳理</a></p></li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>上次根据研究，已经将一个同构的React同构框架搭建起来，期间跳过了很多的坑，采用create-react-app脚手架、Typescript、express、react-router、stylus等技术。但有还是两个问题其实没有解决：  </p><ul><li><p>服务端代码运行<br>原来的框架中，运行时将Ts写的服务端代码也编译成了js之后进行运行，但在这里没有成功，原因是，原来框架中客户端与服务端的代码完全隔离，但在同构渲染时，服务端要渲染，必须要引入React的组件，而这些组件通过webpack打包之后，里边的函数没法再被server侧导入。<br>处理这个问题时，要么全部将Ts都通过gulp-typescript来编译成js，要么直接使用Ts，而经过确认，定于使用了Ts直接运行的方式</p></li><li><p>stylus问题<br>这个延伸自上一个问题，由于CSS采用stylus，造成ts直接运行时，没办法转换其中的stylus模块，这个问题目前还没有找到。可能要退回到将Ts全部编译成js，然后用gulp-stylus来处理一下stylus的方式来实现，要是这样，感觉也有些不妥。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为本周的前端的框架选择做一个总结&lt;/p&gt;
&lt;p&gt;change log：&lt;br&gt;初次写时，概念表达不太到位，再次翻阅不能起到快速回忆的目的，这里再次进行修改，删去原来的过程部分，增加CSR与SSR的技术内容。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>合并区间问题</title>
    <link href="http://yoursite.com/2019/04/11/%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/04/11/合并区间问题/</id>
    <published>2019-04-11T15:18:06.000Z</published>
    <updated>2019-04-15T02:20:24.912Z</updated>
    
    <content type="html"><![CDATA[<p>本题是Leetcode的56题Merge Intervals，主要来训练排序的<br><a id="more"></a></p><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a collection of intervals, merge all overlapping intervals.</p><p>Example 1:</p><p>Input: [[1,3],[2,6],[8,10],[15,18]]<br>Output: [[1,6],[8,10],[15,18]]<br>Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].  </p><p>Example 2:  </p><p>Input: [[1,4],[4,5]]<br>Output: [[1,5]]<br>Explanation: Intervals [1,4] and [4,5] are considered overlapping.  </p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>本周想对排序进行练习，上周的Kth最大子数组就是用归并排序来完成的，是训练分治也是训练排序。本周从sort标签中选了第一题。<br>首先需要将各个区间按第一个起始位置排序，然后去合并这些区间即可。这里采用的是快速排序的方式，而且合并的过程也采用与快排查找中间位置类似的想法。<br>这书写上，想着用一下函数范式的一些规则，形参不改变，返回一个相同的参数，使函数无状态。  </p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * struct Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() : start(0), end(0) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;Interval&gt; merge(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;Interval&gt; sortedVals = sortInterval(intervals);</span><br><span class="line">        <span class="built_in">vector</span>&lt;Interval&gt; mergedVals = mergeInterval(sortedVals);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mergedVals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;Interval&gt; sortInterval(<span class="built_in">vector</span>&lt;Interval&gt; &amp;intervals)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Interval&gt; sortedVals = intervals;</span><br><span class="line">        quickSortInterval(sortedVals, <span class="number">0</span>, sortedVals.size()<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sortedVals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quickSortInterval</span><span class="params">(<span class="built_in">vector</span>&lt;Interval&gt; &amp;intervals, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(start &gt;= end)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = partition(intervals, start, end);</span><br><span class="line">        quickSortInterval(intervals, start, mid<span class="number">-1</span>);</span><br><span class="line">        quickSortInterval(intervals, mid+<span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;Interval&gt; &amp;intervals, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        Interval ref = intervals[end];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = start<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=start; j&lt;end; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[j].start &lt; ref.start)&#123;</span><br><span class="line">                i++;</span><br><span class="line"></span><br><span class="line">                exchange(intervals[i], intervals[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = i+<span class="number">1</span>;</span><br><span class="line">        exchange(intervals[mid], intervals[end]);</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">(Interval &amp;a, Interval &amp;b)</span></span>&#123;</span><br><span class="line">        Interval tmp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;Interval&gt; mergeInterval(<span class="built_in">vector</span>&lt;Interval&gt; &amp;intervals)&#123;</span><br><span class="line">        <span class="keyword">int</span> len = intervals.size();</span><br><span class="line">        <span class="keyword">if</span>(len &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> intervals;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;Interval&gt; mergedVals;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=j+<span class="number">1</span>; i&lt;len; ++i)&#123;</span><br><span class="line">          <span class="keyword">if</span>(intervals[j].end &lt; intervals[i].start)&#123;</span><br><span class="line">              mergedVals.push_back(intervals[j]);</span><br><span class="line">              j=i;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span>(intervals[j].end &lt; intervals[i].end)&#123;</span><br><span class="line">              intervals[j].end = intervals[i].end;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(i == len<span class="number">-1</span>)&#123;</span><br><span class="line">            mergedVals.push_back(intervals[j]);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mergedVals;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本题在合并区间的时候考虑过将合并掉的区间删除，考虑到vector删除size发生变化，就思考与快排用两个指示器来处理的方式。这种方式其实改变了传入值，其实可以做一层复制来规避，这里图简单，没有将无状态贯彻到底。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本题是Leetcode的56题Merge Intervals，主要来训练排序的&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>第三周ARTS</title>
    <link href="http://yoursite.com/2019/04/08/%E7%AC%AC%E4%B8%89%E5%91%A8ARTS/"/>
    <id>http://yoursite.com/2019/04/08/第三周ARTS/</id>
    <published>2019-04-08T02:22:36.000Z</published>
    <updated>2019-04-09T01:47:54.042Z</updated>
    
    <content type="html"><![CDATA[<p>第三周打卡<br><a id="more"></a></p><h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><p><a href="https://sunyanfeng.cn/2019/04/04/kth%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/#more" target="_blank" rel="noopener">kth最大元素</a></p><h1 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h1><p>本周主要Review了陈皓老师的编程范式</p><p><a href="https://sunyanfeng.cn/2019/04/01/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/#more" target="_blank" rel="noopener">编程范式</a></p><h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><p><a href="https://sunyanfeng.cn/2019/04/08/Matrix-Eigenvalue/#more" target="_blank" rel="noopener">Matrix Eigenvalue</a></p><h1 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h1><p>本周顺便做了一个工具的记录，就当share了，稍显薄了一点</p><p><a href="https://sunyanfeng.cn/2019/04/04/vscode%E4%B8%8Bmd%E5%AF%BCpdf/#more" target="_blank" rel="noopener">vscode下md导pdf</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第三周打卡&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Matrix Eigenvalue</title>
    <link href="http://yoursite.com/2019/04/08/Matrix-Eigenvalue/"/>
    <id>http://yoursite.com/2019/04/08/Matrix-Eigenvalue/</id>
    <published>2019-04-08T02:14:22.000Z</published>
    <updated>2019-04-15T02:20:24.908Z</updated>
    
    <content type="html"><![CDATA[<p>本周清明回家，只完成2节的Matrix学习，Lesson21～Lesson22<br>为保持博客的完整性，下周的Matrix依旧会放到本篇博客中  </p><p>第四周完成了Less23~Lesson24,继续在这里记录。<br><a id="more"></a></p><hr><h1 id="Eigenvalues-and-eigenvectors"><a href="#Eigenvalues-and-eigenvectors" class="headerlink" title="Eigenvalues and eigenvectors"></a>Eigenvalues and eigenvectors</h1><ul><li><p>定义</p><p>AX = λX</p><p>A matrix A acts on vectors x . Eigenvectors are vectors for which Axis parallel to x。</p></li><li><p>计算</p><p>det(A-λI) = 0</p></li><li><p>复数eigenvalues</p><p>对称阵的特征值为实数，反对称阵的特征值为纯虚数<br>Symmetric matrices have real eigenvalues<br>For antisymmetric matrices like Q, for which AT = −A, all eigenvalues are imaginary (λ=bi). </p></li><li><p>重复的eigenvalues</p><p>非重复的eigenvalues用于相互独立的eigenvector，重复的eigenvalues可能用于独立的，也可能不独立的eigenvector</p><p><img src="重复的eigenvalues示例.png" alt="重复的eigenvalues示例"></p></li></ul><h1 id="Diagonalization-and-powers-of-A"><a href="#Diagonalization-and-powers-of-A" class="headerlink" title="Diagonalization and powers of A"></a>Diagonalization and powers of A</h1><ul><li><p>对角化：Diagonalization</p><p><img src="对角化公式.png" alt="对角化公式"><br><img src="对角化证明.png" alt="对角化证明"></p></li><li><p>A的幂运算，Powers of A<br><img src="A的幂运算.png" alt="A的幂运算"></p><p>当A的K次幂 -&gt; 0时，说明A的特征向量绝对值&lt;1</p></li><li><p>差分方程<br><img src="差分方程.png" alt="差分方程"></p><p><img src="差分方程的解.png" alt="差分方程的解"><br>在这里，它将U0用A的特征向量来表示的，有点当成一组基在使用</p></li><li><p>菲比队列</p><p><img src="Fibonacci队列.png" alt="Fibonacci"><br><img src="构造矩阵.png" alt="构造矩阵"><br><img src="解.png" alt="解"></p></li></ul><hr><h1 id="微分方程与exp-At"><a href="#微分方程与exp-At" class="headerlink" title="微分方程与exp(At)"></a>微分方程与exp(At)</h1><p>本节可以分成3部分，解一个微分方程，稳态分析，exp(At)</p><ul><li><p>解微分方程<br><img src="微分方程实例.png" alt="微分方程实例"><br>初始状态u1=1 u2=0. </p><p><img src="微分方程.png" alt="微分方程">其中A为<img src="微分方程的A.png" alt="微分方程的A"><br>对A求解特征值与特征向量得<br>λ1=0，λ2=-3<br>对应的特征向量为<br><img src="特征向量1.png" alt="特征向量1"><br><img src="特征向量2.png" alt="特征向量2">  </p><p>微分方程对应的一般解为：<br><img src="一般解.png" alt="一般解"><br>可以看出这个一般解其实是一个线性组合，这里可以有一个证明，原因是在所有微分中，指数函数是唯一微分不变的。<br><img src="证明.png" alt="证明">  </p><p>将特征值、特征向量、初始值带入一般解，求解出c1、c2，以此得到u(t)<br><img src="u(t" alt="u(t)">.png)</p><p>以此解完了整个微分方程，同时也引出了稳态分析</p></li><li><p>稳态分析<br>可以对u(t)，尽心分析，当t趋于无穷.<br><img src="u无穷.png" alt="u无穷"></p><p>由此得到微分方程的稳态条件<br><img src="稳态.png" alt="稳态"></p></li><li><p>推广<br><img src="推广.png" alt="推广"><br>这里的推广，首先是将<img src="一般解.png" alt="一般解">写成了矩阵方式即u=Sv，这里S是A的特征向量组成的矩阵，v是变量；然后将次等式带入微分方程，求解v(t).然后将v(t)代入等式，得到u(t)，这里u(t)多了一个S逆<br>这样引出了本节最后一部分exp(At)</p></li><li><p>exp(At)<br><img src="指数的无穷级数.png" alt="指数的无穷级数"></p><p><img src="指数矩阵.png" alt="指数矩阵"></p><p><img src="指数矩阵的解释.png" alt="指数矩阵的解释"></p></li><li><p>二阶微分方程<br>这里对二阶微分方程做了引申<br><img src="二阶微分方程.png" alt="二阶微分方程"><br>与函数相同，将2阶换成2个一阶<br><img src="二阶引申.png" alt="二阶引申"></p></li></ul><h1 id="马尔科夫矩阵与傅里叶级数"><a href="#马尔科夫矩阵与傅里叶级数" class="headerlink" title="马尔科夫矩阵与傅里叶级数"></a>马尔科夫矩阵与傅里叶级数</h1><ul><li><p>马尔科夫矩阵<br>马尔科夫矩阵是这样一类矩阵：1. 矩阵每个元素都是正数；2. 矩阵每列的和为</p><p><img src="Markov矩阵.png" alt="Markov矩阵">  </p><p>它有两个属性</p><ol><li>λ=1是一个特征值，证明可以det(A-λI) = 0</li><li>其他的特征值都小于1</li></ol><p>上一节主要研究是是指数矩阵，这一节其实主要研究的是幂矩阵<br><img src="幂矩阵.png" alt="幂矩阵"><br><img src="级数矩阵.png" alt="级数矩阵"></p></li><li><p>例子<br><img src="以麻省与加州人口.png" alt="以麻省与加州人口"></p><p>λ1=1， λ2=0.7</p><p>对应特征向量<br><img src="Markov特征向量1.png" alt="Markov特征向量1"><br><img src="Markov特征向量2.png" alt="Markov特征向量2">  </p><p><img src="Markov的解.png" alt="Markov的解"></p></li><li><p>Projections with orthonormal basis<br>这个是之前章的一个复习，正交化的矩阵的一个好处是，做投影时只需与正交矩阵相乘即可。<br><img src="正交矩阵-1.png" alt="正交矩阵-1"><br><img src="正交矩阵-2.png" alt="正交矩阵-2"><br><img src="正交矩阵的解.png" alt="正交矩阵的解">  </p></li><li><p>傅里叶级数<br><img src="傅里叶级数.png" alt="傅里叶级数">  </p><p>对于向量：在R空间中<img src="向量空间.png" alt="向量空间"><br>对于函数：<img src="函数空间.png" alt="函数空间"><br>乘后加操作变成乘后积分操作，因为是周期函数，所以只积分周期即可。<br><img src="解过程.png" alt="解过程"><br><img src="傅里叶的解.png" alt="傅里叶的解"><br> 这样就解出了a1，以此可以解出an。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周清明回家，只完成2节的Matrix学习，Lesson21～Lesson22&lt;br&gt;为保持博客的完整性，下周的Matrix依旧会放到本篇博客中  &lt;/p&gt;
&lt;p&gt;第四周完成了Less23~Lesson24,继续在这里记录。&lt;br&gt;
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Matrix" scheme="http://yoursite.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统</title>
    <link href="http://yoursite.com/2019/04/06/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2019/04/06/分布式系统/</id>
    <published>2019-04-06T13:26:01.000Z</published>
    <updated>2019-04-09T01:27:23.446Z</updated>
    
    <content type="html"><![CDATA[<p>本文总结《左耳听风》分布式系统部分内容，为了帮助理解其中逻辑、加深记忆，也为了能时常的复习。</p><a id="more"></a><h1 id="分布式系统的发展"><a href="#分布式系统的发展" class="headerlink" title="分布式系统的发展"></a>分布式系统的发展</h1><ul><li><p>20世纪70年代模块化编程</p></li><li><p>80年代的面向事件设计</p></li><li><p>90年代的基于接口、构件设计，并演化出了SOA，基于服务的框架</p><p>SOA将应用系统功能作为服务发送给最终用户或者其他服务。</p><p>SOA遵循以下几条原则：</p><ul><li>可重用，模块化，可组合，构件化以及又互操作性</li><li>符合开发标准</li><li>服务的识别和分类，提供和发布，监控和跟踪<br>服务间并不直接依赖，而是通过中间件的标准协议或者通讯框架相互依赖。其实就是接口设计思想。</li></ul></li><li><p>2010年后，出现了微服务架构。<br>每一个微服务都能独立完整的运行，后端单体的数据库也被分散到不同的服务中。</p><p>服务间的整合需要一个服务编排或是服务整合的引擎。如k8s。</p><p>微服务的出现使得开发速度变得更快，部署快，隔离性高，系统的扩展度也很好，但是在集成测试、运维和服务管理等方面就比较麻烦了。</p><p><a href="分布式系统演化.png">分布式系统演化</a></p></li></ul><h1 id="分布式系统技术栈"><a href="#分布式系统技术栈" class="headerlink" title="分布式系统技术栈"></a>分布式系统技术栈</h1><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>构建分布式系统的目的：一是提高整体架构的吞吐量，服务更多的并发和流量，二是为了提高系统的稳定性，让系统的可用性更高。</p><ul><li><p>提高吞吐量<br><img src="提高吞吐量.png" alt="提高吞吐量"></p><p><strong>缓存系统</strong>。加入缓存系统，可以有效地提高系统的访问能力。从前端的浏览器，到网络，再到后端的服务，底层的数据库、文件系统、硬盘和 CPU，全都有缓存，这是提高快速访问能力最有效的手段。对于分布式系统下的缓存系统，需要的是一个缓存集群。这其中需要一个 Proxy 来做缓存的分片和路由。</p><p><strong>负载均衡系统</strong>。负载均衡系统是水平扩展的关键技术，它可以使用多台机器来共同分担一部分流量请求。</p><p><strong>异步系统</strong>。异步系统主要通过消息队列来对请求做排队处理，这样可以把前端的请求的峰值给“削平”了，而后端通过自己能够处理的速度来处理请求。这样可以增加系统的吞吐量，但是实时性就差很多了。同时，还会引入消息丢失的问题，所以要对消息做持久化，这会造成“有状态”的结点，从而增加了服务调度的难度。</p><p><strong>数据分区</strong>。是把数据按一定的方式分成多个区（比如通过地理位置），不同的数据区来分担不同区的流量。这需要一个数据路由的中间件，会导致跨库的 Join 和跨库的事务非常复杂。</p><p><strong>数据镜像</strong>。是把一个数据库镜像成多份一样的数据，这样就不需要数据路由的中间件了。你可以在任意结点上进行读写，内部会自行同步数据。然而，数据镜像中最大的问题就是数据的一致性问题。</p></li><li><p>提高稳定性<br><img src="提高稳定性.png" alt="提高稳定性"></p></li></ul><h2 id="纲领"><a href="#纲领" class="headerlink" title="纲领"></a>纲领</h2><p><img src="分布式系统纲领.png" alt="分布式系统纲领"></p><p>这个可以从表层往深层看</p><ol><li>流量监控与调度</li><li>服务监控与调度</li><li>数据(状态)监控与调度</li><li>资源监控与调度</li></ol><p>在原文中，将监控抽象出来，称为全栈监控</p><h1 id="全栈监控"><a href="#全栈监控" class="headerlink" title="全栈监控"></a>全栈监控</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><img src="全栈监控.png" alt="全栈监控"><br>在这里隐含着，日志数据格式标准化。</p><ul><li><p>资源监控：<br>监控主机和底层资源。比如：CPU、内存、网络吞吐、硬盘 I/O、硬盘使用等。</p></li><li><p>中间层监控：<br>就是中间件层的监控。比如：Nginx、Redis、ActiveMQ、Kafka、MySQL、Tomcat 等。</p></li><li><p>应用监控：<br>监控应用层的使用。比如：HTTP 访问的吞吐量、响应时间、返回码，调用链路分析，性能瓶颈，还包括用户端的监控。这里与上文的分析有点不一致。</p></li></ul><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li><p>服务调用链跟踪</p><p>这个监控系统应该从对外的 API 开始，然后将后台的实际服务给关联起来，然后再进一步将这个服务的依赖服务关联起来，直到最后一个服务（如 MySQL 或 Redis），这样就可以把整个系统的服务全部都串连起来了。这个事情的最佳实践是 Google Dapper 系统，其对应于开源的实现是 Zipkin。</p></li><li><p>服务调用时长分布</p><p>其实这个是调用链跟踪的统计，使用zipkin就可以分析出，在这个调用链上各服务的时长分布。</p></li><li><p>服务TOP N试图</p><p>也是对调用链跟踪的一种统计，时长、被调用次数等都可以</p></li><li><p>数据库操作关联</p><p>对数据库操作的监控，在Java中通过JavaAgent字节码注入技术拿到JDBC执行数据库操作的执行时间</p></li><li><p>服务资源跟踪</p><p>需要把服务运行的机器节点上的数据（CPU、MEM、I/O、DISK、NETWORK）关联起来</p></li></ul><p>功能上的监控偏向于网络、数据库、节点资源</p><h1 id="服务调度"><a href="#服务调度" class="headerlink" title="服务调度"></a>服务调度</h1><h2 id="服务关键程度、服务依赖关系"><a href="#服务关键程度、服务依赖关系" class="headerlink" title="服务关键程度、服务依赖关系"></a>服务关键程度、服务依赖关系</h2><p>  关于服务关键程度，主要是要我们梳理和定义服务的重要程度。这不是使用技术可以完成的，它需要细致地管理对业务的理解，才能定义出架构中各个服务的重要程度。</p><p>  依赖关系就像“铁锁连环”一样，一个服务的问题很容易引起一条链上的问题。传统的 SOA 希望通过 ESB 来解决服务间的依赖关系，微服务中希望服务间是没有依赖的，而让上层或是前端业务来整合这些个后台服务。</p><p>  解决服务依赖的方案一般是，依赖颠倒的设计模式，其实就是接口在架构端的实现。</p><p>  服务依赖的发现也是用的服务调用链跟踪技术，Zipkin</p><h2 id="服务发现和生命周期管理"><a href="#服务发现和生命周期管理" class="headerlink" title="服务发现和生命周期管理"></a>服务发现和生命周期管理</h2><p>   还需要有一个服务发现的中间件。因为这个“架构城市”是非常动态的，有的服务会新加进来，有的会离开，有的会增加更多的实例，有的会减少，有的服务在维护过程中（发布、伸缩等），所以我们需要有一个服务注册中心，来知道，整个系统中服务的种类、各种类的实例数、版本如何，每个服务的状态。</p><p>   服务的状态（生命周期）包括：</p><ul><li>Provision，代表在供应一个新的服务</li><li>Ready，启动成功</li><li>Run，正在运行</li><li>Update，升级中</li><li>Rollback，回滚中</li><li>Scale，伸缩中</li><li>Destroy，销毁中</li><li>Failed，失败</li></ul><h2 id="整个架构的版本控制"><a href="#整个架构的版本控制" class="headerlink" title="整个架构的版本控制"></a>整个架构的版本控制</h2><h2 id="服务状态的维持与拟合"><a href="#服务状态的维持与拟合" class="headerlink" title="服务状态的维持与拟合"></a>服务状态的维持与拟合</h2><p>这里的服务状态指的的服务的运行状态（status），也就是上文中的状态，本质上，维持服务从一个状态到另一个状态，从套路上看，可以分成2种：</p><ul><li><p>正常的scale</p><p>扩展集群，发布新版本等，流程：</p><ul><li>先扩展出几个结点；</li><li>再往上部署服务；</li><li>然后启动服务；</li><li>再检查服务的健康情况；</li><li>最后把新扩展出来的服务实例加入服务发现中提供服务。</li></ul><p>如果是替代原有的版本，需要慢慢的把流量切换过来</p></li><li><p>故障迁移<br>与scale差别很小</p><ul><li>服务的健康监控</li><li>自动重启服务或者自动重新部署服务  </li></ul></li></ul><h2 id="服务工作流和编排"><a href="#服务工作流和编排" class="headerlink" title="服务工作流和编排"></a>服务工作流和编排</h2><p>关于服务的编排会直接导致一个服务编排的工作流引擎中间件的产生。通过工作流引擎，可以非常快速地将若干个服务编排起来形成一个业务流程。（借鉴AWS 上的 Simple Workflow 服务）</p><p>我理解的意思，是服务本身并不包含业务的流程，只提供低耦合下的单一服务，业务的流程交由工作流引擎来做。负责控制先访问哪个，后访问哪个服务来完成一个业务。</p><h1 id="流量调度"><a href="#流量调度" class="headerlink" title="流量调度"></a>流量调度</h1><ul><li><p>目标：</p><p>依据系统运行的情况，自动地进行流量调度，在无需人工干预的情况下，提升整个系统的稳定性；<br>让系统应对爆品等突发事件时，在弹性计算扩缩容的较长时间窗口内或底层资源消耗殆尽的情况下，保护系统平稳运行。</p></li><li><p>要求：</p><p><strong>高性能</strong>。API Gateway 必须使用高性能的技术，所以，也就需要使用高性能的语言。</p><p><strong>集群化</strong>。要能扛流量，就需要使用集群技术。集群技术的关键点是在集群内的各个结点中共享数据。这就需要使用像 Paxos、Raft、Gossip 这样的通讯协议。因为 Gateway 需要部署在广域网上，所以还需要集群的分组技术。</p><p><strong>业务逻辑</strong>。API Gateway 需要有简单的业务逻辑，所以，最好是像 AWS 的 Lambda 服务一样，可以让人注入不同语言的简单业务逻辑。像是nginx中的openresty</p></li></ul><p>PS：状态数据调度部分后面的章节设计的更多，像是编程范式中，以及有状态服务章节，这里暂时先不总结。</p><h1 id="总结Paas平台"><a href="#总结Paas平台" class="headerlink" title="总结Paas平台"></a>总结Paas平台</h1><ul><li><p>本质<br>服务化的能力供应：服务化的能力应该是指的上文的服务调度，软件模块重用，服务治理<br>分布式多层的系统架构：多租户隔离、高可用、服务编排<br>自动化的运维能力：自动化伸缩</p></li><li><p>paas平台的总体架构</p><p><img src="paas服务.png" alt="paas服务"><br>这个与之前的微服务架构是大同小异的。在杨波那里，paas调度层是paas层，paas服务能力层的中间件服务是支撑服务，在其上是微服务，也就是saas，这里增加了数据服务与业务服务。<br>网关层基本类似</p></li><li><p>paas平台的生产与运维</p><p><img src="生产与运维.png" alt="生产与运维"></p><p>左上是开发流程，右下是监控，中间是服务调度</p></li></ul><h1 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h1><ul><li><p>CAP定理<br>Consistency（一致性）：每次读取要么获得最近写入的数据，要么获得一个错误。<br>Avaliable(可用性)：每次请求都能获得一个（非错误）响应，但不保证返回的是最新写入的数据。<br>Partition tolerance(分区容忍)：尽管任意数量的消息被节点间的网络丢失（或延迟），系统仍继续运行。</p><p>CA：这样的系统关注一致性和可用性，它需要非常严格的全体一致的协议，比如“两阶段提交”（2PC）。CA 系统不能容忍网络错误或节点错误，一旦出现这样的问题，整个系统就会拒绝写请求，因为它并不知道对面的那个结点是否挂掉了，还是只是网络问题。唯一安全的做法就是把自己变成只读的。</p><p>CP：这样的系统关注一致性和分区容忍性。它关注的是系统里大多数人的一致性协议，比如：Paxos 算法（Quorum 类的算法）。这样的系统只需要保证大多数结点数据一致，而少数的结点会在没有同步到最新版本的数据时变成不可用的状态。这样能够提供一部分的可用性。</p><p>AP：这样的系统关心可用性和分区容忍性。因此，这样的系统不能达成一致性，需要给出数据冲突，给出数据冲突就需要维护数据版本。Gossip 就是这样的系统。</p><p><img src="CAP.png" alt="CAP"></p></li><li><p>分布式系统的8个误区</p><p> <a href="http://www.rgoarchitects.com/Files/fallacies.pdf" target="_blank" rel="noopener">Fallacies of Distributed Computing</a></p></li><li><p>分布式工程师的分布式理论</p><p> <a href="https://www.the-paper-trail.org/post/2014-08-09-distributed-systems-theory-for-the-distributed-systems-engineer/" target="_blank" rel="noopener">Distributed systems theory for the distributed systems engineer</a></p></li><li><p>Paxos算法</p><p> <a href="http://harry.me/blog/2014/12/27/neat-algorithms-paxos/" target="_blank" rel="noopener">NEAT ALGORITHMS - PAXOS</a></p><p> <a href="https://angus.nyc/2012/paxos-by-example/" target="_blank" rel="noopener">Paxos By Example</a></p><p> <a href="https://static.googleusercontent.com/media/research.google.com/en//archive/paxos_made_live.pdf" target="_blank" rel="noopener">paxos_made_live</a></p></li><li><p>Raft算法</p><p> <a href="https://raft.github.io/raft.pdf" target="_blank" rel="noopener">In search of an Understandable Consensus Algorithm (Extended Version)</a></p></li><li><p>Gossip协议</p><p><a href="https://www.cs.cornell.edu/home/rvr/papers/flowgossip.pdf" target="_blank" rel="noopener">gossip</a><br><a href="https://rrmoelker.github.io/gossip-visualization/" target="_blank" rel="noopener">gossip visualization</a></p></li><li><p>Aurora分布式数据库<br><a href="https://www.allthingsdistributed.com/files/p1041-verbitski.pdf" target="_blank" rel="noopener">aurota</a></p></li><li><p>Spanner分布式数据库<br><a href="http://static.googleusercontent.com/media/research.google.com/zh-CN//archive/spanner-osdi2012.pdf" target="_blank" rel="noopener">spanner</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文总结《左耳听风》分布式系统部分内容，为了帮助理解其中逻辑、加深记忆，也为了能时常的复习。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>kth最大元素</title>
    <link href="http://yoursite.com/2019/04/04/kth%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2019/04/04/kth最大元素/</id>
    <published>2019-04-04T05:57:09.000Z</published>
    <updated>2019-04-09T01:43:59.866Z</updated>
    
    <content type="html"><![CDATA[<p>本题是 Leecode的 215.Kth Largest Element in an Array<br><a id="more"></a></p><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p><p>Example 1:</p><p>Input: [3,2,1,5,6,4] and k = 2<br>Output: 5<br>Example 2:</p><p>Input: [3,2,3,1,2,4,5,5,6] and k = 4<br>Output: 4<br>Note:<br>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>本题，想到了2种可行方式：</p><ol><li>用排序算法，对数组进行排序，然后返回地k-1个元素即可，既然是训练分治，这里可以使用归并排序的方式。</li><li>设计一个k大小的窗口，然后从数组上滑过，每个元素与这k个元素比较，根据大小做处理。类似于插入排序的方式。<br>本题准备实现一下1方式</li></ol><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sortedNums = sort(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> sortedNums[k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mergeNums;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(low == high)&#123;</span><br><span class="line">            mergeNums.push_back(nums[low]);</span><br><span class="line">            <span class="keyword">return</span> mergeNums;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> middle = (low + high)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lnums = sort(nums, low, middle);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hnums = sort(nums, middle+<span class="number">1</span>, high);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&lt;lnums.size() &amp;&amp; j&lt;hnums.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(lnums[i] &gt;= hnums[j])&#123;</span><br><span class="line">                mergeNums.push_back(lnums[i++]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mergeNums.push_back(hnums[j++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&lt;lnums.size())&#123;</span><br><span class="line">            mergeNums.push_back(lnums[i++]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(j&lt;hnums.size())&#123;</span><br><span class="line">            mergeNums.push_back(hnums[j++]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mergeNums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上边2种做法，1中对所有的数组进行了排序，2中对k个元素进行了排序，不是直接去找Kth，应该能直接找子数组与kth之间的关系来直接分治。想了一种k分的方式，取最大，然后再取这k个值的最小，但是错误的;还有2分各取k应该，排序然后取第K，也是一种做法，但受K的影响，如果K &gt; length/2，还需要作转换，衰减也并不明显。<br>暂时并未想到可行的直接分治的方法</p><p>google了一下结果，发现有用快排方式的，有用二分方式的，复杂度都是nlog(n)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本题是 Leecode的 215.Kth Largest Element in an Array&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vscode下md导pdf</title>
    <link href="http://yoursite.com/2019/04/04/vscode%E4%B8%8Bmd%E5%AF%BCpdf/"/>
    <id>http://yoursite.com/2019/04/04/vscode下md导pdf/</id>
    <published>2019-04-04T02:47:46.000Z</published>
    <updated>2019-04-04T03:17:19.548Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下通过vscode转md导成pdf的方法</p><a id="more"></a><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>用md写文档已经渐渐成为习惯，尤其可以通过hexo，直接发布成博客。<br>造成的问题呢，很多文档并不是博客，比如会议纪要、工作的一些记录，写成md分享给非技术人员看，并不太合适，尤其有图片的时候，于是就想用md转成pdf。</p><h1 id="Markdown-Pdf插件安装"><a href="#Markdown-Pdf插件安装" class="headerlink" title="Markdown Pdf插件安装"></a>Markdown Pdf插件安装</h1><p>从扩展中安装Markdown Pdf</p><p><img src="插件.png" alt="插件"></p><p>安装成功后，可以在md文件中右键看到如下菜单</p><p><img src="右键.png" alt="右键"></p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>看到很多介绍，说到这里就可以直接点击导出就能成功，但在我机器上并没有成功。</p><p>点击后，发现没有任何反应，最初以为是导出的目录可能不对，搜索了一下，发现可以通过<code>markdown-pdf.outputDirectory</code>的方式来配置导出的目录，于是进行了设置，发现还是没反应</p><p>我注意到每次启动时，vscode坐下脚的提示中，总在install chromium，于是就有数了，这个Markdown Pdf其实是调用了chromium的接口来完成转换的。也是就看一下这个插件的配置。如下</p><p><img src="ExecutablePath.png" alt="ExecutablePath"></p><p>由于本机上有chromium浏览器，就<code>whereis chromium-browser</code>，然后在进行了配置，在settings.json中增加：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"markdown-pdf.executablePath": "/usr/bin/chromium-browser"</span><br></pre></td></tr></table></figure><p>重试，导出成功。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下通过vscode转md导成pdf的方法&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>
