<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>思 见</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-28T06:43:05.853Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>sun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微积分-无穷级数</title>
    <link href="http://yoursite.com/2019/09/28/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/"/>
    <id>http://yoursite.com/2019/09/28/微积分-无穷级数/</id>
    <published>2019-09-28T06:41:25.000Z</published>
    <updated>2019-09-28T06:43:05.853Z</updated>
    
    <content type="html"><![CDATA[<p>本文是微积分复习的第一篇，教材使用《普林斯顿微积分读本》，涵盖第15章-第21章的内容。  </p><ul><li>函数与微分  </li><li>积分      </li><li>级数      &lt;=</li><li>其他</li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是微积分复习的第一篇，教材使用《普林斯顿微积分读本》，涵盖第15章-第21章的内容。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数与微分  &lt;/li&gt;
&lt;li&gt;积分      &lt;/li&gt;
&lt;li&gt;级数      &amp;lt;=&lt;/li&gt;
&lt;li&gt;其他&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>微积分-积分</title>
    <link href="http://yoursite.com/2019/09/06/%E5%BE%AE%E7%A7%AF%E5%88%86-%E7%A7%AF%E5%88%86/"/>
    <id>http://yoursite.com/2019/09/06/微积分-积分/</id>
    <published>2019-09-06T13:36:30.000Z</published>
    <updated>2019-09-16T00:24:40.232Z</updated>
    
    <content type="html"><![CDATA[<p>本文是微积分复习的第一篇，教材使用《普林斯顿微积分读本》，涵盖第15章-第21章的内容。  </p><ul><li>函数与微分  </li><li>积分       &lt;=</li><li>级数</li><li>其他</li></ul><a id="more"></a><h1 id="积分定义"><a href="#积分定义" class="headerlink" title="积分定义"></a>积分定义</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>积分是从级数求和引入的，比如第一例子：<br><img src="级数求和.png" alt="级数求和.png"><br>这种引入方式即暗示积分的求（有向）面积，求位移做铺垫，也为后边级数做准备。</p><h2 id="伸缩级数"><a href="#伸缩级数" class="headerlink" title="伸缩级数"></a>伸缩级数</h2><p>比较有趣的一个例子:<br><img src="伸缩级数.png" alt="伸缩级数.png"><br>书中用伸缩级数的方法，推导出了平方和级数的和公式：<br><img src="伸缩级数推动-1.png" alt="伸缩级数推动-1.png"><br>将等式左侧整理后得到<br><img src="伸缩级数推动-2.png" alt="伸缩级数推动-2.png"><br><img src="伸缩级数推动-3.png" alt="伸缩级数推动-3.png">  </p><h2 id="有向面积"><a href="#有向面积" class="headerlink" title="有向面积"></a>有向面积</h2><p>这一段主要从直观上看级数到积分的一个过度<br><img src="有向面积.png" alt="有向面积.png"><br><img src="有向面积-2.png" alt="有向面积-2.png">  </p><h1 id="定积分"><a href="#定积分" class="headerlink" title="定积分"></a>定积分</h1><h2 id="定积分定义（黎曼和）"><a href="#定积分定义（黎曼和）" class="headerlink" title="定积分定义（黎曼和）"></a>定积分定义（黎曼和）</h2><p>定积分是一种定义，是一种求某段[a,b]曲线y=f(x)，与X轴形成闭合图形的面积。可以看出，定积分面向的是一个具体的问题，然后再次抽象之后才出现了不定积分。  </p><p>这个图形面积的求法，就需要借鉴上一节有向面积。将上一节的公式区间长度趋向于0,就是这个图像的面积，也就是积分。<br><img src="黎曼和.png" alt="黎曼和.png"><br>上一节的求和部分，也别称作黎曼和。<br>积分的定义也离不开极限。这里发散一下，这个叫黎曼和，也就与黎曼有关，而黎曼是19世纪人物，微积分是17世纪创立的，也就是这个定义，是很久之后才确定的。</p><h2 id="定积分性质"><a href="#定积分性质" class="headerlink" title="定积分性质"></a>定积分性质</h2><p>有了定义，就有了几个简单的性质：  </p><ol><li><img src="定积分性质-1.png" alt="定积分性质-1.png">  </li><li><img src="定积分性质-2.png" alt="定积分性质-2.png"></li><li><img src="定积分性质-3.png" alt="定积分性质-3.png"></li><li><img src="定积分性质-4.png" alt="定积分性质-4.png"></li><li><img src="定积分性质-5.png" alt="定积分性质-5.png"></li></ol><p>对这几个性质只说一点：在矩阵中，我们说线性变换符合两个公式：<br>T(v+w) = T(v) + T(w); T(cv) = cT(v)。如果把f(x)看作v，g(x)看作w，那积分就可以看作成一种线性变换了。  </p><h2 id="估算积分"><a href="#估算积分" class="headerlink" title="估算积分"></a>估算积分</h2><p>积分既然可以看作成一种面积，面积就有大小之分<br><img src="积分的简单估算.png" alt="积分的简单估算.png"><br>这样就看出，积分是在[m(b-a), M(b-a)]之间</p><h2 id="积分中值定理"><a href="#积分中值定理" class="headerlink" title="积分中值定理"></a>积分中值定理</h2><p>有了最大值与最小值，也就想到平均值。<br><img src="积分中值定理.png" alt="积分中值定理.png"><br><img src="积分中值定理2.png" alt="积分中值定理2.png"><br>f(c)就可以看作是f(x)在区间[a,b]上的平均值。  </p><h1 id="微积分基本定理"><a href="#微积分基本定理" class="headerlink" title="微积分基本定理"></a>微积分基本定理</h1><p>注意，这里说的是微积分基本定理，将积分与微分联合到一起的定理。主要有2个基本定理，一个阐述积分与微分之间的关系，从这里引出了不定积分，另一是积分函数与被积函数的关系，从而引出了不定积分的计算方法。</p><h2 id="第一基本定理"><a href="#第一基本定理" class="headerlink" title="第一基本定理"></a>第一基本定理</h2><p><img src="微积分第一基本定理.png" alt="微积分第一基本定理.png"><br>这里看出，微积分基本定理是与定积分相关的定理，也就是包含积分的上下限，以后的很多文章都是在上下限中做的。  </p><p>其证明源自:<br><img src="微积分第一定理的证明.png" alt="微积分第一定理的证明.png"><br><img src="微积分第一定理的证明2.png" alt="微积分第一定理的证明2.png">  </p><p>对比不定积分与导数：<br><img src="不定积分.png" alt="不定积分.png">  </p><h2 id="第二基本定理"><a href="#第二基本定理" class="headerlink" title="第二基本定理"></a>第二基本定理</h2><p><img src="微积分第二基本定理.png" alt="微积分第二基本定理.png"><br>微积分第二基本定理的证明书中没有画图，画图的话会很简单，就是阴影部分面积的减法运算。  </p><p>证明:<br><img src="微积分第二定理证明.png" alt="微积分第二定理证明.png"><br>函数到a部分的面积是F(a)，函数到b部分的面积是F(b)，那[a,b]之间的面积自然就是F(b)-F(a)了。</p><h2 id="积分上下限是函数"><a href="#积分上下限是函数" class="headerlink" title="积分上下限是函数"></a>积分上下限是函数</h2><p>积分上限是函数：  </p><p>这句话说全了是这样：求积分式的导数，如果积分上限是函数。解题时，其实是将上限设成另外一个变量，然后再隐函数求导。如：</p><p><img src="积分上限是函数.png" alt="积分上限是函数.png"><br><img src="积分上限是函数2.png" alt="积分上限是函数2.png"><br>这里需要注意，dy/du中积出的函数变量是u，后边要用x替换掉。  </p><p>积分下限是函数与上限是函数相同，做一个相反数即可转换成，这里不做介绍</p><ul><li>积分与导数公式  </li></ul><p><img src="积分公式.png" alt="积分公式.png"></p><h1 id="微积分基本方法1"><a href="#微积分基本方法1" class="headerlink" title="微积分基本方法1"></a>微积分基本方法1</h1><h2 id="换元法"><a href="#换元法" class="headerlink" title="换元法"></a>换元法</h2><ul><li><p>示例1</p><p><img src="换元法示例1-1.png" alt="换元法示例1-1.png"><br>这里设t = x<sup>3</sup>，将t导入得<br> (1/3)sin(x<sup>3</sup>) + C</p></li><li><p>示例2<br><img src="换元法示例2.png" alt="换元法示例2.png"><br>这里设t = x<sup>3</sup> + 7x - 9<br>从示例2看出的公式是这样：<br><img src="换元法公式1.png" alt="换元法公式1.png">  </p></li><li><p>示例3<br><img src="换元法示例3.png" alt="换元法示例3.png">  </p></li><li><p>示例4<br><img src="换元法示例4.png" alt="换元法示例4.png"><br> 这里的t = e<sup>x</sup>  </p></li><li><p>示例5<br> <img src="换元法示例5-1.png" alt="换元法示例5-1.png"><br> 这个与上边的例子有很大不同，这个需要一次函数的根式形式，需要将t设置成这个根式。<br> <img src="换元法示例5-2.png" alt="换元法示例5-2.png">  </p></li><li><p>理论解释<br><img src="换元法理论解释.png" alt="换元法理论解释.png"><br>这个解释其实只解释了前4个示例，第5个示例并不在此之列</p></li></ul><h2 id="分部积分法"><a href="#分部积分法" class="headerlink" title="分部积分法"></a>分部积分法</h2><ul><li><p>公式<br><img src="分部积分法公式.png" alt="分部积分法公式.png">  </p><p>分部积分法跟贝叶斯公式有点相似</p></li><li><p>示例1<br><img src="分部积分法示例1.png" alt="分部积分法示例1.png">  </p><p>多项式与指数函数</p></li><li><p>示例2<br><img src="分部积分法示例2.png" alt="分部积分法示例2.png"><br> 然后以相同德办法处理等式右边第二项</p><p>多项式与三角函数</p></li><li><p>示例3<br><img src="分部积分法示例3.png" alt="分部积分法示例3.png"><br> 利用三角函数两次求解后便会原值的特点</p><p>三角函数与指数函数  </p></li><li><p>示例4<br>以上三种都是两种基本初等函数的组合方式，e<sup>x</sup> &gt; sin(x) &gt; x 这种顺序<br>以下这些则反之，可以认为它们比 x 还小  </p><p><img src="分部积分法示例4-1.png" alt="分部积分法示例4-1.png"><br><img src="分部积分法示例4-2.png" alt="分部积分法示例4-2.png">  </p></li></ul><h2 id="部分积分法"><a href="#部分积分法" class="headerlink" title="部分积分法"></a>部分积分法</h2><p>部分积分法是处理，有理函数(两个多项式函数的比值)的方法. 通过一些代数运算把它分解成几个更简单的有理函数和的形式, 然后再对真写简单的有理函数求积分.  </p><ul><li><p>步骤  </p><ol><li>要确保分母的次幂大于分子的次幂,否则,通过除法方式,转换成此形式</li><li>对分母做因式分解<br>对于二次函数,查看判别式,若大于0,则可以因式分解</li><li><p>分部<br>分部是将因式分解之后的乘积形式,变成和形式的过程<br><img src="分部积分法1.png" alt="分部积分法1.png"><br><img src="分部积分法2.png" alt="分部积分法2.png"><br>这有些像基向量的样子,在每个基向量的常数倍.</p></li><li><p>计算常量的值</p></li><li>求解分母为线性项次幂的积分</li><li>对分母是二次函数的被积函数求积分</li></ol></li><li><p>示例1:<br><img src="分部积分法3.png" alt="分部积分法3.png">  </p></li><li><p>示例2:<br><img src="部分积分法示例2.png" alt="部分积分法示例2.png"></p></li><li><p>示例3:<br><img src="部分积分法示例3.png" alt="部分积分法示例3.png"><br>再次将进行分部,第一部分用换元法, 第二部分借用<img src="部分积分公式.png" alt="部分积分公式.png">来计算<br><img src="部分积分法示例3-2.png" alt="部分积分法示例3-2.png">  </p></li></ul><h1 id="微积分基本方法2"><a href="#微积分基本方法2" class="headerlink" title="微积分基本方法2"></a>微积分基本方法2</h1><h2 id="三角恒等式的积分"><a href="#三角恒等式的积分" class="headerlink" title="三角恒等式的积分"></a>三角恒等式的积分</h2><p>通过几个三角恒等式进行变化,将不易求的积分转变成易求的积分.恒等式包括:</p><ol><li>倍角公式: <img src="倍角公式.png" alt="倍角公式.png">  </li><li>毕达哥拉斯恒等式: <img src="毕达哥拉斯恒等式.png" alt="毕达哥拉斯恒等式.png">  </li><li>和差公式: <img src="和差公式.png" alt="和差公式.png">  </li></ol><p>这一部分的示例太多了,而且没有统一的解法,只做几个示例:  </p><ul><li><p>示例1<br><img src="三角恒等式示例1-1.png" alt="三角恒等式示例1-1.png"><br>给sec(x)上次幂,转换成2次进行<br><img src="三角恒等式示例1-2.png" alt="三角恒等式示例1-2.png"><br><img src="三角恒等式示例1-3.png" alt="三角恒等式示例1-3.png">  </p></li><li><p>示例2<br><img src="三角恒等式示例2.png" alt="三角恒等式示例2.png">  </p></li></ul><h2 id="三角函数的幂积分"><a href="#三角函数的幂积分" class="headerlink" title="三角函数的幂积分"></a>三角函数的幂积分</h2><p>三角函数的幂积分,很繁琐.不同的三角函数,技巧不相同.</p><ul><li><p>sinx或者cosx<br>如果是奇数次幂,则可以将一个奇数取出,转变积分<br>如果是偶数次幂,则使用倍角公式,将次幂转变成倍角</p></li><li><p>tan(x)<br>1次幂的tan(x),转换成sinx / cosx 的形式来计算<br>偶次幂的tan(x)求导很有趣,使用tan(x)与secx之间的关系,能不断的降幂,每次将2幂来完成</p></li><li><p>sec(x)<br>1次幂的secx求导很有技巧,(sec(x) + tan(x))/(sex(x) + tan(x))相乘之后,一下便可求出<br>偶次幂的sec(x),与偶次幂的tan(x)求法类似,但更复杂一些,不管的降幂,直到求出.</p></li><li><p>其他<br>cot(x) 同 tan(x), csc(x) 同 sec(x)</p></li><li><p>示例1<br><img src="三角函数幂积分示例1.png" alt="三角函数幂积分示例1.png"><br>将cos(x),转变成sin(x),然后将单独的cosx 放进积分中即可.</p></li><li><p>示例2<br><img src="三角函数幂积分示例2.png" alt="三角函数幂积分示例2.png"><br>将等式右侧展看,多变成多项式形式,偶次幂继续升角,奇次幂利用换元法求解</p></li><li><p>示例3<br><img src="tanx的积分.png" alt="tanx的积分.png">  </p></li><li><p>示例4<br><img src="tanx的2次幂积分.png" alt="tanx的2次幂积分.png">  </p></li><li><p>示例5<br><img src="tanx的4次幂积分.png" alt="tanx的4次幂积分.png">  </p></li><li><p>示例6<br><img src="secx的积分.png" alt="secx的积分.png"><br>sec(x)的二次幂积分为tan(x)+c  </p></li><li><p>示例7<br><img src="secx的6次幂积分1.png" alt="secx的6次幂积分1.png"><br><img src="secx的6次幂积分2.png" alt="secx的6次幂积分2.png"><br><img src="secx的6次幂积分3.png" alt="secx的6次幂积分3.png"><br>这里采用了分部积分法,并且只用来降成4次幂. 4次幂的过程仍然要继续采用此方法.  </p></li><li><p>总结  </p></li></ul><p>tan(x)与sex(x)的偶次幂,都是采用了类似数学归纳法的方式,不断降维来求解</p><h2 id="三角换元法"><a href="#三角换元法" class="headerlink" title="三角换元法"></a>三角换元法</h2><p>三角换元法不再求解的是三角函数,而是利用三角函数的特点来求解根式的积分.  </p><p><img src="三角换元法.png" alt="三角换元法.png"><br>进行换元之后,脱离根式,然后进行求解.  </p><ul><li><p>示例1<br><img src="三角换元法示例1.png" alt="三角换元法示例1.png"><br>用x = 3sin(θ)来进行换元<br><img src="三角换元法示例2.png" alt="三角换元法示例2.png">  </p></li><li><p>示例2<br><img src="三角换元法示例3.png" alt="三角换元法示例3.png"><br><img src="三角换元法示例3-1.png" alt="三角换元法示例3-1.png">  </p></li></ul><h1 id="反常积分"><a href="#反常积分" class="headerlink" title="反常积分"></a>反常积分</h1><p>反常积分要么在函数定义域内存在垂直渐进线,要么区间趋向无穷的定积分.这两种积分都涉及用极限来求积分的基本方法.在这种基本方法之上,演化出了常用的3中通用判别方法:比较判别法,极限比较判别法,p判别法,一种不太通用的判别法:绝对值判别法.这些判别法用于判断反常积分是否存在,或者称收敛.<br>原文中以2章的在讲述反常积分,其中,一章讲理论,一章讲示例.这里仅用一章将理论,不在积分花费更多的时间了.  </p><h2 id="2个定义"><a href="#2个定义" class="headerlink" title="2个定义"></a>2个定义</h2><p><img src="反常积分定义1.png" alt="反常积分定义1.png"><br>这是在下界的定义,在上界的定义同理  </p><p><img src="反常积分定义2.png" alt="反常积分定义2.png"><br>区间无穷的定义</p><h2 id="比较判别法"><a href="#比较判别法" class="headerlink" title="比较判别法"></a>比较判别法</h2><p>比较判别法可以从积分的面积定义上找到源头.  </p><p><img src="比较判别法表达式.png" alt="比较判别法表达式.png"><br><img src="比较判别法图像.png" alt="比较判别法图像.png"><br>如图,如果g(x)在区间[a,b]上收敛,则f(x)也一定收敛. 反命题不成立<br>逆反命题是如果f(x)在区间[a,b]上发散,则g(x)也一定发散.  </p><h2 id="极限比较判别法"><a href="#极限比较判别法" class="headerlink" title="极限比较判别法"></a>极限比较判别法</h2><p><img src="极限比较判别法.png" alt="极限比较判别法.png"><br>这个有同样的意义应该理解为:有相同的收敛性. 同收敛,共发散.</p><p>如: 在x -&gt; 0时, tan(x) ~ x, sin(x) ~ x, e<sup>x</sup>-1 ~x</p><h2 id="p判别法"><a href="#p判别法" class="headerlink" title="p判别法"></a>p判别法</h2><p>p判别法,应该是最接近运用的判别法<br><img src="p判别法.png" alt="p判别法.png"><br><img src="p判别法图像.png" alt="p判别法图像.png">  </p><p>记忆的方法是,与y=x相比, 更接近x轴霍y轴的收敛,反之发散</p><h2 id="绝对值判别法"><a href="#绝对值判别法" class="headerlink" title="绝对值判别法"></a>绝对值判别法</h2><p><img src="绝对收敛判别法.png" alt="绝对收敛判别法.png"><br>其他的判别法即可判别发散,也可以判别收敛.绝对值判别法,只能用来判别收敛.<br>在应用上,比较适合使用在sin(x)的判别上,即sin(x) &lt;= |sin(x)| &lt;= 1</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是微积分复习的第一篇，教材使用《普林斯顿微积分读本》，涵盖第15章-第21章的内容。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数与微分  &lt;/li&gt;
&lt;li&gt;积分       &amp;lt;=&lt;/li&gt;
&lt;li&gt;级数&lt;/li&gt;
&lt;li&gt;其他&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="理论" scheme="http://yoursite.com/categories/%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="微积分" scheme="http://yoursite.com/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>微积分-函数与微分</title>
    <link href="http://yoursite.com/2019/08/08/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%87%BD%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/"/>
    <id>http://yoursite.com/2019/08/08/微积分-函数与微分/</id>
    <published>2019-08-08T13:11:43.000Z</published>
    <updated>2019-08-20T06:44:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是微积分复习的第一篇，教材使用《普林斯顿微积分读本》，涵盖第1章-第14章的内容。 </p><ul><li>函数与微分  &lt;=</li><li>积分</li><li>级数</li><li>其他</li></ul><a id="more"></a><h1 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>函数是将一个对象转化成另外一个对象的规则。起始的对象称为输入，来自称为定义域的集合。返回的对象称为输出，来自称为值域的集合。<br>一个函数必须给每一有效的输入制定唯一的输出。</p><h2 id="定义域"><a href="#定义域" class="headerlink" title="定义域"></a>定义域</h2><p>定义据包括实数集尽可能多的部分，几种常见的情况：</p><ol><li>分母不能为0</li><li>不能取一个负数的平方根</li><li>不能取一个负数或0的对数</li></ol><h2 id="反函数"><a href="#反函数" class="headerlink" title="反函数"></a>反函数</h2><p>数据中有很多对称，例如有了函数就有反函数。<br>给定一个实数 y, 那么在 f 定义域中的哪个x满足 f(x) = y ？<br>变换 f<sup>-1</sup> 就像是 f 的撤销按钮: 如果你从 x 出发,并通过函数 f 将它变换为 y, 那么你可以通过在 y 上的反函数 f<sup>-1</sup> 来撤销这个变换的效果,取回 x<br><img src="反函数图像.png" alt="反函数图像"><br>图像关于y=x对称</p><h2 id="奇偶性"><a href="#奇偶性" class="headerlink" title="奇偶性"></a>奇偶性</h2><p>偶函数：f(x) = f(-x)，图像关于y轴具有镜面对称性。<br>奇函数：f(x) = -f(-x)， 图像关于原点有对称性。</p><h2 id="常见函数的图像"><a href="#常见函数的图像" class="headerlink" title="常见函数的图像"></a>常见函数的图像</h2><ul><li><p>多项式  p(x) = a<sub>n</sub>x<sup>n</sup> + a<sub>n-1</sub>x<sup>n-1</sup> + a<sub>1</sub>x<sup>1</sup> + a<sub>0</sub></p><p><img src="多项式函数图像.png" alt="多项式函数图像"><br>一般多项式函数图像很难画，但其左右两段的走势倒是很容易判断。主要是由首项系数决定的。  </p><p><img src="多项式函数走向.png" alt="多项式函数走向"></p></li><li><p>有理函数  p(x) / q(x)<br><img src="有理函数图像.png" alt="有理函数图像"></p></li><li><p>指数函数图像<br><img src="指数函数图像.png" alt="指数函数图像">  </p></li><li><p>对数函数图像<br><img src="对数函数图像.png" alt="对数函数图像">  </p></li><li><p>其他<br>绝对值函数，正值不变，负值关于x周对称<br>开方函数，将多项式关于镜像对称  </p></li></ul><h1 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h1><h2 id="x-a处的极限"><a href="#x-a处的极限" class="headerlink" title="x=a处的极限"></a>x=a处的极限</h2><p>从函数图像上，从左侧往右接近a时，就得到左极限; 反之从右往左接近是，就得到右极限。<br>当左极限等于右极限时，就称为双侧极限; 极限一般是指的双侧极限  </p><p>f(x)在x = a处有一条垂直渐进线，则在a处的左极限和右极限，至少有一个是∞或−∞。</p><p>左右极限不存在的例子：f(x) = sin(1/x)，在x=0,不存在左右极限。</p><p><img src="左右极限不存在.png" alt="左右极限不存在"></p><h2 id="在∞与-∞处的极限"><a href="#在∞与-∞处的极限" class="headerlink" title="在∞与-∞处的极限"></a>在∞与-∞处的极限</h2><p>当x-&gt;∞ f(x)有固定值，则函数有水平渐进线。</p><p><img src="导数与sin的结合.png" alt="导数与sin的结合"></p><p>函数与其渐进线可能会相交。</p><h2 id="三明治定理"><a href="#三明治定理" class="headerlink" title="三明治定理"></a>三明治定理</h2><p><img src="三明治定理.png" alt="三明治定理"><br><img src="三明治定理示例.png" alt="三明治定理示例"></p><h2 id="求解多项式的极限问题"><a href="#求解多项式的极限问题" class="headerlink" title="求解多项式的极限问题"></a>求解多项式的极限问题</h2><ul><li>x-&gt; a 有理函数,有理函数求解注意通分</li><li>x-&gt; a 平方根函数，注意乘共轭表达式</li><li>x-&gt; ∞ 有理函数，取决于首项及其系数</li><li>x-&gt; -∞ 时，若有函数需要开方时，注意取负数</li></ul><h1 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h1><p>连续性, 直观上,连续函数的图像必须能一笔画成;<br>可导性, 直观上,在可导函数的图像中不会出现尖角。</p><h2 id="连续性"><a href="#连续性" class="headerlink" title="连续性"></a>连续性</h2><ul><li><p>定义<br>如果在x=a处的极限 = f(x), 则在x=a处连续。<br>这个定义中包括：在x=a处有双侧极限，并且在x=a处有定义，或者f(a)存在，他们相等。</p></li><li><p>区间连续定义<br>f(x)在[a,b]区间上连续，在区间每一点都连续，且两个端点的单侧极限存在。</p></li><li><p>介值定理<br>如果f(x) 在[a,b]上连续，并且f(a)f(b)&lt;0，则在区间(a,b)上至少有一点c，使得f(c) = 0存在。</p></li><li><p>最值定理<br>如果f(x) 在[a,b]上连续，则在[a,b]上至少有一个最大值和一个最小值。</p></li></ul><h2 id="可导性"><a href="#可导性" class="headerlink" title="可导性"></a>可导性</h2><ul><li><p>定义<br><img src="可导性-切线斜率.png" alt="可导性-切线斜率.png">  </p><p><img src="可导性-表达式.png" alt="可导性-表达式.png"></p><p><img src="导数微分.png" alt="导数微分.png">.<br>后来有dx表示x中十分微笑的彪悍，dy表示y中十分微笑的变化。dy就是微分。</p></li><li><p>不存在导数的情况<br>双侧的导数不相同，直观上，就是有尖角。</p></li><li><p>如果一个函数f在x上可导，则它在x上连续。</p></li></ul><h2 id="求导法则"><a href="#求导法则" class="headerlink" title="求导法则"></a>求导法则</h2><ul><li><p>乘法法则<br><img src="求导-乘法法则.png" alt="求导-乘法法则.png"></p><p><img src="乘法法则的直观展示.png" alt="乘法法则的直观展示.png"><br>两个变量相乘直观的展示是图中矩形的面积，长与宽都是x的函数，当x有一个小变化∆x,时，面积S如何变化。<br>∆S = ∆(uv) = v∆u + u∆v + (∆u)(∆v)。 其中(∆u)(∆v)是更高阶的无穷小，可以忽略。</p></li><li><p>除法法则<br><img src="求导-商法则.png" alt="求导-商法则.png"></p></li><li><p>链式法则<br><img src="链式求导法则.png" alt="链式求导法则.png"><br>以 y=f(u) u=g(x) 为例：<br>∆y = f’(u)∆u<br>∆u = g’(x)∆x</p><p>代入 ∆y = f’(u)g’(x)∆x<br>由此  ∆y/∆x = f’(u)g’(x)</p></li><li><p>常见应用<br>几何：切线<br>物理：加速度<br>代数：导数伪装的极限  </p><p><img src="通过导数求极限-1.png" alt="通过导数求极限-1.png"></p></li></ul><h1 id="函数的导数"><a href="#函数的导数" class="headerlink" title="函数的导数"></a>函数的导数</h1><h2 id="多项式函数"><a href="#多项式函数" class="headerlink" title="多项式函数"></a>多项式函数</h2><p><img src="多项式求导.png" alt="多项式求导.png"></p><h2 id="三角函数的极限与导数"><a href="#三角函数的极限与导数" class="headerlink" title="三角函数的极限与导数"></a>三角函数的极限与导数</h2><ul><li><p>极限<br><img src="sinx与x.png" alt="sinx与x.png">  </p><p><img src="sinx与x的极限.png" alt="sinx与x的极限.png"><br><img src="tanx的0极限.png" alt="tanx的0极限.png"></p><p>x可以换成其他函数代入与x<sup>2</sup> 、5x等</p><p><img src="x、sinx、tanx极限的直观解释.png" alt="x、sinx、tanx极限的直观解释.png"><br>扇形面积= x/2，内三角形面积= sin(x)/2, 外三角形面积= tan(x)/2， 当x趋近0时，它们相等。<br>变换：1 &gt; sin(x)/x &gt; cos(x)，利用三明治定理，可以得到结论。</p><p><img src="sinx除以x图像.png" alt="sinx除以x图像.png"><br><strong>小波函数</strong></p></li><li><p>导数  </p><p> sin’(x) = cos(x)<br> cos’(x) = -sin(x)  </p><p> tan’(x) = sec<sup>2</sup>(x)<br> cot’(x) = -csc<sup>2</sup>(x)  </p><p> sec’(x) = sec(x)tan(x)<br> csc’(x) = -csc(x)cot(x)</p><p> 记忆：正的导数都是正好，余的导数都是负数</p></li><li><p>一个有趣的函数</p><p>f(x) = x<sup>2</sup>sin(1/x)</p><p>根据求导公式，其在0处导数不存在</p><p><img src="导函数不连续.png" alt="导函数不连续.png"><br>这样改之后，用导数定义，发现其在0处f’(0) = 0，但它同样不连续。</p><p><img src="导函数不连续图像.png" alt="导函数不连续图像.png">  </p></li><li><p>小结<br>本节的sin(x)/x函数，是一个很漂亮的函数。貌似在小波中见过。<br>关于最后这个f(x) = x<sup>2</sup>sin(1/x)。导函数在0处存在，但却不连续。这种情况基本都出在sin(1/x)这种情况内，倒数使趋向无穷大变成了趋向无穷小。</p></li></ul><h2 id="指数函数与对数函数"><a href="#指数函数与对数函数" class="headerlink" title="指数函数与对数函数"></a>指数函数与对数函数</h2><ul><li><p>对数基础<br>log<sub>b</sub>(1) = 0  </p><p>log<sub>b</sub>(xy) = log<sub>b</sub>(x) + log<sub>b</sub>(y)<br>log是可以将乘法变成加法的运算。  </p><p>log<sub>b</sub>(x/y) = log<sub>b</sub>(x) - log<sub>b</sub>(y)  </p><p>log<sub>b</sub>(x<sup>y</sup>) = ylog<sub>b</sub>(x)<br>对数可以处理指数与对数都是函数的情况。  </p><p>log<sub>b</sub>(x) =   log<sub>c</sub>(x) /  log<sub>c</sub>(b)<br>这意味着，所有不同底数的对数，其实都互为常数倍。 log<sub>b</sub>(x) =  Klog<sub>c</sub>(x) K=1/log<sub>c</sub>(b)</p></li><li><p>e的定义<br>e一种由来，可以从计算复利而得来：当年利率一定，每年结算的的次数越多，最终的金额也就越多。当次数取向无穷时，其最终金额不会趋向无穷，而是一个常数。  </p><p><img src="e.png" alt="e.png"><br><img src="e2.png" alt="e2.png">  </p></li><li><p>导数<br>介绍e的定义，主要用于计算对数的导数。<br><img src="对数导数.png" alt="对数导数.png"><br><img src="自然对数导数.png" alt="自然对数导数.png">  </p><p>根据反函数求导<br><img src="指数函数导数.png" alt="指数函数导数.png"><br><img src="指数函数导数2.png" alt="指数函数导数2.png">  </p></li><li><p>极限<br><img src="指数与多项式极限.png" alt="指数与多项式极限.png"><br><img src="对数与多项式.png" alt="对数与多项式.png">  </p></li><li><p>取对数求导法<br>y = x<sup>sin(x)</sup><br>=&gt; ln(y) = sin(x)ln(x)<br>=&gt; <img src="取对求导-1.png" alt="取对求导-1.png"><br>=&gt; <img src="取对求导-2.png" alt="取对求导-2.png"><br>=&gt; <img src="取对求导-3.png" alt="取对求导-3.png">  </p></li><li><p>指数增长与指数衰减  </p><p><img src="微分方程.png" alt="微分方程.png"><br>y变化率取决于这个量的大小。当k是正数就是指数增长，负数就是指数衰减。  </p><p>指数增长就是指的： P(t) = P<sub>0</sub>e<sup>kt</sup><br>这时候, dP/dt = kP<br>常见例子是无限条件下，兔子的增长。  </p><p>指数衰减：P(t) = P<sub>0</sub>e<sup>-kt</sup><br>dP/dt = -kP<br>常见例子是放射性原子的衰减。</p></li><li><p>双曲函数<br>![双曲函数.png])(双曲函数.png)<br><img src="双曲函数图像.png" alt="双曲函数图像.png">  </p><p>双曲函数有些像三角函数：</p><ol><li>cosh<sup>2</sup> - sinh<sup>2</sup> = 1</li><li>d(sinh(x))/dx = cosh(x) 及 d(cosh(x))/dx = sinh(x)  </li></ol><p><a href="https://www.zhihu.com/question/21239693" target="_blank" rel="noopener">双曲函数产生</a>  </p></li><li><p>小结：<br>从对称性上，我们可以看到初等函数可以分成很多空间，多项式函数、三角函数、指对函数。他们在很多时候，都在自己空间内玩。比如求导运算，多项式求导之后还是多项式，三角函数求导也还是三角函数。但对数函数却打破了这种规律，它的求导变成了有理函数，这真有趣。  </p><p>另一个是e，从定义上，就可以看到e是多么神奇的一个数字。</p></li></ul><h2 id="隐函数导数"><a href="#隐函数导数" class="headerlink" title="隐函数导数"></a>隐函数导数</h2><p>隐函数求导，比较适合于求等式的导数。</p><ul><li><p>示例<br>x<sup>2</sup> + y<sup>2</sup> = 4  </p><p>2x + 2y dy/dx = 0<br>dy/dx = -x/y  </p></li></ul><p>等式求导，一般关注于特定点，在特定点时，可以将等式求导之后，立即代入点，然后整理。对于二阶导，要等到求导2次之后再代入。</p><p>应用场景：求某个时刻的变化率问题，思路：<br>1、列出等式<br>2、等式求导  </p><h2 id="反函数导数"><a href="#反函数导数" class="headerlink" title="反函数导数"></a>反函数导数</h2><ul><li><p>导数与反函数存在<br>在区间内单调则反函数存在，单调意味着: f’(x)&gt;=0,或者f’(x)&lt;=0,且等于0的点有限。</p></li><li><p>公式<br><img src="反函数求导.png" alt="反函数求导.png"><br><img src="反函数求导-2.png" alt="反函数求导-2.png"><br> 把反函数表示出来，然后再代入原函数的导数，并求其倒数</p></li><li><p>示例<br>h(x) = x<sup>3</sup><br>h’(x) = 3x<sup>2</sup><br>反函数： y=x <sup>1/3</sup>  </p><p>代入可得反函数的导数 1/(3x<sup>2/3</sup>) </p></li></ul><h1 id="导数与图像"><a href="#导数与图像" class="headerlink" title="导数与图像"></a>导数与图像</h1><ul><li><p>函数的极值<br>假设函数 f 定义在开区间 (a, b) 内,并且点 c 在 (a, b) 区间内.如果点 c 为函数的局部最大值或最小值,那么点 c 一定为该函数的临界点.也就是说,f’(c) = 0 或 f’(c) 不存在  </p><p>闭区间[a,b]的最值，求f’(x) = 0的点，再加两个端点进行比较。</p></li><li><p>罗尔定理<br>假设函数 f 在闭区间[a, b]内连续,在开区间(a, b)内可导.如果 f(a) = f(b），那么在开区间 (a, b) 内至少存在一点 c, 使得 f‘(c) = 0.</p><p>也就是一定有极值点。</p></li><li><p>中值定理<br>假设函数 f 在闭区间[a, b]内连续,在开区间(a, b)内可导,那么在开区间(a, b)内至少有一点 c 使得：<br><img src="中值定理.png" alt="中值定理.png"><br><img src="中值定理图像.png" alt="中值定理图像.png"><br>可以看出，罗尔定理是中值定理的特例。  </p></li><li><p>二阶导数  </p><p>二级导数&gt;0时，图像像是一个凹向上的，像是碗的一部分;二阶导书&lt;0时，图像是凹向下的，像是倒着的碗。<br>拐点：在c点两侧，二阶导符号相异，则为拐点。<br><img src="拐点图像.png" alt="拐点图像.png"><br>这个感激挺有趣，经常听房价拐点、经济拐点，感觉像是在说极值点。这里的拐点却不是。<br>拐点处f’’(c) = 0，但反过来并不成立，比如f(x) = x<sup>4</sup>  </p></li></ul><h1 id="导数的应用"><a href="#导数的应用" class="headerlink" title="导数的应用"></a>导数的应用</h1><p>最优化涉及找出各种可能情况中最好的一种；<br>线性化是一种对难以计算的量找出其估算值的有用技术</p><h2 id="最优化"><a href="#最优化" class="headerlink" title="最优化"></a>最优化</h2><ol><li>找到变量  </li><li>找出等式  </li><li>消元  </li><li>求最值，可能用到隐函数求导  </li></ol><p>书上给出3个实例，这里不多介绍了  </p><h2 id="线性化"><a href="#线性化" class="headerlink" title="线性化"></a>线性化</h2><p>线性化其实是用直线（一阶函数）来拟合原函数（曲线），以求解问题。<br>f(a+∆x) ≈ f(a) + f’(a)∆x.<br><img src="线性化图像.png" alt="线性化图像.png">  </p><p>微分： 其中量df = f’(a)∆x，称为f在 x=a 处的微分。<br>误差： r(x) = f(x) - L(x)<br>      r(x) = f‘’(c)(x − a)<sup>2</sup> , 其中 c 为在 x 和 a 之间的某个数  </p><p>示例：  </p><ol><li>估算 (6.01)<sup>2</sup><br>f’(x) = 2x<br>df = f’(a)∆x = f’(6)(0.01) = 12 × (0.01) = 0.12<br>(6.01)<sup>2</sup> ≈ 36.12</li></ol><h2 id="估算零点的牛顿法"><a href="#估算零点的牛顿法" class="headerlink" title="估算零点的牛顿法"></a>估算零点的牛顿法</h2><p>牛顿法求0值，是线性化的一个应用  </p><p>假设现在要解一个形为 f (x) = 0 的方程,但你死活都解不出来.所以你退而求其次,试着猜测该方程有一个解,并把它记为 a. </p><p><img src="牛顿法图像.png" alt="牛顿法图像.png"><br><img src="牛顿法.png" alt="牛顿法.png">  </p><p>失效的情况：  </p><ul><li><p>f‘(a) 的值接近于 0.<br> <img src="牛顿法失效-1.png" alt="牛顿法失效-1.png">  </p></li><li><p>近似可能越来越糟<br> f (x) = x<sup>1/3</sup>，唯一解是 0 ，<br> 代入公式：b = -2a，除非从0开始，否则越来越糟糕  </p></li><li><p>可能限于左右循环<br> <img src="牛顿法失效-3.png" alt="牛顿法失效-3.png">  </p></li></ul><h2 id="洛必答法则"><a href="#洛必答法则" class="headerlink" title="洛必答法则"></a>洛必答法则</h2><p>洛必答法则本身容易记住，重点是使用时的变形，要点是是对不定式使用<br>除法情况：<br><img src="洛必达法则-1.png" alt="洛必达法则-1.png">  </p><p>除法=乘法，只须将一种一个变成倒数即可  </p><p>减法情况，需要将减法进行通分，变成除法  </p><p>指数情况，需要进行取对数，将指数编程乘法</p><p>示例：<br><img src="洛必答法则示例-1.png" alt="洛必答法则示例-1.png"><br><img src="洛必答法则示例-2.png" alt="洛必答法则示例-2.png"><br><img src="洛必答法则示例-3.png" alt="洛必答法则示例-3.png"><br><img src="洛必答法则示例-4.png" alt="洛必答法则示例-4.png">  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是微积分复习的第一篇，教材使用《普林斯顿微积分读本》，涵盖第1章-第14章的内容。 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数与微分  &amp;lt;=&lt;/li&gt;
&lt;li&gt;积分&lt;/li&gt;
&lt;li&gt;级数&lt;/li&gt;
&lt;li&gt;其他&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="理论" scheme="http://yoursite.com/categories/%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="微积分" scheme="http://yoursite.com/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>typeorm使用总结</title>
    <link href="http://yoursite.com/2019/07/11/typeorm%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/07/11/typeorm使用总结/</id>
    <published>2019-07-11T14:23:08.000Z</published>
    <updated>2019-07-15T00:17:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>总结一下typeorm常用的使用方法  </p><a id="more"></a><h1 id="entity"><a href="#entity" class="headerlink" title="entity"></a>entity</h1><h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><p>typeorm中，每个entity必须有主键</p><ul><li><p>普通主键</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Entity()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">TunnelPart</span></span>&#123;</span><br><span class="line">  @PrimaryGeneratedColumn()</span><br><span class="line">  id: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>uuid主键  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Entity()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseFileEntity</span> </span>&#123;</span><br><span class="line">  @PrimaryGeneratedColumn(<span class="string">"uuid"</span>)</span><br><span class="line">  id: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的主键，就是uuid  </p></li><li><p>多列主键  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Entity()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">StructureTeam</span> </span>&#123;</span><br><span class="line">    @PrimaryColumn(&#123; <span class="attr">type</span>: <span class="string">'int'</span> &#125;)</span><br><span class="line">    teamId: number;</span><br><span class="line"></span><br><span class="line">    @PrimaryColumn(&#123; <span class="attr">type</span>: <span class="string">'int'</span> &#125;)</span><br><span class="line">    structureId: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，就形成了一个有多列形成的主键  </p></li></ul><h2 id="ManyToOne与oneToMany"><a href="#ManyToOne与oneToMany" class="headerlink" title="ManyToOne与oneToMany"></a>ManyToOne与oneToMany</h2><p>ManyToOne 与 oneToMany是最常用的关系，两者可同时使用，ManyToOne可以单独使用，基本操作，如：保存、查询、级联删除等，放到后边下边来写，这里只写关系的建立  </p><h2 id="只建立ManyToOne"><a href="#只建立ManyToOne" class="headerlink" title="只建立ManyToOne"></a>只建立ManyToOne</h2>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Entity()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">TunnelSection</span></span>&#123;</span><br><span class="line">    @PrimaryGeneratedColumn()</span><br><span class="line">    id: number;</span><br><span class="line"></span><br><span class="line">    @Column(<span class="string">'int'</span>)</span><br><span class="line">    length: number;</span><br><span class="line"></span><br><span class="line">    @ManyToOne(<span class="function"><span class="params">type</span>=&gt;</span>TunnelMethod)</span><br><span class="line">    method: TunnelMethod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在ManyToOne的创建中，只提用一个参数即可，这个参数是一个箭头函数，指向One所对应的表<br>  关系在建立的时候，可以指明一些参数，比如OnDetete,当用<code>CASCADE</code>时，可以用作级联删除。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@ManyToOne(<span class="function"><span class="params">type</span>=&gt;</span>TunnelMethod, &#123; <span class="attr">onDelete</span>: <span class="string">'CASCADE'</span> &#125;)</span><br><span class="line">    method: TunnelMethod;</span><br></pre></td></tr></table></figure><h2 id="同时建立ManyToOne-与-OneToMany"><a href="#同时建立ManyToOne-与-OneToMany" class="headerlink" title="同时建立ManyToOne 与 OneToMany"></a>同时建立ManyToOne 与 OneToMany</h2>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Entity()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">TunnelFixture</span></span>&#123;</span><br><span class="line">    @PrimaryGeneratedColumn()</span><br><span class="line">    id: number;</span><br><span class="line"></span><br><span class="line">    @Column(<span class="string">'varchar'</span>, &#123;<span class="attr">length</span>: <span class="number">128</span>&#125;)</span><br><span class="line">    name: string;</span><br><span class="line"></span><br><span class="line">    @OneToMany(<span class="function"><span class="params">type</span> =&gt;</span> TunnelProcedure, procedure =&gt; procedure.fixture)</span><br><span class="line">    procedures: TunnelProcedure[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Entity()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">TunnelProcedure</span></span>&#123;</span><br><span class="line">    @PrimaryGeneratedColumn()</span><br><span class="line">    id: number;</span><br><span class="line"></span><br><span class="line">    @Column(<span class="string">"varchar"</span>, &#123;<span class="attr">length</span>: <span class="number">128</span>&#125;)</span><br><span class="line">    name: string;</span><br><span class="line"></span><br><span class="line">    @ManyToOne(<span class="function"><span class="params">type</span> =&gt;</span> TunnelFixture, fixture =&gt; fixture.procedures)</span><br><span class="line">    fixture: TunnelFixture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在建立双向关系时，除了指明所在的entity，还要指明对方entity的属性</p><h1 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h1><h2 id="relation查询"><a href="#relation查询" class="headerlink" title="relation查询"></a>relation查询</h2><p>  创建ManyToOne与OneToMany的关系以后，可以通过repository来查询</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Entity()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Photo</span> </span>&#123;</span><br><span class="line">    @PrimaryGeneratedColumn()</span><br><span class="line">    id: number;</span><br><span class="line"></span><br><span class="line">    @Column()</span><br><span class="line">    url: string;</span><br><span class="line"></span><br><span class="line">    @ManyToOne(<span class="function"><span class="params">type</span> =&gt;</span> User, user =&gt; user.photos)</span><br><span class="line">    user: User;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Entity()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    @PrimaryGeneratedColumn()</span><br><span class="line">    id: number;</span><br><span class="line"></span><br><span class="line">    @Column()</span><br><span class="line">    name: string;</span><br><span class="line"></span><br><span class="line">    @OneToMany(<span class="function"><span class="params">type</span> =&gt;</span> Photo, photo =&gt; photo.user)</span><br><span class="line">    photos: Photo[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userRepository = connection.getRepository(User);</span><br><span class="line"><span class="keyword">const</span> users = <span class="keyword">await</span> userRepository.find(&#123; <span class="attr">relations</span>: [<span class="string">"photos"</span>] &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> photoRepository = connection.getRepository(Photo);</span><br><span class="line"><span class="keyword">const</span> photos = <span class="keyword">await</span> photoRepository.find(&#123; <span class="attr">relations</span>: [<span class="string">"user"</span>] &#125;);</span><br></pre></td></tr></table></figure><h2 id="也可以用createQueryBuilder形式"><a href="#也可以用createQueryBuilder形式" class="headerlink" title="也可以用createQueryBuilder形式"></a>也可以用createQueryBuilder形式</h2>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> users = <span class="keyword">await</span> connection</span><br><span class="line">  .getRepository(User)</span><br><span class="line">  .createQueryBuilder(<span class="string">"user"</span>)</span><br><span class="line">  .leftJoinAndSelect(<span class="string">"user.photos"</span>, <span class="string">"photo"</span>)</span><br><span class="line">  .getMany();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> photos = <span class="keyword">await</span> connection</span><br><span class="line">  .getRepository(Photo)</span><br><span class="line">  .createQueryBuilder(<span class="string">"photo"</span>)</span><br><span class="line">  .leftJoinAndSelect(<span class="string">"photo.user"</span>, <span class="string">"user"</span>)</span><br><span class="line">  .getMany();</span><br></pre></td></tr></table></figure><p>  一直觉得relations只在findOne中，可用，看了官网，发现都可以。<br>  有些情况下，都是自己创建id字段来连接另外一个表使用，这种情况下，只能使用createQueryBuilder，查询出来的是地卡尔乘积的结果，有些情况下，需要经过去重处理。<br>  这里要注意<code>leftJoinAndSelect</code>与<code>leftJoin</code>的区别。leftJoin不会查询出join表的字段</p><h2 id="Raw查询"><a href="#Raw查询" class="headerlink" title="Raw查询"></a>Raw查询</h2><p>  getRawMany()时，注意给列起别名，否则列名包括了表名。查询的数据不是entity时，采用raw方式查询。包括联表的自定义字段、SUM、COUNT等函数</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">async</span> getMaterialList(subprojId:number, type?:string):<span class="built_in">Promise</span>&lt;Material[]&gt;&#123;</span><br><span class="line">      <span class="keyword">let</span> param = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">      param.subprojId = subprojId;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> condition = <span class="string">"material.subprojId=:subprojId "</span></span><br><span class="line">      <span class="keyword">if</span>(!isNullOrUndefined(type))&#123;</span><br><span class="line">          param.type = type</span><br><span class="line">          condition += <span class="string">" and material.type=:type"</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.materialRepos.createQueryBuilder(<span class="string">"material"</span>)</span><br><span class="line">              .select(<span class="string">"material.id"</span>, <span class="string">"id"</span>)</span><br><span class="line">              .addSelect(<span class="string">"material.type"</span>, <span class="string">"type"</span>)</span><br><span class="line">              .addSelect(<span class="string">"material.name"</span>, <span class="string">"name"</span>)</span><br><span class="line">              .addSelect(<span class="string">"material.unit"</span>, <span class="string">"unit"</span>)</span><br><span class="line">              .addSelect(<span class="string">"material.metaQuantityId"</span>, <span class="string">"metaQuantityId"</span>)</span><br><span class="line">              .addSelect(<span class="string">"material.subprojId"</span>, <span class="string">"subprojId"</span>)</span><br><span class="line">              .addSelect(<span class="string">"material.createAt"</span>, <span class="string">"createAt"</span>)</span><br><span class="line">              .addSelect(<span class="string">'materialPrice.price'</span>, <span class="string">"price"</span>)</span><br><span class="line">              .leftJoin(<span class="string">"material.price"</span>, <span class="string">"materialPrice"</span>)</span><br><span class="line">              .where(condition, param)</span><br><span class="line">              .getRawMany();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  注意join都是迪卡尔积，会有重复。<br>  OneToOne关系比较适合，不会用重复</p><h1 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h1><h2 id="LessThan、MoreThan、Between"><a href="#LessThan、MoreThan、Between" class="headerlink" title="LessThan、MoreThan、Between"></a>LessThan、MoreThan、Between</h2><p>  这里在repository中查询时，使用了以上区间函数;<br>  同样可以使用createQueryBuilder的当时完成相同的操作。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">async</span> getMaterialPriceList(materialId:number, startDate?:string, endDate?:string)&#123;</span><br><span class="line">  <span class="keyword">let</span> condition = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  condition.materialId = materialId;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(startDate!=<span class="literal">null</span> &amp;&amp; endDate==<span class="literal">null</span>)&#123;</span><br><span class="line">      condition.createAt =  MoreThan(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.parse(startDate)));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(startDate==<span class="literal">null</span> &amp;&amp; endDate!=<span class="literal">null</span>)&#123;</span><br><span class="line">      condition.createAt =  LessThan(<span class="keyword">new</span> <span class="built_in">Date</span>(endDate));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(startDate!=<span class="literal">null</span> &amp;&amp; endDate!=<span class="literal">null</span>)&#123;</span><br><span class="line">      condition.createAt = Between(<span class="keyword">new</span> <span class="built_in">Date</span>(startDate), <span class="keyword">new</span> <span class="built_in">Date</span>(endDate));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.priceRepos.find(&#123;...condition&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用createQueryBuilder完成区间查询："><a href="#用createQueryBuilder完成区间查询：" class="headerlink" title="用createQueryBuilder完成区间查询："></a>用createQueryBuilder完成区间查询：</h2>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">async</span> getMaterialPriceList(materialId:number, startDate?:string, endDate?:string)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.priceRepos.createQueryBuilder(<span class="string">"materialPice"</span>)</span><br><span class="line">          .where(<span class="string">'materialPice.materialId = :materialId'</span>)</span><br><span class="line">          .andWhere(<span class="string">'materialPice.createAt &gt;= :startDate'</span>)</span><br><span class="line">          .andWhere(<span class="string">'materialPice.createAt &lt;= :endDate'</span>)</span><br><span class="line">          .setParameters(&#123;<span class="attr">materialId</span>:materialId, <span class="attr">startDate</span>:<span class="keyword">new</span> <span class="built_in">Date</span>(startDate),<span class="attr">endDate</span>:<span class="keyword">new</span> <span class="built_in">Date</span>(endDate)&#125;)</span><br><span class="line">          .getMany();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h1><p>同样是使用skip与take来完成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> users = <span class="keyword">await</span> getRepository(User)</span><br><span class="line">    .createQueryBuilder(<span class="string">"user"</span>)</span><br><span class="line">    .leftJoinAndSelect(<span class="string">"user.photos"</span>, <span class="string">"photo"</span>)</span><br><span class="line">    .skip(<span class="number">5</span>)</span><br><span class="line">    .take(<span class="number">10</span>)</span><br><span class="line">    .getMany();</span><br></pre></td></tr></table></figure><h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><p>子查询是两个查询的嵌套，通常发生在where与from中</p><h2 id="where中"><a href="#where中" class="headerlink" title="where中"></a>where中</h2>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> posts = <span class="keyword">await</span> connection.getRepository(Post)</span><br><span class="line">  .createQueryBuilder(<span class="string">"post"</span>)</span><br><span class="line">  .where(<span class="function"><span class="params">qb</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> subQuery = qb.subQuery()</span><br><span class="line">          .select(<span class="string">"user.name"</span>)</span><br><span class="line">          .from(User, <span class="string">"user"</span>)</span><br><span class="line">          .where(<span class="string">"user.registered = :registered"</span>)</span><br><span class="line">          .getQuery();</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"post.title IN "</span> + subQuery;</span><br><span class="line">  &#125;)</span><br><span class="line">  .setParameter(<span class="string">"registered"</span>, <span class="literal">true</span>)</span><br><span class="line">  .getMany();</span><br></pre></td></tr></table></figure><p>  或者写成</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userQb = <span class="keyword">await</span> connection.getRepository(User)</span><br><span class="line">  .createQueryBuilder(<span class="string">"user"</span>)</span><br><span class="line">  .select(<span class="string">"user.name"</span>)</span><br><span class="line">  .where(<span class="string">"user.registered = :registered"</span>, &#123; <span class="attr">registered</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> posts = <span class="keyword">await</span> connection.getRepository(Post)</span><br><span class="line">  .createQueryBuilder(<span class="string">"post"</span>)</span><br><span class="line">  .where(<span class="string">"post.title IN ("</span> + userQb.getQuery() + <span class="string">")"</span>)</span><br><span class="line">  .setParameters(userQb.getParameters())</span><br><span class="line">  .getMany();</span><br></pre></td></tr></table></figure><h2 id="from中"><a href="#from中" class="headerlink" title="from中"></a>from中</h2>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> posts = <span class="keyword">await</span> connection</span><br><span class="line">  .createQueryBuilder()</span><br><span class="line">  .select(<span class="string">"user.name"</span>, <span class="string">"name"</span>)</span><br><span class="line">  .from(<span class="function"><span class="params">subQuery</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> subQuery</span><br><span class="line">          .select(<span class="string">"user.name"</span>, <span class="string">"name"</span>)</span><br><span class="line">          .from(User, <span class="string">"user"</span>)</span><br><span class="line">          .where(<span class="string">"user.registered = :registered"</span>, &#123; <span class="attr">registered</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">  &#125;, <span class="string">"user"</span>)</span><br><span class="line">  .getRawMany();</span><br></pre></td></tr></table></figure><p>  from中的“user“是别名，或者写成</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userQb = <span class="keyword">await</span> connection.getRepository(User)</span><br><span class="line">  .createQueryBuilder(<span class="string">"user"</span>)</span><br><span class="line">  .select(<span class="string">"user.name"</span>, <span class="string">"name"</span>)</span><br><span class="line">  .where(<span class="string">"user.registered = :registered"</span>, &#123; <span class="attr">registered</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> posts = <span class="keyword">await</span> connection</span><br><span class="line">  .createQueryBuilder()</span><br><span class="line">  .select(<span class="string">"user.name"</span>, <span class="string">"name"</span>)</span><br><span class="line">  .from(<span class="string">"("</span> + userQb.getQuery() + <span class="string">")"</span>, <span class="string">"user"</span>)</span><br><span class="line">  .setParameters(userQb.getParameters())</span><br><span class="line">  .getRawMany();</span><br></pre></td></tr></table></figure><h1 id="全列查询"><a href="#全列查询" class="headerlink" title="全列查询"></a>全列查询</h1><p>全表查询指的是对全部字段进行模糊查询，网上找资料看到一些方式，通过引入插件，再用函数的方式来实现，这样的实现在typeorm中很难实现。  </p><ul><li><p>列少时，可以考虑多列的模糊</p><p><code>select * from t where phonenum=&#39;digoal&#39; or info ~ &#39;digoal&#39; or c1=&#39;digoal&#39;</code>  </p></li><li><p>将所有字段记录在1列中，从一列中查询</p></li><li><p>pgsql中使用::text<br><code>select * from structure where structure::text like %大河%</code></p></li></ul><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;getManager&#125; <span class="keyword">from</span> <span class="string">"typeorm"</span>;</span><br><span class="line"><span class="keyword">await</span> getManager().transaction(<span class="keyword">async</span> transactionalEntityManager =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> transactionalEntityManager.save(users);</span><br><span class="line">    <span class="keyword">await</span> transactionalEntityManager.save(photos);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>事物可以使用装饰器方式来书写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Transaction()</span><br><span class="line">save(@TransactionManager() manager: EntityManager, <span class="attr">user</span>: User) &#123;</span><br><span class="line">    <span class="keyword">return</span> manager.save(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Transaction()</span><br><span class="line">save(user: User, @TransactionRepository(User) userRepository: Repository&lt;User&gt;) &#123;</span><br><span class="line">    <span class="keyword">return</span> userRepository.save(user);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在事务中指明隔离级别</p><h1 id="migration"><a href="#migration" class="headerlink" title="migration"></a>migration</h1><ul><li>需要注意其ormconfig.json配置文件的书写</li><li>其原理是通过检测migration中的文件，来执行文件，并且在数据库中创建一个migrations的数据表，用来存储执行过的文件。在执行的时候，会对比文件夹中的文件与数据库执行过的文件，并选择new的进行执行。</li><li>这种方式需要看一个revert如果执行。</li><li>migration其实是一种命令模式。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结一下typeorm常用的使用方法  &lt;/p&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
      <category term="nest.js" scheme="http://yoursite.com/tags/nest-js/"/>
    
  </entry>
  
  <entry>
    <title>hexo迁移记录</title>
    <link href="http://yoursite.com/2019/06/22/hexo%E8%BF%81%E7%A7%BB%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/06/22/hexo迁移记录/</id>
    <published>2019-06-22T14:44:25.000Z</published>
    <updated>2019-09-28T04:00:44.770Z</updated>
    
    <content type="html"><![CDATA[<p>本次在家里机器上迁移hexo成功，对这次迁移做一点记录。</p><a id="more"></a><p>hexo需要2个库，一个github page用来做网页，另一个库用来存md。网上一般的方式是建立一个github page库，用2个分支来存放，我自己的做法是将网站放在github page下，然后创建了一个gitlab库放md。</p><ul><li><p>配置ssh<br>详见ssh与git配置两篇博客<br>这里由于2个帐号，注意.ssh/config的配置</p></li><li><p>clone库<br>从gitlab下将库clone下来</p></li><li><p>安装hexo[3.9.0]<br>装机部分已经安装了git、node.js，这里只安装hexo即可。<br>参照：<a href="https://www.zhihu.com/question/21193762" target="_blank" rel="noopener">hexo换电脑更新</a><br>需要在blog下执行：  </p><ul><li>npm install hexo  </li><li>npm install  </li><li>npm install hexo-deployer-git  </li></ul><p>这样并不能直接使用hexo，我又在global范围内安装了一边hexo  </p><ul><li>npm install hexo -g  </li><li>npm install hexo-cli -g  </li><li>npm install hexo-deployer-git -g</li></ul><p>这样感觉多安装了一边，但确实可以了，只安装global范围内时，在blog下不能执行hexo g</p></li><li><p>_config.yml配置修改  </p><pre><code class="yml"><span class="attr">deploy:</span><span class="attr">  type:</span> <span class="string">git</span><span class="attr">  repo:</span> <span class="string">git@github.com:xxx/xxx.github.io.git</span><span class="attr">  branch:</span> <span class="string">master</span><span class="attr">  name:</span> <span class="string">xxxx</span><span class="attr">  email:</span> <span class="string">xxxx@xxx.xx</span></code></pre><p>这次修改其中的user =&gt; name</p></li><li><p>遗留<br>hexo d时，曾出现过HEAD不对应，但重新安装了global的hexo问题解决，github page的git同步并没有研究，但最终完成了同步，像是hexo内部自己做了封装。  </p></li><li><p>推荐<br>搜索过程中发现一篇比价全的hexo搭建博客<a href="https://thief.one/2017/03/03/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">Hexo搭建博客教程</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本次在家里机器上迁移hexo成功，对这次迁移做一点记录。&lt;/p&gt;
    
    </summary>
    
      <category term="工具与运维" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E4%B8%8E%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu装机后</title>
    <link href="http://yoursite.com/2019/06/16/%E8%A3%85%E6%9C%BA%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/06/16/装机记录/</id>
    <published>2019-06-16T13:18:04.000Z</published>
    <updated>2019-07-01T02:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>本次装机，话费了大半天的时间，ubuntu装机出现几次启动问题，后边的软件安装也颇费功夫。写一下本次的装机记录，以后可以考虑写成脚本来自动完成装机。</p><a id="more"></a><h1 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h1><ul><li><p><a href="https://zhuanlan.zhihu.com/p/59393289" target="_blank" rel="noopener">UEFI+GPT 与 BIOS+MBR</a><br>启动方式是指如何主板上的固件在开机自检后如何找到引导程序，有Legacy模式（BIOS + MBR）和UEFI模式（UEFI _+ GPT）。大家注意这里的对应即可。 UEFI是15年之后才比较火的一种启动方式，电脑启动速度快是它的一大特点。所以15年后很多电脑都是采用这种方式。而之前的主板都是采用Lagacy的模式。需要硬件支持。</p></li><li><p><a href="https://blog.csdn.net/u014292358/article/details/70195932" target="_blank" rel="noopener">分区</a><br>由于本次重装，并没有手动分区，这个当选项了。</p></li></ul><h1 id="基础软件"><a href="#基础软件" class="headerlink" title="基础软件"></a>基础软件</h1><ul><li><p><a href="https://blog.csdn.net/happywho250/article/details/52506321" target="_blank" rel="noopener">换源</a>  </p></li><li><p><a href="https://jingyan.baidu.com/article/f79b7cb31a990d9144023ea2.html" target="_blank" rel="noopener">安装chrome</a><br>sudo apt-get install chromium-browser  </p></li><li><p><a href="https://blog.csdn.net/duxu24/article/details/52955785" target="_blank" rel="noopener">安装wps</a><br>sudo dpkg -i  </p></li><li><p><a href="https://zhuanlan.zhihu.com/p/37914770" target="_blank" rel="noopener">安装node</a><br><a href="https://nodejs.org/en/" target="_blank" rel="noopener">node下载</a><br>tar 之后 ln -s  </p></li><li><p><a href="https://code.visualstudio.com/Download" target="_blank" rel="noopener">安装vscode</a><br>sudo dpkg -i  </p></li><li><p>安装git<br>sudo apt-get install git  </p></li></ul><h1 id="gitlab"><a href="#gitlab" class="headerlink" title="gitlab"></a>gitlab</h1><ul><li><p><a href="https://sunyanfeng.cn/2019/01/09/ssh%E5%85%8D%E5%AF%86%E9%85%8D%E7%BD%AE/" target="_blank" rel="noopener">git免密</a>  </p></li><li><p>翻墙<br>从ubuntu软件中心中下载shadowsocks，下载snap的</p><p><a href="https://ea.36fy.com/clientarea.php" target="_blank" rel="noopener">加速度</a>  </p><p>chromium –proxy-server=”socks5://127.0.0.1:1080”</p></li></ul><h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt update</span><br><span class="line">$ sudo apt install -y \</span><br><span class="line">           apt-transport-https \</span><br><span class="line">           ca-certificates \</span><br><span class="line">           curl \</span><br><span class="line">           software-properties-common</span><br><span class="line">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line">$ sudo add-apt-repository \</span><br><span class="line">           <span class="string">"deb [arch=amd64] https://download.docker.com/linux/ubuntu <span class="variable">$(lsb_release -cs)</span> stable"</span></span><br><span class="line">$ sudo apt update</span><br><span class="line">$ sudo apt install -y docker-ce</span><br><span class="line">$ sudo usermod -a -G docker $(whoami)</span><br><span class="line">$ newgrp docker</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本次装机，话费了大半天的时间，ubuntu装机出现几次启动问题，后边的软件安装也颇费功夫。写一下本次的装机记录，以后可以考虑写成脚本来自动完成装机。&lt;/p&gt;
    
    </summary>
    
      <category term="工具与运维" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E4%B8%8E%E8%BF%90%E7%BB%B4/"/>
    
    
  </entry>
  
  <entry>
    <title>next.js弃坑总结</title>
    <link href="http://yoursite.com/2019/05/23/next%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/05/23/next实践总结/</id>
    <published>2019-05-23T02:30:00.000Z</published>
    <updated>2019-07-01T02:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>关键字：next.js</p><a id="more"></a><h1 id="next-js接触"><a href="#next-js接触" class="headerlink" title="next.js接触"></a>next.js接触</h1><p>接触next.js的过程在<a href>next.js记录</a>中已经说过了，主要是在自己搭建后台渲染过程中，使用了web-isomorphic-tools，而它官网中，推荐使用其进化版本universal-tools或者使用集成了universal-tools的next.js。而自己搭建的渲染，跳过了无数坑之后，渲染Materila-Ui组件时失败，况且不知道越过这坑后边是否还有坑，索性研究一下next.js.</p><p>next.js是一个后台渲染的MPA（多页面应用）</p><h1 id="next-js优点"><a href="#next-js优点" class="headerlink" title="next.js优点"></a>next.js优点</h1><ul><li><p>后台渲染做的不错<br>对Material-Ui支持不错</p></li><li><p>代码切割做的不错<br>本身是不过加载页面中不用的component，也可以手动进行动态加载，并支持prefetch(预取)的功能，提高加载的速度。</p></li><li><p>动态数据加载做的可以<br>由前端服务器向api server获取数据使用getInitPrepoty的方式不错</p></li></ul><h1 id="next-js缺点"><a href="#next-js缺点" class="headerlink" title="next.js缺点"></a>next.js缺点</h1><p>这里的缺点是针对我们应用的场景而言</p><ul><li><p>文件系统路由的方式不太适合<br>虽然它支持定制路由，但也仅是做了as，类似于一个别名，还需要服务侧做转换。<br>并且由于文件系统路由，使它内部仅支持用query方式(url?key=value)传参，若需要param方式(/:userId)，需要使用定制url。</p></li><li><p>对componet不太友好<br>在面临选择page还是componet时，next.js偏向与page。比如通过link导向一个page，然后在page进行一些操作之后，通过component切换的形式来做一些view的切换，这时候如果想再逆操作时，没法通过点击link的方式进行切换，只能自己控制。link发现地址没变，点击不会响应。  </p></li><li><p>传参问题<br>由于更多的页面，在传值问题上存在更多的挑战。使用react的component，可以愉快的使用向下流的传值，而页面只能在地址中增加一些id，然后在页面内部再次去获取数据，这样效率比较低一些。</p></li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>与同事讨论之后，我们觉得，next.js更适合向博客、新闻等使用场景，不太适合写数据交互多的场景，这样就准备弃用了。<br>如果非要用next.js来写的话，感觉可以将next.js做一个后端渲染的活，然后在next.js之上移植react-router，由MPA转换成SPA，这方面的资料在next.js github的issue中可以找到一点，有兴趣的朋友可以考虑一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关键字：next.js&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="next.js" scheme="http://yoursite.com/tags/next-js/"/>
    
  </entry>
  
  <entry>
    <title>同构SPA应用jwt实践</title>
    <link href="http://yoursite.com/2019/05/23/%E5%90%8C%E6%9E%84SPA%E5%BA%94%E7%94%A8jwt%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2019/05/23/同构SPA应用jwt实践/</id>
    <published>2019-05-23T01:30:00.000Z</published>
    <updated>2019-07-01T02:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>关键字：Isomorphic、SPA、Jwt</p><a id="more"></a><h1 id="Jwt简介"><a href="#Jwt简介" class="headerlink" title="Jwt简介"></a>Jwt简介</h1><p>先介绍一下Jwt:<a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener">Jwt简介</a></p><h1 id="3层过程"><a href="#3层过程" class="headerlink" title="3层过程"></a>3层过程</h1><ul><li>浏览器获取页面，前端服务器发现未登录，重定向到登录页面&lt;这个重定向由后端控制&gt;</li><li>录入用户、密码，发送给accout后端服务，验证信息，返回jwt给浏览器</li><li><p>登录成功，浏览器重定向到主页面，此时携带token&lt;这个重定向由浏览器控制&gt;</p></li><li><p>前端服务器接收到主页的请求，再次进行验证，发现已经登录，返回主页面</p></li><li>浏览器做前端渲染，向后台请求数据时，携带token。进行验证。</li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li><p>查资料说，token可以通过cookie来设置，也可以通过localStorage来设置<br>token通过Set-Cookie的方式发送给浏览器但一直没有设置成功，设置了domain、path、max-age<br><a href="http://bubkoo.com/2014/04/21/http-cookies-explained/" target="_blank" rel="noopener">cookie详解</a><br>后来通过浏览器调用document.cookie来进行设置</p></li><li><p>使用cookie设置的问题<br>token时间与cookie时间问题，token与cookie各有自己的过期时间，两个时间不一致会存在问题，不太喜欢2个源的东西。</p></li><li><p>使用localStorage的问题<br>存储在LocalStorag里的问题是，无法在向前端服务器请求页面的时候，自动携带这个token。</p></li><li><p>后端缓存token的问题<br>jwt本身设计就是stateless，如果加上缓存，就是一有状态的东西，与sessionId的使用一致。<br>需要用一些规则来包成token的安全</p></li></ul><h1 id="token安全规则"><a href="#token安全规则" class="headerlink" title="token安全规则"></a>token安全规则</h1><p>  <a href="https://stackoverflow.com/questions/30523238/best-practices-for-server-side-handling-of-jwt-tokens" target="_blank" rel="noopener">token最佳实践</a></p><h1 id="2层过程"><a href="#2层过程" class="headerlink" title="2层过程"></a>2层过程</h1><p>思维过程如下：<br>用cookie来传输jwt由于2个过期时间，所以弃用<br>=&gt; 选择localStorage来存储<br>=&gt; 无法给前端服务器携带<br>=&gt; 放弃前端服务器重定向<br>=&gt; 使用浏览器端的重定向</p><p>浏览器端的重定向通过判断localStorage中是否存在jwt来判断是否登录，判断时机是整个页面重渲染时，由于是Isomorphic的SPA，这个时机可以认为是在页面第一次从后端取之后，前端第一次渲染时做的判断。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关键字：Isomorphic、SPA、Jwt&lt;/p&gt;
    
    </summary>
    
    
      <category term="jwt" scheme="http://yoursite.com/tags/jwt/"/>
    
  </entry>
  
  <entry>
    <title>Matrix-图像压缩与伪逆</title>
    <link href="http://yoursite.com/2019/05/22/Matrix-%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9%E4%B8%8E%E4%BC%AA%E9%80%86/"/>
    <id>http://yoursite.com/2019/05/22/Matrix-图像压缩与伪逆/</id>
    <published>2019-05-21T22:32:16.000Z</published>
    <updated>2019-07-01T02:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>原课程Lessson31～Lesson32课，图像压缩是基于基变换，伪逆</p><a id="more"></a><h1 id="图像压缩"><a href="#图像压缩" class="headerlink" title="图像压缩"></a>图像压缩</h1><ul><li>图像的向量表示<br>对于一副512×512的的黑白图像，它有512<sup>2</sup>个像素，每个像素用8bit的信息来表达，<img src="图片的矩阵表示.png" alt="图片的矩阵表示"></li><li>压缩的必要性<br>如果采用标准基(I)，来表示每一张图片，每一张图片都需要512<sup>2</sup>bit的数据，那所用的带宽太高。如果根据JPEG的标准，换一种基来表达，那么可以更高效的表达、传输数据。<br>以黑板为例，如果是标准基，那每个图片，都需要那么多的数据，但如果用一种基，其中一个基向量代表亮度，那黑板图片，就可以压缩到很小。<br>下边整理一下常见的基.  </li></ul><h2 id="傅里叶基"><a href="#傅里叶基" class="headerlink" title="傅里叶基"></a>傅里叶基</h2><p><img src="傅里叶基.png" alt="傅里叶基"><br>在JPEG中，使用的是w<sup>jk</sup>的实部，也就是cos分量。<br>它将512<sup>2</sup>的向量，分裂成8×8的小块，然后进行压缩，然后剔除掉系数低于某阈值。<br><img src="傅里叶基的使用.png" alt="傅里叶基的使用"></p><h2 id="小波基"><a href="#小波基" class="headerlink" title="小波基"></a>小波基</h2><p><img src="小波基.png" alt="小波基"><br>JPEG2000中采用小波基从上图中可以看出，示例小波基中，每个向量的非零元素在折半递减。</p><h2 id="压缩与矩阵"><a href="#压缩与矩阵" class="headerlink" title="压缩与矩阵"></a>压缩与矩阵</h2><p>  线性代数用来计算从标准基到傅里叶基或者小波基的系数。<br>  <img src="图像基变换公式1.png" alt="图像基变换公式1"><br>  <img src="图像基变换公式2.png" alt="图像基变换公式2"><br>  故，可得c = W<sup>-1</sup>x.<br>  上式中，如果选择合适的基向量使W<sup>-1</sup> = W<sup>T</sup>，这样计算效率就会大大提高。</p><h1 id="基变换"><a href="#基变换" class="headerlink" title="基变换"></a>基变换</h1><p>对于一个在旧基的向量A，可以通过x=Wc关系，转换到新基体系中，转换后的向量是B。<br>A和B是相似的: B=M<sup>-1</sup>AM  </p><p>对于旧基，用v<sub>1</sub>,v<sub>2</sub>…v<sub>8</sub>来表示<br>A暂时用v来表示： <img src="v表示.png" alt="v表示"><br>转换之后表示为： T(v) = c<sub>1</sub>T(v<sub>1</sub>) + c<sub>2</sub>T(v<sub>2</sub>) + … +c<sub>8</sub>T(v<sub>8</sub>)</p><p>如果T(v<sub>i</sub>) = λ<sub>i</sub>x<sub>i</sub>，这样的变化效率是最高的，但计算一个图像的特征向量，是一件计算量很大的操作，所以不如用佛里叶变换或小波变换。  </p><h1 id="左逆"><a href="#左逆" class="headerlink" title="左逆"></a>左逆</h1><p>左逆是矩阵A：m×n rank(A) = n而言的，川型矩阵</p><p>(A<sup>T</sup>A)<sup>-1</sup>A<sup>T</sup>A = I 我们说：<br><img src="A的左逆.png" alt="A的左逆"> 是A 的左逆。</p><h1 id="右逆"><a href="#右逆" class="headerlink" title="右逆"></a>右逆</h1><p>同样的道理，来类比右逆，右逆是对A: m×n rank(A) = m而言，三型矩阵<br><img src="A的右逆.png" alt="A的右逆"> 是A的右逆。</p><h1 id="伪逆"><a href="#伪逆" class="headerlink" title="伪逆"></a>伪逆</h1><p>左右逆解决了长方形矩阵的逆的问题，但对于奇异矩阵，如何来找到最佳的逆呢？伪逆。<br>因为是奇异矩阵，Ax=0存在非0解，存在着null space，也就不可能有逆的存在。伪逆其实建立的是A的row space与column space之间对应关系。A中row space 中的向量与column space中的向量一一对应。证明略。<br>向量x在row space中 Ax转换到column space上，称之为Ax， 然后再通过A<sup>+</sup>，再转换回来。<img src="伪逆.png" alt="伪逆">  </p><p>A = UΣV<sup>T</sup>  =&gt;  A<sup>+</sup> = UΣ<sup>+</sup>V<sup>T</sup>.</p><p>Σ<sup>+</sup>:1/σ1, 1/σ2, …, 1/σ</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原课程Lessson31～Lesson32课，图像压缩是基于基变换，伪逆&lt;/p&gt;
    
    </summary>
    
      <category term="理论" scheme="http://yoursite.com/categories/%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="Matrix" scheme="http://yoursite.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>问题汇总</title>
    <link href="http://yoursite.com/2019/05/15/%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2019/05/15/问题汇总/</id>
    <published>2019-05-14T16:00:00.000Z</published>
    <updated>2019-07-01T02:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录踩的坑</p><a id="more"></a><h1 id="nest框架的坑"><a href="#nest框架的坑" class="headerlink" title="nest框架的坑"></a>nest框架的坑</h1><ul><li><p>搭建pms-account后，连接报502 bad gateway的错<br>描述：<br>pms-account运行后，报502的错  </p><p>解决：<br>报502的错问题很多，这一次是docker运行时候，暴露的端口是10001,而服务启动时候的端口是3000，修改后问题解决  </p></li><li><p>bcrypt的坑<br>描述1：<br>bcrypt在阿华电脑上启动是，报的是node module version的一个错</p><p>解决1：<br>怀疑是node版本造成的问题，对比后发现在build在主机上执行，node版本是10.0+的版本，而运行是在docker中，node版本是8.+版本。<br>删除node_module，在容器中重新编译，然后运行，问题解决。  </p><p>描述2：<br>在阿里云上install事，一直安装不了bcrypt  </p><p>解决2：<br>怀疑也是版本问题，但同样的解决方式虽然install成功了，但却不可运行，还在继续</p></li></ul><h1 id="node"><a href="#node" class="headerlink" title="node"></a>node</h1><ul><li><p>找不到package的坑<br>描述：<br>Couldn’t find package “package-name” on the “npm” registry  </p><p>解决：<br>npm源是官方源，换了一个淘宝源后，问题解决，这个有点真坑<br>查看：<code>npm get registry</code><br>修改：<code>npm config set registry https://registry.npm.taobao.org</code></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录踩的坑&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>next.js基础</title>
    <link href="http://yoursite.com/2019/05/12/next%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/05/12/next基础/</id>
    <published>2019-05-12T07:35:49.000Z</published>
    <updated>2019-07-01T02:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文为学习next.js而做的笔记，主要参照<a href="https://nextjs.org/docs" target="_blank" rel="noopener">官网</a> ，也会借鉴<a href="https://juejin.im/post/5b868b45e51d4538ae4db7ca" target="_blank" rel="noopener">Next.js踩坑</a>  </p><a id="more"></a><h1 id="起因与目的"><a href="#起因与目的" class="headerlink" title="起因与目的"></a>起因与目的</h1><p>最早接触next.js是在看webpack-isomorphic-tools的官网时候，其推荐新项目使用universal-tools，或者直接用next.js这样的框架。那时候基于create-react-app而搭建的同构已经走了大半，没有继续研究next.js。而搭建的系统遇到了stylus问题，一时间没有找到解决方案，就试着接触一下next.js，一方面想看一下next.js是如何解决这个问题的，另一方也看一下是否可以直接使用next.js。<br>看过之后，觉得next.js是不错的框架，值得去整理一下。</p><p>next.js是一个基于react的SSR框架，它有很多特性值得去应用，下边对这些特性进行整理  </p><p>对于SSR，首先它需要根据浏览器的路径，选择合适的页面、组件进行渲染；<br>其次，<code>&lt;head&gt;</code>中对静态文件的引用，页面中也会包含一些静态的文件，包括react、material的js，还有一些图片等；<br>接着，页面、组件加载时为了提升性能，就需要一些技术：代码切割、预取页面、动态导入等<br>然后，对于有些请求，需要从api sever中加载数据，然后再渲染到页面上；<br>再然后，对于登录，需要判断是否登录（头部判断），再进行路由的跳转；<br>最后，在同构的时候react-router有对history的使用，对于这一点有点疑问，浏览器显然是有自己的一块存储区域来存储历史，为什么在服务器也会看到history？<br>这期间还夹杂一些基础，如对css的支持、路由的参数等</p><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><h2 id="文件系统路由"><a href="#文件系统路由" class="headerlink" title="文件系统路由"></a>文件系统路由</h2><p>  next.js是一个文件系统路由，意思是，需要一个pages目录，这个目录对应’/‘路由；若存在’/home’路由，则需要page目录下有一个home目录。路由与目录结构对应。  </p><p>  这种方式跟最早接触的tomcat有些类似，也与http的静态文件形态时候形同。<br>  webship中维护一个路由与文件的映射；<br>  react-router常见的用法是SPA，只有一个页面，也就不太需要这种映射。</p><h2 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h2><p>  Next.js没有一个记录所有路由的清单，当前页面对其他页面一无所知。这样，浏览器中页面的组织、跳转是通过<code>Link</code>来完成的.与html的<code>&lt;a&gt;</code>标签很相似。  </p><p>  它有2个主要属性：<br>  <code>href</code>：a标签的href，包括路由+请求参数。<br>  <code>as</code>：在浏览器中展示的URL。这个听起来有点怪，需要多做一个说明。<code>next.js</code>本身只支持文件系统路由 与 query形式的参数传递，但为了支持制定方式，可以讲文件系统路由命名成其他的路由，展示在浏览器上。这个就是定制路由</p><p>  url参数：<br>  <code>/about?name=Zeit</code>，从根上，next只支持query形式的传参，对于param形式的传参，需要用<code>as</code></p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link href=&#123;&#123; pathname: '/about', query: &#123; name: 'Zeit' &#125; &#125;&#125;&gt;</span><br><span class="line">  &lt;a&gt;here&lt;/a&gt;</span><br><span class="line">&lt;/Link&gt;</span><br></pre></td></tr></table></figure><h2 id="定制路由"><a href="#定制路由" class="headerlink" title="定制路由"></a>定制路由</h2><ul><li>对于<code>/post/:slug</code>路由  </li><li><p>需要在<code>pages/post.js</code>  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Post</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">async</span> getInitialProps(&#123; query &#125;) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'SLUG'</span>, query.slug);</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>My blog post<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Post;</span><br></pre></td></tr></table></figure></li><li><p>在服务增加一个对<code>/post/:slug</code>路由的响应  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.get(<span class="string">'/post/:slug'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> app.render(req, res, <span class="string">'/post'</span>, &#123; <span class="attr">slug</span>: req.params.slug &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里需要将这个<code>/post/:slug</code>路由转换成内部的<code>/post</code>路由，参数通过query的方式传递。</p></li><li><p>在前端使用<code>next/link</code>  </p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link href=<span class="string">"/post?slug=something"</span> <span class="keyword">as</span>=<span class="string">"/post/something"</span>&gt;</span><br></pre></td></tr></table></figure></li></ul><h1 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h1><ul><li><p>static<br>next.js除了pages目录用于放页面，还有一个static目录用于存放静态文件，这个目录是设定死的，不能改变。路由上使用<code>/  static/</code>与之对应。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyImage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/static/my-image.png"</span> <span class="attr">alt</span>=<span class="string">"my image"</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">export default MyImage;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="加载性能"><a href="#加载性能" class="headerlink" title="加载性能"></a>加载性能</h1><h2 id="代码切割"><a href="#代码切割" class="headerlink" title="代码切割"></a>代码切割</h2><p>  代码切割不应该属于静态文件，指的是对于页面，仅会加载<code>import</code>到的组件，并不会加载其他组件。  </p><h2 id="预取页面"><a href="#预取页面" class="headerlink" title="预取页面"></a>预取页面</h2><p><code>prefetch</code>预取页面是<code>Link</code>的第三个属性，加上它，next.js会在后台自动加载这些页面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">'next/link'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;nav&gt;</span><br><span class="line">            &lt;Link prefetch href=<span class="string">"/"</span>&gt;</span><br><span class="line">                &lt;a&gt;Home&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>Link&gt;</span><br><span class="line">            &lt;Link prefetch href=<span class="string">"/about"</span>&gt;</span><br><span class="line">                &lt;a&gt;About&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>Link&gt;</span><br><span class="line">            &lt;Link prefetch href=<span class="string">"/contact"</span>&gt;</span><br><span class="line">                &lt;a&gt;Contact&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>Link&gt;</span><br><span class="line">        &lt;<span class="regexp">/nav&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default Header;</span></span><br></pre></td></tr></table></figure><h2 id="动态引用组件"><a href="#动态引用组件" class="headerlink" title="动态引用组件"></a>动态引用组件</h2><p>动态引用可以认为是另一种控制代码切割的方式。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// components/hello.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dynamic <span class="keyword">from</span> <span class="string">'next/dynamic'</span>;</span><br><span class="line"><span class="keyword">const</span> DynamicComponent = dynamic(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../components/hello'</span>));</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Header /&gt;</span><br><span class="line">      &lt;DynamicComponent /&gt;</span><br><span class="line">      &lt;p&gt;HOME PAGE is here!<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default Home;</span></span><br></pre></td></tr></table></figure><p>动态引入还支持对组件的引入不使用SSR。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dynamic <span class="keyword">from</span> <span class="string">'next/dynamic'</span>;</span><br><span class="line"><span class="keyword">const</span> DynamicComponentWithNoSSR = dynamic(</span><br><span class="line">  () =&gt; <span class="keyword">import</span>(<span class="string">'../components/hello3'</span>),</span><br><span class="line">  &#123;</span><br><span class="line">    ssr: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Header /&gt;</span><br><span class="line">      &lt;DynamicComponentWithNoSSR /&gt;</span><br><span class="line">      &lt;p&gt;HOME PAGE is here!<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Home;</span></span><br></pre></td></tr></table></figure><h1 id="动态数据加载"><a href="#动态数据加载" class="headerlink" title="动态数据加载"></a>动态数据加载</h1><p>当页面启动需要加载数据时，使用<code>getInitialProps</code>函数来完成，它可以异步获取数据，并解析成对象，并发送给<code>props</code>。注意，<code>getInitialProps</code> 仅可以在pages中使用，不能在components中使用。其仅用于渲染在页面路由中有参数，需要根据这些参数来获取数据并进行渲染的情况。对于动态的交互，还是需要ajax。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloUA</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">async</span> getInitialProps(&#123; req &#125;) &#123;</span><br><span class="line">    <span class="keyword">const</span> userAgent = req ? req.headers[<span class="string">'user-agent'</span>] : navigator.userAgent;</span><br><span class="line">    <span class="keyword">return</span> &#123; userAgent &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello World &#123;this.props.userAgent&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> HelloUA;</span><br></pre></td></tr></table></figure><h1 id="定制路由-1"><a href="#定制路由-1" class="headerlink" title="定制路由"></a>定制路由</h1><p>定制路由，next.js的文档写的有点没跟上，大体记录一下：</p><h2 id="路由修改"><a href="#路由修改" class="headerlink" title="路由修改"></a>路由修改</h2><p>  其实与link的as类似，在express中，对外展示一层，对内依然用文件系统路由。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">app.prepare().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"> createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">// Be sure to pass `true` as the second argument to `url.parse`.</span></span><br><span class="line">   <span class="comment">// This tells it to parse the query portion of the URL.</span></span><br><span class="line">   <span class="keyword">const</span> parsedUrl = parse(req.url, <span class="literal">true</span>);</span><br><span class="line">   <span class="keyword">const</span> &#123; pathname, query &#125; = parsedUrl;</span><br><span class="line">   <span class="keyword">if</span> (pathname === <span class="string">'/a'</span>) &#123;</span><br><span class="line">     app.render(req, res, <span class="string">'/b'</span>, query);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pathname === <span class="string">'/b'</span>) &#123;</span><br><span class="line">     app.render(req, res, <span class="string">'/a'</span>, query);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     handle(req, res, parsedUrl);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;).listen(<span class="number">3000</span>, err =&gt; &#123;</span><br><span class="line">   <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'&gt; Ready on http://localhost:3000'</span>);</span><br><span class="line"> &#125;);</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="后端禁用文件系统路由"><a href="#后端禁用文件系统路由" class="headerlink" title="后端禁用文件系统路由"></a>后端禁用文件系统路由</h2><p>  如果使用定制路由，文件系统路由的方式可能会导致从多个路由里边访问的内容是一样的情况，可以禁用掉文件系统路由。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// next.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  useFileSystemPublicRoutes: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  useFileSystemPublicRoutes属性会禁用掉SSR侧的文件名路由，CSR侧可能继续提供。对于CSR侧的需要<code>popstate</code></p><p>  以上是官方提供的文档，但并没有提供SSR侧禁用文件系统路由之后，服务端的渲染该如何处理的方案。</p><h2 id="前端拦截popstate"><a href="#前端拦截popstate" class="headerlink" title="前端拦截popstate"></a>前端拦截<code>popstate</code></h2><p>监听<code>popstate</code>，在router响应之前进行拦截，这样可以操作request，或者强制SSR刷新。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'next/router'</span>;</span><br><span class="line">Router.beforePopState(<span class="function">(<span class="params">&#123; url, <span class="keyword">as</span>, options &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// I only want to allow these two routes!</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">as</span> !== <span class="string">'/'</span> || <span class="keyword">as</span> !== <span class="string">'/other'</span>) &#123;</span><br><span class="line">    <span class="comment">// Have SSR render bad routes as a 404.</span></span><br><span class="line">    <span class="built_in">window</span>.location.href = <span class="keyword">as</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>返回false时，router不再处理<code>popstate</code></p><h2 id="router对象的使用"><a href="#router对象的使用" class="headerlink" title="router对象的使用"></a>router对象的使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'next/router'</span>;</span><br><span class="line"><span class="keyword">const</span> handler = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  Router.push(&#123;</span><br><span class="line">    pathname: <span class="string">'/about'</span>,</span><br><span class="line">    query: &#123; <span class="attr">name</span>: <span class="string">'Zeit'</span> &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReadMore</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      Click &lt;span onClick=&#123;handler&#125;&gt;here&lt;<span class="regexp">/span&gt; to read more</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ReadMore;</span><br></pre></td></tr></table></figure><p>这里的功能与<code>&lt;link&gt;</code>相同，但在router上可以监听很多时间，包括<code>routeChangeStart(url)</code>、<code>routeChangeComplete(url)</code>。<br>通过:  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Router.events.on(<span class="string">'routeChangeStart'</span>, handleRouteChange);</span><br></pre></td></tr></table></figure><h1 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h1><p>页面跳转其实是express的功能，只需要将res.redirect(301, ‘/new/link’)即可。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> next = <span class="built_in">require</span>(<span class="string">'next'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; join &#125; = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> dev = process.env.NODE_ENV !== <span class="string">'production'</span></span><br><span class="line"><span class="keyword">const</span> app = next(&#123; dev &#125;)</span><br><span class="line"><span class="keyword">const</span> handle = app.getRequestHandler()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> redirects = [</span><br><span class="line">  &#123; <span class="attr">from</span>: <span class="string">'/old-link-1'</span>, <span class="attr">to</span>: <span class="string">'/new-link-1'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">from</span>: <span class="string">'/old-link-2'</span>, <span class="attr">to</span>: <span class="string">'https://externalsite.com/new-link-2'</span> &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">app.prepare().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> server = express()</span><br><span class="line"></span><br><span class="line">  redirects.forEach(<span class="function">(<span class="params">&#123; <span class="keyword">from</span>, to, type = <span class="number">301</span>, method = <span class="string">'get'</span> &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    server[method](<span class="keyword">from</span>, (req, res) =&gt; &#123;</span><br><span class="line">      res.redirect(type, to)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  server.get(<span class="string">'*'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> handle(req, res)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  server.listen(<span class="number">3000</span>, err =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'&gt; Ready on http://localhost:3000'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>package.json:  </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"dev"</span>: <span class="string">"node server.js"</span>,</span><br><span class="line">  <span class="attr">"start"</span>: <span class="string">"NODE_ENV=production node server.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于登录，可以在’*’中，检查req来进行重定向</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="lt-App-gt"><a href="#lt-App-gt" class="headerlink" title="&lt;App&gt;"></a><code>&lt;App&gt;</code></h2><p>next利用App组件来初始化页面，我们可以重写它来控制页面的初始化，可以处理：</p><ul><li>在页面变换时，持久化布局  </li><li>在页面导航时，保存状态  </li><li>注入额外的数据</li><li>使用<code>componentDidCatch</code>来做定制的错误处理</li></ul><p>创建一个pages/_app.js，然后继承App来实现即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> App, &#123; Container &#125; <span class="keyword">from</span> <span class="string">'next/app'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">async</span> getInitialProps(&#123; Component, ctx &#125;) &#123;</span><br><span class="line">    <span class="keyword">let</span> pageProps = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (Component.getInitialProps) &#123;</span><br><span class="line">      pageProps = <span class="keyword">await</span> Component.getInitialProps(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; pageProps &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; Component, pageProps &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Container&gt;</span><br><span class="line">        &lt;Component &#123;...pageProps&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Container&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default MyApp;</span></span><br></pre></td></tr></table></figure><h2 id="lt-Document-gt"><a href="#lt-Document-gt" class="headerlink" title="&lt;Document&gt;"></a><code>&lt;Document&gt;</code></h2><p>用于改变初始化时候服务端渲染的document标记。处理与App类似<br>修改pages/_document.js，继承自Document</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为学习next.js而做的笔记，主要参照&lt;a href=&quot;https://nextjs.org/docs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网&lt;/a&gt; ，也会借鉴&lt;a href=&quot;https://juejin.im/post/5b868b45e51d4538ae4db7ca&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Next.js踩坑&lt;/a&gt;  &lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="next.js" scheme="http://yoursite.com/tags/next-js/"/>
    
  </entry>
  
  <entry>
    <title>阿里云使用</title>
    <link href="http://yoursite.com/2019/05/12/%E9%98%BF%E9%87%8C%E4%BA%91%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/05/12/阿里云使用/</id>
    <published>2019-05-11T16:00:00.000Z</published>
    <updated>2019-07-01T02:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>总结阿里云使用需要注意的问题</p><a id="more"></a><h1 id="阿里云新实例的坑"><a href="#阿里云新实例的坑" class="headerlink" title="阿里云新实例的坑"></a>阿里云新实例的坑</h1><ul><li><p>80端口不可用的坑<br>描述：<br>搭建起来之后运行core-nginx失败，log日志中什么都没用，80端口也没有被占用</p><p>解决：<br>每个esc都有自己的安全组，需要在阿里云控制台，需要开相应的端口<br>然后，连接后，ubunt预装了防火墙，需要放行80端口，与行<code>ufw allow http</code>即可<br><a href="https://help.aliyun.com/knowledge_detail/59367.html#ubuntu" target="_blank" rel="noopener">ubuntu</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结阿里云使用需要注意的问题&lt;/p&gt;
    
    </summary>
    
      <category term="工具与运维" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E4%B8%8E%E8%BF%90%E7%BB%B4/"/>
    
    
  </entry>
  
  <entry>
    <title>Matrix-SVD与线性变换</title>
    <link href="http://yoursite.com/2019/05/11/Matrix-SVD%E4%B8%8E%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/"/>
    <id>http://yoursite.com/2019/05/11/Matrix-SVD与线性变换/</id>
    <published>2019-05-11T14:44:48.000Z</published>
    <updated>2019-07-01T02:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>原课程Lessson29～Lesson30课，svd其实是正定的延伸，正定是一种特殊的svd；线性变换是矩阵的基础与来源</p><a id="more"></a><h1 id="SVD奇异变换"><a href="#SVD奇异变换" class="headerlink" title="SVD奇异变换"></a>SVD奇异变换</h1><ul><li><p>SVD定义<br>SVD是找到A的一组行向量空间的正交基，通过线性变换，变成列空间的一组正交基的运算。用公式表达为：<br><img src="SVD分析.png" alt="SVD分析"><br>由于是行向量的变换，所有A是左乘V，得到的结果不一定是单位正交的，通过对角阵来表示。<br>这里还可以回忆一下4个基本向量空间：V<sub>1</sub>…V<sub>r</sub> 是在行向量空间，那么V<sub>r+1</sub>…V<sub>n</sub>就是在就会在Nullspace。<br><img src="SVD公式1.png" alt="SVD公式1"><br><img src="SVD公式2.png" alt="SVD公式2">  </p></li><li><p>计算<br>计算是利用的正定，通过A<sub>T</sub>A，来计算V；通过AA<sub>T</sub>来计算U。<br><img src="SVD的计算.png" alt="SVD的计算">  </p></li><li><p>示例1<br><img src="SVD示例1-1.png" alt="SVD示例1-1"><br><img src="SVD示例1-2.png" alt="SVD示例1-2"><br>求得A<sub>T</sub>A的特征值是32 与 18， 特征向量是v<sup>1</sup>=[1 1]<sup>T</sup> 与 v<sup>2</sup>=[1 -1]<sup>T</sup><br>将特征向量标准化:<br><img src="SVD示例1-3.png" alt="SVD示例1-3"><br>同样的道理来求AA<sub>T</sub><br><img src="SVD示例1-4.png" alt="SVD示例1-4"><br>这里由于正好是对角化，于是原课中，直接使用了u1=[1 0]<sup>T</sup> 与 u2=[0 1]<sup>T</sup><br>这样做造成了结果的不一致，而需要通过最原始的进行验证符号， Av<sub>2</sub> = σ<sub>2</sub>u<sub>2</sub><br>于是u2=[0 -1] 最后结果为：<br><img src="SVD示例1-5.png" alt="SVD示例1-5">  </p></li><li><p>示例2<br>原文中给出了奇异状态下的分解：<br><img src="SVD示例2-1.png" alt="SVD示例2-1"><br>由于奇异，也就只有一个行向量，只有一个特征值(另一个为0)<br>v<sup>1</sup>=[0.8 0.6]<sup>T</sup>  </p><p>同样的求法：先求A<sub>T</sub>A，再求AA<sub>T</sub>，最后得结果<br><img src="SVD示例2-2.png" alt="SVD示例2-2"><br><img src="SVD示例2-3.png" alt="SVD示例2-3">  </p><p>这里给出了结果，由于只有一个行向量，而又是2*2的矩阵，另一个V其实是nullspace的基<br><img src="SVD结尾.png" alt="SVD结尾"></p></li></ul><h1 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h1><ul><li><p>定义<br>一个公式：T(cv + dw) = cT(v) + dT(w)，其中c、d是常数，v、w是向量。<br>等同于2个公式：T(v+w) = T(v) + T(w); T(cv) = cT(v)<br>如此T(0) = 0  </p></li><li><p>线性变换与矩阵<br>理解一个线性变换最好的方式，是找到变换后面的矩阵。为此，要引入基向量与坐标。  </p><p>T(v) = Av，因为：<br>A(v+w) = A(v)+A(w)<br>A(cv) = cA(v)  </p><p>给定一个变换T，如何得到一个矩阵A能够代表它呢？<br>首先要选定2组基，如v: v: v<sub>1</sub>,v<sub>2</sub>…v<sub>n</sub>，是R<sup>n</sup>中的基，w: w<sub>1</sub>,w<sub>2</sub>…w<sub>m</sub>。是R<sup>m</sup>中的基。v是input，w是output。<br>T(v<sub>i</sub>) = a<sub>1i</sub>w<sub>1</sub> + a<sub>2i</sub>w<sub>2</sub>…+a<sub>mi</sub>w<sub>m</sub></p></li><li><p>示例1<br><img src="线性变换1-1.png" alt="线性变换1-1"><br>T(v) = Av<br>在R<sup>2</sup>空间中，对于每一个input v=[x, y]<sup>T</sup>，A会将其x值保持不变，而y值取反。结合图像，针对x轴做了对称  </p></li><li><p>示例2<br>求导也是一种线性变换<br><img src="线性变换2-1.png" alt="线性变换2-1"><br>这是一个3维空间向2维空间变换的例子，取输入的基为3维：v<sub>1</sub> = 1, v<sub>2</sub> = x, v<sub>2</sub> = x<sup>2</sup>，输出的的基为2维：w<sub>1</sub> = 1, w<sub>2</sub> = x<br>由此得到<img src="线性变换2-2.png" alt="线性变换2-2"><br>由此得到<img src="线性变换2-3.png" alt="线性变换2-3"></p></li><li><p>结论<br>对于每一个线性变换，都有一个A与之对应，使得T(v) = Av。<br>如果A是可逆的，则线性变换的逆变换 对应的矩阵就是A<sup>-1</sup><br>两个变换的乘积变换： T<sub>1</sub> : v <--> A<sub>1</sub>v ; T<sub>2</sub> : w <--> A<sub>2</sub>w。则这个变换对应的矩阵是A<sub>2</sub>A<sub>1</sub>。这是矩阵乘积的来源。</--></--></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原课程Lessson29～Lesson30课，svd其实是正定的延伸，正定是一种特殊的svd；线性变换是矩阵的基础与来源&lt;/p&gt;
    
    </summary>
    
      <category term="理论" scheme="http://yoursite.com/categories/%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="Matrix" scheme="http://yoursite.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>js构建工具</title>
    <link href="http://yoursite.com/2019/05/05/js%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2019/05/05/js构建工具/</id>
    <published>2019-05-05T14:45:39.000Z</published>
    <updated>2019-07-01T02:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>前一段时间搭建Isomorphic过程中，对js的构建工具接触比较多，也做了一些记录但都不够系统，这里对接触的构建工具做一些较系统的整理，包括：webpack、gulp、babel</p><a id="more"></a>  <h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><ul><li><p>webpack的用途<br>webpack是一个打包工具，打包又是为什么呢？对于前端，用react写了很多组件，如果直接编译成js会有很多的文件，也就需要很多的script来做引用，这样会极为不方便，webpack就是自动的寻找依赖关系，将这些文件打包到一起的工具。<br>起初它只做这个，这样对于非js的文件就不太好处理，这样它通过自己的插件（loader）来对这些非js文件进行支持。这样对于css、ts、stylus等文件，都可以通过webpack来进行处理了。</p></li><li><p>webpack基本概念</p><p>  <a href="https://webpack.js.org/concepts#loaders" target="_blank" rel="noopener">原文</a><br>  4大概念：Entry、Output、Loaders、Plugins</p><ul><li><p>Entry:<br>An entry point indicates which module webpack should use to begin building out its internal dependency graph. webpack will figure out which other modules and libraries that entry point depends on</p></li><li><p>Output:<br>The output property tells webpack where to emit the bundles it creates and how to name these files  </p></li><li><p>Loaders:<br>Out of the box, webpack only understands JavaScript and JSON files. Loaders allow webpack to process other types of files and convert them into valid modules that can be consumed by your application and added to the dependency graph.  </p></li><li><p>Plugins:<br>While loaders are used to transform certain types of modules, plugins can be leveraged to perform a wider range of tasks like bundle optimization, asset management and injection of environment variables.</p></li></ul></li><li><p>使用<br>对于Ts与stylus的loader配置如下:</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123; </span><br><span class="line">            test: /\.tsx$/, </span><br><span class="line">            use: ['awesome-typescript-loader'],</span><br><span class="line">            exclude: /node_modules/</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            test: /\.styl$/,</span><br><span class="line">            use: [ </span><br><span class="line">                &#123;</span><br><span class="line">                    loader: 'style-loader'</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    loader: 'css-loader',</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        modules: true</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    loader: 'stylus-loader'</span><br><span class="line">                &#125; </span><br><span class="line">            ],</span><br><span class="line">            exclude: /node_modules/</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>其他<br>webpack像是一个家族，对于同构它们提供webpack-isomorphic-tools，但在gitlab库的说明上： It allowed many projects to set up basic isomorphic (universal) rendering in the early days but is now considered deprecated and new projects shouldn’t use it. This library can still be found in legacy projects. For new projects use either universal-webpack or all-in-one frameworks like Next.js.</p></li></ul><h1 id="gulp"><a href="#gulp" class="headerlink" title="gulp"></a>gulp</h1><ul><li><p>gulp的用途<br>gulp是一个流式任务运行器，换句话说，我们通过命令行执行的操作，可以通过gulp定义成任务，然后对任务进行编排（指定运行顺序）、运行。<br>gulp的任务执行，从触发方式上看可以是手动执行，也可以通过watch检测文件变化自动执行。</p></li><li><p>gulp基本概念<br><a href="https://www.gulpjs.com.cn/docs/api/" target="_blank" rel="noopener">原文</a><br>输出（Emits）符合所提供的匹配模式（glob）或者匹配模式的数组（array of globs）的文件。 将返回一个 Vinyl files 的   stream 它可以被 piped 到别的插件中。</p><ul><li><p>pipe<br>管道，任务流</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gulp.src(<span class="string">'client/templates/*.jade'</span>)</span><br><span class="line">.pipe(jade())</span><br><span class="line">.pipe(minify())</span><br><span class="line">.pipe(gulp.dest(<span class="string">'build/minified_templates'</span>));</span><br></pre></td></tr></table></figure></li><li><p>task<br>这里采用的是函数编程范式  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">'somename'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> stream = gulp.src(<span class="string">'client/**/*.js'</span>)</span><br><span class="line">    .pipe(minify())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'build'</span>));</span><br><span class="line"><span class="keyword">return</span> stream;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>任务编排：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个 callback，因此系统可以知道它什么时候完成</span></span><br><span class="line">gulp.task(<span class="string">'one'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 做一些事 -- 异步的或者其他的</span></span><br><span class="line">    cb(err); <span class="comment">// 如果 err 不是 null 或 undefined，则会停止执行，且注意，这样代表执行失败了</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个所依赖的 task 必须在这个 task 执行之前完成</span></span><br><span class="line">gulp.task(<span class="string">'two'</span>, [<span class="string">'one'</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 'one' 完成后</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'one'</span>, <span class="string">'two'</span>]);</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>watch<br>监视文件变化  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> watcher = gulp.watch(<span class="string">'js/**/*.js'</span>, [<span class="string">'uglify'</span>,<span class="string">'reload'</span>]);</span><br><span class="line">watcher.on(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'File '</span> + event.path + <span class="string">' was '</span> + event.type + <span class="string">', running tasks...'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>其他<br>gulp其实也提供了一些插件，比如<code>gulp-typescript</code>，可以Ts直接编译成js，它与webpack中的ts-loader应该有类似的作用，只不过webpack中将所有的文件都打包到一起了。</p></li></ul><h1 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h1><ul><li><p>babel的用途<br>babel是转码器，这个转码器是将不同版本的js进行转换。目前有的浏览器并不支持 ES6，而我们又用ES6来编码，那就用babel进行处理，自动转换成相应的版本。<br>而且babel支持React的JSX语法转换，对于Ts，babel也有所支持，比如退去所有的annotation，以及类型  </p></li><li><p>使用<br><a href="https://babeljs.io/docs/en/" target="_blank" rel="noopener">官方文档</a><br>babel部分摘自：<a href="http://www.ruanyifeng.com/blog/2016/01/babel.html" target="_blank" rel="noopener">阮一峰：Babel 入门教程</a>  </p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 转码结果输出到标准输出</span></span><br><span class="line">$ babel example.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转码一个文件：--out-file 或 -o 参数指定输出文件</span></span><br><span class="line">$ babel example.js --out-file compiled.js</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">$ babel example.js -o compiled.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转码整个目录： --out-dir 或 -d 参数指定输出目录</span></span><br><span class="line">$ babel src --out-dir lib</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">$ babel src -d lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># -s 参数生成source map文件</span></span><br><span class="line">$ babel src -d lib -s</span><br></pre></td></tr></table></figure></li><li><p>babel全家桶  </p><ul><li><p>babel-cli<br>上文使用cli运行，需要安装babel-cli：<code>npm install --global babel-cli</code></p></li><li><p>babel-core<br>我们在用的使用更多的是通过gulp来调用，就需要babel-core，<code>npm install babel-core --save</code>  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> babel = <span class="built_in">require</span>(<span class="string">'babel-core'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串转码</span></span><br><span class="line">babel.transform(<span class="string">'code();'</span>, options);</span><br><span class="line"><span class="comment">// =&gt; &#123; code, map, ast &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件转码（异步）</span></span><br><span class="line">babel.transformFile(<span class="string">'filename.js'</span>, options, <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">result; <span class="comment">// =&gt; &#123; code, map, ast &#125;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件转码（同步）</span></span><br><span class="line">babel.transformFileSync(<span class="string">'filename.js'</span>, options);</span><br><span class="line"><span class="comment">// =&gt; &#123; code, map, ast &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>babel-polyfill<br>Babel默认只转换新的JavaScript句法（syntax），而不转换新的API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。 在使用上，就需要babel-ployfill来完成对这些内容的支持。</p><p>安装：<br><code>npm install --save babel-polyfill</code></p><p>在脚本的头部，加入：<br><code>import &#39;babel-polyfill&#39;</code>;</p></li></ul></li></ul><h1 id="webpack-isomorphic-tools"><a href="#webpack-isomorphic-tools" class="headerlink" title="webpack-isomorphic-tools"></a>webpack-isomorphic-tools</h1><ul><li><p>前言<br>在搭建同构应用中，几次都遇到这个工具，在这里对这个工具进行一个整理  </p></li><li><p>webpack-isomorphic-tools的用途<br>webpack做的事情，是将文件进行打包，方便浏览器去获取原本这些分散的js，但对于isomorphic，事情变的不同。node.js的后端并不需要webpack打包，而不经过打包，对于有些类型的文件(图片类、CSS类)，后端没法直接支持。这也正是在前面<a href="https://sunyanfeng.cn/2019/04/14/SSR%E3%80%81CSR%E4%B8%8E%E5%90%8C%E6%9E%84/#more" target="_blank" rel="noopener">SSR、CSR与同构</a>中对stylus文件处理时遇到的问题。</p><p><a href="https://github.com/catamphetamine/webpack-isomorphic-tools#api" target="_blank" rel="noopener">官网</a>  </p></li><li><p>使用  </p><ul><li><p>安装<br>npm install webpack-isomorphic-tools –save</p></li><li><p>将<code>webpack-isomorphic-tools</code>嵌入webpack的配置中  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> WebpackIsomorphicToolsPlugin = <span class="built_in">require</span>(<span class="string">'webpack-isomorphic-tools/plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> webpackIsomorphicToolsPlugin = </span><br><span class="line"><span class="comment">// webpack-isomorphic-tools settings reside in a separate .js file </span></span><br><span class="line"><span class="comment">// (because they will be used in the web server code too).</span></span><br><span class="line"><span class="keyword">new</span> WebpackIsomorphicToolsPlugin(<span class="built_in">require</span>(<span class="string">'./webpack-isomorphic-tools-configuration'</span>))</span><br><span class="line"><span class="comment">// also enter development mode since it's a development webpack configuration</span></span><br><span class="line"><span class="comment">// (see below for explanation)</span></span><br><span class="line">.development()</span><br><span class="line"></span><br><span class="line"><span class="comment">// usual Webpack configuration</span></span><br><span class="line"><span class="built_in">module</span>.exports =</span><br><span class="line">&#123;</span><br><span class="line">context: <span class="string">'(required) your project path here'</span>,</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>:</span><br><span class="line">&#123;</span><br><span class="line">    loaders:</span><br><span class="line">    [</span><br><span class="line">    ...,</span><br><span class="line">    &#123;</span><br><span class="line">        test: webpackIsomorphicToolsPlugin.regularExpression(<span class="string">'images'</span>),</span><br><span class="line">        loader: <span class="string">'url-loader?limit=10240'</span>, <span class="comment">// any image below or equal to 10K will be converted to inline base64 instead</span></span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">plugins:</span><br><span class="line">[</span><br><span class="line">    ...,</span><br><span class="line"></span><br><span class="line">    webpackIsomorphicToolsPlugin</span><br><span class="line">]</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官网在这里也说明了一下为什么要.development()。对于开发模式，它让asset缓存失效，而让asset hot reload使能。</p></li><li><p>isomorphic自己的配置文件：webpack-isomorphic-tools-configuration.js  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> WebpackIsomorphicToolsPlugin <span class="keyword">from</span> <span class="string">'webpack-isomorphic-tools/plugin'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span></span><br><span class="line">&#123;</span><br><span class="line">  assets:</span><br><span class="line">  &#123;</span><br><span class="line">    images:</span><br><span class="line">    &#123;</span><br><span class="line">      extensions: [<span class="string">'png'</span>, <span class="string">'jpg'</span>, <span class="string">'gif'</span>, <span class="string">'ico'</span>, <span class="string">'svg'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>服务端运行入口 main.js配置  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> WebpackIsomorphicTools = <span class="built_in">require</span>(<span class="string">'webpack-isomorphic-tools'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// this must be equal to your Webpack configuration "context" parameter</span></span><br><span class="line"><span class="keyword">var</span> projectBasePath = <span class="built_in">require</span>(<span class="string">'path'</span>).resolve(__dirname, <span class="string">'..'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// this global variable will be used later in express middleware</span></span><br><span class="line">global.webpackIsomorphicTools = <span class="keyword">new</span> WebpackIsomorphicTools(<span class="built_in">require</span>(<span class="string">'./webpack-isomorphic-tools-configuration'</span>)  )</span><br><span class="line">.server(projectBasePath, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// webpack-isomorphic-tools is all set now.</span></span><br><span class="line">  <span class="comment">// here goes all your web application code:</span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./server'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>后端渲染页面  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// clear require() cache if in development mode</span></span><br><span class="line"><span class="comment">// (makes asset hot reloading work)</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>)</span><br><span class="line">&#123;</span><br><span class="line">    webpackIsomorphicTools.refresh()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for react-router example of determining current page by URL take a look at this:</span></span><br><span class="line"><span class="keyword">const</span> pageComponent = [determine your page component here using request.path]</span><br><span class="line"></span><br><span class="line"><span class="comment">// render the page to string and send it to the browser as text/html</span></span><br><span class="line">response.send(<span class="string">'&lt;!doctype html&gt;\n'</span> +</span><br><span class="line">        React.renderToString(<span class="xml"><span class="tag">&lt;<span class="name">Html</span> <span class="attr">assets</span>=<span class="string">&#123;webpackIsomorphicTools.assets()&#125;</span> <span class="attr">component</span>=<span class="string">&#123;pageComponent&#125;</span> /&gt;</span>))</span></span><br></pre></td></tr></table></figure><p>这里它传了fluxstore，在我们那并没有引入，故这个可以不用</p></li><li><p>Html中的使用<br>Html中接收传入的assets const { assets, component, store } = this.props<br>然后从asset中去获取资源，即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> picture = <span class="built_in">require</span>(<span class="string">'../assets/images/cat.jpg'</span>)</span><br><span class="line"><span class="keyword">const</span> icon = <span class="built_in">require</span>(<span class="string">'../assets/images/icon/32x32.png'</span>)</span><br></pre></td></tr></table></figure><p>在header中，也可有直接去引入styles  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="comment">/* styles (will be present only in production with webpack extract text plugin) */</span>&#125;</span><br><span class="line">&#123;<span class="built_in">Object</span>.keys(assets.styles).map(<span class="function">(<span class="params">style, i</span>) =&gt;</span></span><br><span class="line">&lt;link href=&#123;assets.styles[style]&#125; key=&#123;i&#125; media=<span class="string">"screen, projection"</span></span><br><span class="line">        rel=<span class="string">"stylesheet"</span> type=<span class="string">"text/css"</span>/&gt;)&#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="comment">/* resolves the initial style flash (flicker) on page load in development mode */</span>&#125;</span><br><span class="line">&#123; <span class="built_in">Object</span>.keys(assets.styles).length === <span class="number">0</span> ? <span class="xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">dangerouslySetInnerHTML</span>=<span class="string">&#123;&#123;__html:</span> <span class="attr">require</span>('<span class="attr">..</span>/<span class="attr">assets</span>/<span class="attr">styles</span>/<span class="attr">main_style.css</span>')&#125;&#125;/&gt;</span><span class="undefined"> : null &#125;</span></span></span><br></pre></td></tr></table></figure><p>asserts是由webpack-isomorphic-tools创建的webpack-asset.json中的内容 </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"javascript"</span>:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"main"</span>: <span class="string">"/assets/main-d8c29e9b2a4623f696e8.js"</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="attr">"styles"</span>:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"main"</span>: <span class="string">"/assets/main-d8c29e9b2a4623f696e8.css"</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="attr">"assets"</span>:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"./assets/images/cat.jpg"</span>: <span class="string">"http://localhost:3001/assets/9059f094ddb49c2b0fa6a254a6ebf2ad.jpg"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="yarn-vs-npm"><a href="#yarn-vs-npm" class="headerlink" title="yarn vs npm"></a>yarn vs npm</h1><p><a href="https://zhuanlan.zhihu.com/p/27449990" target="_blank" rel="noopener">原文</a></p><p>源头是一致的，yarn会比npm快一些，并且安装版本统计</p><p>npm install === yarn<br>npm install taco –save === yarn add taco<br>npm uninstall taco –save === yarn remove taco<br>npm install taco –save-dev === yarn add taco –dev<br>npm update –save === yarn upgrade  </p><h1 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h1><p>推荐阅读：<a href="http://www.siguoya.name/pc/home/article/271" target="_blank" rel="noopener">思过崖</a>  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一段时间搭建Isomorphic过程中，对js的构建工具接触比较多，也做了一些记录但都不够系统，这里对接触的构建工具做一些较系统的整理，包括：webpack、gulp、babel&lt;/p&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>产品反思</title>
    <link href="http://yoursite.com/2019/05/04/%E4%BA%A7%E5%93%81%E5%8F%8D%E6%80%9D/"/>
    <id>http://yoursite.com/2019/05/04/产品反思/</id>
    <published>2019-05-04T02:10:39.000Z</published>
    <updated>2019-07-01T02:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>整个4月大部分时间都处在产品重构的思考与设计中，牺牲了一些正在坚持的习惯，一方面是时间紧张，另一方面自己很大的精力都投入在这些思考与设计中，没有分心的心思。作为一个由设计到开发的转折点，我觉得有必要对这个过程进行一些反思。</p><a id="more"></a><h1 id="开场白"><a href="#开场白" class="headerlink" title="开场白"></a>开场白</h1><p>回顾4月，先是产品的定位的思考，包括其提供给用户的核心价值。后又用了不太到2个周的时间，对前端的框架进行了探索，包括SPA与MPA、SSR与CSR与同构。后来产品设计、架构设计尤其后端服务的拆分通信、最后对界面进行了讨论与设计。下面反思一下整个过程，一方面为了总结经验，另一方面通过回顾也找一下不足与提升空间。</p><h1 id="产品设计"><a href="#产品设计" class="headerlink" title="产品设计"></a>产品设计</h1><p>产品本身是一个重构，并不是完全从无到有去设计一个产品。从旧的产品中，发现了一些不足。这些不足表现为：  </p><ul><li>原产品中，最初的想法是将项目管理整个从线下搬到线上，这个出发点没有具体表达出产品的核心价值;  </li><li>项目管理是一个整体，同时整体搬迁到线上的难度很高，可行性差;  </li><li>原产品中，虽然有很多角色，但对这些角色如何使用产品，并没有进行设计;  </li><li>原系统中，功能开发出来，但这个功能本身能为用户提供什么帮助，或者设想用户怎么使用并没有思考清楚;  </li></ul><p>所以这次的重构，超越了代码层面、服务架构，是一个从旧产品中重新构思新产品的过程。这个过程：  </p><ul><li><p>首先是归纳了旧产品的价值，提出了3个核心价值：控制、协同、知识。<br>控制指的是项目管理者，对项目进度、产值、成本的控制<br>协同指的是项目成员为完成项目所进行的沟通、交互、审核、汇报等协同<br>知识指的是由数据涌现的对工程的计划、施工、设计等的辅助功能、预警功能  </p></li><li><p>接着制定了3个使用场景<br>第一个场景是控制场景，其包括4种角色，这4种角色以什么样的工作流程、什么样的操作来使用系统，使用后为各角色以及整体产生怎样的价值<br>第二个场景是协同场景，业务上是一个用料申请的场景，这个场景本身其实可以分成4个子场景，每个子场景都是一种用料申请，每个子场景中，都是一种1v1的交互<br>第三个场景也是协同场景，是一个巡查的场景，涉及2个人物也是1v1的交互  </p></li><li><p>从场景中抽象功能<br>从第一场景开始，想象每个角色需要如何使用产品，为了满足其需要，系统要提供什么的功能<br>借鉴旧系统，将这些功能分解、聚合这也就就自然过度到了服务设计  </p></li></ul><h1 id="服务设计"><a href="#服务设计" class="headerlink" title="服务设计"></a>服务设计</h1><p>这里的服务指的是业务层微服务的设计，不能算是整个系统架构的设计。<br>服务的设计过程中，是根据功能分解、聚合之后的结构，尽量达到高内聚，低耦合。另外，一些公共的业务低相关度的功能抽离到独立的微服务中完成<br>后来发现，业务服务竟然大约可以与角色相对应，很大程度上达到的多租户的隔离方式。<br>服务间的通信，大部分采用消息队列来做事件驱动，一部分采用通过redis来共享数据，最小的一部分采用Restful的方式来调用。<br>这种业务服务设计，由于用户的使用频率不同，对应的服务的流量要求就不同，部署的使用也就要有所差异，当然后边可以通过整个架构的监控、devops等设施来完成</p><h1 id="交互设计与界面"><a href="#交互设计与界面" class="headerlink" title="交互设计与界面"></a>交互设计与界面</h1><p>交互的设计上也对比着旧系统，旧系统的组织方式是以部分来划分，原本是可以的，但存在的问题是，现有情况多个部门对于主要的个功能的要求相同，造成前端好几处写了多遍。<br>在这次设计中，并不是从上而下的设计方式，是根据功能使用，自下而上的设计，即先想这个小场景中的功能，应该如何表达，然后画出草图，全部场景设计完全后，将他们聚合在一起的方式。<br>整个设计过程也与队友进行过多次讨论，吸取了他们的意见。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>由产品核心价值定义产品使用场景  </li><li>由产品使用场景定义需求  </li><li>由需求来定义功能，由功能定义业务服务  </li><li>同样由产品使用场景定义交互  </li><li>产品的使用场景亦可以验证交互与需求  </li></ul><p>除此之外，本次的产品，很大程度上是借鉴了旧产品，这方面的空间还有很多，比如现场管理分析、各用户分析，比如竞品分析等</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整个4月大部分时间都处在产品重构的思考与设计中，牺牲了一些正在坚持的习惯，一方面是时间紧张，另一方面自己很大的精力都投入在这些思考与设计中，没有分心的心思。作为一个由设计到开发的转折点，我觉得有必要对这个过程进行一些反思。&lt;/p&gt;
    
    </summary>
    
      <category term="思考" scheme="http://yoursite.com/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>Matrix PositivDefinite</title>
    <link href="http://yoursite.com/2019/05/03/Matrix-PositiveDefinite/"/>
    <id>http://yoursite.com/2019/05/03/Matrix-PositiveDefinite/</id>
    <published>2019-05-03T14:02:34.000Z</published>
    <updated>2019-07-01T02:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>本部分主要研究的是正定，课程包括Lesson25~Lesson28<br>包括：Symmetric matrices and positive definite­ness、Complex matrices and fast Fourier transform、Positive definite matrices and minima、Similar matrices and Jordan form</p><a id="more"></a><h1 id="对称矩阵与正定"><a href="#对称矩阵与正定" class="headerlink" title="对称矩阵与正定"></a>对称矩阵与正定</h1><h2 id="对称矩阵的性质"><a href="#对称矩阵的性质" class="headerlink" title="对称矩阵的性质"></a>对称矩阵的性质</h2><p>A = A<sup>T</sup></p><p>性质：  </p><ul><li>the eigenvalues are real</li><li>the eigenvector are perpendicular even orthonormal</li></ul><p>由此，若A对称，则 A =Q Λ Q<sup>−1</sup> = Q Λ Q<sup>T</sup></p><p>why real eigenvalues?<br>证明思路是从：AX = λX开始，一方面都取共轭，另一方面将原式乘以X的共轭，通过变换，得到λ = λ共轭，得证</p><p>Symmetric matrices with real entries have A =A<sup>T</sup>,  real eigenvalues, and perpendicular eigenvectors.<br>If A has complex entries, then it  will have real eigenvalues and perpendicular eigenvectors if and only if <img src="共轭转置.png" alt="共轭转置"></p><h2 id="对阵矩阵的解释"><a href="#对阵矩阵的解释" class="headerlink" title="对阵矩阵的解释"></a>对阵矩阵的解释</h2><p>A = Q Λ Q<sup>T</sup><br>Q = [q<sub>1</sub>, q<sub>2</sub>… q<sub>n</sub>]<br>展开后得到A = λ<sub>1</sub>q<sub>1</sub>q<sub>1</sub><sup>T</sup> + λ<sub>2</sub>q<sub>2</sub>q<sub>2</sub><sup>T</sup> +…+ λ<sub>n</sub>q<sub>n</sub>q<sub>n</sub><sup>T</sup></p><p>由于q正交，所以q<sub>1</sub>q<sub>1</sub><sup>T</sup>其实是投影矩阵，如此得到，每一个对称阵，其实都是投影的组合。</p><h2 id="关于特征值的符号"><a href="#关于特征值的符号" class="headerlink" title="关于特征值的符号"></a>关于特征值的符号</h2><p>number of positive pivots = number of positive eigenvalues.<br>主元的符号与特征值的符号相同</p><h2 id="正定的定义"><a href="#正定的定义" class="headerlink" title="正定的定义"></a>正定的定义</h2><p>A positive definite matrix is a symmetric matrix A for which all eigenvalues are positive.正定矩阵是所有特征值都是正数的对称矩阵。</p><p>=&gt;  </p><ul><li>所有特征值都是正数  </li><li>所有主元都是正数  </li><li>所有的子行列式(1<em>1,2</em>2..n*n形成的行列式)都是正数</li></ul><h1 id="复数矩阵与FFT"><a href="#复数矩阵与FFT" class="headerlink" title="复数矩阵与FFT"></a>复数矩阵与FFT</h1><h2 id="复数矩阵的特性"><a href="#复数矩阵的特性" class="headerlink" title="复数矩阵的特性"></a>复数矩阵的特性</h2><p>  对于复数向量，取转置运算要变成取共轭转置，或者交Hermite，简写H</p><ul><li><p>复向量的长度<br><img src="复向量长度.png" alt="复向量长度"><br><img src="Hermite.png" alt="Hermite"></p></li><li><p>内积<br>y<sup>T</sup>x =&gt; y<sup>H</sup>x</p></li><li><p>正交<br>Q<sup>H</sup>Q = I，这时候正交Orthogonal 要用 unitary来表达，单位化。</p></li></ul><h2 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h2><ul><li><p>基础形式<br><img src="傅里叶变换1.png" alt="傅里叶变换1"></p></li><li><p>复数矩阵形式<br><img src="傅里叶变换2.png" alt="傅里叶变换2"><br><img src="w定义.png" alt="w定义"></p></li><li><p>n=4例子<br><img src="F4.png" alt="F4"><br><img src="F4结论.png" alt="F4结论">  </p></li></ul><h2 id="FFT"><a href="#FFT" class="headerlink" title="FFT"></a>FFT</h2><p>FFT将傅里叶计算从n<sup>2 =&gt; nlogn  </sup></p><p><img src="FFT.png" alt="FFT"><br>其中<img src="P.png" alt="P">,其作用是将奇数行拿到偶数行的前面<br><img src="D.png" alt="D">  </p><h1 id="正定矩阵性质"><a href="#正定矩阵性质" class="headerlink" title="正定矩阵性质"></a>正定矩阵性质</h1><ul><li><p>最小值<br>对于正定，除了，特征值&gt;0，主元&gt;0，子行列式&gt;0，还有一个X<sup>T</sup>AX &gt; 0<br><img src="正定分析.png" alt="正定分析"><br>如果二次方程一定 &gt; 0，则A正定</p><p><img src="非正定.png" alt="非正定"><br><img src="正定.png" alt="正定">  </p><p>由此得出，正定 =&gt; 有最小值</p><p><img src="Hessian矩阵.png" alt="Hessian矩阵"><br>首先它是对阵的，Its determinant is positive when the matrix is positive definite</p><p><img src="正定多维推广.png" alt="正定多维推广"><br>一个多维的向上的碗，而且全是正的</p></li><li><p>加法<br>if A,B 正定  =&gt; A+B正定</p></li><li><p>推论<br>A<sup>T</sup>A 一定正定， 这里A是m×n 且 rank(A) = n 的矩阵<br>应为其多项式：<img src="正定的一个推理.png" alt="正定的一个推理"></p></li></ul><h1 id="相似矩阵与Jordan式"><a href="#相似矩阵与Jordan式" class="headerlink" title="相似矩阵与Jordan式"></a>相似矩阵与Jordan式</h1><ul><li><p>定义<br>对于A，B两个矩阵，若A = M<sup>-1</sup>BM，则A、B相似</p></li><li><p>性质<br>相似矩阵，拥有相同的特征值，相同数量的独立特征向量（一般不同）</p></li><li><p>重特征值问题<br>以λ<sub>1</sub> = λ<sub>2</sub> = 4 为例<br>可以分成两个famliy:  </p><ol><li><img src="重特征值-1.png" alt="重特征值-1">,这一族比较大  </li><li><img src="重特征值-2.png" alt="重特征值-2">，这一族只有这一个矩阵，因为它与任何M相乘都会返回自身  </li></ol></li><li><p>Jordan matrix<br>简单的说，对于重特征值问题，它们需要有相同的Jordan blocks的形式.<br><img src="Jordan-blocks.png" alt="Jordan-blocks"><br><img src="Jordan-blocks一般形式.png" alt="Jordan-blocks一般形式"><br>其中<img src="Jordan-blocks一般形式2.png" alt="Jordan-blocks一般形式2">，这里，对角线上都是特征值，下方都是0，上方跟随一层1.</p><p><img src="概括Jordan.png" alt="概括Jordan"><br>这样，不同的特征值情况可以认为是一种特殊的Jordan Matrix，它们的Jordan Block都是为1*1的特征值本身</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本部分主要研究的是正定，课程包括Lesson25~Lesson28&lt;br&gt;包括：Symmetric matrices and positive definite­ness、Complex matrices and fast Fourier transform、Positive definite matrices and minima、Similar matrices and Jordan form&lt;/p&gt;
    
    </summary>
    
      <category term="理论" scheme="http://yoursite.com/categories/%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="Matrix" scheme="http://yoursite.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>nest.js记录</title>
    <link href="http://yoursite.com/2019/05/03/nest%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/05/03/nest记录/</id>
    <published>2019-05-03T06:45:39.000Z</published>
    <updated>2019-07-01T02:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文为理解nest.js而做记录，内容为官网中的基础部分，目的是为了理解、记忆，所以不会抄原文的例子。<br><a href="https://docs.nestjs.com/" target="_blank" rel="noopener">官网</a>  </p><a id="more"></a><h1 id="骨架"><a href="#骨架" class="headerlink" title="骨架"></a>骨架</h1><p>骨架部分主要介绍：Controllers、Providers、Modules，他们组成了nest应用的最基础部分，可以认为Route Handler部分</p><h2 id="Controllers"><a href="#Controllers" class="headerlink" title="Controllers"></a>Controllers</h2><ul><li><p>定义<br>Controllers are responsible for handling incoming requests and returning responses to the client.</p></li><li><p>路由<br>分层的定义方法，在类上定义的，被其下的方法所继承，如在类上定义<code>@Controller(&#39;customers&#39;)</code>，在类方法中定义<code>@Get(&#39;profile&#39;)</code>，则其路由为<code>GET /customers/profile</code></p></li><li><p>两种模式<br>一种是标准模式，也是推荐模式，通过nest的装饰器来使用各种参数;<br>另一种原生模式（Library-specific），通过@Res(),@Req()获取库原生的request与response对象，来直接进行操作。<br>这两种方式不能同时使用，当然nest推荐前者。</p></li><li><p>装饰器  </p></li></ul><table><thead><tr><th style="text-align:left">装饰器</th><th style="text-align:center">介绍</th></tr></thead><tbody><tr><td style="text-align:left">@Req()</td><td style="text-align:center">获取Request对象(express)</td></tr><tr><td style="text-align:left">@Res()</td><td style="text-align:center">获取Response对象(express)</td></tr><tr><td style="text-align:left">@Session()</td><td style="text-align:center">获取req.session</td></tr><tr><td style="text-align:left">@Param(key?: string)</td><td style="text-align:center">req.params / req.params[key],param是路由中的参数</td></tr><tr><td style="text-align:left">@Body(key?: string)</td><td style="text-align:center">req.body / req.body[key]</td></tr><tr><td style="text-align:left">@Query(key?: string)</td><td style="text-align:center">req.query / req.query[key],query是?后的参数</td></tr><tr><td style="text-align:left">@Headers(name?: string)</td><td style="text-align:center">req.headers / req.headers[name]</td></tr><tr><td style="text-align:left">@HttpCode(201)</td><td style="text-align:center">指定response中的返回值</td></tr></tbody></table><h2 id="Providers"><a href="#Providers" class="headerlink" title="Providers"></a>Providers</h2><ul><li><p>定义<br>Many of the basic Nest classes may be treated as a provider – services, repositories, factories, helpers, and so on. A provider is simply a class annotated with an @Injectable() decorator  </p></li><li><p>理解<br>这里说的很明白的，provider可以理解成功能的提供者了,任何可以注入的类都可以认为是provider。原文中也说，provider不仅仅是@Injectable(),它可以是数值、类、同步或异步工厂(plain values, classes, and either asynchronous or synchronous factories)，这个在后边的Custom Provider中会做更多介绍  </p></li></ul><h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h2><ul><li><p>定义<br>A module is a class annotated with a @Module() decorator. The @Module() decorator provides metadata that Nest makes use of to organize the application structure.  </p></li><li><p>理解<br>Module要做一点解释，Nest是Module来组织的，不论是Controller还是Provider都需要注册到Module中才能被Nest托管。还有一点比较有趣的，在Module中可以imports其他Module，而imports的内容，其实是被引用Module中exports出的内容</p></li><li><p>属性<br>@Module装饰器接收一个对象，其属性包括</p></li></ul><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:center">介绍</th></tr></thead><tbody><tr><td style="text-align:left">providers</td><td style="text-align:center">被Nest injector实例化的providers</td></tr><tr><td style="text-align:left">controllers</td><td style="text-align:center">被Nest injector实例化的controllers</td></tr><tr><td style="text-align:left">imports</td><td style="text-align:center">引入这些moludes export 的providers</td></tr><tr><td style="text-align:left">exports</td><td style="text-align:center">providers的子集，被其他模块可以import</td></tr></tbody></table><h1 id="经脉"><a href="#经脉" class="headerlink" title="经脉"></a>经脉</h1><p>经脉介绍中间件(Middleware)、异常过滤器(Exception filters)、管道(Pipes)、哨兵(Guards)、拦截器(Interceptors)。我觉得广义上看，他们都可以被称为拦截器，他们要么在拦截request（Middleware,Pipe，Guard），要么在拦截response(Exception filter)，要么双方都拦截（Interceptors）。<br>它们有着类似的scope，包括：全局(global)、控制器（controller）、路由函数(router)，其实隐藏着模块（module）等范围</p><h2 id="Middleware"><a href="#Middleware" class="headerlink" title="Middleware"></a>Middleware</h2><ul><li><p>定义<br>Middleware is a function which is called before the route handler. Middleware functions have access to the request and response objects, and the next() middleware function in the application’s request-response cycle.<br><img src="middleware.png" alt="middleware"></p></li><li><p>理解<br>中间件常见的场景包括，Log，cors，helmet等，中间件的使用上，主要在routers,controllers,module范围内，原文中没有在全局使用中间件。</p></li></ul><h2 id="Exception-filters"><a href="#Exception-filters" class="headerlink" title="Exception filters"></a>Exception filters</h2><ul><li><p>定义<br>Nest comes with a built-in exceptions layer which is responsible for processing all unhandled exceptions across an application. When an exception is not handled by your application code, it is caught by this layer, which then automatically sends an appropriate user-friendly response.</p><p><img src="pipe与filter.png" alt="filter"></p></li><li><p>理解<br>从定义中可以看出，它是在request上，进行filter，当服务端有异常抛出，对异常进行捕获、处理，并返回给客户端。<br>异常过滤器4种使用方式都支持，这部分可以写一些异常处理的代码，定义好Exception 与 exception 与 filter，然后在代码中可以方便的抛异常了。</p><p><a href="https://docs.nestjs.com/exception-filters#exception-filters-1" target="_blank" rel="noopener">Exception filters</a></p></li></ul><h2 id="Pipes"><a href="#Pipes" class="headerlink" title="Pipes"></a>Pipes</h2><ul><li><p>定义<br>A pipe is a class annotated with the @Injectable() decorator. Pipes should implement the PipeTransform interface.<br>原文可能觉得pipe真不用定义了，所以也没有定义，就是函数编程范式pipe，其实跟中间件、拦截器都一样.<br><img src="pipe与filter.png" alt="pipe"></p></li><li><p>使用场景  </p><ul><li>transformation: transform input data to the desired output  </li><li>validation: evaluate input data and if valid, simply pass it through unchanged; otherwise, throw an exception when the data is incorrect</li></ul><p>就是数据转换与有效性检验。这一部分集成化比较高，通过class-validator and class-transformer可以直接使用ValidationPipe，ParseIntPipe了，支持4种使用方式</p></li></ul><h2 id="Guards"><a href="#Guards" class="headerlink" title="Guards"></a>Guards</h2><ul><li><p>定义<br>A guard is a class annotated with the @Injectable() decorator. Guards should implement the CanActivate interface.<br><a href="guard.png">guard</a><br>Guards have a single responsibility. They determine whether a given request will be handled by the route handler or not, depending on certain conditions (like permissions, roles, ACLs, etc.) present at run-time. This is often referred to as authorization。<br>在express中，认证由中间件来做，原文中有对为什么用guard而不用middleware的解释，大约就是middleware你需要控制next，并且不知道next的下一步是什么，而guard由于有执行环境（ExecutionContext），可以清楚的知道下一步执行什么。</p></li><li><p>理解<br>4种使用方式都支持。<br>这里使用了reflect，因为对于guard，它需要知道定义在每个router的角色<br><a href="https://docs.nestjs.com/guards#putting-it-all-together" target="_blank" rel="noopener">实例</a><br>这个部分要好好写一下，与原文中的例子略有不同，原文中认证的角色，我们要认证权限  </p></li></ul><h2 id="Interceptors"><a href="#Interceptors" class="headerlink" title="Interceptors"></a>Interceptors</h2><ul><li><p>定义<br>An interceptor is a class annotated with the @Injectable() decorator. Interceptors should implement the NestInterceptor interface.<br><img src="Interceptors.png" alt="Interceptors">  </p></li><li><p>理解<br>支持4种使用方式。通过next.handle()来调用主体，然后在pipe中对返回进行处理。在piple中可以对response进行处理，可以对异常进行处理等。<br>应用场景比如通过记录每个调用的入口、出口时间来计算响应时间，对response中数据的处理，对异常的处理等。<br>Interceptor可以对前后两端的处理，由于入口侧的验证、转换、认证都有特殊的解决方案了，所以我觉得它更注重出口侧一些，以及更注重业务逻辑一些。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 中间件的实现可能与其他略有不同，Exception filter，pipe,guard简直就是interception在各应用场景的细化。<br> 在使用上，需要对异常处理(Exception Filter)、参数验证(Pipe)、权限认证(Guard)、日志(Middleware/Interceptor)、监控(Interceptor)等，都可以用到.</p><h1 id="套路"><a href="#套路" class="headerlink" title="套路"></a>套路</h1><h2 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h2><p>这里的认证，并不是权限认证，而是主要是对客户端的认证，这里只记录jwt方式，认证主要使用Passport模块</p><ul><li><p>过程<br>客户端进行登录，后端核对完用户名、密码之后，创一个token给浏览器，浏览器之后在header(cookie与Authorization其实都行)中一直带着，来做http状态的认证。</p></li><li><p>理解<br>因为后端要验证用户名、密码，以及生成token，就需要一个Service来做这件事情，而passport本身支持‘bearer’,‘jwt’等不同策略，也就需要一个Strategy来解耦不同策略，而这个策略本身要依赖那个验证的Service。Strategy完成的是对token的解析，调用Service去验证，其统一的接口应该validate()函数。<br>在Strategy的使用上，即Strategy如何被nest使用，这里只能做一个推测，其通过Module的providers属性注入到nest中，nest在注册PassportModule时，自动将注册的Strategy注册到Passport当中，并完成jwt认证过程。<br>在使用上，通过Passport提供的AuthGuard来使用，这样就与Guard联系到了一起。</p><p>本质上讲，Passport也是一种Guard，更本质，就是一前置拦截器。</p></li></ul><h2 id="Database-ORM"><a href="#Database-ORM" class="headerlink" title="Database/ORM"></a>Database/ORM</h2><p>这里的ORM使用的TypeORM<br><a href="https://typeorm.io/" target="_blank" rel="noopener">ypeORM</a></p><ul><li><p>概念<br>这里需要注意的概念包括：  </p><ul><li><p>连接(Connection)<br>在这里连接的建立，使用过在ApplicationModule中，import TypeOrmModule.forRoot()来建立的，forRoot的参数就是一个数据库连接必备的字段。连接本身有name属性，缺省为’default’，这在多连接建立时会需要。</p></li><li><p>实体(Entity)<br>实体就是Model层，需要指定类属性对应的表结构，并指定one2Many/Many2One等与其他实体的关系</p></li><li><p>实体管理器(EntityManager)<br>Using EntityManager you can manage (insert, update, delete, load, etc.) any entity. EntityManager is just like a collection of all entity repositories in a single place  </p><p>实体管理器是对所有实体进行管理，它是Repository的一个集合</p></li><li><p>库(Repository)<br>Repository is just like EntityManager but its operations are limited to a concrete entity</p><p>Repository是对单个实体进行管理</p></li></ul></li><li><p>使用<br>需要在Module中imports TypeOrmModule.forFeature([Photo])，这个forFeature应该是获取Photo实体所对应的Repository，进而在Service中就可以使用Repository来操作实体了。<br>在TypeORM官网中，可以通过Connection来直接获取Repository，在nest中介绍的并不详细。<br>应该是在forRoot时，指明连接的名字，然后在Service中通过InjectConnection(‘连接名’)，来注入连接，通过@InjectEntityManager(‘连接名’)来注入实体管理器entityManager。</p></li></ul><h1 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h1><h2 id="Custom-providers"><a href="#Custom-providers" class="headerlink" title="Custom providers"></a>Custom providers</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为理解nest.js而做记录，内容为官网中的基础部分，目的是为了理解、记忆，所以不会抄原文的例子。&lt;br&gt;&lt;a href=&quot;https://docs.nestjs.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网&lt;/a&gt;  &lt;/p&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
      <category term="nest.js" scheme="http://yoursite.com/tags/nest-js/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统设计模式</title>
    <link href="http://yoursite.com/2019/04/19/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/04/19/分布式系统设计模式/</id>
    <published>2019-04-18T23:25:35.000Z</published>
    <updated>2019-07-01T02:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章来整理《左耳听风》栏目的分布式设计模式弹力设计、管理设计、性能设计篇，并根据当下情况，借鉴一二</p><a id="more"></a><h1 id="弹力设计"><a href="#弹力设计" class="headerlink" title="弹力设计"></a>弹力设计</h1><h2 id="隔离设计-Bulkheads"><a href="#隔离设计-Bulkheads" class="headerlink" title="隔离设计 Bulkheads"></a>隔离设计 Bulkheads</h2><ul><li><p>背景<br>这个设计借鉴了船舱通过隔板来把船隔成几个独立空间，防止一点进水蔓延到整个船只。</p></li><li><p>2种隔离方法  </p><ul><li><p>按服务的种类来做隔离<br>如用户注册、商品中心、社交服务，将他们独立成各自的服务，并独占各自自己的DB<br>总会面对获取多个板块数据的情况，这样会调用多个服务，对于这样的问题，一般来说，我们需要小心地设计用户交互，最好不要让用户在一个页面上获得所有的数据。对。<br>业务跨板块时，控制就有点复杂。对此我们需要一个类似于 Pub/Sub 的高可用的并可以持久化的消息订阅通知的中间件来打通各个版块的数据和信息交换。最后还会有在多个版块中分布式事务的问题。对此，我们需要“二阶段提交”这样的方案。在亚马逊中，使用的是 Plan – Reserve – Commit/Cancel 模式。  </p></li><li><p>多租户：按用户的请求来分离<br>将用户分成不同的组，并把后端的同一个服务根据这些不同的组分成不同的实例。让同一个服务对于不同的用户进行冗余和隔离，这样一来，当服务实例挂掉时，只会影响其中一部分用户，而不会导致所有的用户无法访问。<br>做法有：<br>完全独立的设计。每个租户有自己完全独立的服务和数据。<br>独立的数据分区，共享的服务。多租户的服务是共享的，但数据是分开隔离的。<br>共享的服务，共享的数据分区。每个租户的数据和服务都是共享的。<br>一般会选择折中方案，服务是共享的，数据通过分区来隔离。</p></li></ul></li><li><p>重点<br>隔离模式需要配置一些高可用、重试、异步、消息中间件，流控、熔断等设计模式的方式配套使用。</p></li><li><p>课外<br>在虚拟化技术非常成熟的今天，我们完全可以使用“完全独立”（完全隔离）的方案，通过底层的虚拟化技术（Hypervisor 的技术，如 KVM，或是 Linux Container 的技术，如 Docker）来实现物理资源的共享和成本的节约。</p></li></ul><h2 id="异步通讯设计-Asynchronous"><a href="#异步通讯设计-Asynchronous" class="headerlink" title="异步通讯设计 Asynchronous"></a>异步通讯设计 Asynchronous</h2><ul><li><p>异步通讯的3种方式  </p><ul><li><p>请求响应式<br>直接REST调用  </p></li><li><p>通过订阅的方式<br>订阅者模式，接收方（receiver）会来订阅发送方（sender）的消息，发送方会把相关的消息或数据放到接收方所订阅的队列中，而接收方会从队列中获取数据。<br>这种情况下接收方需要想发送方订阅事件</p></li><li><p>通过中间人的方式<br>这是完整版的订阅者模式，发送方（sender）和接收方（receiver）都互相看不到对方，它们看得到的是一个 Broker，发送方向 Broker 发送消息，接收方向 Broker 订阅消息。如下图所示。<br><img src="broker方式.png" alt="broker方式"></p></li></ul></li><li><p>事件驱动  </p><p><img src="时间驱动.png" alt="时间驱动"><br>每个服务都是“自包含”的。所谓“自包含”也就是没有和别人产生依赖。而要把整个流程给串联起来，我们需要一系列的“消息通道（Channel）”。各个服务做完自己的事后，发出相应的事件，而又有一些服务在订阅着某些事件来联动。<br>这好处与遇到问题，与隔离设计其实是相同的。</p><p>需要消息跟踪：异步通讯会导致业务处理流程不那么直观，因为像接力一样，所以在 Broker 上需要有相关的服务消息跟踪机制，否则出现问题后不容易调试。<br>需要工作流引擎：因为服务间只通过消息交互，所以业务状态最好由一个总控方来管理，这个总控方维护一个业务流程的状态变迁逻辑，以便系统发生故障后知道业务处理到了哪一步，从而可以在故障清除后继续处理。  </p></li></ul><h2 id="幂等设计-Idempotency"><a href="#幂等设计-Idempotency" class="headerlink" title="幂等设计 Idempotency"></a>幂等设计 Idempotency</h2><ul><li><p>定义<br>所谓幂等性设计，就是说，一次和多次请求某一个资源应该具有同样的副作用。用数学的语言来表达就是：f(x)  = f(f(x))。<br>为什么我们需要这样的操作？说白了，就是在我们把系统解耦隔离后，服务间的调用可能会有三个状态，一个是成功（Success），一个是失败（Failed），一个是超时（Timeout）。前两者都是明确的状态，而超时则是完全不知道是什么状态。因为系统超时，而调用户方重试一下，会给我们的系统带来不一致的副作用。</p></li><li><p>全局ID<br>要做到幂等性的交易接口，需要有一个唯一的标识，来标志交易是同一笔交易。而这个交易 ID 由谁来分配是一件比较头疼的事。因为这个标识要能做到全局唯一。<br>算法详见： Twitter 的开源项目 Snowflake</p></li><li><p>处理流程<br>对于幂等性的处理流程来说，说白了就是要过滤一下已经收到的交易。要做到这个事，我们需要一个存储来记录收到的交易。于是，当收到交易请求的时候，我们就会到这个存储中去查询。如果查找到了，那么就不再做查询了，并把上次做的结果返回。如果没有查到，那么我们就记录下来。<br>所以，最好是当这个存储出现冲突的时候会报错。也就是说，我们收到交易请求后，直接去存储里记录这个 ID（相对于数据的 Insert 操作），如果出现 ID 冲突了的异常，那么我们就知道这个之前已经有人发过来了，所以就不用再做了。比如，数据库中你可以使用。<br>对于更新的场景来说，如果只是状态更新，可以使用如下的方式。如果出错，要么是非法操作，要么是已被更新，要么是状态不对，总之多次调用是不会有副作用的。</p></li><li><p>HTTP幂等性<br>Post不具备幂等性，处理如下：<br>首先，在表单中需要隐藏一个 token，这个 token 可以是前端生成的一个唯一的 ID。用于防止用户多次点击了表单提交按钮，而导致后端收到了多次请求，却不能分辨是否是重复的提交。这个 token 是表单的唯一标识。（这种情况其实是通过前端生成 ID 把 POST 变成了 PUT。）<br>然后，当用户点击提交后，后端会把用户提示的数据和这个 token 保存在数据库中。如果有重复提交，那么数据库中的 token 会做排它限制，从而做到幂等性。<br>当然，更为稳妥的做法是，后端成功后向前端返回 302 跳转，把用户的前端页跳转到 GET 请求，把刚刚 POST 的数据给展示出来。如果是 Web 上的最好还把之前的表单设置成过期，这样用户不能通过浏览器后退按钮来重新提交。这个模式又叫做。[对于前端渲染的方式，需要前端来控制]</p></li></ul><h2 id="重试设计-Retry"><a href="#重试设计-Retry" class="headerlink" title="重试设计 Retry"></a>重试设计 Retry</h2><ul><li><p>场景<br>“重试”的语义是我们认为这个故障是暂时的，而不是永久的，所以，我们会去重试<br>我认为，设计重试时，我们需要定义出什么情况下需要重试，例如，调用超时、被调用端返回了某种可以重试的错误（如繁忙中、流控中、维护中、资源不足等）。<br>而对于一些别的错误，则最好不要重试，比如：业务级的错误（如没有权限、或是非法数据等错误），技术上的错误（如：HTTP 的 503 等，这种原因可能是触发了代码的 bug，重试下去没有意义）。</p></li><li><p>策略<br>关于重试的设计，一般来说，都需要有个重试的最大值，经过一段时间不断的重试后，就没有必要再重试了，应该报故障了。在重试过程中，每一次重试失败时都应该休息一会儿再重试，这样可以避免因为重试过快而导致网络上的负担加重。<br>在重试的设计中，我们一般都会引入，Exponential Backoff 的策略，也就是所谓的 “ 指数级退避 “。在这种情况下，每一次重试所需要的休息时间都会成倍增加。这种机制主要是用来让被调用方能够有更多的时间来从容处理我们的请求。这其实和 TCP 的拥塞控制有点像。  </p><p>例如，我们定义一个调用返回的枚举类型，其中包括了 5 种返回错误——成功 SUCCESS、维护中 NOT_READY、流控中 TOO_BUSY、没有资源 NO_RESOURCE、系统错误 SERVER_ERROR。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Results &#123;</span><br><span class="line">  SUCCESS,</span><br><span class="line">  NOT_READY,</span><br><span class="line">  TOO_BUSY,</span><br><span class="line">  NO_RESOURCE,</span><br><span class="line">  SERVER_ERROR</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>spring的重试方法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Retryable</span>(</span><br><span class="line">    value = &#123; SQLException.class &#125;,</span><br><span class="line">    maxAttempts = <span class="number">2</span>,</span><br><span class="line">    backoff = <span class="meta">@Backoff</span>(delay = <span class="number">5000</span>))</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">retryService</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设计重点<br>重试的代码比较简单也比较通用，完全可以不用侵入到业务代码中。这里有两个模式。一个是代码级的，像 Java 那样可以使用 Annotation 的方式（在 Spring 中你可以用到这样的注解），如果没有注解也可以包装在底层库或是 SDK 库中不需要让上层业务感知到。另外一种是走 Service Mesh 的方式（关于 Service Mesh 的方式，我会在后面的文章中介绍）。<br>对于有事务相关的操作。我们可能会希望能重试成功，而不至于走业务补偿那样的复杂的回退流程。对此，我们可能需要一个比较长的时间来做重试，但是我们需要保存请求的上下文，这可能对程序的运行有比较大的开销，因此，有一些设计会先把这样的上下文暂存在本机或是数据库中，然后腾出资源来做别的事，过一会再回来把之前的请求从存储中捞出来重试。</p></li></ul><h2 id="补偿设计-Compensating-Transaction"><a href="#补偿设计-Compensating-Transaction" class="headerlink" title="补偿设计 Compensating Transaction"></a>补偿设计 Compensating Transaction</h2><ul><li>前沿<br>既然要分布式，必须要分离，隔离的服务之间通信要用异步的来解耦开，然后可能会存在通信异常，就需要重试，重试时不想被重试操作多次，也就需要幂等，更重要的一个问题是如果业务走不下去怎么办？那就是本节的补偿，如果前边几种是正流程，那么补偿就是逆流程。  </li><li><p>ACID 和 BASE<br>这里先做一点解释，这两个概念其实是tradeoff，严格必然不会繁荣，繁荣必然存在瑕疵。<br>有必要先说一下 ACID 和 BASE 的差别。传统关系型数据库系统的事务都有 ACID 属性，即原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。<br>为了提高性能，出现了 ACID 的一个变种 BASE。可以看到，BASE 系统是允许或是容忍系统出现暂时性问题的，这样一来，我们的系统就能更有弹力。因为我们知道，在分布式系统的世界里，故障是不可避免的，我们能做的就是把故障处理当成功能写入代码中，这就是 Design for Failure。</p></li><li><p>业务补偿<br>一般来说，业务的事务补偿都是需要一个工作流引擎的。亚马逊是一个超级喜欢工作流引擎的公司，这个工作流引擎把各式各样的服务给串联在一起，并在工作流上做相应的业务补偿，整个过程设计成为最终一致性的。<br>对于业务补偿来说，首先需要将服务做成幂等性的，如果一个事务失败了或是超时了，我们需要不断地重试，努力地达到最终我们想要的状态。然后，如果我们不能达到这个我们想要的状态，我们需要把整个状态恢复到之前的状态。另外，如果有变化的请求，我们需要启动整个事务的业务更新机制。</p><p>一个好的业务补偿机制需要做到下面这几点：<br>要能清楚地描述出要达到什么样的状态（比如：请假、机票、酒店这三个都必须成功，租车是可选的），以及如果其中的条件不满足，那么，我们要回退到哪一个状态。这就是所谓的整个业务的起始状态定义。<br>当整条业务跑起来的时候，我们可以串行或并行地做这些事。对于旅游订票是可以并行的，但是对于网购流程（下单、支付、送货）是不能并行的。总之，我们的系统需要努力地通过一系列的操作达到一个我们想要的状态。如果达不到，就需要通过补偿机制回滚到之前的状态。这就是所谓的状态拟合。<br>对于已经完成的事务进行整体修改，可以考虑成一个修改事务。  </p><p>我们需要小心维护和监控整个过程的状态，所以，千万不要把这些状态放到不同的组件中，最好是一个业务流程的控制方来做这个事，也就是一个工作流引擎。所以，这个工作流引擎是需要高可用和稳定的。这就好像旅行代理机构一样，我们把需求告诉它，它会帮我们搞定所有的事。如果有问题，也会帮我们回滚和补偿的。<br>下层的业务方最好提供短期的资源预留机制。就像电商中的把货品的库存预先占住等待用户在 15 分钟内支付。如果没有收到用户的支付，则释放库存。然后回滚到之前的下单操作，等待用户重新下单。</p></li></ul><h2 id="熔断设计-Circuit-Breaker"><a href="#熔断设计-Circuit-Breaker" class="headerlink" title="熔断设计 Circuit Breaker"></a>熔断设计 Circuit Breaker</h2><p>先简单描述  </p><ul><li><p>定义<br>熔断器模式可以防止应用程序不断地尝试执行可能会失败的操作，使得应用程序继续执行而不用等待修正错误，或者浪费 CPU 时间去等待长时间的超时产生。熔断器模式也可以使应用程序能够诊断错误是否已经修正。如果已经修正，应用程序会再次尝试调用操作。</p><p>由此可见，重试的次数显示实在前端的一种控制，这里的熔断实在后端，更确切说是网关的控制</p></li><li><p>示意图<br><img src="熔断示意图.png" alt="熔断示意图"></p></li><li><p>状态<br><img src="熔断状态转换.png" alt="熔断状态转换"></p><ul><li><p>closed，通畅状态<br>我们需要一个调用失败的计数器，如果调用失败，则使失败次数加 1。如果最近失败次数超过了在给定时间内允许失败的阈值，则切换到断开 (Open) 状态。此时开启了一个超时时钟，当该时钟超过了该时间，则切换到半断开（Half-Open）状态。该超时时间的设定是给了系统一次机会来修正导致调用失败的错误，以回到正常工作的状态。在 Closed 状态下，错误计数器是基于时间的。在特定的时间间隔内会自动重置。这能够防止由于某次的偶然错误导致熔断器进入断开状态。也可以基于连续失败的次数。  </p></li><li><p>open，断开状态<br>在该状态下，对应用程序的请求会立即返回错误响应，而不调用后端的服务。这样也许比较粗暴，有些时候，我们可以 cache 住上次成功请求，直接返回缓存（当然，这个缓存放在本地内存就好了），如果没有缓存再返回错误（缓存的机制最好用在全站一样的数据，而不是用在不同的用户间不同的数据，因为后者需要缓存的数据有可能会很多）。</p></li><li><p>Half-open，半开状态<br>允许应用程序一定数量的请求去调用服务。如果这些请求对服务的调用成功，那么可以认为之前导致调用失败的错误已经修正，此时熔断器切换到闭合状态，同时将错误计数器重置。</p></li></ul></li><li><p>课外<br> Netflix 的Hystrix开源项目</p></li></ul><h2 id="限流设计-Throttle"><a href="#限流设计-Throttle" class="headerlink" title="限流设计 Throttle"></a>限流设计 Throttle</h2><ul><li><p>定义<br>保护系统不会在过载的情况下出现问题，需要通过对并发访问进行限速，相关的策略一般是，一旦达到限制的速率，那么就会触发相应的限流行为。包括：拒绝服务、服务降级、特权请求、延时请求等</p></li><li><p>3种实现方式  </p><ul><li><p>计数器方式<br>最简单的限流算法就是维护一个计数器 Counter，当一个请求来时，就做加一操作，当一个请求处理完后就做减一操作。如果这个 Counter 大于某个数了（我们设定的限流阈值），那么就开始拒绝请求以保护系统的负载了。可以增加对特权用户增加新的队列，来完成对不同用户的控制。<br><img src="计数限流.png" alt="计数限流"><br><img src="队列限流.png" alt="队列限流"></p></li><li><p>漏斗方式<br>我们可以看到，就像一个漏斗一样，进来的水量就好像访问流量一样，而出去的水量就像是我们的系统处理请求一样。当访问流量过大时这个漏斗中就会积水，如果水太多了就会溢出。<br>一般来说，这个“漏斗”是用一个队列来实现的，当请求过多时，队列就会开始积压请求，如果队列满了，就会开拒绝请求。很多系统都有这样的设计，比如 TCP。当请求的数量过多时，就会有一个 sync backlog 的队列来缓冲请求，或是 TCP 的滑动窗口也是用于流控的队列。<br><img src="漏斗限流方式.png" alt="漏斗限流方式">  </p></li><li><p>令牌桶方式<br>关于令牌桶算法，主要是有一个中间人。在一个桶内按照一定的速率放入一些 token，然后，处理程序要处理请求时，需要拿到 token，才能处理；如果拿不到，则不处理。<br><img src="令牌桶限流方式.png" alt="令牌桶限流方式"></p></li><li><p>基于响应时间的动态限流<br>这其实是将限流加了负反馈回路<br>上面的算法有个不好的地方，就是需要设置一个确定的限流值。这就要求我们每次发布服务时都做相应的性能测试，找到系统最大的性能值。<br>我们想使用一种动态限流的方式。这种方式，不再设定一个特定的流控值，而是能够动态地感知系统的压力来自动化地限流。这方面设计的典范是 TCP 协议的拥塞控制的算法。TCP 使用 RTT - Round Trip Time 来探测网络的延时和性能，从而设定相应的“滑动窗口”的大小，以让发送的速率和网络的性能相匹配。这个算法是非常精妙的，我们完全可以借鉴在我们的流控技术中。</p></li></ul></li><li><p>课外<br>tcp的限流方式</p></li></ul><h2 id="降级设计-Degradation"><a href="#降级设计-Degradation" class="headerlink" title="降级设计 Degradation"></a>降级设计 Degradation</h2><ul><li><p>定义<br>所谓的降级设计（Degradation），本质是为了解决资源不足和访问量过大的问题。当资源和访问量出现矛盾的时候，在有限的资源下，为了能够扛住大量的请求，我们就需要对系统进行降级操作。也就是说，暂时牺牲掉一些东西，以保障整个系统的平稳运行。  </p></li><li><p>方法</p><ul><li><p>停止次要功能<br>停止次要的功能也是一种非常有用的策略。把一些不重要的功能给暂时停止掉，让系统释放出更多的资源来。比如，电商中的搜索功能，用户的评论功能，等等。等待访问的峰值过去后，我们再把这些功能给恢复回来。  </p></li><li><p>简化功能<br>关于功能的简化上，上面的下单流程中已经提到过相应的例子了。而且，从缓存中返回数据也是其中一个。这里再提一个，就是一般来说，一个 API 会有两个版本，一个版本返回全量数据，另一个版本只返回部分或最小的可用的数据。  </p></li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>分布式核心就是分，就是隔离服务<br>联系起来整理，才发现这一系列的脉络，整个分布式系统有两条流程，一条是正向流程、一条是反向流程。<br>正向流程中包括，分解服务、异步通讯、重试、幂等<br>反向流程指的是补偿设计<br>为了保护正反向流程不被流量压跨，又有了3个保护设计：熔断、限流、降级</p><h1 id="管理设计"><a href="#管理设计" class="headerlink" title="管理设计"></a>管理设计</h1><h2 id="分布式锁-Distributed-Lock"><a href="#分布式锁-Distributed-Lock" class="headerlink" title="分布式锁 Distributed Lock"></a>分布式锁 Distributed Lock</h2><p>先简化写了</p><ul><li><p>定义<br>我们知道，在多线程情况下访问一些共享资源需要加锁，不然就会出现数据被写乱的问题。在分布式系统下，这样的问题也是一样的。只不过，我们需要一个分布式的锁服务。对于分布式的锁服务，一般可以用数据库 DB、Redis 和 ZooKeeper 等实现。不管怎么样，分布式的锁服务需要有以下几个特点。  </p></li><li><p>redis分布式锁<br><code>SET resource_name my_random_value NX PX 30000</code></p></li><li><p>redis分布式锁的问题</p></li><li><p>解决方案</p><ul><li>版本号</li><li>fence token</li></ul></li><li><p>课外<br>细心的你一定发现了，这不就是计算机汇编指令中的原子操作 CAS（Compare And Swap）嘛，大量无锁的数据结构都需要用到这个。（关于 CAS 的话题，你可以看一下我在 CoolShell 上写的</p></li></ul><h2 id="配置中心-Configuration-Management"><a href="#配置中心-Configuration-Management" class="headerlink" title="配置中心 Configuration Management"></a>配置中心 Configuration Management</h2><p>先简写了，这个跟杨波老师的配置中心一个概念，不过引出了下边3节的内容</p><ul><li><p>配置区分<br>有一种方式是把软件的配置分成静态配置和动态配置。<br>静态配置：所谓静态配置其实就是在软件启动时的一些配置，运行时基本不会进行修改，也可以理解为是环境或软件初始化时需要用到的配置。如，操作系统的网络配置，软件运行时 Docker 进程的配置，这些配置在软件环境初始化时就确定了，未来基本不会修改了<br>动态配置：就是软件运行时的一些配置，在运行时会被修改。比如，日志级别、降级开关、活动开关。</p></li><li><p>架构<br><img src="配置中心.png" alt="配置中心"></p></li></ul><h2 id="边车模式-SideCar"><a href="#边车模式-SideCar" class="headerlink" title="边车模式 SideCar"></a>边车模式 SideCar</h2><ul><li><p>定义<br>边车就有点像一个服务的 Agent，这个服务所有对外的进出通讯都通过这个 Agent 来完成。这样，我们就可以在这个 Agent 上做很多文章了。但是，我们需要保证的是，这个 Agent 要和应用程序一起创建，一起停用。</p><p>编程的本质就是将控制和逻辑分离和解耦，而边车模式也是异曲同工，同样是让我们在分布式架构中做到逻辑和控制分离。</p></li><li><p>讨论<br>对于监视、日志、限流、熔断、服务注册、协议转换等等这些功能，其实都是大同小异，甚至是完全可以做成标准化的组件和模块的。一般来说，我们有两种方式：<br>一种是通过 SDK、Lib 或 Framework 软件包方式，在开发时与真实的应用服务集成起来。性能高，但对应用有侵入<br>另一种是通过像 Sidecar 这样的方式，在运维时与真实的应用服务集成起来。性能低，无需改应用，增加了依赖，也做到了逻辑与控制的分离。  </p><p>其实一种是在代码层面解决，一种是在服务层面解决</p></li><li><p>结构<br><img src="边车模式.png" alt="边车模式"></p></li><li><p>特点<br>我们知道，熔断、路由、服务发现、计量、流控、监视、重试、幂等、鉴权等控制面上的功能，以及其相关的配置更新，本质来上来说，和服务的关系并不大。但是传统的工程做法是在开发层面完成这些功能，这就会导致各种维护上的问题，而且还会受到特定语言和编程框架的约束和限制。<br>而随着系统架构的复杂化和扩张，我们需要更统一地管理和控制这些控制面上的功能，所以传统的在开发层面上完成控制面的管理会变得非常难以管理和维护。这使得我们需要通过 Sidecar 模式来架构我们的系统。  </p></li></ul><h2 id="服务网格-Service-Mesh"><a href="#服务网格-Service-Mesh" class="headerlink" title="服务网格 Service Mesh"></a>服务网格 Service Mesh</h2><ul><li><p>背景<br>将边车模式发扬广大，是 CNCF（Cloud Native Computing Foundation，云原生计算基金会）目前主力推动的新一代的微服务架构——Service Mesh 服务网格。<br>Service Mesh 这个服务网络专注于处理服务和服务间的通讯。其主要负责构造一个稳定可靠的服务通讯的基础设施，并让整个架构更为的先进和 Cloud Native。在工程中，Service Mesh 基本来说是一组轻量级的服务代理和应用逻辑的服务在一起，并且对于应用服务是透明的。  </p></li><li><p>示意图<br><img src="service_mesh.png" alt="service_mesh"><br><img src="server_mesh_2.png" alt="server_mesh_2">  </p></li><li><p>课外<br>Rust/Go 语言实现的 lstio 和 Conduit，后者比前者要轻很多。</p></li></ul><h2 id="网关模式-Gateway"><a href="#网关模式-Gateway" class="headerlink" title="网关模式 Gateway"></a>网关模式 Gateway</h2><ul><li><p>背景<br>这其实与service mesh是两个方向的发展了<br>它不需要为每个服务的实例都配置上一个 Sidecar。其实，一个服务集群配上一个 Gateway 就可以了，或是一组类似的服务配置上一个 Gateway。  </p></li><li><p>示意图<br><img src="网关示意图.png" alt="网关示意图"></p></li><li><p>网关的功能</p><ul><li>请求路由</li><li>服务注册</li><li>负载均衡</li><li>弹力设计：重试、幂等、流控、熔断、监视等都可以实现进去</li><li>安全方面：SSL 加密及证书管理、Session 验证、授权、数据校验等</li></ul></li></ul><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>首先，Sidecar 的方式主要是用来改造已有服务。我们知道，要在一个架构中实施一些架构变更时，需要业务方一起过来进行一些改造。然而业务方的事情比较多，像架构上的变更会低优先级处理，这就导致架构变更的“政治复杂度”太高。而通过 Sidecar 的方式，我们可以适配应用服务，成为应用服务进出请求的代理。这样，我们就可以干很多对于业务方完全透明的事情了。<br>当 Sidecar 在架构中越来越多时，需要我们对 Sidecar 进行统一的管理。于是，我们为 Sidecar 增加了一个全局的中心控制器，就出现了我们的 Service Mesh。在中心控制器出现以后，我们发现，可以把非业务功能的东西全部实现在 Sidecar 和 Controller 中，于是就成了一个网格。业务方只需要把服务往这个网格中一放就好了，与其它服务的通讯、服务的弹力等都不用管了，像一个服务的 PaaS 平台。<br>然而，Service Mesh 的架构和部署太过于复杂，会让我们运维层面上的复杂度变大。为了简化这个架构的复杂度，我认为 Sidecar 的粒度应该是可粗可细的，这样更为方便。但我认为，Gateway 更为适合，而且 Gateway 只负责进入的请求，不像 Sidecar 还需要负责对外的请求。因为 Gateway 可以把一组服务给聚合起来，所以服务对外的请求可以交给对方服务的 Gateway。于是，我们只需要用一个负责进入请求的 Gateway 来简化需要同时负责进出请求的 Sidecar 的复杂度。</p><h1 id="性能设计"><a href="#性能设计" class="headerlink" title="性能设计"></a>性能设计</h1><h2 id="缓存-Cache"><a href="#缓存-Cache" class="headerlink" title="缓存 Cache"></a>缓存 Cache</h2><h2 id="异步处理-Asynchronous"><a href="#异步处理-Asynchronous" class="headerlink" title="异步处理 Asynchronous"></a>异步处理 Asynchronous</h2><h2 id="数据库扩展"><a href="#数据库扩展" class="headerlink" title="数据库扩展"></a>数据库扩展</h2><h2 id="秒杀-Flash-Sales"><a href="#秒杀-Flash-Sales" class="headerlink" title="秒杀 Flash Sales"></a>秒杀 Flash Sales</h2><h2 id="边缘计算-Edge-Computing"><a href="#边缘计算-Edge-Computing" class="headerlink" title="边缘计算 Edge Computing"></a>边缘计算 Edge Computing</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章来整理《左耳听风》栏目的分布式设计模式弹力设计、管理设计、性能设计篇，并根据当下情况，借鉴一二&lt;/p&gt;
    
    </summary>
    
      <category term="系统" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="分布式系统" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>同构渲染SPA框架搭建过程</title>
    <link href="http://yoursite.com/2019/04/19/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/04/19/前端框架搭建记录/</id>
    <published>2019-04-18T16:00:00.000Z</published>
    <updated>2019-07-01T02:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>合并了4月19与5月15的搭建记录， 主要记录了当时前端框架搭建的过程，虽然最后没有使用，但为了以后再次搭建，发布出来。</p><a id="more"></a><h1 id="借鉴"><a href="#借鉴" class="headerlink" title="借鉴"></a>借鉴</h1><p><a href="https://github.com/erikras/react-redux-universal-hot-example" target="_blank" rel="noopener">项目</a></p><ol><li><p>components与containers这种分离<br>containers来包含components，然后被routers所依赖，router被client与server所调用</p></li><li><p>bin中通过global方式处理server或者client的处理</p></li><li>helpers中ApiClient的处理</li><li><p>server、router、client;<br>client与server都依赖于ApiClient,ApiClient是与redux依赖的一个通信的接口，在它其中也对<strong>SERVER</strong>进行了判断，这里有个superagent，超级代理，来完成对api的调用，客户端为什么会调用这里？</p></li><li><p>config，js没有它灵活是因为在它里边可以做判断</p></li><li>client中通过ReactDOM.render()将路由刷进content所在的dom</li><li>server通过helpers中的Html，执行less预编译，使其可以在服务端进行渲染css model</li><li>重定向  </li></ol><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li><p>异构时client 如何渲染的<br>应该在Html中将client作为script传递过去才对<br>按这个思路来实现一下吧<br>一直没有找到client.js如何放进浏览器的，感觉上要么是打包时候，要么是在redux做了一些处理</p><p><a href="https://juejin.im/post/5bc7ea48e51d450e46289eab" target="_blank" rel="noopener">同构原理</a><br><a href="https://github.com/amandakelake/blog/issues/60" target="_blank" rel="noopener">同构应用</a></p><p>入口不同的意思是，server端是staticRouter, 浏览器是browserRouter,所以从服务端刷新时候使用是sever端的入口，在浏览器端时候的client端的入口。</p></li><li><p>product与develop的差别?</p></li></ul><h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><ul><li>components来做组件</li><li>container来组建componets</li><li>router来组建containers,借鉴了react-router官网，将这一部分改为了<code>&lt;App&gt;</code></li><li>Html类似于模板，根据传入数据来渲染不同的内容</li><li>在sever中将routers传送给Html来做服务端的渲染，反之不传router，完全client渲染  </li><li>服务端的入口是server，客户端的入口是client，客户端需要打包，并通过server端传递到浏览器</li></ul><h1 id="搭建记录"><a href="#搭建记录" class="headerlink" title="搭建记录"></a>搭建记录</h1><h2 id="文件介绍"><a href="#文件介绍" class="headerlink" title="文件介绍"></a>文件介绍</h2><ul><li>server<br>服务的创建<br>服务端渲染<br>路由的代理[先不移植]<br>可以以模板的写，但太过于硬编码，于是抽象成Html来做，Html是一个mponent，通过RenderToString的方式来完成body体中字符串的拼接</li><li><p>Html<br>Html有一个componet的接口，可以渲染任意的传入的组件，并返回一个无DOCTYPE html&gt;的页面<br>在这里需要有对client.js的引入，以及client render的位置。<br>Html最后只对server负责<br>Server中传入的Component，是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;StaticRouter&gt;</span><br><span class="line">  &lt;App /&gt;</span><br><span class="line">&lt;<span class="regexp">/StaticRouter&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>client<br>根据路由再次渲染，渲染的位置是Html指定的挂载点<br>内容应该是  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;BrowserRoute&gt;</span><br><span class="line">  &lt;App /&gt;</span><br><span class="line">&lt;<span class="regexp">/BrowserRoute&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>route<br>route应该是App，来聚合各种的Route，为server与browser提供支持  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> someVariable = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Switch&gt;</span><br><span class="line">      &#123;<span class="comment">/* these are good */</span>&#125;</span><br><span class="line">      &lt;Route exact path=<span class="string">"/"</span> component=&#123;Home&#125; /&gt;</span><br><span class="line">      &lt;Route</span><br><span class="line">        path=<span class="string">"/about"</span></span><br><span class="line">        render=&#123;props =&gt; <span class="xml"><span class="tag">&lt;<span class="name">About</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">extra</span>=<span class="string">&#123;someVariable&#125;</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">      /&gt;</span></span><br><span class="line"><span class="xml">      &#123;/* do not do this */&#125;</span></span><br><span class="line">      &lt;Route</span><br><span class="line">        path="/contact"</span><br><span class="line">        component=&#123;props =&gt; &lt;Contact &#123;...props&#125; extra=&#123;someVariable&#125; /&gt;&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/Switch&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>containers<br>containers中用来装各个组装的组件，在MPA中，是页面，用来被App引用，其内部也可以再做转发  </p></li><li><p>components<br>这个是common的组件，是被container所共用的组件</p></li></ul><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><ul><li><p>不认识Styl模块问题  </p><p>需要增加一个lib.d.ts</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> "*.styl" &#123;</span><br><span class="line"><span class="keyword">interface</span> IClassNames &#123;</span><br><span class="line">    [className: <span class="built_in">string</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> classNames: IClassNames;</span><br><span class="line"><span class="keyword">export</span> = classNames;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>后端React引用问题<br>“React”指 UMD 全局，但当前文件是模块。请考虑改为添加导入。ts(2686)<br>routers.tsx中没有直接使用React，但使用着Route、Switch等，没有引入React，结果显示问题。</p><p>原因是：b.tsx does directly rely on React. The <code>&lt;SomeComponent /&gt;</code> line will be turned into a React.createComponent call.</p></li><li><p>ts检验的问题<br><code>Import sources within a group must be alphabetized.</code>：模块的导入须排序<br><code>未命名函数只能是箭头函数</code><br><code>不能使用console.log</code>等问题</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  "rules": &#123;</span><br><span class="line">    "ordered-imports": [false],</span><br><span class="line">    "object-literal-sort-keys": [false],</span><br><span class="line">    "only-arrow-functions": false,</span><br><span class="line">    "no-console": false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>js中调用ts运行<br>需要增加ts-node来在js中直接调用ts，否则不会认识模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'ts-node'</span>).register(&#123;</span><br><span class="line">  project: <span class="built_in">require</span>(<span class="string">'../tsconfig.json'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>js运行不识别import问题<br>运行bin中的server.js，不认识import，用require就不认识ts中的imports<br><code>SyntaxError: Unexpected token import</code>  </p><p>感觉还是ts的问题，试着修改了tsconfig.json<br>module”: “esnext”, =&gt; “module”: “commonjs”, 的时候问题解决</p></li><li><p>[*]客户端刷新没成功<br>客户端刷新的形式几个例子都是通过直接挂载在模板上过去的，这时候他们的webpack都是分开打包的，从server中去访问dist中相应的js文件来完成的<br>但我们主要的同构的不是这样玩的，它是通过webpack的同构工具完成的：<code>&lt;script src={assets.javascript.main} charSet=&quot;UTF-8&quot;/&gt;</code>，把这条注释掉，发现再点击的时候，每次点击都会走路由，若不注释，只第一次刷新时候走的路由。考虑移植webpackIsomorphicTools来试试</p></li><li><p>webpack客户端的只打包成main.xxxxxx.js的原因<br>webpack在编译的时候entry可以是对象、数组、字符串，对象的key值是编译后的文件名，value值是路径，若直接放字符串，则默认是main<br>在output中指明了[name].js， 这样编译出来的就是main.js了  </p></li><li><p>[*]debug模式如何完成客户端渲染<br>确实去拿了，确实拿到了，原因是express把所有的路由都返回了服务端的那个渲染<br>研究一下express.static，express可以托管静态文静</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="string">'/dist'</span>, Express.static(<span class="string">'dist/browser'</span>));</span><br></pre></td></tr></table></figure><p>前边还是路由，后边是Express托管的静态文件的地址，这样修改后，浏览器中即可获取到客户端入口文件了</p></li><li><p>浏览器上显示React引用问题<br>React is not defined<br>在这里又返回了我们第一问题，即要想用BrowserRouter，就必须引入React，因为它是通过React.createElement()的方式来创建的对象，像是一个语法糖一样<br>找了了<a href="https://stackoverflow.com/questions/32070303/uncaught-referenceerror-react-is-not-defined" target="_blank" rel="noopener">React is not defined处理</a>文章，去查了一下webpack的配置，发现已经存在了 ‘react’:’React’ 了<br>从问题描述中看到react.min.js等需要引入，于是引入，问题解决。</p></li><li><p>[*]ts中运行成功，但编译成dist之后运行不成功  </p><ul><li><p>从编译后的server的js中引用browser中js失败<br>引用的函数返回undefined</p></li><li><p>采用js来写这段代码<br>import 问题，修改import成 require, 编译问题<br>js中没有经过babel，无法识别其中的React标签，然后通过<br><a href="https://imweb.io/topic/5b8699a96a0f1b02454de3c0" target="_blank" rel="noopener">React与Babel</a>,安装babel-loader，@babel/core，@babel/preset-env，@babel/preset-react之后，问题解决，一运行，问题回到原点，及没法引出编译之后的模块<br>然后发现编译之后的模块没有导出任何东西，编译之后的js自成模块，无对外的引用与导出,…<br>然后考虑在server中增加对它的连接</p></li><li><p>链接失败<br>因为入口设成server.ts之后，会去递归连接.express\net等模块，出现错误<br>对比了借鉴项目，webpack并不去处理server的入口…<br>有一种方式，就是跟server端的连接一样，将tsx也都翻译成js，链接一份，非链接一份，这样运行即可。但这样对styl等的处理不好<br>这样有两种选择：1. 用模板，2. 用ts直接运行</p><p><a href="https://github.com/TypeStrong/ts-node/issues/104" target="_blank" rel="noopener">ts-node for production</a><br><a href="https://github.com/TypeStrong/ts-node/issues/653" target="_blank" rel="noopener">ts-node for production</a></p><p>以上两个问题的回到，ts-node可以直接用与生产，只不过会比js直接运行多一点内存。<br>那就先用这种方式吧。  </p></li></ul></li><li><p>后端渲染stylus的坑<br>需要使用webpack-isomorphic-tools来辅助，步骤见<a href="https://github.com/catamphetamine/webpack-isomorphic-tools" target="_blank" rel="noopener">官网</a><br>大体的过程是，先配置一个webpack-isomorphic-tools注入到webpack中，并进行配置，然后在服务端启动的入口，将webpack-isomorphic-tools注入到server中，然后在Html中即可使用这个工具。<br>工具本身已经在js构建工具中记录过了，这里不再详谈了</p></li><li><p>后端渲染的browser dom的坑<br>描述：<br>在Html渲染时，使用的是 react-dom/server引出的ReactDOM.renderToString()函数，并且组建也是用staticRouter包裹的<code>&lt;App /&gt;</code>。但却依旧报了browser dom渲染的错。  </p><p>解决：<br>问题的解决是发现App组件中，又增加了一个router，去掉这个router之后，问题解决了  </p></li><li><p>后端渲染material-ui组件的坑<br>描述：<br>后台在渲染material-ui组件时，总是会报错，包括 <code>&lt;Divider /&gt;</code> <code>&lt;IconButton&gt;</code>等组件  </p><p>方案：<br>借鉴，<a href="https://material-ui.com/guides/server-rendering/" target="_blank" rel="noopener">material-ui ssr</a>。<br>这个问题没有真正解决，原因在于react-jss安装不成功，怀疑是node与npm版本问题  </p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;合并了4月19与5月15的搭建记录， 主要记录了当时前端框架搭建的过程，虽然最后没有使用，但为了以后再次搭建，发布出来。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>SSR、CSR与同构</title>
    <link href="http://yoursite.com/2019/04/14/SSR%E3%80%81CSR%E4%B8%8E%E5%90%8C%E6%9E%84/"/>
    <id>http://yoursite.com/2019/04/14/SSR、CSR与同构/</id>
    <published>2019-04-14T00:51:40.000Z</published>
    <updated>2019-07-01T02:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>为本周的前端的框架选择做一个总结</p><p>change log：<br>初次写时，概念表达不太到位，再次翻阅不能起到快速回忆的目的，这里再次进行修改，删去原来的过程部分，增加CSR与SSR的技术内容。</p><a id="more"></a><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>团队的前端同学们想探索一些新的框架，于是就跟他们一起做一些技术选择。<br>现有的前端框架分成server部分与browser部分，server中是一个node.js服务器，负责页面与路由的映射，根据路由导向不同的页面，渲染的交给了前端来完成，是一个React MPA 前端渲染的框架，设计是用的Material-UI库</p><h1 id="发展观"><a href="#发展观" class="headerlink" title="发展观"></a>发展观</h1><p>随着这篇文章来梳理一下</p><ul><li><p>html时代<br>http协议最早设计的是从服务器上获取静态的资源，其实也就是静态html  </p></li><li><p>模板渲染<br>后来Java时代，可以通过模板，将数据渲染进模板，从而生成html发送给前端，在后来的CSR出现之间，我觉得可能也没有SSR的概念。  </p><p>浏览器与服务端数据的交互通过表单来实现，浏览器将表达中的数据一次性通过表单提交，后代进行处理完成后可以再次渲染模板，然后将数据表达出来。</p></li><li><p>CSR(客户端侧渲染)<br>后来我觉得是ajax与virtual dom技术的出现，使浏览器渲染成为可能，一开始可能只是想做一点改变，感觉很平滑，后来干脆所有的dom都直接渲染，这就成成CSR  </p><p>这个CSR从过程上看，浏览器先去获取一个空模板，然后再获取js文件进行virtual dom的渲染，这个过程浏览器上会有一瞬的白屏。  </p><p>浏览器与服务端数据交互很多时候被ajax所替代，好处是比较灵活，不论是数据交互还是页面刷新，不好处容易被滥用，使通信的效率降低，后台服务压力上升。  </p></li><li><p>SSR(服务侧渲染)-追加<br>模板渲染就是一种SSR，这里针对的主要的是React所以略有不同，SSR主要是将render的操作放在了后端来执行，将数据从API Server取来，然后直接通过render函数渲染到页面上，并将页面返回浏览器。这样浏览器也不用再获取js，自己来渲染。  </p><p>不好处也比较明显，每次获取数据、渲染，对服务器的要求会比CSR高，不过模板时期也是这么玩的。另外响应感觉要比CSR慢一点。<br>这里要加一下看过next.js之后的感想，next.js是一个SSR的框架，它是一种MPA，提供的prefech与Dynamic Import等功能，在SSR方面做的更突出一些。</p></li><li><p>isomorphic(同构渲染)-修改<br>Isomorphic既是CSR也是SSR，它是服务器渲染一遍，浏览器也渲染一遍。<br>在一些实践中服务器渲染完初识界面之后就算完成任务，其余的渲染就靠浏览器来完成。这种同构渲染感觉更偏向CSR<br>想象中，SSR完成之后，通过AJAX获取数据，然后根据数据做一些render，这样的效果也会不错。这种通过感觉更偏向SSR  </p></li></ul><h1 id="CSR与SSR"><a href="#CSR与SSR" class="headerlink" title="CSR与SSR"></a>CSR与SSR</h1><p>一些文章中将Isomophic也说成SSR</p><ul><li><p>差异<br>刚开始接触花费了挺多时间来区别这两个概念，其实从名字就能做区分，对于React而言，就是是render函数是在服务器上执行还是在浏览器上执行。</p></li><li><p>SSR与CSR原理<br>原理从下边两张图中即可说明：<br><img src="CSR.png" alt="CSR"><br><img src="SSR.png" alt="SSR"><br>这里的SSR其实是Isomophic，它有2个入口，第一次是服务端的入口，第二次是客户端再次获取js文件渲染之后的浏览器入口。</p><p>推荐：<a href="https://juejin.im/post/5bc7ea48e51d450e46289eab" target="_blank" rel="noopener">React 中同构（SSR）原理脉络梳理</a></p></li><li><p>一些对比文章<br><a href="https://medium.com/@goldybenedict/single-page-applications-vs-multiple-page-applications-do-you-really-need-an-spa-cf60825232a3" target="_blank" rel="noopener">原文</a><br><a href="https://yaoyanzhu.iteye.com/blog/2171347" target="_blank" rel="noopener">原文</a></p></li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>上次根据研究，已经将一个同构的React同构框架搭建起来，期间跳过了很多的坑，采用create-react-app脚手架、Typescript、express、react-router、stylus等技术。但有还是两个问题其实没有解决：  </p><ul><li><p>服务端代码运行<br>原来的框架中，运行时将Ts写的服务端代码也编译成了js之后进行运行，但在这里没有成功，原因是，原来框架中客户端与服务端的代码完全隔离，但在同构渲染时，服务端要渲染，必须要引入React的组件，而这些组件通过webpack打包之后，里边的函数没法再被server侧导入。<br>处理这个问题时，要么全部将Ts都通过gulp-typescript来编译成js，要么直接使用Ts，而经过确认，定于使用了Ts直接运行的方式</p></li><li><p>stylus问题<br>这个延伸自上一个问题，由于CSS采用stylus，造成ts直接运行时，没办法转换其中的stylus模块，这个问题目前还没有找到。可能要退回到将Ts全部编译成js，然后用gulp-stylus来处理一下stylus的方式来实现，要是这样，感觉也有些不妥。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为本周的前端的框架选择做一个总结&lt;/p&gt;
&lt;p&gt;change log：&lt;br&gt;初次写时，概念表达不太到位，再次翻阅不能起到快速回忆的目的，这里再次进行修改，删去原来的过程部分，增加CSR与SSR的技术内容。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
</feed>
