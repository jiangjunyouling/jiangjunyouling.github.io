<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>思 见</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-06T08:01:55.280Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>sun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>查询引擎之二</title>
    <link href="http://yoursite.com/2020/05/06/%E6%9F%A5%E8%AF%A2%E5%BC%95%E6%93%8E%E4%B9%8B%E4%BA%8C/"/>
    <id>http://yoursite.com/2020/05/06/查询引擎之二/</id>
    <published>2020-05-06T03:41:17.000Z</published>
    <updated>2020-05-06T08:01:55.280Z</updated>
    
    <content type="html"><![CDATA[<p>这一部分承接上一部分，主要介绍Eleasticsearch Stack<br>本篇是本系列第四篇，也是最后一篇  </p><a id="more"></a><h1 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h1><p>前一段时间，在接触spring-boot时有过接触，当时的<a href="https://sunyanfeng.cn/2020/02/20/spring-boot%E8%BF%9B%E9%98%B6/#more" target="_blank" rel="noopener">博客</a><br>这里先上一张图：<br><img src="./elasticsearch数据结构.png" alt="elasticsearch数据结构.png">  </p><p>再看看ES的术语：</p><table><thead><tr><th style="text-align:center">关系型数据库</th><th style="text-align:center">Elasticsearch</th></tr></thead><tbody><tr><td style="text-align:center">Table</td><td style="text-align:center">Index(Type)</td></tr><tr><td style="text-align:center">Row</td><td style="text-align:center">Document</td></tr><tr><td style="text-align:center">Column</td><td style="text-align:center">Filed</td></tr><tr><td style="text-align:center">Schema</td><td style="text-align:center">Mapping</td></tr><tr><td style="text-align:center">SQL</td><td style="text-align:center">DSL</td></tr></tbody></table><p>Elasticsearch有3个标签：Store, Search, and Analyze，前边的博客介绍了Store与Search，这里主要介绍Analyze。<br><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html" target="_blank" rel="noopener">官网</a>、<a href="https://www.cnblogs.com/leeSmall/p/9215909.html" target="_blank" rel="noopener">参考</a>  </p><h2 id="聚合简介"><a href="#聚合简介" class="headerlink" title="聚合简介"></a>聚合简介</h2><p>  ES提供了4种类型的聚合，包括：Bucekting、Metric、Matrix、Pipeline，主要是前2个<br>  Metrix: 在一组document之上的计算指标，max、min、sum、avg等<br>  Bucketing: 生成Bucketing的一组聚合，其中每个Bucketing都与一个键和一个Document的条件相关联。执行汇总时，将对上下文中的每个document评估所有bucketing条件，并且当条件匹配时，该文档将被视为“落入”相关buckeing内。对应SQL的groupBy<br>  Matrix：一类聚合，可在多个字段上进行操作，并根据从请求的文档字段中提取的值生成矩阵结果。ES对它的支持还不完善，还不支持脚本<br>  Pipeline: 汇总其他汇总及其相关指标的输出的汇总  </p><p>  聚合的结构：<br>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">"aggregations" : &#123;</span><br><span class="line">    "&lt;aggregation_name&gt;" : &#123;</span><br><span class="line">        "&lt;aggregation_type&gt;" : &#123;</span><br><span class="line">            &lt;aggregation_body&gt;</span><br><span class="line">        &#125;</span><br><span class="line">        [,"meta" : &#123;  [&lt;meta_data_body&gt;] &#125; ]?</span><br><span class="line">        [,"aggregations" : &#123; [&lt;sub_aggregation&gt;]+ &#125; ]?</span><br><span class="line">    &#125;</span><br><span class="line">    [,"&lt;aggregation_name_2&gt;" : &#123; ... &#125; ]*</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 说明：aggregations可以写成aggs  </p><h2 id="Metrix"><a href="#Metrix" class="headerlink" title="Metrix"></a>Metrix</h2><h3 id="Avg"><a href="#Avg" class="headerlink" title="Avg"></a>Avg</h3><p>  比如一个学生分数的document，计算平均分：  </p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /exams/_search?size=<span class="number">0</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"aggs"</span> : &#123;</span><br><span class="line">        <span class="string">"avg_grade"</span> : &#123; <span class="string">"avg"</span> : &#123; <span class="string">"field"</span> : <span class="string">"grade"</span> &#125; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的aggregation_name是”avg_grade”，自定义的。aggregation_type是”avg”，类似于算子，ES提供的，filed指明avg在哪个field上执行，算子的参数。结果：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">"aggregations"</span>: &#123;</span><br><span class="line">        <span class="string">"avg_grade"</span>: &#123;</span><br><span class="line">            <span class="string">"value"</span>: <span class="number">75.0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>avg可以基于脚本来编写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POST /exams/_search?size=<span class="number">0</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"aggs"</span> : &#123;</span><br><span class="line">        <span class="string">"avg_grade"</span> : &#123;</span><br><span class="line">            <span class="string">"avg"</span> : &#123;</span><br><span class="line">                <span class="string">"script"</span> : &#123;</span><br><span class="line">                    <span class="string">"id"</span>: <span class="string">"my_script"</span>,</span><br><span class="line">                    <span class="string">"params"</span>: &#123;</span><br><span class="line">                        <span class="string">"field"</span>: <span class="string">"grade"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这会将脚本参数解释为具有painless语言且没有脚本参数的嵌入式脚本。更进一步可以写为：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">POST /exams/_search?size=<span class="number">0</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"aggs"</span> : &#123;</span><br><span class="line">        <span class="string">"avg_corrected_grade"</span> : &#123;</span><br><span class="line">            <span class="string">"avg"</span> : &#123;</span><br><span class="line">                <span class="string">"field"</span> : <span class="string">"grade"</span>,</span><br><span class="line">                <span class="string">"script"</span> : &#123;</span><br><span class="line">                    <span class="string">"lang"</span>: <span class="string">"painless"</span>,</span><br><span class="line">                    <span class="string">"source"</span>: <span class="string">"_value * params.correction"</span>,</span><br><span class="line">                    <span class="string">"params"</span> : &#123;</span><br><span class="line">                        <span class="string">"correction"</span> : <span class="number">1.2</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="string">"missing"</span>:  <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在原有的分数上做一个修正。missing参数指定缺省值。<br>与Avg类似的还有个加权平均：Weighted Avg，比Avg增加了weight参数，这个不多介绍了。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST /exams/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"size"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">"aggs"</span> : &#123;</span><br><span class="line">        <span class="string">"weighted_grade"</span>: &#123;</span><br><span class="line">            <span class="string">"weighted_avg"</span>: &#123;</span><br><span class="line">                <span class="string">"value"</span>: &#123;</span><br><span class="line">                    <span class="string">"field"</span>: <span class="string">"grade"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"weight"</span>: &#123;</span><br><span class="line">                    <span class="string">"field"</span>: <span class="string">"weight"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="extended-stats"><a href="#extended-stats" class="headerlink" title="extended_stats"></a>extended_stats</h3><p>cardinality等价于distinct，查询某个field不同值的个数，max、min、sum都类似于sql，不多介绍，简单介绍一个stats与extended_stats。stats是将某个field的count、min、max、avg、sum都计算出来，extended_stats比stats增加了平方和、方差、标准差等值  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /exams/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"size"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">"aggs"</span> : &#123;</span><br><span class="line">        <span class="string">"grades_stats"</span> : &#123; <span class="string">"extended_stats"</span> : &#123; <span class="string">"field"</span> : <span class="string">"grade"</span> &#125; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="string">"aggregations"</span>: &#123;</span><br><span class="line">        <span class="string">"grades_stats"</span>: &#123;</span><br><span class="line">           <span class="string">"count"</span>: <span class="number">2</span>,</span><br><span class="line">           <span class="string">"min"</span>: <span class="number">50.0</span>,</span><br><span class="line">           <span class="string">"max"</span>: <span class="number">100.0</span>,</span><br><span class="line">           <span class="string">"avg"</span>: <span class="number">75.0</span>,</span><br><span class="line">           <span class="string">"sum"</span>: <span class="number">150.0</span>,</span><br><span class="line">           <span class="string">"sum_of_squares"</span>: <span class="number">12500.0</span>,</span><br><span class="line">           <span class="string">"variance"</span>: <span class="number">625.0</span>,</span><br><span class="line">           <span class="string">"std_deviation"</span>: <span class="number">25.0</span>,</span><br><span class="line">           <span class="string">"std_deviation_bounds"</span>: &#123;</span><br><span class="line">            <span class="string">"upper"</span>: <span class="number">125.0</span>,</span><br><span class="line">            <span class="string">"lower"</span>: <span class="number">25.0</span></span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这一块用的是Get，有点疑惑，另外std_deviation_bounds这个值是：与测量值的正负两个标准差的间隔，正态分布的话，应该是95.4%的区间    </p><h3 id="percentiles"><a href="#percentiles" class="headerlink" title="percentiles"></a>percentiles</h3><p>还有一个比较有趣的是percentiles，这个给出的是相应概率发生的位置，比如对加响应时间的分析：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET latency/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"size"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">"aggs"</span> : &#123;</span><br><span class="line">        <span class="string">"load_time_outlier"</span> : &#123;</span><br><span class="line">            <span class="string">"percentiles"</span> : &#123;</span><br><span class="line">                <span class="string">"field"</span> : <span class="string">"load_time"</span> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果是：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">   "aggregations": &#123;</span><br><span class="line">      "load_time_outlier": &#123;</span><br><span class="line">         "values" : &#123;</span><br><span class="line">            "1.0": 5.0,</span><br><span class="line">            "5.0": 25.0,</span><br><span class="line">            "25.0": 165.0,</span><br><span class="line">            "50.0": 445.0,</span><br><span class="line">            "75.0": 725.0,</span><br><span class="line">            "95.0": 945.0,</span><br><span class="line">            "99.0": 985.0</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Bucket"><a href="#Bucket" class="headerlink" title="Bucket"></a>Bucket</h2><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>介绍一些filter，类似于where的用法，比如计算t-shirt的平均价格：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POST /sales/_search?size=<span class="number">0</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"aggs"</span> : &#123;</span><br><span class="line">        <span class="string">"t_shirts"</span> : &#123;</span><br><span class="line">            <span class="string">"filter"</span> : &#123; <span class="string">"term"</span>: &#123; <span class="string">"type"</span>: <span class="string">"t-shirt"</span> &#125; &#125;,</span><br><span class="line">            <span class="string">"aggs"</span> : &#123;</span><br><span class="line">                <span class="string">"avg_price"</span> : &#123; <span class="string">"avg"</span> : &#123; <span class="string">"field"</span> : <span class="string">"price"</span> &#125; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    "aggregations" : &#123;</span><br><span class="line">        "t_shirts" : &#123;</span><br><span class="line">            "doc_count" : 3,</span><br><span class="line">            "avg_price" : &#123; "value" : 128.33333333333334 &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还有一种写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST /sales/_search?size=<span class="number">0</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span> : &#123;</span><br><span class="line">        <span class="string">"constant_score"</span> : &#123;</span><br><span class="line">            <span class="string">"filter"</span> : &#123;</span><br><span class="line">                <span class="string">"match"</span> : &#123; <span class="string">"type"</span> : <span class="string">"hat"</span> &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"aggs"</span> : &#123;</span><br><span class="line">        <span class="string">"hat_prices"</span> : &#123; <span class="string">"sum"</span> : &#123; <span class="string">"field"</span> : <span class="string">"price"</span> &#125; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="term"><a href="#term" class="headerlink" title="term"></a>term</h3><p>term有点类似与group by，分组统计个数，例如，汇总某种类型(genre)的document数量  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"aggs"</span> : &#123;</span><br><span class="line">        <span class="string">"genres"</span> : &#123;</span><br><span class="line">            <span class="string">"terms"</span> : &#123; <span class="string">"field"</span> : <span class="string">"genre"</span> &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：  </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    "aggregations" : &#123;</span><br><span class="line">        "genres" : &#123;</span><br><span class="line">            "doc_count_error_upper_bound": 0, </span><br><span class="line">            "sum_other_doc_count": 0, </span><br><span class="line">            "buckets" : [ </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"key"</span> : <span class="string">"electronic"</span>,</span><br><span class="line">                    <span class="attr">"doc_count"</span> : <span class="number">6</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"key"</span> : <span class="string">"rock"</span>,</span><br><span class="line">                    <span class="attr">"doc_count"</span> : <span class="number">3</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"key"</span> : <span class="string">"jazz"</span>,</span><br><span class="line">                    <span class="attr">"doc_count"</span> : <span class="number">2</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方对这里有个说明：terms聚合应该是关键字类型的字段或适用于bucket聚合的任何其他数据类型。为了与text一起使用，您将需要启用fielddata。</p><p>默认情况下，terms汇总将返回doc_count排序的前十的 数据，可以通过设置size参数来更改此默认行为。另外还有一个<br>shard_size来对size过大时出现的性能问题进行调优。如果要分页来获取，需要使用Composite，这个后边介绍。  </p><p>查询时可以通过order来对结果进行排序，如下：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"aggs"</span> : &#123;</span><br><span class="line">        <span class="string">"genres"</span> : &#123;</span><br><span class="line">            <span class="string">"terms"</span> : &#123;</span><br><span class="line">                <span class="string">"field"</span> : <span class="string">"genre"</span>,</span><br><span class="line">                <span class="string">"order"</span> : &#123; <span class="string">"_count"</span> : <span class="string">"asc"</span> &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分组最大并排序：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"aggs"</span> : &#123;</span><br><span class="line">        <span class="string">"genres"</span> : &#123;</span><br><span class="line">            <span class="string">"terms"</span> : &#123;</span><br><span class="line">                <span class="string">"field"</span> : <span class="string">"genre"</span>,</span><br><span class="line">                <span class="string">"order"</span> : &#123; <span class="string">"max_play_count"</span> : <span class="string">"desc"</span> &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"aggs"</span> : &#123;</span><br><span class="line">                <span class="string">"max_play_count"</span> : &#123; <span class="string">"max"</span> : &#123; <span class="string">"field"</span> : <span class="string">"play_count"</span> &#125; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在嵌套的情况下，有时会应用聚合的结果，这时通过”&gt;”来指明层级，而通过”.”来引用某个metric  </p><h3 id="histogram"><a href="#histogram" class="headerlink" title="histogram"></a>histogram</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST /sales/_search?size=<span class="number">0</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"aggs"</span> : &#123;</span><br><span class="line">        <span class="string">"prices"</span> : &#123;</span><br><span class="line">            <span class="string">"histogram"</span> : &#123;</span><br><span class="line">                <span class="string">"field"</span> : <span class="string">"price"</span>,</span><br><span class="line">                <span class="string">"interval"</span> : <span class="number">50</span>,</span><br><span class="line">                <span class="string">"min_doc_count"</span> : <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>interval来指明间隔、min_doc_count指明最少的个数，如果小于该值，则过滤掉该区间<br>结果： </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    "aggregations": &#123;</span><br><span class="line">        "prices" : &#123;</span><br><span class="line">            "buckets": [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"key"</span>: <span class="number">0.0</span>,</span><br><span class="line">                    <span class="attr">"doc_count"</span>: <span class="number">1</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"key"</span>: <span class="number">50.0</span>,</span><br><span class="line">                    <span class="attr">"doc_count"</span>: <span class="number">1</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"key"</span>: <span class="number">150.0</span>,</span><br><span class="line">                    <span class="attr">"doc_count"</span>: <span class="number">2</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"key"</span>: <span class="number">200.0</span>,</span><br><span class="line">                    <span class="attr">"doc_count"</span>: <span class="number">3</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="date-histogram"><a href="#date-histogram" class="headerlink" title="date_histogram"></a>date_histogram</h3><p>最常用的按时间汇总，比如按月统计  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST /sales/_search?size=<span class="number">0</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"aggs"</span> : &#123;</span><br><span class="line">        <span class="string">"sales_over_time"</span> : &#123;</span><br><span class="line">            <span class="string">"date_histogram"</span> : &#123;</span><br><span class="line">                <span class="string">"field"</span> : <span class="string">"date"</span>,</span><br><span class="line">                <span class="string">"calendar_interval"</span> : <span class="string">"month"</span>,</span><br><span class="line">                <span class="string">"format"</span> : <span class="string">"yyyy-MM-dd"</span> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的calendar_interval只能是单位时间，如：1d、1M等，key是时间戳，如果要显示文本，可以增加format，结果如下：  </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    "aggregations": &#123;</span><br><span class="line">        "sales_over_time": &#123;</span><br><span class="line">            "buckets": [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"key_as_string"</span>: <span class="string">"2015-01-01"</span>,</span><br><span class="line">                    <span class="attr">"key"</span>: <span class="number">1420070400000</span>,</span><br><span class="line">                    <span class="attr">"doc_count"</span>: <span class="number">3</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"key_as_string"</span>: <span class="string">"2015-02-01"</span>,</span><br><span class="line">                    <span class="attr">"key"</span>: <span class="number">1422748800000</span>,</span><br><span class="line">                    <span class="attr">"doc_count"</span>: <span class="number">2</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"key_as_string"</span>: <span class="string">"2015-03-01"</span>,</span><br><span class="line">                    <span class="attr">"key"</span>: <span class="number">1425168000000</span>,</span><br><span class="line">                    <span class="attr">"doc_count"</span>: <span class="number">2</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是想自定义时间区间，可以用date_range来查询，这里不多说了。  </p><h3 id="composite"><a href="#composite" class="headerlink" title="composite"></a>composite</h3><ul><li><p>source<br>source用来指明构建composite bucket的源，source的顺序很重要，它控制返回key的顺序。<br>composite有3种source: term、histogram、Date histogram。可以但source，但感觉单source跟原意差别不大。下例组合date_histogram与 term，感觉像是两种source的笛卡尔积，这个得试一下，官网没给出  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="string">"size"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="string">"aggs"</span> : &#123;</span><br><span class="line">          <span class="string">"my_buckets"</span>: &#123;</span><br><span class="line">              <span class="string">"composite"</span> : &#123;</span><br><span class="line">                  <span class="string">"sources"</span> : [</span><br><span class="line">                      &#123; <span class="string">"date"</span>: &#123; <span class="string">"date_histogram"</span>: &#123; <span class="string">"field"</span>: <span class="string">"timestamp"</span>, <span class="string">"calendar_interval"</span>: <span class="string">"1d"</span> &#125; &#125; &#125;,</span><br><span class="line">                      &#123; <span class="string">"product"</span>: &#123; <span class="string">"terms"</span>: &#123;<span class="string">"field"</span>: <span class="string">"product"</span> &#125; &#125; &#125;</span><br><span class="line">                  ]</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>pagination<br> 通过size与after来制定分页</p><p> 第一次查询：    </p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"size"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">"aggs"</span> : &#123;</span><br><span class="line">        <span class="string">"my_buckets"</span>: &#123;</span><br><span class="line">            <span class="string">"composite"</span> : &#123;</span><br><span class="line">                <span class="string">"size"</span>: <span class="number">2</span>,</span><br><span class="line">                <span class="string">"sources"</span> : [</span><br><span class="line">                    &#123; <span class="string">"date"</span>: &#123; <span class="string">"date_histogram"</span>: &#123; <span class="string">"field"</span>: <span class="string">"timestamp"</span>, <span class="string">"calendar_interval"</span>: <span class="string">"1d"</span> &#125; &#125; &#125;,</span><br><span class="line">                    &#123; <span class="string">"product"</span>: &#123; <span class="string">"terms"</span>: &#123;<span class="string">"field"</span>: <span class="string">"product"</span> &#125; &#125; &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>  返回：<br>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      ...</span><br><span class="line">      "aggregations": &#123;</span><br><span class="line">          "my_buckets": &#123;</span><br><span class="line">              "after_key": &#123;</span><br><span class="line">                  "date": 1494288000000,</span><br><span class="line">                  "product": "mad max"</span><br><span class="line">              &#125;,</span><br><span class="line">              "buckets": [</span><br><span class="line">                  &#123;</span><br><span class="line">                      <span class="attr">"key"</span>: &#123;</span><br><span class="line">                          <span class="attr">"date"</span>: <span class="number">1494201600000</span>,</span><br><span class="line">                          <span class="attr">"product"</span>: <span class="string">"rocky"</span></span><br><span class="line">                      &#125;,</span><br><span class="line">                      <span class="attr">"doc_count"</span>: <span class="number">1</span></span><br><span class="line">                  &#125;,</span><br><span class="line">                  &#123;</span><br><span class="line">                      <span class="attr">"key"</span>: &#123;</span><br><span class="line">                          <span class="attr">"date"</span>: <span class="number">1494288000000</span>,</span><br><span class="line">                          <span class="attr">"product"</span>: <span class="string">"mad max"</span></span><br><span class="line">                      &#125;,</span><br><span class="line">                      <span class="attr">"doc_count"</span>: <span class="number">2</span></span><br><span class="line">                  &#125;</span><br><span class="line">              ]</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  第二次查询：  </p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"size"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">"aggs"</span> : &#123;</span><br><span class="line">        <span class="string">"my_buckets"</span>: &#123;</span><br><span class="line">            <span class="string">"composite"</span> : &#123;</span><br><span class="line">                <span class="string">"size"</span>: <span class="number">2</span>,</span><br><span class="line">                <span class="string">"sources"</span> : [</span><br><span class="line">                    &#123; <span class="string">"date"</span>: &#123; <span class="string">"date_histogram"</span>: &#123; <span class="string">"field"</span>: <span class="string">"timestamp"</span>, <span class="string">"calendar_interval"</span>: <span class="string">"1d"</span>, <span class="string">"order"</span>: <span class="string">"desc"</span> &#125; &#125; &#125;,</span><br><span class="line">                    &#123; <span class="string">"product"</span>: &#123; <span class="string">"terms"</span>: &#123;<span class="string">"field"</span>: <span class="string">"product"</span>, <span class="string">"order"</span>: <span class="string">"asc"</span> &#125; &#125; &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="string">"after"</span>: &#123; <span class="string">"date"</span>: <span class="number">1494288000000</span>, <span class="string">"product"</span>: <span class="string">"mad max"</span> &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h2><p>这个只介绍一个：sum_bucket，可以对兄弟聚合的结果进行再次聚合</p><p>例如：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">POST /sales/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"size"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">"aggs"</span> : &#123;</span><br><span class="line">        <span class="string">"sales_per_month"</span> : &#123;</span><br><span class="line">            <span class="string">"date_histogram"</span> : &#123;</span><br><span class="line">                <span class="string">"field"</span> : <span class="string">"date"</span>,</span><br><span class="line">                <span class="string">"calendar_interval"</span> : <span class="string">"month"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"aggs"</span>: &#123;</span><br><span class="line">                <span class="string">"sales"</span>: &#123;</span><br><span class="line">                    <span class="string">"sum"</span>: &#123;</span><br><span class="line">                        <span class="string">"field"</span>: <span class="string">"price"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"sum_monthly_sales"</span>: &#123;</span><br><span class="line">            <span class="string">"sum_bucket"</span>: &#123;</span><br><span class="line">                <span class="string">"buckets_path"</span>: <span class="string">"sales_per_month&gt;sales"</span> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sum_bucket与buckets_path是语法,sales_per_month&gt;sales是致命对兄弟聚合的哪个field进行聚合，结果：  </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"took"</span>: <span class="number">11</span>,</span><br><span class="line">   <span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line">   <span class="attr">"_shards"</span>: ...,</span><br><span class="line">   <span class="attr">"hits"</span>: ...,</span><br><span class="line">   <span class="attr">"aggregations"</span>: &#123;</span><br><span class="line">      <span class="attr">"sales_per_month"</span>: &#123;</span><br><span class="line">         <span class="attr">"buckets"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="attr">"key_as_string"</span>: <span class="string">"2015/01/01 00:00:00"</span>,</span><br><span class="line">               <span class="attr">"key"</span>: <span class="number">1420070400000</span>,</span><br><span class="line">               <span class="attr">"doc_count"</span>: <span class="number">3</span>,</span><br><span class="line">               <span class="attr">"sales"</span>: &#123;</span><br><span class="line">                  <span class="attr">"value"</span>: <span class="number">550.0</span></span><br><span class="line">               &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="attr">"key_as_string"</span>: <span class="string">"2015/02/01 00:00:00"</span>,</span><br><span class="line">               <span class="attr">"key"</span>: <span class="number">1422748800000</span>,</span><br><span class="line">               <span class="attr">"doc_count"</span>: <span class="number">2</span>,</span><br><span class="line">               <span class="attr">"sales"</span>: &#123;</span><br><span class="line">                  <span class="attr">"value"</span>: <span class="number">60.0</span></span><br><span class="line">               &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="attr">"key_as_string"</span>: <span class="string">"2015/03/01 00:00:00"</span>,</span><br><span class="line">               <span class="attr">"key"</span>: <span class="number">1425168000000</span>,</span><br><span class="line">               <span class="attr">"doc_count"</span>: <span class="number">2</span>,</span><br><span class="line">               <span class="attr">"sales"</span>: &#123;</span><br><span class="line">                  <span class="attr">"value"</span>: <span class="number">375.0</span></span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         ]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"sum_monthly_sales"</span>: &#123;</span><br><span class="line">          <span class="attr">"value"</span>: <span class="number">985.0</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子也给出一般的写法，用bucket来分组，用metrix来计算，最后可以通过pipeline对计算结果再次汇总。  </p><h1 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h1><p>Logstash只做简单的介绍<br>Logstash主要用于收集数据，具有实时管道功能。Logstash可以动态地将来自不同数据源的数据统一起来，并将数据标准化到你所选择的目的地。  </p><p><a href="https://www.elastic.co/cn/logstash" target="_blank" rel="noopener">官网</a>、<a href="https://www.elastic.co/guide/en/logstash/current/pipeline.html" target="_blank" rel="noopener">简介</a>、<a href="https://zhuanlan.zhihu.com/p/53410539" target="_blank" rel="noopener">参考</a>  </p><p><img src="./logstash结构示意图.png" alt="logstash结构示意图.png"><br>Logstash事件处理管道包括3个阶段：inputs 、filters、outputs。  </p><ul><li><p>inputs<br> input产生事件，源可以包括：file、syslog、redis、beats</p></li><li><p>filters<br>filter转换数据，包括：grok结构化数据；对数据进行修改、替换、删除数据，比如修改日期格式；geoip对ip增加地理信息等  </p></li><li><p>outputs<br> 输出，一般就输出到es中  </p></li></ul><h1 id="kibana"><a href="#kibana" class="headerlink" title="kibana"></a>kibana</h1><p><a href="https://www.elastic.co/guide/cn/kibana/current/getting-started.html" target="_blank" rel="noopener">官网</a><br>kibana不介绍了，官网就比较清楚啦，从初步了解上看，它做了2个事情：将页面的配置转换成ES的查询；将查询的结果用图形显示出来。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一部分承接上一部分，主要介绍Eleasticsearch Stack&lt;br&gt;本篇是本系列第四篇，也是最后一篇  &lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>查询引擎之一</title>
    <link href="http://yoursite.com/2020/05/03/%E6%9F%A5%E8%AF%A2%E5%BC%95%E6%93%8E%E4%B9%8B%E4%B8%80/"/>
    <id>http://yoursite.com/2020/05/03/查询引擎之一/</id>
    <published>2020-05-03T03:29:13.000Z</published>
    <updated>2020-05-06T09:21:07.548Z</updated>
    
    <content type="html"><![CDATA[<p>第一部分给出了数据中台的分层，第二部分给出了计算框架，这一部分来看看计算之外的，包括：HBase与Hive<br>本篇是本系列第三篇  </p><a id="more"></a><p>上一部分是计算，这一部分是存储与查询，对接计算之后结果的存取。其中HBase是存储，它是基于HDFS；Hive是基于MR，提供近似SQL的查询，经过解析转换成相应的计算。<br>下一篇介绍的ES应该与Hive一层，考虑到这2个组件先不考虑适用，将它们分开  </p><p>ElasticSearch是搜索引擎、Logstash是用来日志的搜集、分析、过滤日志的工具、Kibana 为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面；<br>这一部分只做简单的介绍  </p><h1 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h1><p><a href="https://www.ibm.com/developerworks/cn/analytics/library/ba-cn-bigdata-hbase/index.html" target="_blank" rel="noopener">参考</a> 、<a href="https://sunyanfeng.cn/2018/01/04/Hadoop%E7%94%9F%E6%80%81-Hive%E3%80%81HBase/" target="_blank" rel="noopener">以前的博客</a>  </p><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>Table：HBase以表(Table)的方式组织数据；<br>HBase：HBase表中的行通过RowKey（类似于DB表的主键）进行唯一标识，HBase表中的行是按RowKey字典顺序排列的；<br>Column Family：引入列族的概念，它将一列或多列组织在一起，列族作为表模式定义的一部分必须预先给出<br>Column： 每个列都数据列族，列名以列族作为前缀，每个列族都可以有多个列成员，新的列，可以随时按需动态加入；<br>Cell：行和列的交叉点称为单元格，单元格的内容就是列的值，以二进制形式存储；<br>Version：每个Cell的值可保存数据的多个版本（到底支持几个版本可在建表时指定），按时间顺序倒序排列，时间戳是64位的整数，可在写入数据时赋值，也可由RegionServer自动赋值  </p><p><img src="./HBase的数据模型.png" alt="HBase的数据模型.png"><br>在逻辑结构上，是按Row -&gt;  CF -&gt; Column -&gt; Cell来存储；<br>在物理存储中，类似于键值对的存储方式，key认为是Row:CF:C，value就是Cell除了值还包括一个时间戳。    </p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="./HBase工作原理.jpg" alt="HBase工作原理.jpg"><br> 一图胜万言，架构就不多说了，主要是RegionServer内部，每一个 Region Server 管理着很多个 Region。对于 HBase 来说，Region 是 HBase 并行化的基本单元。因此，数据也都存储在 Region 中。这里我们需要特别注意，每一个 Region 都只存储一个 Column Family 的数据，并且是该 CF 中的一段（按 Row 的区间分成多个 Region）。Region 所能存储的数据大小是有上限的，当达到该上限时（Threshold），Region 会进行分裂，数据也会分裂到多个 Region 中，这样便可以提高数据的并行化，以及提高数据的容量。每个 Region 包含着多个 Store 对象。每个 Store 包含一个 MemStore，和一个或多个 HFile。MemStore 便是数据在内存中的实体，并且一般都是有序的。当数据向 Region 写入的时候，会先写入 MemStore。当 MemStore 中的数据需要向底层文件系统倾倒（Dump）时（例如 MemStore 中的数据体积到达 MemStore 配置的最大值），Store 便会创建 StoreFile，而 StoreFile 就是对 HFile 一层封装。所以 MemStore 中的数据会最终写入到 HFile 中，也就是磁盘 IO。由于 HBase 底层依靠 HDFS，因此 HFile 都存储在 HDFS 之中。这便是整个 HBase 工作的原理简述。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>cli使用如下：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="string">'t'</span>,  <span class="string">'cf1'</span></span><br><span class="line">put <span class="string">'t'</span>,  <span class="string">'row1'</span> , <span class="string">'cf1:name'</span>, <span class="string">'zhangsan'</span>             // <span class="number">001</span>是rowkey</span><br><span class="line"><span class="keyword">scan</span> <span class="string">'t'</span>                                            // 查看所有</span><br><span class="line"><span class="keyword">get</span> <span class="string">'t'</span>,  <span class="string">'row1'</span></span><br><span class="line"><span class="keyword">disable</span> <span class="string">'t'</span></span><br><span class="line"><span class="keyword">drop</span> <span class="string">'t'</span>                  // 删除表需要先<span class="keyword">disable</span>再<span class="keyword">drop</span></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/liuj2511981/java/article/details/8676519" target="_blank" rel="noopener">简单示例</a>    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HBaseBasic</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HBaseConfiguration config = <span class="keyword">new</span> HBaseConfiguration();</span><br><span class="line">        HBaseAdmin admin = <span class="keyword">new</span> HBaseAdmin(config);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (admin.tableExists(<span class="string">"scores"</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"drop table"</span>);</span><br><span class="line">            admin.disableTable(<span class="string">"scores"</span>);</span><br><span class="line">            admin.deleteTable(<span class="string">"scores"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"create table"</span>);</span><br><span class="line">        HTableDescriptor tableDescripter = newHTableDescriptor(<span class="string">"scores"</span>.getBytes());</span><br><span class="line">        tableDescripter.addFamily(newHColumnDescriptor(<span class="string">"grade:"</span>));</span><br><span class="line">        tableDescripter.addFamily(newHColumnDescriptor(<span class="string">"course:"</span>));</span><br><span class="line">        admin.createTable(tableDescripter);</span><br><span class="line"></span><br><span class="line">        HTable table = <span class="keyword">new</span> HTable(config, <span class="string">"scores"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"add Tom's data"</span>);</span><br><span class="line">        BatchUpdate tomUpdate = <span class="keyword">new</span> BatchUpdate(<span class="string">"Tom"</span>);</span><br><span class="line">        tomUpdate.put(<span class="string">"grade:"</span>, Writables.getBytes(newIntWritable(<span class="number">1</span>)));</span><br><span class="line">        tomUpdate.put(<span class="string">"course:math"</span>, Writables.getBytes(newIntWritable(<span class="number">87</span>)));</span><br><span class="line">        tomUpdate.put(<span class="string">"course:art"</span>, Writables.getBytes(newIntWritable(<span class="number">97</span>)));</span><br><span class="line">        table.commit(tomUpdate);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"add Jerry's data"</span>);</span><br><span class="line">        BatchUpdate jerryUpdate = <span class="keyword">new</span> BatchUpdate(<span class="string">"Jerry"</span>);</span><br><span class="line">        jerryUpdate.put(<span class="string">"grade:"</span>, Writables.getBytes(newIntWritable(<span class="number">2</span>)));</span><br><span class="line">        jerryUpdate.put(<span class="string">"course:math"</span>, Writables.getBytes(newIntWritable(<span class="number">100</span>)));</span><br><span class="line">        jerryUpdate.put(<span class="string">"course:art"</span>, Writables.getBytes(newIntWritable(<span class="number">80</span>)));</span><br><span class="line">        table.commit(jerryUpdate);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (RowResult row : table.getScanner(<span class="keyword">new</span> String[] &#123;<span class="string">"course:"</span> &#125;)) &#123;</span><br><span class="line">            System.out.format(<span class="string">"ROW\t%s\n"</span>, newString(row.getRow()));</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;<span class="keyword">byte</span>[], Cell&gt; entry : row.entrySet()) &#123;</span><br><span class="line">                String column = <span class="keyword">new</span> String(entry.getKey());</span><br><span class="line">                Cell cell = entry.getValue();</span><br><span class="line">                IntWritable value = <span class="keyword">new</span> IntWritable();</span><br><span class="line">                Writables.copyWritable(cell.getValue(), value);</span><br><span class="line">                System.out.format(<span class="string">"  COLUMN\t%s\t%d\n"</span>, column, value.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Hive是最原始的sql on hadoop组件，原理是将SQL语句转换成mapreduce作业。它有一个metastore的概念，就是元数据，这个元数据在后面其他的框架里面也有。Spark有SparkSQL组件，Flink有FlinkSQL组件。<br>Hive适合的是什么场景呢？数据仓库。基于Hadoop做一些数据清洗啊（ETL）、报表啊、数据分析啊。基本上就是朝着替代传统数据库的方向去的，当然是在大数据背景下的替代。本质上来说，它还是一个面向读的、面向分析的SQL工具。<br><a href="https://www.zhihu.com/question/36053025" target="_blank" rel="noopener">出处</a>  </p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>Hive最大的特点是通过类SQL来分析大数据，而避免了写MapReduce程序来分析数据，这样使得分析数据更容易；<br>数据是存储在HDFS上的，Hive本身并不提供数据的存储功能；<br>Hive是将数据映射成数据库和一张张的表，库和表的元数据信息一般存在关系型数据库上（比如MySQL）；<br>数据处理方面：因为Hive语句最终会生成MapReduce任务去计算，所以不适用于实时计算的场景，它适用于离线分析  </p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>  <img src="./Hive架构.png" alt="Hive架构.png">  </p><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>Hive的使用跟sql就很像，这个加载稍微说一下：  </p><p>创建表：  </p><pre><code class="sql"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> default.log (    ip <span class="keyword">string</span> <span class="keyword">COMMENT</span> <span class="string">'remote ip address'</span> ,    <span class="keyword">user</span> <span class="keyword">string</span> ,    req_url <span class="keyword">string</span> <span class="keyword">COMMENT</span> <span class="string">'user request url'</span>)<span class="keyword">COMMENT</span> <span class="string">'BeiFeng Web Access Logs'</span><span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span> <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">' '</span><span class="keyword">STORED</span> <span class="keyword">AS</span> TEXTFILE ;</code></pre><p>加载数据：<br><code>load data local inpath &#39;/opt/datas/bf-log.txt&#39; into table default.log;</code></p><p>local：从本地文件加载数据到hive表；否则从HDFS加载数据到hive表。<br><a href="https://blog.csdn.net/gongxifacai_believe/article/details/80144470" target="_blank" rel="noopener">更多示例</a>  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一部分给出了数据中台的分层，第二部分给出了计算框架，这一部分来看看计算之外的，包括：HBase与Hive&lt;br&gt;本篇是本系列第三篇  &lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>分布式计算框架</title>
    <link href="http://yoursite.com/2020/04/30/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2020/04/30/分布式计算框架/</id>
    <published>2020-04-30T02:48:47.000Z</published>
    <updated>2020-05-06T09:20:35.919Z</updated>
    
    <content type="html"><![CDATA[<p>前文中给出了数据中台的分层，本文对分布式计算框架简单介绍，包括：MapReduce、Spark及Flink。<br>本篇是本系列第二篇  </p><a id="more"></a><h1 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h1><p>理解MapReduce对理解Spark有帮助，所以这里简单介绍一下，Spark与Flink才是计算方面的重头戏。  </p><h2 id="MapReduce的过程"><a href="#MapReduce的过程" class="headerlink" title="MapReduce的过程"></a>MapReduce的过程</h2><p>  <img src="./mapreduce原理.png" alt="mapreduce原理.png"><br>  MapReduce主要分成3个阶段：map、shuffle、reduce<br>  map是对数据分别进行运算的过程，这像是我们用的map函数，如:  </p>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">const</span> b = a.map(<span class="function"><span class="params">v</span> =&gt;</span> v+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>  shuffle可以理解成在本机进行分类的过程，如图：包括对map之后的结果进行partition（分区），sort  （排序），combine合并溢写到磁盘  </p><p>  reduce是对多机的运行结果进行聚合的过程，它通过将copy将多机结果copy过来，然后merge到一起，最  后进行reduce结合操作。  </p><p>  一个实例：<br>  <img src="./MR实例.png" alt="MR实例.png">  </p><h2 id="MapReduce的任务调度"><a href="#MapReduce的任务调度" class="headerlink" title="MapReduce的任务调度"></a>MapReduce的任务调度</h2><p>  <a href="https://cloud.tencent.com/developer/article/1023958" target="_blank" rel="noopener">参考</a><br>  <img src="./mr任务调度.png" alt="mr任务调度.png">  </p><p>一个完整的mapreduce作业流程，包括4个独立的实体：<br>client：编写mapreduce程序，配置作业，提交作业;<br>JobTracker：协调这个作业的运行，分配作业，初始化作业，与TaskTracker进行通信;<br>TaskTracker：负责运行作业，保持与JobTracker进行通信;<br>HDFS：分布式文件系统，保持作业的数据和结果.  </p><p>过程基本上看图就可以看明白，需要多说一下任务部分：  </p><ul><li><p>任务分配：<br>TaskTracker和JobTracker之间的通信和任务分配是通过心跳机制完成的。TaskTracker作为一个单独的JVM，它执行一个简单的循环，主要实现每隔一段时间向JobTracker发送心跳，告诉JobTracker此TaskTracker是否存活，是否准备执行新的任务。如果有待分配的任务，它就会为TaskTracker分配一个任务。  </p></li><li><p>任务执行：<br>TaskTracker申请到新的任务之后，就要在本地运行了。首先，是将任务本地化（包括运行任务所需的数据、配置信息、代码等），即从HDFS复制到本地。调用localizeJob()完成的。<br>对于使用Streaming和Pipes创建Map或者Reduce程序的任务，Java会把key/value传递给外部进程，然后通过用户自定义的Map或者Reduce进行处理，然后把key/value传回到java中。其中就好像是TaskTracker的子进程在处理Map和Reduce代码一样。  </p></li><li><p>执行结果：<br>当Job完成后，JobTracker会收一个Job Complete的通知，并将当前的Job状态更新为successful，同时JobClient也会轮循获知提交的Job已经完成，将信息显示给用户。<br>最后，JobTracker会清理和回收该Job的相关资源，并通知TaskTracker进行相同的操作（比如删除中间结果文件）。</p></li></ul><h1 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h1><p>spark的文章，要么过于肤浅，要么过于片面，没有很好的借鉴，这里参考官网、以前的博客、以及一些网文进行汇总。  </p><h2 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h2><p>spark有很多的运行模式，可以单机、分布式时，可以通过內建的Standalone模式进行资源调度，也可以借助Mesos与Yarn进行资源调度。结构大于如下：<br><img src="./spark集群结构.png" alt="spark集群结构.png"><br>Master做调度，Woker节点负责执行任务。Master节点做高可用  </p><h2 id="RDD"><a href="#RDD" class="headerlink" title="RDD"></a>RDD</h2><p>理解Spark需要层RDD入手，那什么是RDD？Resilient Distributed Dataset，弹性分布式数据集。它包括：  </p><ol><li>a list of partitions(固定在某节点里的某块连续数据):一般是一个hdfs的block对应一个partitions，一般遵循数据的本地性。  </li><li>a function for computiong each split（partitons=split从数据角度，mr的切割，算子：map、filter, reduce等等）</li><li>a list of dependencies on other RDDS(不同算子将RDD变成不同的RDD，用于重新计算，内存中RDD不稳定缘故，出现宕机会重算)    </li></ol><p>这样看RDD有点想面向对象时的class：数据、定义在数据上的函数，并且数据还有与其他RDD的关联<br>看一段代码：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JavaRDD&lt;String&gt; lines = sc.textFile(<span class="string">"data.txt"</span>);</span><br><span class="line">JavaRDD&lt;Integer&gt; lineLengths = lines.map(s -&gt; s.length());</span><br><span class="line"><span class="keyword">int</span> totalLength = lineLengths.reduce((a, b) -&gt; a + b);</span><br></pre></td></tr></table></figure><p>data.txt是数据,map与reduce是算子  </p><p>在RDD基础之上，Spark又抽象了与DataFrame数据帧与DataStream流，这一部分先不深挖。详见:<a href="https://spark.apache.org/docs/latest/sql-programming-guide.html" target="_blank" rel="noopener">DataFrame</a> 、<a href="https://spark.apache.org/docs/latest/structured-streaming-programming-guide.html" target="_blank" rel="noopener">DStream</a>  </p><h2 id="算子"><a href="#算子" class="headerlink" title="算子"></a>算子</h2><p>DAG是有向无环图的意思，要理解DAG，要从算子开始说起。  </p><p><a href="https://spark.apache.org/docs/latest/rdd-programming-guide.html#transformations" target="_blank" rel="noopener">算子</a><br><img src="./算子.png" alt="算子.png"><br>大约分成了T ransformation算子与action算子，Transformation算子从一种RDD转换成另外一种，action算子则直接出的结果  。<br>整个Job由这些算子组成，由开始到结束，形成了有向无环图DAG。  </p><h2 id="DAG"><a href="#DAG" class="headerlink" title="DAG"></a>DAG</h2><p><img src="./DAG与宽窄依赖.png" alt="DAG与宽窄依赖.png">   </p><p>在这些算子中，有些被成为Shuffle算子，这些算子会触发数据的重新分布，如此对不同的partition进行重组。<br>Spark根据shuffle路由，划分了宽窄依赖。有Shuffle算子的就是宽依赖，比如上图的GroupBy算子与Join算子，没有Shuffle算子的就是窄依赖，如map，union算子。然后以宽依赖为边界，将job划分成了多个Stage，然后将stage划分成多个task进行计算。   </p><p> 整体过程如下：<br><img src="./RDD的运行过程.png" alt="RDD的运行过程.png"><br>(1)  首先针对一段应用代码，driver会以action算子为边界生成响应的DAG图<br>(2)  DAG Scheduler从DAG图的末端开始，以图中的shuffle算子为边界来划分stage，stage划分完成后，将每个stage划分为多个task，DAG Scheduler将taskSet传给Task Scheduler来调用<br>(3)  Task Scheduler根据一定的调度算法，将接收到的task池中的task分给work node节点中的executor执行  </p><h2 id="Spark与MR"><a href="#Spark与MR" class="headerlink" title="Spark与MR"></a>Spark与MR</h2><p>从上边的介绍看，可以看出Spark与MR的一点不同，Spark基本是在内存中运算的，而MapReduce通过Hadoop到本地来进行的，所以Spark会比MapReduce快一些。还有一个相同点，他们都是批处理方式，RDD的partition是一个批量数据。Spark在此基础上，发展了DataStream的流处理方式，这一块上文没有介绍到。  </p><h1 id="Structured-Streaming"><a href="#Structured-Streaming" class="headerlink" title="Structured Streaming"></a>Structured Streaming</h1><p>以上对Spark的介绍，基本都是批处理部分，它承接的是MapReduce，对于流处理部分，单独拿出来。这一部分对照后边的Flink。先简单介绍一下Spark Streaming，然后介绍最新的<a href="https://spark.apache.org/docs/latest/structured-streaming-programming-guide.html" target="_blank" rel="noopener">Structured Streaming</a>    </p><h2 id="Spark-Streaming简介"><a href="#Spark-Streaming简介" class="headerlink" title="Spark Streaming简介"></a>Spark Streaming简介</h2><p><img src="./SparkStreaming.png" alt="SparkStreaming.png"><br>Spark Streaming获取实时数据，将它们分割成小批次，然后交给Spark引擎去处理  </p><p><img src="./DStream.png" alt="DStream.png"><br>Spark Streaming提供一个高层的抽象：discretized stream，DStream，代表连续数据流，从源接收的输入数据流，或通过转换输入流生成的已处理数据流。在内部，一个DStream由一系列连续的RDD表示。如上图，一个DStream转换成4个RDD。在DStream上执行的任何操作都转换为对基础RDD的操作。  </p><h2 id="Structured-Streaming-1"><a href="#Structured-Streaming-1" class="headerlink" title="Structured Streaming"></a>Structured Streaming</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="./StructureStream图.png" alt="StructureStream图.png"><br>将输入数据流视为“输入表”，流上到达的每个数据项都像是将新行附加到输入表中。<br><img src="./SS编程模型.png" alt="SS编程模型.png"><br>输入查询将生成“结果表”。在每个触发间隔（例如，每1秒钟），新行将附加到输入表中，然后最终触发结果表更新。无论何时更新结果表，更改后的结果行写入外部存储。<br>结果输出到外存中，有3种方式：Complete Mode（全量）、Append Model（添加）、Update Model（更新）</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><img src="./SS示例.png" alt="SS示例.png">   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create DataFrame representing the stream of input lines from connection to localhost:9999</span></span><br><span class="line">Dataset&lt;Row&gt; lines = spark</span><br><span class="line">.readStream()</span><br><span class="line">.format(<span class="string">"socket"</span>)</span><br><span class="line">.option(<span class="string">"host"</span>, <span class="string">"localhost"</span>)</span><br><span class="line">.option(<span class="string">"port"</span>, <span class="number">9999</span>)</span><br><span class="line">.load();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Split the lines into words</span></span><br><span class="line">Dataset&lt;String&gt; words = lines</span><br><span class="line">.as(Encoders.STRING())</span><br><span class="line">.flatMap((FlatMapFunction&lt;String, String&gt;) x -&gt; Arrays.asList(x.split(<span class="string">" "</span>)).iterator(), Encoders.STRING());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate running word count</span></span><br><span class="line">Dataset&lt;Row&gt; wordCounts = words.groupBy(<span class="string">"value"</span>).count();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start running the query that prints the running counts to the console</span></span><br><span class="line">StreamingQuery query = wordCounts.writeStream()</span><br><span class="line">.outputMode(<span class="string">"complete"</span>)</span><br><span class="line">.format(<span class="string">"console"</span>)</span><br><span class="line">.start();</span><br><span class="line"></span><br><span class="line">query.awaitTermination();</span><br></pre></td></tr></table></figure><h3 id="过期数据"><a href="#过期数据" class="headerlink" title="过期数据"></a>过期数据</h3><p>这里增加了一种对过时数据处理的功能，很多情况下对于这种 late data 的时效数据并没有必要一直保留太久。比如说，数据晚了 10 分钟或者还有点有，但是晚了 1 个小时就没有用了，另外这样设计还有一个好处就是中间状态没有必要维护那么多。watermark 的形式化定义为 max(eventTime) - threshold，早于 watermark 的数据直接丢弃  。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Dataset&lt;Row&gt; words = ... <span class="comment">// streaming DataFrame of schema &#123; timestamp: Timestamp, word: String &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Group the data by window and word and compute the count of each group</span></span><br><span class="line">Dataset&lt;Row&gt; windowedCounts = words</span><br><span class="line">    .withWatermark(<span class="string">"timestamp"</span>, <span class="string">"10 minutes"</span>)</span><br><span class="line">    .groupBy(</span><br><span class="line">        window(col(<span class="string">"timestamp"</span>), <span class="string">"10 minutes"</span>, <span class="string">"5 minutes"</span>),</span><br><span class="line">        col(<span class="string">"word"</span>))</span><br><span class="line">    .count();</span><br></pre></td></tr></table></figure><p>在 12:15 trigger 时 watermark 为 12:14 - 10m = 12:04，所以 late date (12:08, ; 12:13,) 都被接收了，所以 late data (12:04, donkey) 都丢弃了  </p><h3 id="连续处理（Continuous-Processing）"><a href="#连续处理（Continuous-Processing）" class="headerlink" title="连续处理（Continuous Processing）"></a>连续处理（Continuous Processing）</h3><p>  在新版(2.4)的Spark中增加了一个实验性的Model，之前 Spark 是基于 micro-batch 模式的，就被很多人诟病不是“真正的”流式处理。continuous mode 这种处理模式只要一有数据可用就会进行处理。epoch 是 input 中数据被发送给 operator 处理的最小单位。这块内容官网很少，简单一提。  </p><h1 id="Flink"><a href="#Flink" class="headerlink" title="Flink"></a>Flink</h1><p><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.10/concepts/programming-model.html" target="_blank" rel="noopener">官网</a>、<a href="http://wuchong.me/" target="_blank" rel="noopener">参考1</a>、<a href="https://www.jianshu.com/p/2ee7134d7373" target="_blank" rel="noopener">参考2</a>  </p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>首先 Flink 是一个纯流式的计算引擎，它的基本数据模型是数据流。流可以是无边界的无限流，即一般意义上的流处理。也可以是有边界的有限流，这样就是批处理。因此 Flink 用一套架构同时支持了流处理和批处理。其次，Flink 的一个优势是支持有状态的计算。如果处理一个事件（或一条数据）的结果只跟事件本身的内容有关，称为无状态处理；反之结果还和之前处理过的事件有关，称为有状态处理。稍微复杂一点的数据处理，比如说基本的聚合，数据流之间的关联都是有状态处理。  </p><h2 id="编程模型"><a href="#编程模型" class="headerlink" title="编程模型"></a>编程模型</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="./Flink编程模型.png" alt="Flink编程模型.png">  </p><ol><li>Stateful Stream Processing：最底层，只简单提供有状态的数据流，通过ProcessFunction嵌入到DataSream Api  </li><li>DataSream/DataSet Api: 这一层是核心Api层，它提供了数据处理的基础模块，像各种transformation, join,aggregations,windows,stat 以及数据类型等等  </li><li>Table Api层，它是围绕表的声明性DSL，它可以动态更改Table（在表示流时）。 Table API遵循（扩展的）关系模型：表具有附加的schema（类似于关系数据库中的表），并且该API提供可比较的操作，例如select、project、join<br>、group-by、aggregate等。</li><li><p>SQL层。 它是定义与Table API层次之上的，但是提供的是纯SQL的查询表达式。</p><p><img src="./Flink的StreamingDataflow.png" alt="Flink的StreamingDataflow.png"><br>Flink程序的基本模块是Stream和Transformtions,Stream是（可能是永无止境的）数据记录流，而Transformtions是一种操作，它将一个或多个流作为输入，并产生一个或多个输出流。这点与spark应该类似。  </p><p><img src="./Flink数据流并行view.png" alt="Flink数据流并行view.png"><br>一个Stream可以被分成多个Stream分区（Stream Partitions），一个Operator可以被分成多个Operator Subtask，每一个Operator Subtask是在不同的线程中独立执行的。一个Operator的并行度，等于Operator Subtask的个数，一个Stream的并行度总是等于生成它的Operator的并行度。这是spark中宽窄依赖的划分，Flink中的术语是One2One与redistributing两种模式<br>Flink的<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.10/dev/stream/operators/index.html" target="_blank" rel="noopener">数据流算子</a>、<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.10/dev/batch/dataset_transformations.html" target="_blank" rel="noopener">批处理算子</a>，其中，批处理算子与saprk的很像。比如这个join操作：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123; <span class="keyword">public</span> String name; <span class="keyword">public</span> <span class="keyword">int</span> zip; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123; <span class="keyword">public</span> Manager mgr; <span class="keyword">public</span> <span class="keyword">int</span> zip; &#125;</span><br><span class="line">DataSet&lt;User&gt; input1 = <span class="comment">// [...]</span></span><br><span class="line">DataSet&lt;Store&gt; input2 = <span class="comment">// [...]</span></span><br><span class="line"><span class="comment">// result dataset is typed as Tuple2</span></span><br><span class="line">DataSet&lt;Tuple2&lt;User, Store&gt;&gt;</span><br><span class="line">            result = input1.join(input2)</span><br><span class="line">                          .where(<span class="string">"zip"</span>)       <span class="comment">// key of the first input (users)</span></span><br><span class="line">                          .equalTo(<span class="string">"zip"</span>);    <span class="comment">// key of the second input (stores)</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="window"><a href="#window" class="headerlink" title="window"></a>window</h3><p><img src="./Flink窗口.png" alt="Flink窗口.png"><br>流处理中的聚合操作（counts,sums等等）不同于批处理，因为数据流是无限，无法在其上应用聚合，所以通过限定窗口(window)的范围，来进行流的聚合操作。例如：5分钟的数据计数，或者计算100个元素的总和等等。<br>窗口可以由时间驱动 (every 30 seconds) 或者数据驱动(every 100 elements)。如：滚动窗口tumbling windows（无叠加），滑动窗口sliding windows（有叠加），以及会话窗口session windows(被无事件活动的间隔隔开)<br>PS：这个窗口的概念，跟TCP中的滑动窗口有些像，而且针对的都是流。  </p><h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><p><img src="./Flink的Time.png" alt="Flink的Time.png"><br>事件时间 Event Time：事件的创建时间，通常通过时间中的一个时间戳来描述<br>摄入时间 Ingestion time： 事件进入Flink 数据流的source的时间<br>处理时间 Processing Time:Processing Time表示某个Operator对事件进行处理时的本地系统时间（是在TaskManager节点上）<br>PS：这个与spark中的WarterMark相同  </p><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p><img src="./Flink的state.png" alt="Flink的state.png"><br>在流处理中，有些操作仅仅在某一时间针对单一事件（如事件转换map），有些操作需要记住多个事件的信息并进行处理（window operators）,后者的这些操作称为有状态的操作。<br>有状态的操作一般被维护在内置的key/value存储中。这些状态信息会跟数据流一起分区并且分布存储，并且可以通过有状态的数据操作来访问。因此这些key/value的状态信息仅在带key的数据流（通过keyBy() 函数处理过）中才能访问到。数据流按照key排列能保证所有的状态更新都是本地操作，保证一致性且无事务问题。<br>PS：状态这部分与Spark的处理不同，spark的SS，将状态都是存储的，有complete、append、update等方式。  </p><h3 id="容错的Checkpoint"><a href="#容错的Checkpoint" class="headerlink" title="容错的Checkpoint"></a>容错的Checkpoint</h3><p>Flink 通过流回放和设置检查点的方式实现容错。一个checkpoint关联了输入流中的某个记录和相应状态和操作。数据流可以从checkpoint中进行恢复，并保证一致性（exactly-once 的处理语义）。 Checkpoint的间隔关系到执行是的容错性和恢复时间。  </p><h2 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h2><p>  <img src="./Flink的runtime.png" alt="Flink的runtime.png"><br>  Flink的运行时，由两种类型的进程组成：</p><p>  JobManagers： 也就是masters ，协调分布式任务的执行 。用来调度任务，协调checkpoints，协调错误恢复等等。至少需要一个JobManager，高可用的系统会有多个，一个leader，其他是standby<br>  TaskManagers： 也就是workers，用来执行数据流任务或者子任务，缓存和交互数据流。 至少需要一个TaskManager<br>  Client: Client不是运行是和程序执行的一部分，它是用来准备和提交数据流到JobManagers。之后，可以断开连接或者保持连接以获取任务的状态信息。<br>  PS: 这个运行环境与spark、就很相似啦</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>  可以看出Flink与spark的异同，它们都是分布式计算，从流或批量中获取数据开始，到通过算子对数据进行变换与操作，最后得到结果存储、发布。<br>  在对算子的划分上两者是一样的，Flink基于流的window与状态都很有特色，Spark将流当成无限大表的构思也不错，在对状态的处理上，Spark应该不如Flink一些。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前文中给出了数据中台的分层，本文对分布式计算框架简单介绍，包括：MapReduce、Spark及Flink。&lt;br&gt;本篇是本系列第二篇  &lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据仓库与数据中台简介</title>
    <link href="http://yoursite.com/2020/04/28/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2020/04/28/数据仓库与数据中台简介/</id>
    <published>2020-04-28T12:18:56.000Z</published>
    <updated>2020-05-06T09:19:25.018Z</updated>
    
    <content type="html"><![CDATA[<p>本阶段想做统计服务，由于之前写SQL的糟糕体验，这次准备对统计做一番调研，来设计一个好扩展、性能高的统计服务。用了一周左右的时间进行了梳理，写成博客做个分享。<br>本篇是本系列第一篇，主要介绍数据仓库与数据中台概念</p><a id="more"></a><h1 id="数据仓库"><a href="#数据仓库" class="headerlink" title="数据仓库"></a>数据仓库</h1><p><a href="https://www.toutiao.com/i6701129910171206151/?tt_from=weixin&amp;utm_campaign=client_share&amp;wxshare_count=1&amp;timestamp=1588054639&amp;app=news_article&amp;utm_source=weixin&amp;utm_medium=toutiao_android&amp;req_id=202004281417190100260772010276CE16&amp;group_id=6701129910171206151" target="_blank" rel="noopener">参考</a>  </p><h2 id="几个术语"><a href="#几个术语" class="headerlink" title="几个术语"></a>几个术语</h2><p>OLTP(On-Line Transaction Processing)，在线事务处理，操作型处理<br>OLAP(On-Line Analytical Processing)，在线分析处理，分析型处理<br>ODS(Operational Data Store)，操作数据存储，为多个数据源聚合数据时做临时存储使用<br>DW(DataWareHose)，数据仓库，一致的、准确的、干净的数据，最细粒度的数据<br>DM(Data Market)，数据集市层，面向主题来组织数据，是对DW层数据的轻度汇总<br>ADS(Application Data Store)，应用数据存储，数据的应用层存储</p><h2 id="架构的演变"><a href="#架构的演变" class="headerlink" title="架构的演变"></a>架构的演变</h2><ul><li><p>离线架构  </p><p><img src="./离线架构.png" alt="离线架构.png">  </p><p>业务数据通过ETL工具经过提取（Extract）到ODS中，然后在ODS中进行清理（Clean）、转换(Tranform)，最终加载(Loading)到DW中。然后在DW中，面向主题（应用）进行初步的统计，存储到DM中。最后数据应用层，使用存储在DW、DM中的数据使用，为数据业务提供支持。  </p></li><li><p>lamda架构  </p><p><img src="./lamda架构.png" alt="lamda架构.png"><br> 随着人们对系统的实时性要求的提高，为了计算一些实时指标，就在原来离线数仓的基础上增加了一个实时计算的链路，并对数据源做流式改造（即把数据发送到消息队列），实时计算去订阅消息队列，直接完成指标增量的计算，推送到下游的数据服务中去，由数据服务层完成离线&amp;实时结果的合并。<br>注：流处理计算的指标批处理依然计算，最终以批处理为准，即每次批处理计算后会覆盖流处理的结果。（这仅仅是流处理引擎不完善做的折中）</p></li><li><p>Kappa架构</p><p><img src="./Kappa架构.png" alt="Kappa架构.png"><br> Lambda架构虽然满足了实时的需求，但带来了更多的开发与运维工作，其架构背景是流处理引擎还不完善，流处理的结果只作为临时的、近似的值提供参考。后来随着Flink等流处理引擎的出现，流处理技术很成熟了，这时为了解决两套代码的问题，LickedIn 的Jay Kreps提出了Kappa架构。<br> 在Kappa架构中，由于流计算的成熟，去掉了离线的批量的方式，直接对流数据进行操作了。其实，我倒觉得Kappa的出现，一方面是流计算本身的成熟，另一方面也是大部分业务数据通过前期的离线方式，已经整合进了数据仓库，现阶段只关注增量数据即可。如果lamda架构中，如果将Flink替换不成熟的流处理引擎，也就整合了Kappa。</p></li><li><p>其他<br> 随着数据多样性的发展，数据仓库这种提前规定schema的模式显得越来难以支持灵活的探索&amp;分析需求，这时候便出现了一种数据湖技术，即把原始数据全部缓存到某个大数据存储上，后续分析时再根据需求去解析原始数据。简单的说，数据仓库模式是schema on write，数据湖模式是schema on read。  </p></li></ul><h2 id="Kappa示例"><a href="#Kappa示例" class="headerlink" title="Kappa示例"></a>Kappa示例</h2><p><img src="./数据模型.png" alt="数据模型.png">  </p><p>第一层DWD公共实时明细层<br>实时计算订阅业务数据消息队列，然后通过数据清洗、多数据源join、流式数据与离线维度信息等的组合，将一些相同粒度的业务系统、维表中的维度属性全部关联到一起，增加数据易用性和复用性，得到最终的实时明细数据。这部分数据有两个分支，一部分直接落地到ADS，供实时明细查询使用，一部分再发送到消息队列中，供下层计算使用；</p><p>第二层DWS公共实时汇总层<br>以数据域+业务域的理念建设公共汇总层，与离线数仓不同的是，这里汇总层分为轻度汇总层和高度汇总层，并同时产出，轻度汇总层写入ADS，用于前端产品复杂的olap查询场景，满足自助分析和产出报表的需求；高度汇总层写入Hbase，用于前端比较简单的kv查询场景，提升查询性能，比如实时大屏等；</p><p>这里的维度信息，应该就是静态的字典型的信息。  </p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>前文设计的报表服务，是一种lamda架构的数据仓储技术，全量数据是从业务数据库中读取，而增量数据通过消息来获取。<br>离线架构中，在DW中，保存的是细粒度的数据，然后在DM中去连接，而这个在Kappa模型中，就是直接join了。  </p><h1 id="数据中台"><a href="#数据中台" class="headerlink" title="数据中台"></a>数据中台</h1><p>下边换个看看从数据仓库到数据中台，这篇文章是从微信的DBAplus社区而来。  </p><h2 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h2><p><img src="./大数据发展历程.png" alt="大数据发展历程.png"><br>这个是一个宽泛的划分方式，我觉得上文中的，对应着数据库时代、离线数据仓库时代、实时流仓库（数据中台）时代。  </p><h2 id="核心架构"><a href="#核心架构" class="headerlink" title="核心架构"></a>核心架构</h2><p><img src="./数据中台核心架构.png" alt="数据中台核心架构.png">  </p><p>底座是数据基础平台，包括数据采集平台&amp;计算平台&amp;存储平台，这些可以自建也可以使用云计算服务；  </p><p>中间部分两大块是中台的公共数据区，公共数据区包括数据仓库(数据湖) ，主要负责公共数据模型研发，还包括统一指标（标签）平台，负责把模型组织成可以对外服务的数据，例如数据指标、数据标签；  </p><p>上层是数据应用服务层，主要将公共数据区的数据对外包装并提供服务，包括数据接口平台、多维查询平台，数据可视化平台、数据分析平台等。  </p><p>这里的分类，数据中台是建立上数据仓库基础上的，增加了一层统一指标/标签平台，这在数据仓库视角中，应该属于数据应用层。可能是在机器学习的一些算法下，用数据模型来对数据分类与标示的过程。  </p><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p><img src="./技术选型.png" alt="技术选型.png">  </p><ul><li><p>数据抽取层<br>sqoop和flume是两大主流工具，其中sqoop作为结构化数据（关系型数据库）离线抽取，flume作为非结构化日志接入；  </p></li><li><p>数据存储层<br>Hadoop文件系统Hdfs大家都比较了解，而kafka作为流式数据总线应用也非常广泛；  </p></li><li><p>计算与调度层<br>包括：<br>离线计算：离线计算主要是hive，spark，也有部分选用tez<br>实时计算：前些年storm，spark比较流行，最近几年大家纷纷往Flink转型  </p></li><li><p>数据调度<br>除了像Airflow Azkaban Oozie等，易观开源的Dolphin-scheduler也非常活跃  </p></li><li><p>数据引擎层<br> 也就是我们常说的OLAP层，我们看到这一层里的选择非常多，就不一一列举了，（业务需求带动技术进步的典型，选择丰富主要是可以适配不同的数据应用场景）。从概念上讲分为ROLAP、MOLAP以及两者混搭。MOLAP提前做一些预计算，以生成Cube的方式，达到空间换取查询效率；而ROLAP是即查即用，效率完全取决于查询引擎的性能，我个人认为从将来看，ROLAP的趋势会更加明显，因为没有中间的数据链路。但目前看来，没有一个统一的引擎足以支撑各类数据场景（这或许是将来的机会~）；  </p></li><li><p>数据可视化层<br> 比较主流的有Metabase、Superset、Redash，也可以选择阿里、百度的一些开源控件。</p></li></ul><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><ul><li><p>数仓分层<br><img src="./数仓分层.png" alt="数仓分层.png"><br>原文说这里使用了ELT的数据架构，查了一下，如下：<br><img src="./ETL与ELT.png" alt="ETL与ELT.png"><br>说白了，就是ELT增加了通过数据模型打标签那一层，是广义上的Transform<br>这里的DWD：公共明细层，DWS公共汇总层，就是对应的之前的DW与DM。  </p><p>公共数据层是数据仓库的核心层，是整个数仓中使用率最高的，这一层主要采用的维度建模思路进行设计，类型包括事务事实、周期快照、累积快照。同时为了方便下游对数据的使用，我们会设计一系列的宽表模型，将不同业务过程中的事实进行统一整合，包括纵向整合&amp;横向整合；对于商品、用户主数据类可能分散在不同的源系统中采用纵向整合；横向整合主要包括交易、内容等行为数据不同业务过程的整合，比如：用户（用户信息、注册信息）购买（下单、支付、结算、覆约、完成）商品（商品信息，商家信息，等），我们会把订单流转业务过程整合放到一张明细表里，同时会研发一些基于用户、或者商品视角的轻度汇总宽表。</p></li><li><p>主题分类<br>数仓架构的数据分类两个视角，包括主题视角与业务视角。  </p><p>最重要的一个视角，也就是咱们经常提到的数仓主题，主题是将企业的业务进行宏观数据抽象，是数据仓库里数据的主要组织形式，划分方法如下：<br>参照波特价值链，分析企业本身经营的业务（基本活动、支持型活动），分别对应哪些数据；<br>参照业界通用模型，例如像IBM、TD等针对大型行业（如电信、金融、零售）有一些数据主题的通用划分方法；<br>对企业的内部数据（线上数据模块、数据字典）进行摸底，确认对应到哪些主题。<br>划分结果会按照三个层级：主题域–》主题–》子主题。<br>第一级是主题域，针对相对稳定的主题进行合并，归拢到主题域，利于数据的理解与建立全局的数据资产目录；<br>第二级是主题；<br>第三级是子主题，主要针对有些主题下分类较多，比如供应链主题下会包含采购、仓储、配送等子主题。<br>数据主题划分建议完全互斥，不建议重复。  </p><p>数据业务域是根据企业经营的具体业务，结合企业的组织架构进行划分，层次和分类可以相对灵活，子分类可以允许重复，因为两条不同的业务域可能经营相同的业务。  </p></li><li><p>数据模型<br>整体的数据模型设计通过模型设计工具完成，包括从概念模型、逻辑模型到物理模型的设计。模型设计完成后，可以一键生成数据知识文档。  </p></li></ul><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>这一部分要结合前一部分的数据仓库来看，数据中心是数据仓库的发展，它没有将重心放在数据整合，而是放在了数据应用上，尤其在数据模型上，尤其是指标/标签平台。<br>数据模型一般都是用python来训练，训练之后来对数据进行识别、分类是否也是用的python，这块就不得而知了<br>总的来说，通过这些探索，基本贯穿了业务、大数据、数据分析3个领域，收获不错  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本阶段想做统计服务，由于之前写SQL的糟糕体验，这次准备对统计做一番调研，来设计一个好扩展、性能高的统计服务。用了一周左右的时间进行了梳理，写成博客做个分享。&lt;br&gt;本篇是本系列第一篇，主要介绍数据仓库与数据中台概念&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>gossip协议</title>
    <link href="http://yoursite.com/2020/04/21/gossip%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2020/04/21/gossip协议/</id>
    <published>2020-04-21T00:48:39.000Z</published>
    <updated>2020-04-24T00:45:46.333Z</updated>
    
    <content type="html"><![CDATA[<p>前边微服务框架选择中，反复看到一致性的协议，这一阶段就来对这些一些进行研究，包括：Paxos协议、Raft协议、Gossip协议，本文是这一系列第三篇：Gossip协议  </p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果仅看协议本身，Gossip协议比Paxos与Raft协议都要简单一些，下载论文一看，在它背后还是有些东西需要去深入学习一下。与前2篇不同，本文打算不再以论文为中心。<br>本文参考<a href="https://github.com/CDDSCLab/DMCL-2018/blob/master/Theory/Part4_DistributedConsensus/gossip.md" target="_blank" rel="noopener">Gossip文章</a>、<a href="https://zhuanlan.zhihu.com/p/41228196" target="_blank" rel="noopener">Gossip知乎</a>以及<a href="http://bitsavers.trailing-edge.com/pdf/xerox/parc/techReports/CSL-89-1_Epidemic_Algorithms_for_Replicated_Database_Maintenance.pdf" target="_blank" rel="noopener">论文</a>  </p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Gossip 过程是由种子节点发起，当一个种子节点有状态需要更新到网络中的其他节点时，它会随机的选择周围几个节点散播消息，收到消息的节点也会重复该过程，直至最终网络中所有的节点都收到了消息。这个过程可能需要一定的时间，由于不能保证某个时刻所有节点都收到消息，但是理论上最终所有节点都会收到消息，因此它是一个最终一致性协议。</p><p><img src="gossip协议.webp" alt="gossip协议.webp"><br>ps: 从动图上可以看出4节点被传播了2遍，问题是什么情况下集群认为已经达成一致，不再需要传播了。  </p><p>正是疫情期间，Gossip的指数传播效率还是很高的，系统的不一致状态很快可以得到收敛。即使再快的效率，这个过程还是需要时间的，在实时性要求不高的场合，应该是能够接受的。  </p><h1 id="Gossip"><a href="#Gossip" class="headerlink" title="Gossip"></a>Gossip</h1><h2 id="Gossip的2种类型"><a href="#Gossip的2种类型" class="headerlink" title="Gossip的2种类型"></a>Gossip的2种类型</h2><ul><li>Anti-Entropy（反熵）：以固定的概率传播所有的数据(只要数据不同步就开始同步数据)</li><li>Rumor-Mongering（谣言传播）：仅传播新到达的数据(每隔固定的时间同步数据)</li></ul><p>Anti-Entropy 是 SI model，节点只有两种状态，Suspective 和 Infective，叫做 simple epidemics。<br>Rumor-Mongering 是 SIR model，节点有三种状态，Suspective，Infective 和 Removed，叫做 complex epidemics<br>在 SI model 下，一个节点会把所有的数据都跟其他节点共享，以便消除节点之间数据的任何不一致，它可以保证最终、完全的一致。由于在SI model 下消息会不断反复的交换，因此消息数量是非常庞大的，无限制的（unbounded），这对一个系统来说是一个巨大的开销。<br>在 Rumor Mongering（SIR Model） 模型下，消息可以发送得更频繁，因为消息只包含最新 update，体积更小。而且，一个 Rumor 消息在某个时间点之后会被标记为 removed，并且不再被传播，因此，SIR model 下，系统有一定的概率会不一致。而由于，SIR Model 下某个时间点之后消息不再传播，因此消息是有限的，系统开销小。<br>PS：SI方式很不环保，为了一致性付出了巨大的带宽代价，而且对于大数据，根本不现实，几个节点固定时间传播PB量级数据，这没有可能。</p><h2 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2><p>在 Gossip 协议下，网络中两个节点之间有三种通信方式:</p><p>Push: 节点 A 将数据 (key,value,version) 及对应的版本号推送给 B 节点，B 节点更新 A 中比自己新的数据<br>Pull：A 仅将数据 key, version 推送给 B，B 将本地比 A 新的数据（Key, value, version）推送给 A，A 更新本地<br>Push/Pull：与 Pull 类似，只是多了一步，A 再将本地比 B 新的数据推送给 B，B 则更新本地<br>如果把两个节点数据同步一次定义为一个周期，则在一个周期内，Push 需通信 1 次，Pull 需 2 次，Push/Pull 则需 3 次。虽然消息数增加了，但从效果上来讲，Push/Pull 最好，理论上一个周期内可以使两个节点完全一致。直观上，Push/Pull 的收敛速度也是最快的。  </p><h2 id="协调机制"><a href="#协调机制" class="headerlink" title="协调机制"></a>协调机制</h2><p>协调机制是讨论在每次2个节点通信时，如何交换数据能达到最快的一致性，也即消除两个节点的不一致性。push、pull等是通信方式，协调是在通信方式下的数据交换机制。协调所面临的最大问题是，因为受限于网络负载，不可能每次都把一个节点上的数据发送给另外一个节点，也即每个Gossip的消息大小都有上限。在有限的空间上有效率地交换所有的消息是协调要解决的主要问题。</p><ul><li><p>精确协调<br>精确协调希望在每次通信周期内都非常准确地消除双方的不一致性，具体表现为相互发送对方需要更新的数据，因为每个节点都在并发与多个节点通信，理论上精确协调很难做到。精确协调需要给每个数据项独立地维护自己的version，在每次交互是把所有的(key,value,version)发送到目标进行比对，从而找出双方不同之处从而更新。但因为Gossip消息存在大小限制，因此每次选择发送哪些数据就成了问题。当然可以随机选择一部分数据，也可确定性的选择数据。对确定性的选择而言，可以有最老优先（根据版本）和最新优先两种，最老优先会优先更新版本最新的数据，而最新更新正好相反，这样会造成老数据始终得不到机会更新，也即饥饿。<br>ps：精确协调并没有解决双方的不一致，除非把双方所有的数据进行对比，而这又是很低效的，另外各自维护自己的version也增加了对比的难度。各自维护自己的version对于每个节点本身是有用处的，但对于2个节点而言，并没发现起用处。</p></li><li><p>整体协调<br>整体协调与精确协调不同之处是，整体协调不是为每个数据都维护单独的版本号，而是为每个节点上的宿主数据维护统一的version。比如节点P会为(p1,p2,…)维护一个一致的全局version，相当于把所有的宿主数据看作一个整体，当与其他节点进行比较时，只需选择这些宿主数据的最高version，如果最高version相同说明这部分数据全部一致，否则再进行精确协调。<br>整体协调对数据的选择也有两种方法：<br>广度优先：根据整体version大小排序，也称为公平选择<br>深度优先：根据包含数据多少的排序，也称为非公平选择。因为后者更有使用价值，所有原论文更鼓励后者  </p><p>ps：整体协调理想很丰满，问题是如何维护全局的version，这不就是Raft中的term吗？不就是Paxos中的index吗？它俩为了维持这个一致，费了多少功夫。  </p></li></ul><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li><p>优点<br>1）扩展性<br>网络可以允许节点的任意增加和减少，新增加的节点的状态最终会与其他节点一致。 </p><p>2）去中心化<br>Gossip 协议不要求任何中心节点，所有节点都可以是对等的，任何一个节点无需知道整个网络状况，只要网络是连通的，任意一个节点就可以把消息散播到全网。 </p></li><li><p>缺点<br>1）消息的延迟<br>由于 Gossip 协议中，节点只会随机向少数几个节点发送消息，消息最终是通过多个轮次的散播而到达全网的，因此使用 Gossip 协议会造成不可避免的消息延迟。不适合用在对实时性要求较高的场景下。 </p><p>2）消息冗余<br>Gossip 协议规定，节点会定期随机选择周围节点发送消息，而收到消息的节点也会重复该步骤，因此就不可避免的存在消息重复发送给同一节点的情况，造成了消息的冗余，同时也增加了收到消息的节点的处理压力。而且，由于是定期发送，因此，即使收到了消息的节点还会反复收到重复消息，加重了消息的冗余。 </p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>gossip有种四处透风的感觉，我有很高的传播性，但传没传成功，我不管。一种方式对所传数据不设限制，一直在集群中荡着就行，另一种方式我设过期时间，过了这段时间就不传了。但至此没有被感染的，就一致不会感染了。<br>如果有更好的数据退出传播的方式，gossip会更好一些。<br>gossip的扩展性，可以在大量的节点之间进行数据的传播，这比raft、paxos都有更好的场景。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前边微服务框架选择中，反复看到一致性的协议，这一阶段就来对这些一些进行研究，包括：Paxos协议、Raft协议、Gossip协议，本文是这一系列第三篇：Gossip协议  &lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Raft协议</title>
    <link href="http://yoursite.com/2020/04/20/raft%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2020/04/20/raft协议/</id>
    <published>2020-04-20T13:06:19.000Z</published>
    <updated>2020-04-21T00:47:24.487Z</updated>
    
    <content type="html"><![CDATA[<p>前边微服务框架选择中，反复看到一致性的协议，这一阶段就来对这些一些进行研究，包括：Paxos协议、Raft协议、Gossip协议，本文是这一系列第二篇：Raft协议  </p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h2><p>简单讲，Paxos太难啦，于是他们想设计一个又好理解又好实现的一致性算法，于是就有了Raft。他们指的是斯坦福的Diego Ongaro与John Ousterhout。下图为Diego Ongaro<br><img src="DiegoOngaro.jpeg" alt="DiegoOngaro.jpeg"></p><h2 id="Raft协议特点"><a href="#Raft协议特点" class="headerlink" title="Raft协议特点"></a>Raft协议特点</h2><ul><li>强leader：日志条目只允许从leader流向其他server，这简化了复制日志的管理。</li><li>leader选举：Raft使用随机定时器选举leader，这仅在已有心跳基础上增加少量的机制。</li><li>成员变化：对于改变server集群，Raft采用一种新的共识方法，使两种不同的配置在过渡时期可以重叠，这样在集群配置发生改变的时候，可以正常运行。</li></ul><h2 id="Replicated-state-machines"><a href="#Replicated-state-machines" class="headerlink" title="Replicated state machines"></a>Replicated state machines</h2><p><img src="raft模型.png" alt="raft模型.png">。如上图，每一个server都存储包含一系列指令的日志，状态机按次序执行这些指令。不同server的Log中每个位置上的指令完全相同，当状态机按次序执行这行时，产生的状态就是确定的。<br>保持复制日志的一致就是一致性算法的工作，当每个server上的Consensus Module接收到clinet的指令时，将他们添加到Log上。为了保证每个server上log中指令与指令顺序完全一致，不同server上Consensus Module之间需要通信。一旦指令被恰当的复制，每个server上的状态机就会按顺序执行它们，然后将结果返回给client。最终server形成了一个高可用的状态机</p><h1 id="Raft算法"><a href="#Raft算法" class="headerlink" title="Raft算法"></a>Raft算法</h1><p>Raft首先选举一个杰出的leader，然后leader全权负责复制日志。它接收client的日志条目，然后复制到其他server上，并告诉server何时可以安全的将日志应用到状态机上。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><p>服务间状态转换<br><img src="server状态转换.png" alt="server状态转换.png"><br>任何事件，server都处于leader、follower、candidate三者之一的状态。正常情况下，集群中有一个leader，其余都是follower。<br>Follower是被动了，它从不主动提出申请，仅是响应leader与candidate。<br>Leader处理处理所有client请求，如果一个请求发送给follower，它会将请求重定向给leader<br>candidate用来选举新的领导  </p></li><li><p>时间划分<br> <img src="时间划分.png" alt="时间划分.png"><br> Raft将时间划分成任意长短的term。Team用连续的整数编号。<br> 每一段term都是以选举开始，一个或多个candidate师徒成为leader，一旦其中一个candidate当选，在tearm剩余时间，它将成为leader。<br> 有时候会出现t3的情况，在tearm时间段内，由于candidate瓜分了选票，没有leader胜出，Raft会开始一轮新的选举。<br> term扮演逻辑时钟的角色。由于它的存在，server可以检测到过期的leader发出了过时的信息。<br> ps: 在这里可以看出term对应paxos中的index </p></li></ul><h2 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h2><p><img src="RequestVoteRPC.png" alt="RequestVoteRPC.png"><br>Raft使用心跳机制来触发leader选举。为了维持leader的权威，它周期性的发送心跳信号（没有日志条目的AppendEntries RPC）。如果一个follower在一段时间内（这个时间成为election timeout）没有接收到心跳，它就假设集群中没有leader，从而发起一个轮新的选举。  </p><p>follower增加自己当前的current term，并将自己转换成candidate状态。接着并发的向其他server拉选票（RequestVoteRPC）。大部分时候它会成功当选；少部分时候当它在等待选票的时候，收到了其他candidate拉选票的请求，它会判断自己的current term与另外一个candidate的term，如果一样大，它就会转成follower，如果自己的更大，那么它就拒绝该请求；极小部分时候它与其他candidate旗鼓相当，平分了选票，造成没有leader选出的尴尬局面，这种情况在时间超过一个election timeout后，就会开始新一轮的选举。<br>对于election timeout就有一个精心的设计了。试想如果每个server的election timeout相同，当leader宕机时，大家同时觉察到天下无主，竞争势必会激烈，容易造成没有leader的局面。那如果election timeout每个server都是在一范围内的随机，总有幸运的server较早的觉察到机会，也就减少了竞争，增加了leader选出的概率。  </p><p>ps：candidate在等待选票的时候，如果其他candidate拉选票的申请，这里存在问题。如果他们的term一样大，而参选的candidate都退出，岂不一样都没有leader？如果都不退出，而是等待选票，大多数的获胜，从算法上看，并不排除follower为candidate都grant【因为图中拒绝是if term &lt; currentTerm】，这样两个都可能成为大多数。当然如果是term &lt;= currentTerm应该不会出现这种情况。这样如果某个candidate得到了大多数选票，那么它就成为leader，反之成为fallower。</p><h2 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h2><p><img src="AppendEntriesRPC.png" alt="AppendEntriesRPC.png"><br>每一个client请求都可以看做是一个待状态机执行的命令。leader接收到该请求后，将请求放到自己的log中，然后并发的向其他server发送复制日志RPC（AppendEntries RPC）,当日志安全的复制，leader就将该日志应用到状态机上，并返回结果。如果follower宕机或者由于网络丢包，leader就会无限次的重新发送该同步RPC，知道全部follower都收到。  </p><p>这里有一个概念要说一下，Log Maching Property：</p><ul><li>在不同server日志上的两个条目，如果index与term都相同，那么他们存储的命令是一样的。</li><li>在不同server日志上的两个项目，如果index与term都相同，那么在它们之前的日志都相同。</li></ul><p>leader在log的每个位置上最多创建一个条目，这样就满足了第一个属性<br>第二个属性通过在AppendEntries RPC时进行简单的一致性检查来满足。在leader发送的AppendEntries RPC中包含着preIndex与preTerm，follower收到后，会检查一下自己的index与term，如果不一致它不会添加新的日志。换句话说，只要leader知道follower添加了日志，那么就能保证他们的log是一致的。  </p><p><img src="日志冲突示意图.png" alt="日志冲突示意图.png"><br>下边简单介绍一下，当由于宕机、网络等问题，发生log不一致时，如何处理<br>Raft的做法很直接，有不一致，听leader的。leader通过强制follower复制自己的日志来处理不一致问题。这意味着follower中与leader有冲突的日志会被重写。<br>这样就引起了下面这个问题，要想重写，leader需要找到从何处开始不一致<br>在正常情况下，由于AppendEntries RPC的存在，leader能发现与某个follower发生了不一致，然后它就递减index发送给这个follower，直到与follower达成一致。然后follower删除一致点后冲突的日志，并用增加server的日志  </p><p>ps：既然是递减index，那要保证leader的index是最大的，否则递减是不成功的，这就回顾选举阶段的工作，能否保证leader中的index是最大的。<br>另外一个由于不一致可能发送在leader之间的term，在补全这些条目时，使用的应该是条目的term，而不是leader的term  </p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>到目前为止，Raft协议主线已经完成，我相信下边这些内容，是测试过程中发现的不足，然后对Raft协议进行的修正。  </p><p>这里首先要提出问题：如leader提交了几条日志条目，而follower正好在这个时间不可用，接着偏偏它又被选举成leader，于是重写这几条条目，结果不同的server的状态机上，可能执行了不同的指令，造成了不一致。  </p><ul><li><p>选举限制<br>在很多以leader为基础的算法中，leader都需要存储所有的已提交的log，Raft也是如此。它通过在选举过程中增加限制：只有包含所有已提交的条目，才有资格成为leader。拉选票的RPC（Request Vote RPC）中包含candidate的log（preIndex与preTerm），follower在投票时，拒绝那些比自己的index、term低的请求。  </p><p>ps：这里隐含，只要大多数的fallow同意即可成为leader，如果存在仅有少部分有某个日志条目，那么即使它们拒绝，也不会阻止新leader的产生。  </p></li><li><p>提交之前版本的term</p><p>当日志条目被复制到大多数的server上之后，leader才会提交该条目，如果这时候leader宕机了，一般情况下新的leader应该负责这个条目。但为了减少麻烦，Raft规定，leader只会提交当前term的日志条目。一旦一条日志提交成功，由于日志匹配特性（Log Matching Property）的存在，之前的条目间接被提交。  </p></li><li><p>Leader完整特性（Leader Completeness Property）<br>如果一个server，将一个指定index的日志条目应用到了其状态机，那么所有其他server在这个index上，不会应用不同的条目。某个时刻，server应用了一个日志条目，一直到这个条目，它的的日志必须与leader的日志一致。  </p></li></ul><h1 id="集群配置更改"><a href="#集群配置更改" class="headerlink" title="集群配置更改"></a>集群配置更改</h1><p>现实中，偶尔会出现需要修改配置的情况，比如更换坏的server，或者更改备份的方式等。为了更改配置机制的安全，Raft需要实现在集群不能完全离线的前提下，实现一致性。整个过渡期间，不会同时出现2个leader的情况。为了保证安全，配置文件的更改必须使用2PC方式（要么都做、要么都不做）。Raft集群首先达到一个联合一致（joint consensus），一旦联合一致提交，系统接着过渡到新的配置上。所谓的联合一致，包括新旧2种配置下的一致，这时：</p><ul><li>日志条目会复制到2种配置下的所有server  </li><li>任意一种配置的server都可以成为leader  </li><li>协议（选举，日志提交）需要满足2种配置各自的多数同意<br><img src="配置修改示意图.png" alt="配置修改示意图.png">  </li></ul><p>ps: 主要是在C<sub>old,new</sub>阶段，一致性需要双方都同意。  </p><h1 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h1><p><img src="日志压缩.png" alt="日志压缩.png">  </p><p>Raft的日志不能无限制的增长，通过快照的方式进行压缩。快照时，当前系统全部的状态都写在持久化的快照上，然后到快照点的全部日志，全部删除。<br>尽管一般server会独立的生成快照，但leader也会偶尔发送它的快照给落后的follower。这种情况经常在leader已经删除了老旧的日志，而follower还没有这些日志的时候发生。这时候leader发送一个新的RPC：InstallSnapshot RPC，将它的快照发送过去。<br><img src="InstallSnapShot.png" alt="InstallSnapShot.png">  </p><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><p>这样Raft协议就简单的介绍完了，对比Paxos，这篇论文写的更详细，也确实易懂一些。Raft中的term对应Paxos中的index，Raft在leader election阶段，对应的是Paxos的Prepare阶段。在Raft中选出了leader，也就是选出了term，在Paxos选出了index。<br>深度对比Paxos最后提出的状态机，就会发现与Paxos中最大的不同是Raft在选出leader后，follower执行leader的命令即可，而Paxos的acceptor还是会prepare、accept去交互去完成一致性。Paxos中最后的杰出proposer与Raft的leader有些相近，但地位若于leader。  </p><p>要说Raft有什么不好的，大部分的时间，系统只要一个leader就可以完成工作，其余4台机器，只在选举时候参与一下工作即可。fallow有没有可能对client的读请求进行响应。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前边微服务框架选择中，反复看到一致性的协议，这一阶段就来对这些一些进行研究，包括：Paxos协议、Raft协议、Gossip协议，本文是这一系列第二篇：Raft协议  &lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>paxos协议</title>
    <link href="http://yoursite.com/2020/04/12/paxos%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2020/04/12/paxos协议/</id>
    <published>2020-04-12T13:24:22.000Z</published>
    <updated>2020-04-20T00:41:57.890Z</updated>
    
    <content type="html"><![CDATA[<p>前边微服务框架选择中，反复看到一致性的协议，这一阶段就来对这些一些进行研究，包括：Paxos协议、Raft协议、Gossip协议，本文是这一系列第一篇：Paxos协议  </p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>网上关于Paxos协议的介绍有很多，概览一番之后，觉得参差不齐、深浅不一，有些还相互矛盾，不看原论文估计是不行了，本文是Lamport2001年的Paxos Made Simple论文的摘要以及一点思考。  </p><h1 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h1><p>本节是写raft时发现把作者的图片贴出来，一来表示尊敬，二来也挺有趣的.<br><img src="Leslie_Lamport.jpg" alt="Leslie_Lamport"></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="一致性要求"><a href="#一致性要求" class="headerlink" title="一致性要求"></a>一致性要求</h2><ul><li>一个值只有被提出来之后才可能被选中  </li><li>只有一个值被选中  </li><li><p>只有当一个值被选中后，process才能learn它 </p></li><li><p>Only a value that has been proposed may be chosen  </p></li><li>Only a single value is chosen, and</li><li>A process never learns that a value has been chosen unless it actually has been.</li></ul><h2 id="3种agent"><a href="#3种agent" class="headerlink" title="3种agent"></a>3种agent</h2><ul><li>proposers</li><li>acceptors</li><li>learners  </li></ul><p>一个进程可以扮演多个agent，agent与进程之间的映射关系，这里并不关注。  </p><h2 id="通信模型"><a href="#通信模型" class="headerlink" title="通信模型"></a>通信模型</h2><p>使用异步、非拜占庭模型：  </p><ul><li>Agents 以随意的速度运行，它可能宕机、重启。由于在一个值被选中后，任意一个agents都可能宕机、重启，一个solution只有在某些信息被agent记住才可能有效  </li><li>消息传输可能不稳定、重复、丢失，但不会冲突  </li></ul><h1 id="选择一个值"><a href="#选择一个值" class="headerlink" title="选择一个值"></a>选择一个值</h1><h2 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h2><ul><li><p>P1： acceptor必须接收它收到的第一份议案<br>=&gt; 当多个proposer同时提出自己的提案时，各acceptor各自接收自己value，而达不到多数胜出<br>=&gt; 为了区分这些同时提出的议案，自然就需要对它们进行编号，这样一个议案就包括2个属性：编号number与值value<br>=&gt; 当有多数acceptor接收一个议案时，这个议案才能被选中  </p></li><li><p>P2： 如果值为v的议案被选中，那么所有被选中的更高编号的议案值都是v<br>允许多个议案被选中，但必须保证所有被选中的议案有相同的number。  </p></li><li><p>P2<sup>a</sup>： 如果值为v的议案被选中，那么所有被acceptor接收的更高编号的议案值都是v  </p></li><li><p>P2<sup>b</sup>： 如果值为v的议案被选中，那么所有被proposer提出的更高编号的议案值都是v  </p></li><li><p>P2<sup>c</sup>： 对于任意 v与n，如果一个值为v、编号为n的议案被提出，那么有一个由多数acceptors组成的集合S，使得(a)没有接收过编号小于n的议案，或者(b)v是被acceptors接收的编号小于n的议案中最高编号的议案对应的值  </p><p>=&gt; 为了维持P2<sup>c</sup> 不变，如果proposer想提出编号为n的议案，必须学习过上一个被大多数acceptor接收的议案。  </p><p>可以这样来思考，如果在值为v被选中，而这个v提出时议案的编号为m，在这个m后，proposer又提出了几个议案，一致到编号n（n&gt;m），那么propser在[m+1, n]这几个议案的值都需要是v。proposer在提出这几个议案的时候，只需要参考上一个议案（如在提m+1时，参考m议案）的值即可。那这样会不会有问题？当然有，上一个议案如果发生变化怎么办？为了防止这种可能，就需要accptor做出承诺，上一个议案保证不变。怎么能保证不变呢？保证上次议案与本次议案之间不会再有新的插队议案就可以。  </p><p>这样一直在说的都是都是在m已经达成一致的情况，如何让在编号为m上达成一致？自然就需要进行一次投票，决定出m与v。</p></li><li><p>P1<sup>a</sup> 如果acceptor在prepare阶段没有响应过大于n的议案，那么它能够接收编号为n的议案。 </p></li></ul><p>PS:<br> =&gt; 对于learner来说，目的是最后的value一致<br> =&gt; 既然为了区分不同的议案，给它们做了编号，那么 1. 只要编号一致，就能保证value一致; 2. 如果编号不一致，那么只要保证不同编号的值是一致的<br> =&gt; paxos本着少数服从多数的原则<br> =&gt; 编号n的单调递增性对一致性的价值是什么？<br>    在现实中，通过一起开会的方式（同步）对某个议案进行表决，最终少数服从多数得出一致性<br>    但计算机没有同步的条件，只能通过异步的方式，单调递增是给异步定了一个方向。像极了时间的概念。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>Phase 1: Prepare<br>（a）proposer选择一个编号n，然后发送prepare请求给大多数的acceptor，这个请求中只携带编号n（这时候没有value）<br>（b） 当acceptor接收到prepare请求后，如果它没有响应过编号大于n的议案，那么它就回复给proposer一个承诺，表示不再接收编号小于n的议案，以及它接收过的上一个议案，（如果有的话），包括编号n与值v  </p></li><li><p>Phase 2: Accept<br>(a) 如果proposer接收到大多数acceptors的回复，那么它就给每一个acceptors发送一个accept请求，包括编号n与值v，v是所有回复中最高编号议案对应的值（如果有的话），或者是proposer选择的任意值（如果没有回复的话）。<br>(b) acceptor如果没有响应过比n更高的议案，它就接收这个编号为n的议案  </p></li></ul><h1 id="学习被选中的值"><a href="#学习被选中的值" class="headerlink" title="学习被选中的值"></a>学习被选中的值</h1><p>为了学习被选中的值，learner需要找到被选中的议案，最简单的方式是，每个acceptor选则一个议案后，都想每一个learner汇报自己的选择，但这样就会有 Number(learners) * Number(acceptors) 次通信。  </p><p>由于假设了非拜占庭的模式，learner可以从另外一个learner中获取答案。这样只要找到一个杰出的learner，所有的acceptors都向它汇报自己的选择，然后这个杰出的learner再通知其他learner，这样通信的次数就减少到Number(learners) + Number(acceptors)。</p><p>也可以有多个杰出的learner，这样以更高一点的通信复杂度换取更高一点的可靠性。  </p><p>由于信息丢失，以及acceptor宕机，可能让learner不知道议案是否被大多数acceptors选中，这样只有等到一个新的议案被选中时才能知道，当然learner也可以发起一个询问议案。</p><h1 id="演变"><a href="#演变" class="headerlink" title="演变"></a>演变</h1><p>想象一个有2个proposer交互持续提出议案的情景，proposer p以编号n1结束phase 1，另一个proposer q以编号n2(n2&gt; n1)完成phase 1，这时候当p以n1提出phase 2时，它的议案就被忽略。然后p接着以n3（n3&gt;n2）完成phase 1，而q以n2提出phase 2时，也遇到p相同的情况…，依次循环，这样就永远不会有值被选中。  </p><p>这样就需要一个杰出的proposer，只有它可以提出议案，它可以与大多数acceptors通信，就可以保证提出更高编号的议案。  </p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>假设有多个进程组成一个网络，每个进程扮演proposer，acceptor，learner的角色，算法选择出一个leader，扮演杰出的proposer与杰出的learner的角色。每个acceptor都应该有持久化存储，在发送响应前先存储一下。  </p><p>剩下的就是如果保证两个议案不会有相同的编号，不同的proposer从独立的空间中选择编号，这样就可以保证。 每个proposer都记住自己提出的最高编号的议案，在开始新议案时，采用比它更大的编号。</p><h1 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h1><p>实现分布式系统的一种简单方式是一组clients向中心server提交指令。当sever以一定的顺序执行指令时，它的状态就是确定的。这个状态机有一个当前的状态，执行每一个指令都会产生一个新的状态。比如银行系统的出纳是分布式系统的client，状态机包括所有账户的盈余。对于一个取钱指令，当账户余额大于取钱数的时，就会执行减少账户余额操作从而产生新的状态。<br>如果只用单一的中心server，当它宕机时，操作就会失败。所以引入多台sever，每个server都是一个状态机。因为它们状态是确定的，当执行相同的指令序列后，它们最后的结果是一致的。<br>为了保证所有机器执行相同序列的指令，我们实现一系列单独实例的Paxos一致算法，第i个实例选择的值就是指令序列中第i个指令。在所有的实例中，每一个server扮演所有的角色（proposer、acceptor、learner）。假定server的集合是固定的，那么在一致性算法的所有实例，使用的都是相同的agents。<br>通常，一个server被选成为leader，在所有一致性算法的实例中扮演杰出的proposer的角色。client向leader发送指令，leader决定每个指令的次序。如果leader决定某一个指令是第135号，它尝试使这个指令成为第135号一致性算法的实例。一般都会成功，也会由于错误或者另外一个觉得是leader的server提出一个不同的第135号指令而失败。但一致性算法保证了至多只有一个指令是第135号指令。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前边微服务框架选择中，反复看到一致性的协议，这一阶段就来对这些一些进行研究，包括：Paxos协议、Raft协议、Gossip协议，本文是这一系列第一篇：Paxos协议  &lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>服务设计中的2个问题</title>
    <link href="http://yoursite.com/2020/03/27/%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%842%E4%B8%AA%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/03/27/服务设计中的2个问题/</id>
    <published>2020-03-27T03:41:55.000Z</published>
    <updated>2020-03-27T04:04:36.082Z</updated>
    
    <content type="html"><![CDATA[<p>前文做了架构的选型，在这里需要对系统的架构设计做个简单的整理，本文主要从服务拆分与数据库的分库分表2个方面进行总结  </p><a id="more"></a><h1 id="服务拆分"><a href="#服务拆分" class="headerlink" title="服务拆分"></a>服务拆分</h1><p>服务的拆分是与业务紧密相关的，从直觉上，以业务来拆分服务符合面向对象封装的特性，容易理解，从性能上，分布式系统面向的面向的问题是如何在高并发、大流量的情况下保持系统的可用性、稳定性，以业务来拆分服务，可以很好的控制流量及IO控制。<br>还有一个心得是，什么叫以业务拆分？一种标准是参考用户的角色，比如在商城这个经典的例子中，用户角色包括：消费者、商家、仓库、快递4种角色，围绕他们问题空间创建各自的服务。<br>我猜想既然服务的架构与业务紧密相关，相似互联网领域，他们的服务结构是相似的  </p><h1 id="数据库分库分表"><a href="#数据库分库分表" class="headerlink" title="数据库分库分表"></a>数据库分库分表</h1><p>服务拆分好之后，数据库的抽象就定下来了，数据库本身有自己的问题，需要考虑到。<a href="https://www.toutiao.com/a6807842387243565579/?tt_from=weixin&amp;utm_campaign=client_share&amp;wxshare_count=1&amp;timestamp=1585176807&amp;app=news_article&amp;utm_source=weixin&amp;utm_medium=toutiao_android&amp;req_id=202003260653260100140470212E93FB42&amp;group_id=6807842387243565579" target="_blank" rel="noopener">链接</a>    </p><p>在微服务的架构设计中，一般是一个服务跟一个数据库，但这事并不绝对，不能太教条。<strong>关联是绝对的，内聚是相对的</strong>，服务再怎么拆分，总会有其边界，那些边界处总会与其他服务产生一些关联，比如要同时修改或者查询2个库中的数据，这就牵扯到事务一致性问题以及跨库join。另外如果这里连接是大量存在的，那么说明服务的切分、数据库的分库是不合理的。<br>表的存储是有上限的，当数据过大时，就会用到分表，这些分开的表其结构是相同的，也不存在它们之间的关联问题，最主要的是查询，比如跨多个分表的分页、排序问题  </p><h2 id="事务一致性"><a href="#事务一致性" class="headerlink" title="事务一致性"></a>事务一致性</h2><ul><li><p>分布式事务<br>当更新内容同时存在于不同库找那个，不可避免会带来跨库事务问题。一般可使用“XA协议”和“两阶段提交”处理。 分布式事务能最大限度保证了数据库操作的原子性。但在提交事务时需要协调多个节点，推后了提交事务的时间点，延长了事务的执行时间，并发的性能就会下来。  </p></li><li><p>最终一致性<br>对于性能要求很高，但对一致性要求不高的系统，不苛求实时一致性，这样只要在允许的时间段内达到最终一致性即可，可采用事务补偿的方式。与事务在执行中发生错误立刻回滚的方式不同，事务补偿是一种事后检查补救的措施，一些常见的实现方法有：对数据进行对账检查，基于日志进行对比，定期同标准数据来源进行同步等。</p></li></ul><h2 id="跨库join"><a href="#跨库join" class="headerlink" title="跨库join"></a>跨库join</h2><ul><li><p>全局字典表<br>就是系统中所有模块都可能依赖的一些表，为了避免库join查询，可以将这类表在每个数据库中都保存一份。<br>这个适用场景不多，因为这些表的修改会带来一致性问题，少修改甚至不修改  </p></li><li><p>字段冗余<br>就是将另外一个库表的需要join读取的字段存在本表中，减少join。 比如，订单表在保存userId的时候，也将userName也冗余的保存一份，这样查询订单详情顺表就可以查到用户名userName，就不用查询买家user表了。<br>这个适用场景也不会很多，同样是一致性的问题</p></li><li><p>Service层面组装<br>在系统service业务层面，分两次查询，第一次查询的结果集找出关联的数据id，然后根据id发起器二次请求得到关联数据，最后将获得的结果进行字段组装。这是比较常用的方法。</p></li></ul><h2 id="跨节点分页、排序、函数"><a href="#跨节点分页、排序、函数" class="headerlink" title="跨节点分页、排序、函数"></a>跨节点分页、排序、函数</h2><p>跨节点多库进行查询时，会出现limit分页、order by 排序等问题。分页需要按照指定字段进行排序，当排序字段就是分页字段时，通过分片规则就比较容易定位到指定的分片；当排序字段非分片字段时，就变得比较复杂.需要先在不同的分片节点中将数据进行排序并返回，然后将不同分片返回的结果集进行汇总和再次排序，最终返回给用户。<br>也就是MapReduce的做法，这样的操作很耗费CPU和内存资源  </p><h2 id="全局主键避重问题"><a href="#全局主键避重问题" class="headerlink" title="全局主键避重问题"></a>全局主键避重问题</h2><p>在分库分表环境中，由于表中数据同时存在不同数据库中，主键值平时使用的自增长将无用武之地，某个分区数据库自生成ID无法保证全局唯一。因此需要单独设计全局主键，避免跨库主键重复问题。  </p><p><img src="./snowflake.jpeg" alt="snowflake.jpeg"><br>snowflake算法，在同一时间，同一机器，重复的可能性比较小：  </p><ul><li>第一位未使用</li><li>接下来的41位是毫秒级时间，41位的长度可以表示69年的时间</li><li>5位datacenterId,5位workerId。10位长度最多支持部署1024个节点</li><li>最后12位是毫秒内计数，12位的计数顺序号支持每个节点每毫秒产生4096个ID序列  </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前文做了架构的选型，在这里需要对系统的架构设计做个简单的整理，本文主要从服务拆分与数据库的分库分表2个方面进行总结  &lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>微服务框架选择</title>
    <link href="http://yoursite.com/2020/03/26/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6%E9%80%89%E6%8B%A9/"/>
    <id>http://yoursite.com/2020/03/26/微服务框架选择/</id>
    <published>2020-03-26T02:22:40.000Z</published>
    <updated>2020-03-26T07:59:22.274Z</updated>
    
    <content type="html"><![CDATA[<p>随着产品的设计的结束，如今进入架构设计阶段，需要选择一些基础的组件来完善系统。去年年初学习了微服务架构，包括杨波架构师对微服务的简单介绍以及陈皓老师对分布式系统的介绍，年中又接触了K8S，对其结构略懂一二。在这种背景下，来进行框架的选择。  </p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>微服务架构功能方面需要的功能包括：服务发现、负载均衡、熔断限流、流量分析、日志聚合、配置中心、调用链监控、性能监控、自动化部署等。可以将它们分成3层：网关层，主要做流量控制；服务层，主要对各服务提供支持；运维层，自动化部署。分别来选择。</p><h1 id="网关层"><a href="#网关层" class="headerlink" title="网关层"></a>网关层</h1><p>这一部分我把它定义为流量在系统与业务服务之间的阶段，入、出都算在其中。包括nginx，zuul中servlet的filter，K8S的ingress以及service。<br>在功能上，它包括：负载均衡、安全认证、熔断限流、流量日志等内容<br>在实现上，确实在向2个方向发展：1. 统一的网关，2. Service Mesh</p><h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><p><img src="./服务发现.jpg" alt="服务发现.jpg"><br><img src="./Eureka架构.png" alt="Eureka架构.png">  </p><p>Provider与Server：Eureka服务发现是服务的Provider通过注册到 Eureka Service中，并Keep Alive。这里的Eureka sever可能有多个，它们之间做数据的同步，保持一致性。<br>Consumer与Server：这里可能有多种方式，Server将数据同步到Eureka Client上，在杨波课程中，这里称作LB，也就是在这里确定选择哪个Provider进行通讯  </p><p>由此可见Eureka是做了Cosumer发现Provider，提供负载均衡的功能。这个在K8S中，service与pod之间的关系，就是做了这个事情，由于pod的短暂特性，ip会发生变化，通过service，不仅能提供统一的服务，也能流量在多个pod中均衡    </p><h2 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h2><p><img src="./zuul架构图.jpg" alt="zuul架构图.jpg"><br>Zuul是一个Servlet，里边有很多的filter，分成Pre routing filter，Routing filter，Post Routing filter等部分，Request Context在filter之间保存状态。除此之外，写的filter通过客户端的Filter Poller传递到服务的Filter Directory下，并最终由Filter Loader加载进Zuul中。  </p><p>那Zuul跟Servlet有什么区别呢？最主要的区别应该是，Servlet是在每个服务中起作用，而Zuul是一个统一的网关。这样看，将认证授权、流量分析等工作放在Zuul上就会比较适合。</p><h2 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h2><p><img src="./hystrix架构图.jpg" alt="hystrix架构图.jpg"><br> Hystrix为分布式系统提供了限流、熔断、降级的功能，<br> Hystrix对请求进行了封装。被调用方在Hystrix中被称为依赖项，利用HystrixCommand或HystrixObservableCommand封装对依赖项的请求。收到请求后，先查看是否有缓存，如果有就直接返回；然后查看Circle-breaker是否open，没有open，就直接进行降级处理；然后看线程池的状态，如果满也进行降级处理；没满的情况，正常执行，并对执行结果进行跟踪，如果执行失败或者超时，都进行降级处理。  这些失败的情况，会被汇总在一起，决定circuit-breaker是否open。<br>在这里可以看到，增加缓存以应对大流量是有效措施；有趣的是对circuit-breaker的控制上，有个反馈回路在在起作用；在判断系统是否满状态时，Hystrix参考了2个指标：线程池与调用结果。这对没有线程的情况如何控制呢？</p><p>以上3者是spring cloud中提供的组件，都是Java写的，可以提供做负载均衡、安全认证、流量分析、熔断限流等功能。在K8S，Eureka的价值就不高，Hystrix虽然有趣，但它对服务有浸入，对非Java应用的可用性有待查看。下边分析一下K8S中的网关  </p><h2 id="K8S的ingress"><a href="#K8S的ingress" class="headerlink" title="K8S的ingress"></a>K8S的ingress</h2><p>K8S的网关是Ingress，它提供了一个类似 ConfigMap 的接口功能 ，用户可以以 [ host - paths -&gt; services ] 的形式 , 在 Ingress 里建立一个个映射规则 , 然后启动一个 Ingress Controller（nginx为主） , Ingress Controller 将订阅 Ingress 里的配置规则并转化成 Nginx 的配置 , 然后对外部提供服务。在对外网暴露地址的时候, 只需要暴露 Ingress Controller 自身就行了, 所有服务可以被隔离在集群内部。 </p><h2 id="kong"><a href="#kong" class="headerlink" title="kong"></a>kong</h2><p><img src="./API网关示意图.png" alt="API网关示意图.png"><br><a href="https://www.jianshu.com/p/4dd5ed88468c" target="_blank" rel="noopener">链接</a><br>Kong主要有三个组件：<br>Kong Server ：基于nginx的服务器，用来接收API请求。<br>Apache Cassandra/PostgreSQL ：用来存储操作数据。<br>Kong dashboard：官方推荐UI管理工具   </p><p>Kong采用插件机制进行功能定制，插件集（可以是0或N个）在API请求响应循环的生命周期中被执行。插件使用Lua编写，目前已有几个基础功能：HTTP基本认证、密钥认证、CORS（Cross-Origin Resource Sharing，跨域资源共享）、TCP、UDP、文件日志、API请求限流、请求转发以及Nginx监控。</p><p>Kong在架构中的位置与Zuul类似，通过这种AOP的做法，在请求上做一些工作。Kong可以集成到K8S中，位置应该就是Ingress。<a href="https://qhh.me/2019/08/17/Kong-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3%E5%9C%A8-Kubernetes-%E7%9A%84%E5%AE%9E%E8%B7%B5/" target="_blank" rel="noopener">链接</a>  </p><p>ps：用Kong去访问权限数据库是否妥当？  </p><h2 id="Istio"><a href="#Istio" class="headerlink" title="Istio"></a><strong>Istio</strong></h2><p><img src="./Istio架构图.jpeg" alt="Istio架构图.jpeg"><br>Istio是ServiceMesh的一种设计，ServiceMesh可以分成2部分：控制平面与数据平面，Istio控制平面主要分为三大块，Pilot、Mixer、Istio-Auth, 数据平面是Envoy Proxy.</p><p>Pilot: 主要作为服务发现和路由规则，并且管理着所有Envoy，它对资源的消耗是非常大的。对应Eureka<br>Mixer: 主要负责策略请求和配额管理，还有Tracing，所有的请求都会上报到Mixer。对应Hystrix，它的限流与Hystrix不相同，是面向流量的一张限流方式，好处是不浸入服务。<br>Istio-Auth: 升级流量、身份验证等等功能。对应Zuul  </p><p>Hystrix可以被视为白盒监控工具，而Istio可以被视为黑盒监控工具，主要是因为Istio从外部监控系统并且不知道系统内部如何工作。每个服务中有Hystrix来获取所需的数据。Istio是通过Envoy Proxy 来实现熔断和限流机制的，Envoy 强制在网络层面配置熔断和限流策略，这样就不必为每个应用程序单独配置或重新编程。<br>Istio嵌入K8S利用了CRD（customResourceDefinition）。在k8s中，它是在Ingress后边，service之前的位置，自称Virtual  Service。 </p><p><a href="https://www.jianshu.com/p/bed143a1c886" target="_blank" rel="noopener">链接1</a><br><a href="https://jimmysong.io/istio-handbook/preface/service-mesh-the-microservices-in-post-kubernetes-era.html" target="_blank" rel="noopener">链接2</a>  </p><h1 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h1><h2 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a><strong>Consul</strong></h2><p><img src="./consul.png" alt="consul.png">  </p><p><a href="https://www.consul.io/docs/internals/architecture.html" target="_blank" rel="noopener">官网</a><br>Consul的介绍找到的几个都或多或少的存在问题，结合官网及这些资料，简单写一下。<br>Consul可以在多个数据中心中，在每一数据中心中，每个Consul的节点被成为Agent，Agent管理注册的服务信息，提供查询响应，运行检查等功能。Agent通过Gossip协议来做彼此之间的发现。一般配置3个或这5个Server，这些Server通过Raft算法产生唯一的Leader。注册到Client上的服务会被转发到Server做存储，Leader负责同步数据到所有端，并且负责与其他数据中心的Leader通信。  </p><p>从功能上看Consul功能包括：服务发现与配置中心<br>service discovery：consul通过DNS或者HTTP接口使服务注册和服务发现变的很容易，一些外部服务，例如saas提供的也可以一样注册。<br>health checking：健康检测使consul可以快速的告警在集群中的操作。和服务发现的集成，可以防止服务转发到故障的服务上面。<br>key/value storage：一个用来存储动态配置的系统。提供简单的HTTP接口，可以在任何地方操作。  </p><p>ps：consul的集群很有趣，值得研究。K8S中可以通过control感知到Pod的运行状态，也就做了Pod的健康监控，Consul更接近与服务的健康检查。另外还有配置中心的功能，在K8S中有ConfigMap功能与配置中心有重合的地方，比如说启动的端口，这种配置还是在ConfigMap中好一些，但比如说每个服务中用的业务配置，放在Consul里也会很舒服。另外Consul是用Go实现的。</p><h2 id="zipkin"><a href="#zipkin" class="headerlink" title="zipkin"></a><strong>zipkin</strong></h2><p><img src="./zipkin示意图.png" alt="zipkin示意图.png"><br><a href="https://www.jianshu.com/p/4cdba2fc62ad" target="_blank" rel="noopener">链接</a><br>调用链监控，有2个基本概念，trace与span，trace代表调用链，span代表它在每个调用节点。<br>从功能上除了对调用进行性能分析，  也可以看出服务间依赖，以此来排查依赖环的产生  </p><h2 id="Promethues"><a href="#Promethues" class="headerlink" title="Promethues"></a><strong>Promethues</strong></h2><p><img src="./promethues架构图.png" alt="promethues架构图.png"><br><a href="https://songjiayang.gitbooks.io/prometheus/content/introduction/what.html" target="_blank" rel="noopener">链接</a><br>Promethues是基于时序数据库的监控组件，通过server主动去抓取exporter上的数据，或者可以先将数据Push到PushGateway上，然后server再去PushGateway上去抓取数据。server将数据存在时序数据库（TSDB）上。 在输出上，可以通过alert将一些告警通知出去，也支持UI页面通过自定义的语句（PromQL）查看数据。 </p><h2 id="ELK"><a href="#ELK" class="headerlink" title="ELK"></a><strong>ELK</strong></h2><p>ELK是Elasticsearch、Logstash、Kibana，它本质上建立在NoSQL（document）上的搜索引擎，主要是Elasticsearch。拿来做日志聚合的事情正好，可以方便查看各种日志。<br>一度被一个问题困恼着：Promethues与ELK应该选哪个？Promethues 的数据是按一定时间采集的，注的更多是系统的运行瞬时状态以及趋势，即使有少量数据没有采集也能容忍，本质是一种监控；ELK对实时监控力有不逮，本质上是对日志的存取，比如去看一个故障，Promethues可能没有采集到这个数据，那只能从ELK上看。  所以它俩确实有些重合，但2者可以兼得。</p><h1 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h1><h2 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a><strong>Jenkins</strong></h2><p><a href="https://www.kancloud.cn/huyipow/kubernetes/716441" target="_blank" rel="noopener">链接</a><br>Jenkins是一个可扩展的持续集成引擎，当程序员提交代码，从代码Repository处得到通知，然后做 Build -&gt; Test -&gt; Package -&gt; Deploy 等工作<br>通过pipeline可以完成 clone代码 =&gt; test代码 =&gt; build镜像 =&gt; push镜像 =&gt; 修改k8s的yml =&gt; apply yml的过程</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:center">位置</th><th style="text-align:center">用途</th><th style="text-align:right">语言</th><th style="text-align:right">是否需要</th><th style="text-align:center">优先级</th></tr></thead><tbody><tr><td style="text-align:left">Zuul</td><td style="text-align:center">网关</td><td style="text-align:center">安全认证、流量日志</td><td style="text-align:right">Java</td><td style="text-align:right">No</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">Kong</td><td style="text-align:center">网关</td><td style="text-align:center">负载均衡、安全认证、熔断限流、流量日志</td><td style="text-align:right">Lua</td><td style="text-align:right">No</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">Hystrix</td><td style="text-align:center">网关</td><td style="text-align:center">熔断限流</td><td style="text-align:right">Java</td><td style="text-align:right">No</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">Istio</td><td style="text-align:center">网关</td><td style="text-align:center">负载均衡、安全认证、流量日志、熔断限流</td><td style="text-align:right">Go</td><td style="text-align:right">Yes</td><td style="text-align:center">5</td></tr><tr><td style="text-align:left">Eureka</td><td style="text-align:center">网关、服务</td><td style="text-align:center">服务发现、负载均衡</td><td style="text-align:right">Java</td><td style="text-align:right">No</td></tr><tr><td style="text-align:left">Consul</td><td style="text-align:center">服务</td><td style="text-align:center">服务发现</td><td style="text-align:right">Go</td><td style="text-align:right">Yes</td><td style="text-align:center">3</td></tr><tr><td style="text-align:left">Zipkin</td><td style="text-align:center">服务</td><td style="text-align:center">调用链监控</td><td style="text-align:right">Java</td><td style="text-align:right">Yes</td><td style="text-align:center">4</td></tr><tr><td style="text-align:left">Prometheus</td><td style="text-align:center">服务</td><td style="text-align:center">监控</td><td style="text-align:right">Go</td><td style="text-align:right">Yes</td><td style="text-align:center">5</td></tr><tr><td style="text-align:left">ELK</td><td style="text-align:center">服务</td><td style="text-align:center">Java</td><td style="text-align:right">日志</td><td style="text-align:right">Yes</td><td style="text-align:center">4</td></tr><tr><td style="text-align:left">Jenkins</td><td style="text-align:center">运维</td><td style="text-align:center"></td><td style="text-align:right">Java</td><td style="text-align:right">Yes</td><td style="text-align:center">5</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着产品的设计的结束，如今进入架构设计阶段，需要选择一些基础的组件来完善系统。去年年初学习了微服务架构，包括杨波架构师对微服务的简单介绍以及陈皓老师对分布式系统的介绍，年中又接触了K8S，对其结构略懂一二。在这种背景下，来进行框架的选择。  &lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>spring-boot进阶</title>
    <link href="http://yoursite.com/2020/02/20/spring-boot%E8%BF%9B%E9%98%B6/"/>
    <id>http://yoursite.com/2020/02/20/spring-boot进阶/</id>
    <published>2020-02-20T02:39:45.000Z</published>
    <updated>2020-03-26T08:56:40.660Z</updated>
    
    <content type="html"><![CDATA[<p>本文为第二篇<br>主要是中间件与部署方面的内容  </p><p>主要参考：<br><a href="https://github.com/ityouknow/spring-boot-leaning" target="_blank" rel="noopener">spring-boot-learning</a></p><a id="more"></a><h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Spring Boot 提供了对 Redis 集成的组件包：spring-boot-starter-data-redis，它依赖于 spring-data-redis 和 lettuce。Spring Boot 1.0 默认使用的是 Jedis 客户端，2.0 替换成了 Lettuce</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lettuce → Spring Data Redis → Spring Data → spring-boot-starter-data-redis</span><br></pre></td></tr></table></figure><ol><li>Lettuce：是一个可伸缩线程安全的 Redis 客户端，多个线程可以共享同一个 RedisConnection，它利用优秀 Netty NIO 框架来高效地管理多个连接</li><li>Spring Data Redis：是 Spring Data 项目中的一个主要模块，实现了对 Redis 客户端 API 的高度封装，使对 Redis 的操作更加便捷。</li><li>Spring Data：是 Spring 框架中的一个主要项目，目的是为了简化构建基于 Spring 框架应用的数据访问，包括非关系数据库、Map-Reduce 框架、云数据服务等，另外也包含对关系数据库的访问支持。</li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>与postgres的安装相同，在docker-compse.yml中添加:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis:</span></span><br><span class="line"><span class="attr">  image:</span> <span class="attr">redis:4.0.13</span></span><br><span class="line"><span class="attr">  container_name:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">  restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">  command:</span> <span class="bullet">--appendonly</span> <span class="literal">yes</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="number">6379</span><span class="string">:6379</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">./redis_data:/data</span></span><br></pre></td></tr></table></figure><p>然后docker-compose up -d 等待即可</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li><p>依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引入 commons-pool 2 是因为 Lettuce 需要使用 commons-pool 2 创建 Redis 连接池。</p></li><li><p>配置</p><p>配置文件application.properties：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Redis 数据库索引（默认为 0）</span><br><span class="line">spring.redis.database=0</span><br><span class="line"># Redis 服务器地址</span><br><span class="line">spring.redis.host=localhost</span><br><span class="line"># Redis 服务器连接端口</span><br><span class="line">spring.redis.port=6379  </span><br><span class="line"># Redis 服务器连接密码（默认为空）</span><br><span class="line">spring.redis.password=</span><br><span class="line"># 连接池最大连接数（使用负值表示没有限制） 默认 8</span><br><span class="line">spring.redis.lettuce.pool.max-active=8</span><br><span class="line"># 连接池最大阻塞等待时间（使用负值表示没有限制） 默认 -1</span><br><span class="line">spring.redis.lettuce.pool.max-wait=-1</span><br><span class="line"># 连接池中的最大空闲连接 默认 8</span><br><span class="line">spring.redis.lettuce.pool.max-idle=8</span><br><span class="line"># 连接池中的最小空闲连接 默认 0</span><br><span class="line">spring.redis.lettuce.pool.min-idle=0</span><br></pre></td></tr></table></figure><p>配置类RedisConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> <span class="keyword">extends</span> <span class="title">CachingConfigurerSupport</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KeyGenerator <span class="title">keyGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KeyGenerator() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">generate</span><span class="params">(Object target, Method method, Object... params)</span> </span>&#123;</span><br><span class="line">                StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                sb.append(target.getClass().getName());</span><br><span class="line">                sb.append(method.getName());</span><br><span class="line">                <span class="keyword">for</span> (Object obj : params) &#123;</span><br><span class="line">                    sb.append(obj.toString());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sb.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上配置了主键生成的策略，如不配置会默认使用参数名作为主键，这里添加了类名+函数名+参数名</p></li><li><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRedisTemplate</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testString</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">      redisTemplate.opsForValue().set(<span class="string">"neo"</span>, <span class="string">"ityouknow"</span>);</span><br><span class="line">      Assert.isTrue(<span class="string">"ityouknow"</span>.equals(redisTemplate.opsForValue().get(<span class="string">"neo"</span>)), <span class="string">"测试出错"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="session"><a href="#session" class="headerlink" title="session"></a>session</h1><ul><li><p>简介<br>使用redis来存储http的sessionId信息，这个spring boot对这块都进行了封装。封装到牙齿的感觉。  </p></li><li><p>依赖  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置  </p><p>application.properties:<br>这里的配置就是redis的配置即可  </p><p>配置类：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableRedisHttpSession</span>(maxInactiveIntervalInSeconds = <span class="number">86400</span>*<span class="number">30</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>maxInactiveIntervalInSeconds: 设置 Session 失效时间</p></li><li><p>使用  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(value = <span class="string">"/login"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">login</span> <span class="params">(HttpServletRequest request,String userName,String password)</span></span>&#123;</span><br><span class="line">      String msg=<span class="string">"logon failure!"</span>;</span><br><span class="line">      User user= userRepository.getByUserName(userName);</span><br><span class="line">      <span class="keyword">if</span> (user!=<span class="keyword">null</span> &amp;&amp; user.getPassword().equals(password))&#123;</span><br><span class="line">          request.getSession().setAttribute(<span class="string">"user"</span>,user);</span><br><span class="line">          msg=<span class="string">"login successful!"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> msg;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping</span>(value = <span class="string">"/logout"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">logout</span> <span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line">      request.getSession().removeAttribute(<span class="string">"user"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"loginout successful!"</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>问题  </p><p>这里，如果有登录的要求，需要在每个路由中都去判断是否登录，这样在写的时候会比较费劲，适合使用spring切片的方式来进行登录与否的验证  </p></li></ul><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>  这里的缓存，是将从关系型数据库中读取数据，变成先从缓存中读取，若没有则从关系型数据库中读取，这里用的缓存，也是用的redis。spring对这些操作也进行了封装，只需要用几个注解，就可以完成  </p><p>  @Cacheable是读取完之后，再次读取时候会做缓存，主要用在Get上<br>  @CachePut，这个是数据发生变化之后，将更新变化数据，主要用在Put上<br>  @CacheEvict，这个是数据删除之后，同时清除缓存  </p><p>  他们共有的属性：value：缓存的名称；key：缓存的key值(redis的hash结构)；condition：在什么条件上做缓存<br>  CacheEvict，还有两个属性，allEntries：这个是true清除缓存的所有内容，不是删hash的key，而是删这个整个对象，默认是false；beforeInvocation：这个是值true指在执行Delele前，清除缓存，false是之后清除，默认是false；</p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><ul><li><p>@Cacheable：读取数据之后，缓存数据 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"user/&#123;id&#125;"</span>)</span><br><span class="line"><span class="meta">@Cacheable</span>(value=<span class="string">"user"</span>, key=<span class="string">"#id"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getId</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>&#123;</span><br><span class="line">    User user = <span class="keyword">this</span>.userRepository.getById(id);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@CachePut：数据修改之后，更新缓存数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation</span>(value =<span class="string">"修改用户信息"</span>, notes =<span class="string">"根据传参修改用户"</span>)</span><br><span class="line">  <span class="meta">@PutMapping</span>(value = <span class="string">"user"</span>)</span><br><span class="line">  <span class="meta">@CachePut</span>(value=<span class="string">"user"</span>,key=<span class="string">"#id"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">modify</span><span class="params">(String nickName, Long id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> r = <span class="keyword">this</span>.userRepository.upateNickNameById(nickName, id);</span><br><span class="line">      <span class="keyword">if</span> (r &lt; <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      User u = <span class="keyword">this</span>.userRepository.getById(id);</span><br><span class="line">      <span class="keyword">return</span> u;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>@CacheEvict：数据删除之后，删除缓存数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeleteMapping</span>(value = <span class="string">"user/&#123;id&#125;"</span>)</span><br><span class="line">  <span class="meta">@CacheEvict</span>(value=<span class="string">"user"</span>, key=<span class="string">"#id"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> BaseResult&lt;String&gt; <span class="title">Delete</span> <span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.userRepository.deleteById(id);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> BaseResult.success();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p><a href="https://zhuanlan.zhihu.com/p/103642773" target="_blank" rel="noopener">借鉴</a></p><ul><li><p>说RabbitMQ,要先介绍AMQP<br>AMQP（Advanced Message Queuing Protocol，高级消息队列协议）是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。<br>RabbitMQ 是一个开源的 AMQP 实现，服务器端用 Erlang 语言编写，支持多种客户端</p></li><li><p>基本概念<br>通常我们谈到队列服务，会有三个概念：<strong>生产者(Producer)、队列(Queue)、消费者(Consumer)</strong>。RabbitMQ 在这个基本概念之上，多做了一层抽象，在发消息者和队列之间加入了<strong>交换机（Exchange）</strong>。这样发消息者和队列就没有直接联系，转而变成发消息者把消息给交换器，交换器根据调度策略再把消息再给队列。<br><img src="./rabbitmq流转图.png" alt="rabbitmq流转图.png"></p><ol><li>生产者发送消息的时候指定RoutingKey，然后消息被发送到Exchange</li><li>Exchange根据一些列规则(BindingKey)将消息路由到指定的队列中</li><li>消费者从队列中消费消息</li></ol></li><li><p>交换机<br>交换机有4种类型：Direct Exchange(默认)、Topic Exchange、Headers Exchange、Fanout Exchange<br>前3种都是消息队列，虽然交换机与队列之间的映射机制不同（路由方式），但对于一条消息，只有一个生产者与消费者。Fanout是广播，对于一条消息可以有多个消费者。<br>Direct Exchange把消息路由到BindingKey和RoutingKey完全匹配的队列中<br>Topic Exchange把消息路由到BindingKey可以模糊匹配的队列中，Binding Key可以认为是消息名称，Binding Key是一种模糊匹配，代表一类消息，其中”*”表示一个单词,”#”表示多个单词（包括0,1）<br>Fanout Exchange把消息发送与该交换机绑定的所有队列上,不光BindingKey,用来广播  </p></li></ul><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li><p>安装  </p><p>docker-compose.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rabbitmq:</span></span><br><span class="line"><span class="attr">  image:</span> <span class="attr">rabbitmq:3-management</span></span><br><span class="line"><span class="attr">  container_name:</span> <span class="string">rabbitmq</span></span><br><span class="line"><span class="attr">  restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">  environment:</span></span><br><span class="line"><span class="attr">    RABBITMQ_DEFAULT_USER:</span> <span class="string">"rabbitmq"</span></span><br><span class="line"><span class="attr">    RABBITMQ_DEFAULT_PASS:</span> <span class="string">"rabbitmq"</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="number">15672</span><span class="string">:15672</span></span><br><span class="line"><span class="bullet">    -</span> <span class="number">5672</span><span class="string">:5672</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">./rabbitmq_data:/var/lib/rabbitmq</span></span><br></pre></td></tr></table></figure></li><li><p>依赖  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置  </p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.rabbitmq.host=192.168.0.1</span></span><br><span class="line"><span class="string">spring.rabbitmq.port=5672</span></span><br><span class="line"><span class="string">spring.rabbitmq.username=rabbitmq</span></span><br><span class="line"><span class="string">spring.rabbitmq.password=rabbitmq</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h2><ul><li><p>Direct Exchange<br>spring boot默认使用时，应该自己封装了exchange，只需定义routeKey即可<br>可以发送对象，二进制发送，需要实现Serializable</p><ol><li><p>定义Queue  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">Queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><ol start="2"><li><p>定义生产者  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String context = <span class="string">"hello "</span> + <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(<span class="string">"Sender : "</span> + context);</span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate.convertAndSend(<span class="string">"hello"</span>, context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义接收者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String hello)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Receiver  : "</span> + hello);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>topic exchange<br>需要定义queue、exchange，并且binding queue与exchange</p><p>1.定义queue、exchange  </p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicRabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> String message = <span class="string">"topic.message"</span>;    <span class="comment">// queue名</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> String messages = <span class="string">"topic.messages"</span>;  <span class="comment">// queue名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(TopicRabbitConfig.message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueMessages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(TopicRabbitConfig.messages);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">TopicExchange <span class="title">exchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(<span class="string">"exchange"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将队列和交换机绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">bindingExchangeMessage</span><span class="params">(Queue queueMessage, TopicExchange exchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueMessage).to(exchange).with(<span class="string">"topic.message"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">bindingExchangeMessages</span><span class="params">(Queue queueMessages, TopicExchange exchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueMessages).to(exchange).with(<span class="string">"topic.#"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  注意定义queue时使用，只是queue名，在接收者时用来指定某个queue使用。<br>  后边binding时候使用with才是bindingKey</p><ol start="2"><li><p>发送者  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String context = <span class="string">"hi, i am message 1"</span>;</span><br><span class="line">    System.out.println(<span class="string">"Sender : "</span> + context);</span><br><span class="line">    <span class="keyword">this</span>.rabbitTemplate.convertAndSend(<span class="string">"exchange"</span>, <span class="string">"topic.message"</span>, context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String context = <span class="string">"hi, i am messages 2"</span>;</span><br><span class="line">    System.out.println(<span class="string">"Sender : "</span> + context);</span><br><span class="line">    <span class="keyword">this</span>.rabbitTemplate.convertAndSend(<span class="string">"exchange"</span>, <span class="string">"topic.messages"</span>, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这个“exchange”是指明交换机，topic.message与top.messages是routeKey</p><ol start="3"><li>接收者  </li></ol><p>接收者同上，没有改变。 </p></li><li><p>fanout<br>fanout与topic类似，定义部分稍有不同，生产者与消费者使用相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutRabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">AMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"fanout.A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">BMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"fanout.B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">FanoutExchange <span class="title">fanoutExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(<span class="string">"fanoutExchange"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分部进行绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">bindingExchangeA</span><span class="params">(Queue AMessage,FanoutExchange fanoutExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(AMessage).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">bindingExchangeB</span><span class="params">(Queue BMessage, FanoutExchange fanoutExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(BMessage).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h1><h2 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h2><p>elasticsearch也借鉴了一篇文章，可惜是微信的，链接有signature，访问会受限，这里没法给出原链接了。</p><ul><li><p>是什么<br>Elasticsearch 是一个 <strong>real-time</strong>, <strong>distributed storage</strong>, <strong>search engine</strong>  </p></li><li><p>特性<br>Elasticsearch是专门做搜索的,我们在用搜狗、google时候，输入关键字没那么匹配都可以搜索的出来，用elaticsearch就可以做到：</p><ol><li>Elasticsearch对模糊搜索非常擅长（模糊查询）</li><li>没有那么准确的关键字也能搜出相关的结果（相关性查询）</li><li>从Elasticsearch搜索到的数据可以根据评分过滤掉大部分的，只要返回评分高的给用户就好了（原生就支持排序）</li></ol></li><li><p>简单介绍原理<br>分词： 写入到Elasticsearch的数据会进行分词<br>存储：<br>  <img src="./elasticsearch数据结构.png" alt="elasticsearch数据结构.png"><br>  从右往左看：position是记录所在的位置，term dictionary是分词字典， term index是为了快速查找分词所做的索引  </p></li><li><p>基本术语  </p></li></ul><table><thead><tr><th style="text-align:center">关系型数据库</th><th style="text-align:center">Elasticsearch</th></tr></thead><tbody><tr><td style="text-align:center">Table</td><td style="text-align:center">Index(Type)</td></tr><tr><td style="text-align:center">Row</td><td style="text-align:center">Document</td></tr><tr><td style="text-align:center">Column</td><td style="text-align:center">Filed</td></tr><tr><td style="text-align:center">Schema</td><td style="text-align:center">Mapping</td></tr><tr><td style="text-align:center">SQL</td><td style="text-align:center">DSL</td></tr></tbody></table><p>  这个术语与mongo的术语基本相同，mongo中与Table对应的概念是Collection。所以在分布式存储这块，elasticsearch应该用的NoSQL，至于与mongo的关系还需要探索一下  </p><h2 id="准备-1"><a href="#准备-1" class="headerlink" title="准备"></a>准备</h2><ul><li><p>安装<br><a href="https://www.cnblogs.com/zz0412/p/10572828.html" target="_blank" rel="noopener">借鉴1</a><br><a href="https://blog.csdn.net/qq_36835255/article/details/89314248" target="_blank" rel="noopener">借鉴2</a>  </p><p>docker-compose.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  es1:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch:6.8.6</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">es1</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">node.name=es01</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">cluster.name=es-cluster</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"ES_JAVA_OPTS=-Xms1024m -Xmx1024m"</span></span><br><span class="line"><span class="attr">    ulimits:</span></span><br><span class="line"><span class="attr">      nproc:</span> <span class="number">65535</span></span><br><span class="line"><span class="attr">      memlock:</span></span><br><span class="line"><span class="attr">        soft:</span> <span class="bullet">-1</span></span><br><span class="line"><span class="attr">        hard:</span> <span class="bullet">-1</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./elasticsearch_data/es1_data:/usr/share/elasticsearch/data</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">9200</span><span class="string">:9200</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">9300</span><span class="string">:9300</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">esnet</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  es2:</span></span><br><span class="line"><span class="attr">  image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch:6.8.6</span></span><br><span class="line"><span class="attr">  container_name:</span> <span class="string">es2</span></span><br><span class="line"><span class="attr">  environment:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">node.name=es02</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">cluster.name=es-cluster</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"ES_JAVA_OPTS=-Xms1024m -Xmx1024m"</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"discovery.zen.ping.unicast.hosts=es1"</span></span><br><span class="line"><span class="attr">  ulimits:</span></span><br><span class="line"><span class="attr">    nproc:</span> <span class="number">65535</span></span><br><span class="line"><span class="attr">    memlock:</span></span><br><span class="line"><span class="attr">      soft:</span> <span class="bullet">-1</span></span><br><span class="line"><span class="attr">      hard:</span> <span class="bullet">-1</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">./elasticsearch_data/es2_data:/usr/share/elasticsearch/data</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="number">9201</span><span class="string">:9200</span></span><br><span class="line"><span class="bullet">    -</span> <span class="number">9301</span><span class="string">:9300</span></span><br><span class="line"><span class="attr">  networks:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">esnet</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  kibana:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">docker.elastic.co/kibana/kibana:6.8.6</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">kibana</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      SERVER_NAME:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">      ELASTICSEARCH_URL:</span> <span class="attr">http://es1:9200</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">5601</span><span class="string">:5601</span></span><br><span class="line"><span class="attr">    ulimits:</span></span><br><span class="line"><span class="attr">      nproc:</span> <span class="number">65535</span></span><br><span class="line"><span class="attr">      memlock:</span></span><br><span class="line"><span class="attr">        soft:</span> <span class="bullet">-1</span></span><br><span class="line"><span class="attr">        hard:</span> <span class="bullet">-1</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">esnet</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">  esnet:</span></span><br></pre></td></tr></table></figure><p>这里ulimits是对资源的限制，nproc是线程的个数,memlock<br>浏览器打开<code>http://localhost:5601</code>即可监控集群状态  </p><p>在启动过程中出现了<code>max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</code>意思是最大的虚拟内存太小了，要求扩容，解决方案：<br>修改本机的 /etc/sysctl.conf，在文件末尾增加：<code>vm.max_map_count=262144</code><br>sysctl -p生效  </p><p>由于本机的内存限制，使用过程中，将es2节点删去之后进行的实验  </p></li><li><p>依赖  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置  </p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.data.elasticsearch.cluster-name=es-cluster</span></span><br><span class="line"><span class="comment"># 集群节点地址列表，用逗号分隔</span></span><br><span class="line"><span class="string">spring.data.elasticsearch.cluster-nodes=localhost:9300</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h2><p>spring-boot下使用elasticsearch与JPA很相似，因为它们都是在从相同的父类下继承而来  </p><ul><li><p>定义对象  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Document</span>(indexName = <span class="string">"customer"</span>, type = <span class="string">"customer"</span>, shards = <span class="number">1</span>, replicas = <span class="number">0</span>, refreshInterval = <span class="string">"-1"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//省略部分 getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Document 注解会对实体中的所有属性建立索引<br>indexName = “customer” 表示创建一个名称为 “customer” 的索引<br>type = “customer” 表示在索引中创建一个名为 “customer” 的 type<br>shards = 1 表示只使用一个分片<br>replicas = 0 表示不使用复制<br>refreshInterval = “-1” 表示禁用索引刷新</p></li><li><p>repository</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomerRepository</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">Customer</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Customer&gt; <span class="title">findByAddress</span><span class="params">(String address)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Customer <span class="title">findByUserName</span><span class="params">(String userName)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>  <span class="title">deleteByUserName</span><span class="params">(String userName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerRepositoryTest</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> CustomerRepository repository;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveCustomers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      repository.save(<span class="keyword">new</span> Customer(<span class="string">"Alice"</span>, <span class="string">"北京"</span>,<span class="number">13</span>));</span><br><span class="line">      repository.save(<span class="keyword">new</span> Customer(<span class="string">"Bob"</span>, <span class="string">"北京"</span>,<span class="number">23</span>));</span><br><span class="line">      repository.save(<span class="keyword">new</span> Customer(<span class="string">"Hibe"</span>, <span class="string">"上海"</span>,<span class="number">30</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fetchAllCustomers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (Customer customer : repository.findAll()) &#123;</span><br><span class="line">          System.out.println(customer);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteCustomers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      repository.deleteByUserName(<span class="string">"Hibe"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateCustomers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Customer customer= repository.findByUserName(<span class="string">"Bob"</span>);</span><br><span class="line">      customer.setAddress(<span class="string">"北京市海淀区"</span>);</span><br><span class="line">      repository.save(customer);</span><br><span class="line">      Customer xcustomer=repository.findByUserName(<span class="string">"Bob"</span>);</span><br><span class="line">      System.out.println(xcustomer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fetchIndividualCustomers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (Customer customer : repository.findByAddress(<span class="string">"北京"</span>)) &#123;</span><br><span class="line">          System.out.println(customer);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="Quartz"><a href="#Quartz" class="headerlink" title="Quartz"></a>Quartz</h1><h2 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h2><p>  Quartz其实就是linux的cron，能够定时执行某些任务，spring boot内部也集成了一个简单的定时任务调度。说怎么实现原理的话，可能有2种，一种的用定时器来实现，另一种封装系统的cron来实现，在内核层都应该是软中断。  </p><h2 id="spring-boot自带"><a href="#spring-boot自带" class="headerlink" title="spring boot自带"></a>spring boot自带</h2><ol><li><p>application上增加@EnableScheduling  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Spring</span> BootApplication</span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对应函数上增加配置@Scheduled(),cron与fixedRate都可以  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SchedulerTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron=<span class="string">"*/6 * * * * ?"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is scheduler task runing  "</span>+(count++));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled</span>(fixedRate = <span class="number">6000</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reportCurrentTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"现在时间："</span> + dateFormat.format(<span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cron：秒、时、分，日、月、星期、年； *表示每， /表示步长，也就是间隔， ？表示不确定（因为周与日是不会共存的，所以选择一种，另外一个就用？来表示）</p></li></ol><h2 id="Quartz-1"><a href="#Quartz-1" class="headerlink" title="Quartz"></a>Quartz</h2><ul><li><p>4个基本概念  </p><p>Job: 一个接口，表示要执行的任务<br>JobDetail: Job的实例<br>Trigger: 什么情况下触发，类似cron或者fixedRate<br>Scheduler: 调度器，包含这Job与Trigger</p></li><li><p>依赖  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-quartz<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用  </p><ol><li><p>定义job，需要实现Job接口  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"schedule job1 is running ..."</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用  </p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleJob</span><span class="params">(Scheduler scheduler)</span> <span class="keyword">throws</span> SchedulerException</span>&#123;</span><br><span class="line">    <span class="comment">// 这里生成JobDetail</span></span><br><span class="line">    JobDetail jobDetail = JobBuilder.newJob(ScheduledJob.class) .withIdentity(<span class="string">"job"</span>, <span class="string">"group1"</span>).build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里生成Trigger</span></span><br><span class="line">    CronScheduleBuilder scheduleBuilder = CronScheduleBuilder.cronSchedule(<span class="string">"0/6 * * * * ?"</span>);</span><br><span class="line">    CronTrigger cronTrigger = TriggerBuilder.newTrigger().withIdentity(<span class="string">"trigger"</span>, <span class="string">"group"</span>) .withSchedule(scheduleBuilder).build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用Scheduler，注册JobDetail与Trigger</span></span><br><span class="line">    scheduler.scheduleJob(jobDetail,cronTrigger);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>调用  </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleJobs</span><span class="params">()</span> <span class="keyword">throws</span> SchedulerException </span>&#123;</span><br><span class="line">  Scheduler scheduler = schedulerFactoryBean.getScheduler();</span><br><span class="line">  scheduleJob(scheduler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>启动时开始运行  </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStartupRunner</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> CronSchedulerJob scheduleJobs;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        scheduleJobs.scheduleJobs();</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;定时任务开始执行&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="邮件系统"><a href="#邮件系统" class="headerlink" title="邮件系统"></a>邮件系统</h1><ul><li><p>简介  </p><p><img src="./sendmail.png" alt="sendmail.png"><br>发送的时候使用SMTP协议，服务器推送时候使用POP3或者IMAP协议  </p></li><li><p>依赖  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置  </p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.mail.host=smtp.163.com</span> <span class="string">//邮箱服务器地址</span></span><br><span class="line"><span class="string">spring.mail.username=xxx@oo.com</span> <span class="string">//用户名</span></span><br><span class="line"><span class="string">spring.mail.password=xxyyooo</span>    <span class="string">//密码</span></span><br><span class="line"><span class="string">spring.mail.default-encoding=UTF-8</span></span><br><span class="line"></span><br><span class="line"><span class="string">//超时时间，可选</span></span><br><span class="line"><span class="string">spring.mail.properties.mail.smtp.connectiontimeout=5000</span>  </span><br><span class="line"><span class="string">spring.mail.properties.mail.smtp.timeout=3000</span></span><br><span class="line"><span class="string">spring.mail.properties.mail.smtp.writetimeout=5000</span></span><br></pre></td></tr></table></figure><p>这里的密码需要注意，并不是邮箱的密码，而是开启POP3的客户端授权码  </p></li><li><p>使用  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JavaMailSender mailSender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.mail.username&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendSimpleMail</span><span class="params">(String to, String subject, String content)</span> </span>&#123;</span><br><span class="line">        SimpleMailMessage message = <span class="keyword">new</span> SimpleMailMessage();</span><br><span class="line">        message.setFrom(from);</span><br><span class="line">        message.setTo(to);</span><br><span class="line">        message.setSubject(subject);</span><br><span class="line">        message.setText(content);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mailSender.send(message);</span><br><span class="line">            logger.info(<span class="string">"简单邮件已经发送。"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"发送简单邮件时发生异常！"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><ul><li><p>简介<br>Spring Security，是封装401与403的模块。401是未登录问题，这个感觉还不错；403是无权限问题，这个对复杂的，感觉还差一点  </p></li><li><p>依赖  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>加上这个依赖，默认所有的路由，都需要登录认证  </p></li><li><p>登录认证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">"/"</span>, <span class="string">"/home"</span>).permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">                <span class="comment">// .loginPage("/login")</span></span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">            .logout()</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">            .csrf()</span><br><span class="line">                .ignoringAntMatchers(<span class="string">"/logout"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是统一配置，哪些路由需要登录才能访问，哪个可以直接访问<br><code>antMatchers(&quot;/&quot;, &quot;/home&quot;).permitAll()</code>，这个意思是”/“,”/home”可以直接访问<br><code>anyRequest().authenticated()</code>，这个是其他的都需要登录认证<br>后边的几个是对登录与退出说的，对于Restful，可以省略  </p></li><li><p>权限认证<br>权限认证，首先要告诉spring boot有哪些角色、与成员，然后可以在config中确定哪些路由需要什么样的角色、权限，或者可以直接在函数上注解权限或角色。  </p><ol><li><p>配置角色</p><p>在SecurityConfig中增加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureGlobal</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    auth.inMemoryAuthentication()</span><br><span class="line">            .passwordEncoder(<span class="keyword">new</span> BCryptPasswordEncoder())</span><br><span class="line">            .withUser(<span class="string">"user"</span>)</span><br><span class="line">                .password(<span class="keyword">new</span> BCryptPasswordEncoder()</span><br><span class="line">                    .encode(<span class="string">"123456"</span>)).roles(<span class="string">"USER"</span>)</span><br><span class="line">            .and()</span><br><span class="line">            .withUser(<span class="string">"admin"</span>)</span><br><span class="line">                .password(<span class="keyword">new</span> BCryptPasswordEncoder()</span><br><span class="line">                    .encode(<span class="string">"admin"</span>)).roles(<span class="string">"ADMIN"</span>, <span class="string">"USER"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是直接通过代码写进去的，没有借鉴意义，只作演示用途  </p></li><li><p>统一配置路由方式  </p></li></ol><p>同登录认证，在SecurityConfig中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            .antMatchers(<span class="string">"/resources/**"</span>, <span class="string">"/"</span>).permitAll()</span><br><span class="line">            .antMatchers(<span class="string">"/admin/**"</span>).hasRole(<span class="string">"ADMIN"</span>)</span><br><span class="line">            .antMatchers(<span class="string">"/content/**"</span>).access(<span class="string">"hasRole('ADMIN') or hasRole('USER')"</span>)</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">            .and()</span><br><span class="line">        .formLogin()</span><br><span class="line"><span class="comment">//                .loginPage("/login")</span></span><br><span class="line">            .permitAll()</span><br><span class="line">            .and()</span><br><span class="line">        .logout()</span><br><span class="line">            .permitAll()</span><br><span class="line">            .and()</span><br><span class="line">        .csrf()</span><br><span class="line">            .ignoringAntMatchers(<span class="string">"/logout"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>antMatchers(&quot;/admin/**&quot;).hasRole(&quot;ADMIN&quot;)</code>，/admin路由，需要有’ADMIN’角色才可以访问，<br><code>antMatchers(&quot;/content/**&quot;).access(&quot;hasRole(&#39;ADMIN&#39;) or hasRole(&#39;USER&#39;)&quot;)</code>，/content路由，’ADMIN’,’USER’角色都可以访问</p><ol start="2"><li><p>在函数注解方式  </p><p>使用PreAuthorize()来配置，使用之前，需要先打开PreAuthorize的开关，否则不起作用<br>在SecurityConfig上，增加<code>@EnableGlobalMethodSecurity(prePostEnabled = true)</code> 注解即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize</span>(<span class="string">"hasAuthority('ADMIN')"</span>)</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/admin"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">admin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"admin"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关于权限认证  </p></li></ol><p>权限认证，是可以通过角色，也可以通过权限。如果角色固定，且较少的话，通过角色会好一些；如果角色不定，用权限来做会更佳一些。</p></li></ul><h1 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h1><h2 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h2><p>  对应用的监控，spring boot给出的方案是Actuator，它的监控分成两类：原生端点和用户自定义端点。自定义端点主要是指扩展性，用户可以根据自己的实际应用，定义一些比较关心的指标，在运行期进行监控。<br>  原生端点又可以分成三类：<br>  应用配置类，可以查看应用在运行期的静态信息，例如自动配置信息、加载的 springbean 信息、yml 文件配置信息、环境信息、请求映射信息；<br>  度量指标类，主要是运行期的动态信息，如堆栈、请求连、一些健康指标、metrics 信息等；<br>  操作控制类，主要是指 shutdown，用户可以发送一个请求将应用的监控功能关闭。  </p><p>  Actuator的提供了很多接口常用的：  </p><table><thead><tr><th>接口</th><th>路径</th><th>描述</th></tr></thead><tbody><tr><td>health</td><td>/health</td><td>报告应用程序的健康指标</td></tr><tr><td>info</td><td>/info</td><td>获取应用程序的定制信息，这些信息由 info 打头的属性提供</td></tr><tr><td>env</td><td>/env</td><td>获取全部环境属性</td></tr><tr><td>metrics</td><td>/metrics</td><td>报告各种应用程序度量信息，比如内存用量和 HTTP 请求计数</td></tr><tr><td>heapdump</td><td>/heapdump</td><td>dump 一份应用的 JVM 堆信息</td></tr><tr><td>threaddump</td><td>/threaddump</td><td>获取线程活动的快照</td></tr><tr><td>httptrace</td><td>/httptrace</td><td>显示 HTTP 足迹，最近 100 个 HTTP request/repspons(未成功)</td></tr><tr><td>sessions</td><td>/sessions</td><td>如果我们使用了 Spring Session 展示应用中的 HTTP Sessions 信息</td></tr><tr><td>logfile</td><td>/logfile</td><td>返回 log file 中的内容（如果 logging.file 或者 logging.path 被设置）</td></tr></tbody></table><p>  另外，在Actuator基础上，构建了分布式的Admin，来收集各应用的Actuator信息，进行汇总显示  </p><h2 id="Actuator"><a href="#Actuator" class="headerlink" title="Actuator"></a>Actuator</h2><ul><li><p>依赖  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置  </p><p>开启哪些监控，可以进行配置<br><code>management.endpoints.web.exposure.include=*</code>，默认开启health与info，通过这个设置，开启所有<br><code>management.endpoints.web.base-path=/manage</code>， 默认base路径是/actuator/*，这个可以进行配置<br><code>management.endpoint.health.show-details=always</code>，对health监控显示的内容进行配置</p></li></ul><h2 id="Admin"><a href="#Admin" class="headerlink" title="Admin"></a>Admin</h2><ul><li><p>server依赖  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>sever配置  </p><p><code>server.port=8000</code> 修改启动的端口  </p></li><li><p>client依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>spring-boot-admin-starter-client 会自动添加 Actuator 相关依赖</p></li><li><p>client配置  </p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.application.name=Admin</span> <span class="string">Client</span></span><br><span class="line"><span class="comment"># 配置sever的地址</span></span><br><span class="line"><span class="string">spring.boot.admin.client.url=http://localhost:8000</span>  </span><br><span class="line"><span class="comment"># 打开所有监控</span></span><br><span class="line"><span class="string">management.endpoints.web.exposure.include=*</span></span><br></pre></td></tr></table></figure></li><li><p>访问<br>通过<code>http://localhost:8000</code>访问页面，就可以查看指标了</p></li></ul><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><h2 id="普通部署"><a href="#普通部署" class="headerlink" title="普通部署"></a>普通部署</h2><ul><li><p>打包配置<br>可以打包成jar包，也可以打成war包，这里只介绍jar包<br>配置文件中设置打包方式：  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>打包命令<br>cd到项目根目录下，执行<br><code>mvn clean package -Dmaven.test.skip=true</code><br>mvn clean 是清除项目target目录下的文件<br>mvn package 是打包，可以跟clean一起执行，类似于管道。默认情况下，打包时候会自动运行test下的测试，如果失败打包就结束，可以通过<code>-Dmaven.test.skip=true</code>来禁用此测试。  </p><p>打包成功后，在target目录下，就会生成jar文件  </p></li><li><p>运行  </p><p><code>java -jar  target/spring-boot-package-1.0.0.jar</code><br><code>nohup java -jar spring-boot-package-1.0.0.jar &amp;</code>  </p></li><li><p>多配置文件  </p><ol><li><p>pom.xml修改</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">env</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">env</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">env</span>&gt;</span>test<span class="tag">&lt;/<span class="name">env</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>pro<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">env</span>&gt;</span>pro<span class="tag">&lt;/<span class="name">env</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置文件修改<br>在 Spring Boot 中多环境配置文件名需要满足 application-{profile}.properties 的格式<br>在 resources 目录下<strong>增加</strong>以下三个文件。<br>application-dev.properties：开发环境<br>application-test.properties：测试环境<br>application-prod.properties：生产环境  </p><p>将原来的application.properties修改为<code>spring.profiles.active=dev</code>，这样默认时候的是dev配置文件  </p></li><li><p>运行<br>打包完成之后，可以通过<code>java -jar  target/spring-boot-package-1.0.0.jar --spring.profiles.active=dev</code> 的方式来运行</p></li></ol></li><li><p>Jenkins简介<br>Jenkins，批量部署时候，它是目前CI领域使用最广泛的工具之一，它是一个独立的开源自动化服务器，可用于自动化各种任务，如构建、测试和部署软件。Jenkins 可以通过本机系统包以 Docker 的方式部署项目。</p><p>使用 Jenkin 之后，部署项目的步骤如下：<br>push 代码到 Github（或者 SVN） 触发 WebHook<br>Jenkins 从仓库拉去代码<br>Maven 构建项目、单元测试<br>备份项目，停止正在运行的项目<br>启动应用<br>查看启动日志  </p></li></ul><h2 id="docker部署"><a href="#docker部署" class="headerlink" title="docker部署"></a>docker部署</h2><ul><li><p>配置<br>在pom.xml中，增加  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--镜像前缀--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">docker.image.prefix</span>&gt;</span>friday<span class="tag">&lt;/<span class="name">docker.image.prefix</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 中间省略 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- Docker maven plugin --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spotify<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>docker-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">imageName</span>&gt;</span>$&#123;docker.image.prefix&#125;/$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">imageName</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">dockerDirectory</span>&gt;</span>src/main/docker<span class="tag">&lt;/<span class="name">dockerDirectory</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>/<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.build.directory&#125;<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">include</span>&gt;</span>$&#123;project.build.finalName&#125;.jar<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- Docker maven plugin --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>${project.build.directory}</code>，构建目录，缺省为 target<br><code>${project.build.finalName}</code>，产出物名称，缺省为 <code>${project.artifactId}-${project.version}</code></p></li><li><p>Dockerfile</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:8-jdk-alpine</span><br><span class="line">ADD account-0.1.0.jar app.jar</span><br><span class="line">ENTRYPOINT [<span class="string">"java"</span>,<span class="string">"-jar"</span>,<span class="string">"/app.jar"</span>]</span><br></pre></td></tr></table></figure><p>account-0.1.0.jar是打的jar包</p></li><li><p>打包部署  </p><ol start="0"><li><p>pro的配置文件<br>application-pro.properties中的localhost需要修改成对应的docker，如</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.datasource.url:</span> <span class="attr">jdbc:postgresql://postgresql:5432/account</span>  </span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">spring.redis.host=redis</span></span><br></pre></td></tr></table></figure></li><li><p>打包<br><code>mvn clean package -Dmaven.test.skip=true</code></p></li><li><p>启动<br><code>java -jar target/account-0.1.0.jar --spring.profiles.active=pro</code><br>运行正常，若启动失败，需要调试到正常  </p></li><li><p>打镜像<br><code>mvn docker:build</code> </p></li><li><p>docker-compose.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">account:</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">friday/account:latest</span></span><br><span class="line"><span class="attr">container_name:</span> <span class="string">account</span></span><br><span class="line"><span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line"><span class="attr">environment:</span></span><br><span class="line">  <span class="string">spring.profiles.active:</span> <span class="string">pro</span></span><br><span class="line"><span class="attr">ports:</span> </span><br><span class="line"><span class="bullet">  -</span> <span class="number">8080</span><span class="string">:8080</span></span><br><span class="line"><span class="attr">links:</span> </span><br><span class="line"><span class="bullet">  -</span> <span class="string">postgresql</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">redis</span></span><br></pre></td></tr></table></figure></li><li><p>启动<br>docker-compose up -d  </p></li></ol></li></ul><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>spring boot使用学习到此结束，嚼别人嚼过的馒头，虽速度不慢，但真不香。如果想深入的学习应该去看看spring boot的实现，Druid的实现，Elasticsearch的实现，RabbitMQ的原理等内容。这些全看，太费时，还有更重要的内容要去学习；不看，浅尝辄止，对于自己没有多少提高。那就综合一下，对spring boot的实现进行一下探索。  </p><p>这里有关于学习有些话想说，使用级别的学习，也是最肤浅的学习，就如同小孩子学会用水杯喝水，我称它为器；对原理与实现的学习，是第二阶段的学习，这就像学习如何制造水杯，我称它为术法；在众多术法以及术法演化中，涌现出了一些共性的东西，我称它为道，道不再局于某个领域，经济、组织、控制、生态、心智无不包含其中。吾辈学习，应以器学术，以术悟道。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为第二篇&lt;br&gt;主要是中间件与部署方面的内容  &lt;/p&gt;
&lt;p&gt;主要参考：&lt;br&gt;&lt;a href=&quot;https://github.com/ityouknow/spring-boot-leaning&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;spring-boot-learning&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>spring-boot基础</title>
    <link href="http://yoursite.com/2020/02/06/spring-boot%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/02/06/spring-boot基础/</id>
    <published>2020-02-06T06:16:45.000Z</published>
    <updated>2020-03-26T08:53:45.820Z</updated>
    
    <content type="html"><![CDATA[<p>最近窝在家里，准备对微服务学习再深入一步，这样就跨不过spring cloud这个坎了，那咱就从spring boot开始学习，然后转到spring cloud，并对spring cloud中的相关组件分别进行学习。<br>本文为第一篇  </p><p>主要参考：</p><p><a href="https://github.com/ityouknow/spring-boot-leaning" target="_blank" rel="noopener">spring-boot-learning</a> </p><a id="more"></a><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><ul><li><p>JDK<br>oracle官方下载JDK1.8，解压，添加环境变量<br><a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">jdk8下载</a>  </p></li><li><p>Maven<br>官网下载，解压，添加环境变量<br><a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">maven下载</a>  </p></li><li><p>IDE：VS<br>几个个插件：Java Extension Pack；Spring Initializr Java Support; Spring Boot Tools; Spring Boot Dashborad;<br><a href="https://code.visualstudio.com/docs/java/java-spring-boot" target="_blank" rel="noopener">指导</a>  </p></li><li><p>docker<br>另外，需要用到数据库（postgresql），redis，RabbitMQ等基础设施，用docker安装比较省事，本机已经安装了docker与docker-compose  </p></li></ul><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p>在 spring vs中有引导生成的方法： </p><ul><li>Ctrl + Shift + P</li><li>选择spring initializr maven</li><li>包名</li><li>依赖</li><li>生成位置</li><li>用VS打开  </li><li>F5执行  </li></ul><h1 id="Spring-Web"><a href="#Spring-Web" class="headerlink" title="Spring Web"></a>Spring Web</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li><p>@SpringBootApplication</p><p>每个应用都有一个application类，用@SpringBootApplication来注解  </p></li><li><p>@RestController与@RequestMapping</p><p>Contoller层用@RestController来注解，里边每个路由用@RequestMapping来注解</p></li><li><p>注入<br>将被注入的service用@Service(“xxx”)来注解<br>注入时，使用@Autowired来进行注入即可  </p></li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul><li><p>@SpringBootTest与@Test<br>原课程中使用被@Before注解的setUp()来创建基础环境，但在的版本中，没有@Before只用 @BeforeAll，且使用之后，就无法运行下边的测试了，所以这里改为通过声明时直接初始化的方法来创建mockMvc<br>测试的使用VS会在测试类与测试方法上，自动添加Run Test、Debug Test，点击即可运行  </p></li><li><p>@Before与@BeforeAll<br>搜索了一下@BeforeAll，它是在Junit5才出现的，用来对静态方法的注解。@Before是Junit4中的注解，与Junit5中的@BeforeEach等价</p></li><li><p>注入<br>在测试中，如果像之前一样用MockMvcBuilders.standaloneSetup(new WebController()).build();来创建mockMvc会发现，service无法注入到controller中，但直接运行是没问题的。<br>mockMvc需要用MockMvcBuilders.webAppContextSetup(this.wac).build();来定义，这个this.wac是@AutoWired的WebApplicationContext对象。</p></li></ul><h2 id="swagger"><a href="#swagger" class="headerlink" title="swagger"></a>swagger</h2><ul><li><p>依赖<br>  pom.xml中增加</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置<br>这里的配置，使用配置类的方式来配置  </p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger</span>2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">api</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                <span class="comment">// 自行修改为自己的包路径</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">"com.sun.account.controller"</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                .title(<span class="string">"用户管理"</span>)</span><br><span class="line">                .description(<span class="string">"用户管理操作文档"</span>)</span><br><span class="line">                .version(<span class="string">"1.0"</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用<br>在controller上用@Api(description=”xxx”)来装饰<br>在controller每个方法上用@ApiOperation(value=”xx”, notes=”xxxx”)来装饰<br>另外有@ApiImplicitParams，用来对入参进行解释；@ApiResponse，用来对返回进行解释；不过我感觉这2个用处不大，入参命名恰当，完全可以自注释。出参本身有用处，@ApiResponse返回的是对状态码的解释，如果状态码约定好了，并不需要每个都注释。</p><p>在返回数据的class上，用@ApiModel(description=”xxx”)来注解<br>class中的成员变量，用@ApiModelProperty(value=”xx”, name=”xxx”)来注解</p><p>这里例子中给出的class BaseResult<t>{}不错</t></p></li></ul><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="Postgresl安装"><a href="#Postgresl安装" class="headerlink" title="Postgresl安装"></a>Postgresl安装</h2><p>这里说安装是值得容器化的过程，看了一下之前的容器化，将每个数据库都创建一个镜像，这种做法是费力的，正确的做法是一个镜像，可以运行多个实例，在run的时候，通过配置将环境变量注入进去。  </p><ul><li><p>安装docker-compose<br>pip install upgrade pip<br>pip install docker-compose</p></li><li><p>docker-compose.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.4'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  postgresql:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">postgres:10.5</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">unless-stopped</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      POSTGRES_DB:</span> <span class="string">account</span></span><br><span class="line"><span class="attr">      POSTGRES_USER:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">      POSTGRES_PASSWORD:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./data:/var/lib/postgresql/data</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"5432:5432"</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><ul><li><p>依赖  </p><p>需要在pom.xml中增加2个依赖  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.postgresql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>postgresql<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一个是jdbc另外一个是postgres的驱动</p></li><li><p>配置</p><p>在application.properties中增加：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.datasource.url:</span> <span class="attr">jdbc:postgresql://localhost:5432/account</span></span><br><span class="line"><span class="string">spring.datasource.username:</span> <span class="string">root</span></span><br><span class="line"><span class="string">spring.datasource.password:</span> <span class="number">123456</span></span><br><span class="line"><span class="string">spring.datasource.driverClassName:</span> <span class="string">org.postgresql.Driver</span></span><br></pre></td></tr></table></figure></li><li><p>使用</p><p>在Repository的Impl类中，自动注入JdbcTemplate对象，通过此对象操作数据库。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryImpl</span> <span class="keyword">implements</span> <span class="title">UserRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">save</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.update(<span class="string">"INSERT INTO users(name, password, age) values(?, ?, ?)"</span>,</span><br><span class="line">            user.getName(), user.getPassword(), user.getAge());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> jdbcTemplate.update(<span class="string">"UPDATE users set name=?, password=?, age=? WHERE id=?"</span>,</span><br><span class="line">          user.getName(), user.getPassword(), user.getAge(), user.getId());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(<span class="keyword">long</span> id)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> jdbcTemplate.update(<span class="string">"DELETE FROM users WHERE id = ?"</span>,id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">findById</span><span class="params">(<span class="keyword">long</span> id)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> jdbcTemplate.queryForObject(<span class="string">"SELECT * from users WHERE id = ?"</span>, <span class="keyword">new</span> Object[] &#123; id &#125;, <span class="keyword">new</span> BeanPropertyRowMapper&lt;User&gt;(User.class));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Spring-Boot-JPA"><a href="#Spring-Boot-JPA" class="headerlink" title="Spring Boot JPA"></a>Spring Boot JPA</h2><p>同样的3个步骤</p><h3 id="前奏"><a href="#前奏" class="headerlink" title="前奏"></a>前奏</h3><ul><li><p>依赖</p><p>将jdbc改为data-jpa即可  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.postgresql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>postgresql<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置</p><p>除了postgres数据库的配置，增加了jpa的配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.datasource.url:</span> <span class="attr">jdbc:postgresql://localhost:5432/account</span></span><br><span class="line"><span class="string">spring.datasource.username:</span> <span class="string">root</span></span><br><span class="line"><span class="string">spring.datasource.password:</span> <span class="number">123456</span></span><br><span class="line"><span class="string">spring.datasource.driverClassName:</span> <span class="string">org.postgresql.Driver</span></span><br><span class="line"><span class="comment"># 可以用create\update\validate</span></span><br><span class="line"><span class="string">spring.jpa.properties.hibernate.hbm2ddl.auto=update</span></span><br><span class="line"><span class="string">spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect</span></span><br><span class="line"><span class="string">spring.jpa.show-sql=true</span></span><br><span class="line"><span class="string">spring.jpa.properties.hibernate.format_sql=true</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li><p>entity</p><p>entity上用@Entity来注解，如果表名与类名不同，可以增加@Table(name=”表名”)来注解表名  </p><p>主键：@Id @GeneratedValue来注解  </p><p>不同列：@Column(nullable=false, unqiue=true)来注解  </p><p>使用postgres来创建User对象时，这里有个小坑，因为postgres中默认有一个user表，会与User类重复，导致创建失败，这时候用@Table注解来重新命名表名即可  </p></li><li><p>JpaRepository</p><p>reppository是与JDBC不同最大的，在JDBC中，我们创建了一个interface+impl class来做的repository。而在jpa中，我们只需要一个interface，而有spring自动帮助我们实现。</p><ul><li><p>自动实现<br>Spring Data JPA 可以根据接口方法名来实现数据库操作，主要的语法是 findXXBy、readAXXBy、queryXXBy、countXXBy、getXXBy 后面跟属性名称，利用这个功能仅需要在定义的 Repository 中添加对应的方法名即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">User <span class="title">findByUserName</span><span class="params">(String userName)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>自定义查询<br>在自己本地，只实现了HQL的版本，原生的并没有实现  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query</span>(<span class="string">"select u from User u where u.nickName = ?1"</span>)</span><br><span class="line"><span class="function">User <span class="title">findUserByNickName</span><span class="params">(String nickName)</span></span>;</span><br></pre></td></tr></table></figure><p>在实践过程中发现：如果一个自定义函数有问题，会影响其他函数的生成与执行  </p></li></ul></li><li><p>分页查询  </p><p>分页有2种形式：Page与Slice，Page继承自Slice，并且多一个总数的属性  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query</span>(<span class="string">"select u from User u"</span>)</span><br><span class="line"><span class="function">Page&lt;User&gt; <span class="title">getAll</span><span class="params">(Pageable pageable)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Slice&lt;User&gt; <span class="title">getByNickName</span><span class="params">(String nickName, Pageable pageable)</span></span>;</span><br></pre></td></tr></table></figure><p>定义时候比较简单，复杂的是使用，这个Pageable的生成比较复杂。<br>Pageable的生成通过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Pageable pageable = PageRequest.of(page, size, sort);</span><br><span class="line">``</span><br><span class="line">来生成，前两个参数是<span class="keyword">int</span>类型，page表示第几页，size表示页的大小，sort是Sort对象，可以在这里传入order的参数。sort可以不填写。</span><br><span class="line">我经常的写法是将order写入语句中，比起这里将sort放到查询时候加入，没有这个通用性好。</span><br><span class="line"></span><br><span class="line">sort对象通过：  </span><br><span class="line">```java</span><br><span class="line"> Sort sort = Sort.by(Sort.Direction.DESC, <span class="string">"id"</span>);</span><br></pre></td></tr></table></figure><p>来生成  </p><p>整个过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAll</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> page=<span class="number">0</span>, size=<span class="number">2</span>;</span><br><span class="line">      Sort sort = Sort.by(Sort.Direction.DESC, <span class="string">"id"</span>);</span><br><span class="line"></span><br><span class="line">      Pageable pageable = PageRequest.of(page, size, sort);</span><br><span class="line">      Page&lt;User&gt; allUser = userRepository.getAll(pageable);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (User user : allUser) &#123;</span><br><span class="line">          System.out.print(user);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Page是Slice的子类，Slice是Iterable的孙类，故可以遍历访问  </p></li><li><p>top查询  </p><p>top查询将spring中约定大于配置的理念发挥得淋漓尽致，spring自动生成了TopN的查询：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">findTop2ByNickName</span><span class="params">(String nickName, Sort pageable)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><p>  只需要在repository的interface中增加此接口，就可以进行top2的查询了，t如果是top可以直接用User来当返回参数</p><ul><li><p>联表查询  </p><p>多表查询就是有外键的情况，在接口注解的时候，以HQL的形式注解即可<br>需要注意的是返回值，这里不像node,返回值需要访问，需要自定义访问接口，有getter即可。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query</span>(<span class="string">"select u.id as id, u.userName as userName, u.phone as phone, i.realName as realName, i.hobby as hobby from User u join UserInfo i on u.id=i.userId  where  u.id = ?1 "</span>)</span><br><span class="line"><span class="function">UserDetail <span class="title">getUserDetail</span><span class="params">(Long id)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDetail</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getUserName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getPhone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getRealName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getHobby</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>疑问  </li></ul><p>spring data JPA 是从Hibernate借鉴过来的，而Hibernate是有@OneToMany等关系的注解的，这里没找到例子，后边使用的时候再研究一下使用。</p><h2 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h2><ul><li>简介  </li></ul><p>Druid 首先是一个数据库连接池，但它不仅仅是一个数据库连接池，还包含了一个 ProxyDriver，一系列内置的 JDBC 组件库，一个 SQL Parser。</p><ol><li>替换其他 Java 连接池，Druid 提供了一个高效、功能强大、可扩展性好的数据库连接池。</li><li>可以监控数据库访问性能，Druid 内置提供了一个功能强大的 StatFilter 插件，能够详细统计 SQL 的执行性能，这对于线上分析数据库访问性能有很大帮助。</li><li>SQL 执行日志，Druid 提供了不同的 LogFilter，能够支持 Common-Logging、Log4j 和 JdkLog，可以按需要选择相应的 LogFilter，监控应用的数据库访问情况。</li></ol><ul><li><p>依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化大小、最小、最大链接数</span></span><br><span class="line"><span class="string">spring.datasource.druid.initial-size=3</span></span><br><span class="line"><span class="string">spring.datasource.druid.min-idle=3</span></span><br><span class="line"><span class="string">spring.datasource.druid.max-active=10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置获取连接等待超时的时间</span></span><br><span class="line"><span class="string">spring.datasource.druid.max-wait=60000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  StatViewServlet 配置</span></span><br><span class="line"><span class="string">spring.datasource.druid.stat-view-servlet.login-username=admin</span></span><br><span class="line"><span class="string">spring.datasource.druid.stat-view-servlet.login-password=admin</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 StatFilter</span></span><br><span class="line"><span class="string">spring.datasource.druid.filter.stat.log-slow-sql=true</span></span><br><span class="line"><span class="string">spring.datasource.druid.filter.stat.slow-sql-millis=2000</span></span><br></pre></td></tr></table></figure><p>另外有个<code>spring.datasource.type: com.alibaba.druid.pool.DruidDataSource</code>配置，放在jdbc连接配置之上</p></li><li><p>使用</p><p> <code>http://localhost:8080/druid</code>访问即可，登录的用户名用户密码都是admin，每次有数据库访问时，都可以监控到</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近窝在家里，准备对微服务学习再深入一步，这样就跨不过spring cloud这个坎了，那咱就从spring boot开始学习，然后转到spring cloud，并对spring cloud中的相关组件分别进行学习。&lt;br&gt;本文为第一篇  &lt;/p&gt;
&lt;p&gt;主要参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ityouknow/spring-boot-leaning&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;spring-boot-learning&lt;/a&gt; &lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>k8s基础</title>
    <link href="http://yoursite.com/2019/12/11/k8s%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/12/11/k8s基础/</id>
    <published>2019-12-11T07:33:04.000Z</published>
    <updated>2020-03-23T02:42:57.753Z</updated>
    
    <content type="html"><![CDATA[<p>本文是学习ali云的云原生课程的记录，目的是对基础概念的理解<br><a href="https://edu.aliyun.com/roadmap/cloudnative" target="_blank" rel="noopener">原课程</a>  </p><a id="more"></a><h1 id="K8S核心概念"><a href="#K8S核心概念" class="headerlink" title="K8S核心概念"></a>K8S核心概念</h1><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ul><li><p>K8S的架构是CS架构：<br><img src="架构-1.png" alt="架构-1.png">  </p></li><li><p>master的结构如下：<br><img src="master结构.png" alt="master结构.png">  </p><ul><li>Api Server不仅是外部访问k8s的入口，也是k8s各组件内部的枢纽  </li><li>Scheduler用于调度deployment的pod在哪个node节点运行  </li><li>Controller用于控制状态，做一些检测，确定集群运行正常，当有节点宕机，将其上的pod运行到其他节点上。  </li><li>etcd是一个分布式数据库  </li></ul></li><li><p>node的结构如下：<br><img src="node.png" alt="master结构.png">  </p><ul><li>pod翻译是豆荚，是k8s对容器的一种封装  </li><li>kubelet，是node下的控制，接收自master的命令，运行pod  </li><li>Container Runtime，容器运行环境，是容器实际运行的地方  </li><li>storage plugin，存储插件，是云计算厂商实现的存储接口  </li><li>network plugin，网络插件，同样也是云计算厂商实现  </li><li>kube-proxy，是位置k8s内部service集群的代理  </li></ul></li><li><p>示例<br><img src="一个例子.png" alt="一个例子.png">  </p><p>这个例子是有一个pod要运行，先与api server进行交互，api server进行存储，然后交给scheduler进行调度，scheduler根据目前集群的状态，计算该pod运行的位置，并经过api server进行存储，下发给node上的kubelet，kubelet再在container Runtime下运行起相应的pod（容器）  </p></li></ul><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul><li><p>Pod</p><p><img src="pod.png" alt="pod.png">  </p><ul><li>k8s最小的调度及资源单元  </li><li>由一个或多个容器组成  </li><li>为这些容器，提供共享的资源（网络、进程空间）</li></ul></li><li><p>Volume  </p><ul><li>声明再Pod中的容器可访问的文件目录  </li><li>支持多种后端存储的抽象：本地存储、分布式存储、云存储  </li></ul></li><li><p>Deployment  </p><ul><li>部署的概念，定义一组pod的副本数、版本等。意思是告诉k8s，我想要这种状态。  </li><li>k8s通过scheduler调度pod运行的节点  </li><li>通过Controller维持想要的这种状态，包括自愈，版本控制  </li></ul></li><li><p>service  </p><p><img src="service.png" alt="service.png">  </p><p>既然服务可以运行多个容器，这些容器对外提供服务就需要用稳定的访问地址，service就是为多个pod而建立稳定的虚拟ip。  </p></li><li><p>Namespaces  </p><p><img src="namespace.png" alt="namespace.png"><br>集群内部的逻辑隔离机制，每个资源都属于一个Namespace<br>上述的概念都可认为是一种资源，namesapce为一套K8S运行多个产品做好了铺垫  </p></li></ul><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>  <img src="api基础.png" alt="api基础.png">  </p><h1 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h1><h2 id="Pod概念"><a href="#Pod概念" class="headerlink" title="Pod概念"></a>Pod概念</h2><ul><li><p>容器<br>容器是一个试图被隔离、资源受限的<strong>进程（linux线程）</strong><br>容器里PID = 1的进程就是应用本身<br>容器是单进程模型  </p></li><li><p>k8s<br>k8s是对容器的编排，等价于<strong>操作系统</strong></p></li><li><p>pod<br>pod中的容器共享一些资源，可以任务是<strong>进程组(linux进程)</strong></p><p>两个docker应该运行在以pod上时，应该有超亲密关系：</p><ul><li>会发生直接的文件操作</li><li>通过localhost进行本地同喜</li><li>非常频繁的rpc调用</li></ul></li></ul><h2 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h2><p><img src="共享网络.png" alt="共享网络.png"></p><p>通过Infra Container的方式来共享一个Network Namespace，将网络放到Infa Contanier中，也使得一个pod只有一个ip地址，整个pod的生命中期与infra container一致。</p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><ul><li><p>InitContainer<br>pod中的InitContainer按用户定义的顺序依次启动，其他容器并发启动，并且InitContainer运行完成后自动退出。<br>用InitContainer来执行一些配置、预先准备资源的任务。</p></li><li><p>SideCar<br>用边车来执行一些辅助且通用的工作，如：</p><ul><li><p>日志收集<br><img src="日志收集.png" alt="日志收集.png">  </p></li><li><p>应用监控<br><img src="应用监控.png" alt="应用监控.png"></p></li></ul></li></ul><h1 id="应用编排"><a href="#应用编排" class="headerlink" title="应用编排"></a>应用编排</h1><h2 id="控制的核心"><a href="#控制的核心" class="headerlink" title="控制的核心"></a>控制的核心</h2><h3 id="资源对象"><a href="#资源对象" class="headerlink" title="资源对象"></a>资源对象</h3><ul><li>spec：期望的状态</li><li>status: 观测到的状态</li><li><p>metadata</p><ul><li><p>Lables<br>key-value形式的标签，用于筛选资源，<br>Selector: Tie=front  </p><p>Selector:<br>Env in (test, gray)<br>Tie notin (front, back)  </p></li><li><p>Annotations<br>存储资源的非标识性信息，可以包含特殊字符  </p></li><li><p>OwnerReference<br>资源创建者对象，如pod一般的所有者是replicas</p></li></ul></li></ul><h3 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h3><ul><li><p>控制循环<br><img src="控制循环.png" alt="控制循环.png"><br>主要是2部分：sensor、controller，不断使status趋近spec</p></li><li><p>sensor部分<br><img src="sensor部分.png" alt="sensor部分.png"><br>通过不断的list &amp; watch来获取变化，通过informer通知给controller部分来处理</p></li><li><p>controller部分<br><img src="controller.png" alt="controller.png"><br>hander发出指令，woker进行操作。  </p></li><li><p>示例：<br><img src="控制示例-1.png" alt="控制示例-1.png"><br><img src="控制示例-2.png" alt="控制示例-2.png"><br><img src="控制示例-3.png" alt="控制示例-3.png"></p></li></ul><h2 id="deployment"><a href="#deployment" class="headerlink" title="deployment"></a>deployment</h2><p>本节应该算是运维重点  </p><ul><li><p>用处<br>定义一组pod的spec数量，controller会维持status与spec一致<br>配置pod的发布方式，controller会暗中给定策略更新pod，保证发布过程可用<br>如有发布问题，支持一键回滚  </p></li><li><p>基础<br><img src="deployment语法.png" alt="deployment语法.png"><br>replicas: 期望的数量；<br>template: pod模板</p><p>deployment只负责管理不同版本的replicaSet，由ReplicaSet管理Pod副本数。每个ReplicaSet对应 deployment的一个版本，每个ReplicaSet下的pod都是相同的版本<br><img src="replicaSet与pod.png" alt="replicaSet与pod.png">  </p></li><li><p>发布<br><img src="deployment扩容.png" alt="deployment扩容.png">  </p></li><li><p>扩容<br><img src="发布模拟.png" alt="发布模拟.png">  </p></li><li><p>快速回滚<br>kubectl rollout undo deployment/nginx-deployment   // 回滚到上一版本   </p><p>kebectl rollout undo deployment.v1.apps/nginx-deployment –to-revision=2    // 回滚到固定版本  </p><p><img src="回滚模拟.png" alt="回滚模拟.png">  </p></li><li><p>控制字段  </p><ul><li>revisionHistroyLimit:保留历史resion(ReplicaSet)的数量，默认10</li><li>paused: 标志Deployment只做数量维持，不做新的发布  </li><li>progressDeadlineSeconds: 判断deloyment失败的最大时间  </li><li>MaxUnavailable: 发布过程中最多的pod不可用数目</li><li>MaxSurge: 发布过程中最多存在多少个Pod超过期望replicas数量</li></ul></li></ul><h2 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h2><ul><li><p>普通job</p><p>Job可以看做是直接运行的任务进程，执行某种计算，完成之后就停止。  </p><p><img src="Job示例.png" alt="Job示例.png"><br>用pod执行一个计算pi的任务  </p><p>在spec中指明</p><ul><li>completions： 代表这个job执行的总次数</li><li>parallelism:  代表并发的个数 </li></ul><p>kubectl get jobs  </p></li><li><p>cronJob</p><p>定时运行的job，与linux的cron相似<br><img src="cronJob.png" alt="cronJob.png">  </p></li></ul><h2 id="daemonSet"><a href="#daemonSet" class="headerlink" title="daemonSet"></a>daemonSet</h2><ul><li><p>用处<br>如同守护进程类似，可以用来：  </p><ul><li>保证集群每一个(或一些)节点都运行一组相同的Pod</li><li>跟踪集群节点状态，保证新加入的节点自动创建对应的pod</li><li>跟踪集群节点状态，保证移除的节点删除对应的pod</li><li>跟踪pod状态，保证每个节点pod处于运行状态</li></ul></li><li><p>示例</p></li></ul><p><img src="deamonSet.png" alt="deamonSet.png">  </p><h1 id="应用配置"><a href="#应用配置" class="headerlink" title="应用配置"></a>应用配置</h1><h2 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h2><p>主要管理容器运行所需的配置文件，环境便利，命令行参数等可变配置。用于解耦镜像和可变配置，从而保证pod的可移植性。</p><ul><li><p>yml  </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span> </span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span> </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">example-configmap</span> </span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="comment"># Configuration values can be set as key-value properties</span></span><br><span class="line"><span class="attr">  database:</span> <span class="string">mongodb</span></span><br><span class="line"><span class="attr">  database_uri:</span> <span class="attr">mongodb://localhost:27017</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># Or set as complete file contents (even JSON!)</span></span><br><span class="line"><span class="attr">  keys:</span>  </span><br><span class="line">    <span class="string">image.public.key=771</span> </span><br><span class="line">    <span class="string">rsa.public.key=42</span></span><br></pre></td></tr></table></figure></li><li><p>创建<br>kubectl apply -f config-map.ymal </p></li><li><p>使用  </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span> </span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span> </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">pod-env-var</span> </span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">env-var-configmap</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">k8s.gcr.io/busybox</span></span><br><span class="line"><span class="attr">      command:</span> <span class="string">["/bin/sh",</span> <span class="string">"-c"</span><span class="string">,</span> <span class="string">"env"</span><span class="string">]</span></span><br><span class="line"><span class="attr">      envFrom:</span></span><br><span class="line"><span class="attr">        - configMapRef:</span></span><br><span class="line"><span class="attr">            name:</span> <span class="string">example-configmap</span></span><br></pre></td></tr></table></figure></li><li><p>说明  </p><ol><li>ConfigMap文件大小限制：1MB(ETCD限制)</li><li>Pod只能引用同Namespace中的ConfigMap</li></ol></li></ul><h2 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h2><p>Secret是用在集群中用于存储密码，token等敏感信息的资源对象，使用base-64编码  </p><ul><li><p>yml<br><img src="secret.png" alt="secret.png">  </p></li><li><p>创建<br>kubectl apply -f ~/kube/hello/registry-secret.yaml  </p></li><li><p>使用<br><img src="secret使用.png" alt="secret使用.png"><br>secret使用一般通过volume挂载到指定容器目录，供容器中业务使用。 </p></li></ul><h2 id="ServiceAccount"><a href="#ServiceAccount" class="headerlink" title="ServiceAccount"></a>ServiceAccount</h2><p>secviceAccount主要用于解决Pod在集群中的身份认证问题。认证使用的授权信息，利用Secret</p><ul><li><p>yml<br><img src="serviceAccount.png" alt="serviceAccount.png">  </p></li><li><p>示例：私有镜像仓库<br><img src="私有镜像仓库.png" alt="私有镜像仓库.png">  </p></li></ul><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>主要是pod中配置所需要的cpu、memory、外存等</p><ul><li><p>yml<br><img src="resource.png" alt="resource.png">  </p></li><li><p>说明<br><img src="resource2.png" alt="resource2.png"></p></li></ul><h1 id="应用存储"><a href="#应用存储" class="headerlink" title="应用存储"></a>应用存储</h1><p>存储与容器的隔离，pod的生命周期与volume的生命周期解耦</p><h2 id="核心知识"><a href="#核心知识" class="headerlink" title="核心知识"></a>核心知识</h2><ul><li><p>概念  </p><p>static volume provisioning:  pv是静态的，当用户提交pvc，从静态中匹配合适的pv，这种容易找不到合适的pv  <img src="staticVolumeProvisioning.png" alt="staticVolumeProvisioning.png">  </p><p>dynamic volume provisioning: 通过storage class分配pv的模板，K8s根据pvc与sc自动创建pv<br><img src="dynamicVolumeProvisioning.png" alt="dynamicVolumeProvisioning.png">  </p></li><li><p>示例1<br>pod中的多个容器共享一个volume  </p><p><img src="pv示例1.png" alt="pv示例1.png">  </p><ul><li>spec.volumes声明pod的volume</li><li>spec.containers.volumeMounts声明container如何使用volume</li><li>多个container共享volume时，可以使用spec.containers.volumeMounts.subPath隔离不同容器上数据存储的路径  </li></ul></li><li><p>示例2<br>static volume provisoning  </p><p><img src="pv示例2.png" alt="pv示例2.png">  </p><p><img src="pv示例2-2.png" alt="pv示例2-2.png">  </p><p><img src="pv示例2-3.png" alt="pv示例2-3.png">  </p></li><li><p>示例3<br>dynamic volume provisioning  </p><p>系统员创建sc<br><img src="pv示例3-1.png" alt="pv示例3-1.png">  </p><p><img src="pv示例3-2.png" alt="pv示例3-2.png"></p><p><img src="pv示例3-3.png" alt="pv示例3-3.png">  </p></li><li><p>字段  </p><p>AccessModes：PV访问策略控制，必须同PVC的访问策略控制匹配才能绑定  </p><pre><code>ReadWriteOnce:只允许单node访问ReadOnlyMany：允许多node只读访问ReadWriteOnly：允许多node读写访问</code></pre><p>PersistentVolumeReclaimPolicy: PV被release之后再回收策略</p><pre><code>Delete：删除Retain：默认策略，保留</code></pre><p>StorageClassName：动态时，可以通过对应的storageClass动态生成新pv对象<br>NodeAffinity: 限制可以访问该volume的node，影响使用该volume的pod调度</p></li><li><p>pv状态机<br><img src="pv状态机.png" alt="pv状态机.png"><br>pv状态release后，无法再通过Reclaim Policy回收，而再次绑定新的PVC。原文给出2种方式，我觉得后一种比较靠谱一些：<br>直接从PVC对象服用，即不unbound PVC和PV。statefulSet处理存储状态的原理。</p></li><li><p>pvc与node流程分析<br><img src="pvc-node流程-1.png" alt="pvc-node流程-1.png"><br><img src="pvc-node流程-2.png" alt="pvc-node流程-2.png">  </p></li></ul><h2 id="存储快照"><a href="#存储快照" class="headerlink" title="存储快照"></a>存储快照</h2><p>存储快照主要是数据的恢复与数据复制迁移场景  </p><ul><li><p>基本概念<br><img src="存储快照基本概念.png" alt="存储快照基本概念.png">  </p></li><li><p>示例<br><img src="存储快照示例.png" alt="存储快照示例.png"></p></li><li><p>流程<br><img src="存储快照流程.png" alt="存储快照流程.png">  </p></li></ul><h2 id="拓扑调度"><a href="#拓扑调度" class="headerlink" title="拓扑调度"></a>拓扑调度</h2><p>拓扑调度应用场景是对volume的调度  </p><ul><li><p>定义<br>拓扑是针对k8s中node位置关系的一种人为划分，通过再node的labels中设置，以标志自己属于具体的拓扑域.3种拓扑域：  </p><ul><li>kubernetes.io/hostname =&gt;  node范围 </li><li>failure-domain.beta.kubernetes.io/region =&gt; Region范围</li><li>failure-domain.beta.kubernetes.io/zone =&gt; Zone范围  </li></ul></li><li><p>背景<br>k8s通过pvc与pv讲存储与计算分离，但有的存储有位置的限制，只能在特定的node上才能访问pv，这就需要拓扑域，来对node运行进行调度。如loval PV只能在制定的Node上被pod使用  </p></li><li><p>本质<br>pv在binding或dynamic provision时，并不知道它会被哪些node所使用，而pv本身是有node限制的  </p><p>这样将binding或者dynamic provision pv的操作延迟到pod调度结果确定之后。再pod调度时，会根据pvc的要求，选择合适的node，然后再去做pv与pvc的binding或者pv的dynamic provision</p></li><li><p>local PV示例<br><img src="localpv示例.png" alt="localpv示例.png">  </p></li><li><p>dynamic provision pv示例<br><img src="dynamicProvisionPv示例.png" alt="dynamicProvisionPv示例.png">  </p></li></ul><h1 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h1><h2 id="基本约束"><a href="#基本约束" class="headerlink" title="基本约束"></a>基本约束</h2><p>  k8s对Pod间的网络没有多少限制，但需要满足3个基本条件：  </p><ul><li>所有Pod可以与其他Pod直接通信，无需显示使用NAT</li><li>所有Node可以与所有Pod直接通信，无需显示使用NAT</li><li><p>Pod课间的IP地址确为其他Pod与其通信时所用，无需显示转换  </p><p>这就有4个方面：</p></li><li>容器与容器间通信  </li><li>Pod与Pod间通信</li><li>Pod与Service间通信</li><li>外部与Service的通信  </li></ul><h2 id="Netns"><a href="#Netns" class="headerlink" title="Netns"></a>Netns</h2><ul><li><p>本质<br><img src="netns.png" alt="netns.png">  </p></li><li><p>pod与netns的关系<br>每个Pod拥有独立的Nets空间，Pod内的Container共享该空间。宿主机本身有一个Root Netns</p><p><img src="pod与netns.png" alt="pod与netns.png">  </p></li><li><p>典型的容器网络实现方案<br><img src="容器网络方案.png" alt="容器网络方案.png">  </p></li></ul><h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><ul><li><p>k8s 服务发现  </p><p>由于pod生命周期短暂，IP地址随时变化，而deployment时pod组需要统一访问入口和负载均衡，所有需要Service  </p><p><img src="service服务发现与负载均衡.png" alt="service服务发现与负载均衡.png">  </p></li><li><p>示例  </p><p><img src="service-1.png" alt="service-1.png"><br><img src="service-2.png" alt="service-2.png"><br><img src="service-3.png" alt="service-3.png"></p></li><li><p>集群外暴露Service<br><img src="向集群外暴露Service.png" alt="向集群外暴露Service.png">  </p></li></ul><h1 id="可观测性"><a href="#可观测性" class="headerlink" title="可观测性"></a>可观测性</h1><h2 id="探测"><a href="#探测" class="headerlink" title="探测"></a>探测</h2><ul><li><p>背景<br>k8s如何知道应用运行是否正常？  </p></li><li><p>liveness与readness<br>通过liveness探测确定应用是否存活；<br>通过readness探测确定应用是否就绪</p><p>探测方式：<br>httpGet、Exec脚本、tcpSocket  </p></li><li><p>probe示例<br><img src="探测示例.png" alt="探测示例.png">  </p></li><li><p>故障排查<br><img src="故障排查.png" alt="故障排查.png">  </p></li></ul><h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><ul><li><p>类型  </p><p>资源监控：CPU、内存、网络等资源类的指标<br>性能监控：通过Hook的机制在虚拟机层、字节码执行层隐式回调，或者在应用层显示注入，用来调优<br>安全监控<br>事件监控</p></li><li><p>k8s监控接口标准  </p><p>k8s提供了3种不同的metrics接口标准：<br><img src="监控接口标准.png" alt="监控接口标准.png">  </p><p>注意这里k8s提供的是标准，而不是实现。<br>Prometheus：开源社区的监控标准  </p></li></ul><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><ul><li><p>类型<br>主机内核的日志<br>容器docker的日志<br>k8s核心组件的日志<br>部署应用的日志  </p><p>他们可以是宿主机文件，也可能是容器内文件，或者容器标准/错误输出的文件<br>可以通过边车模式，用logging-agent-pod来读取文件</p></li><li><p>Fluentd日志采集方案<br><img src="日志采集方案.png" alt="日志采集方案.png">  </p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是学习ali云的云原生课程的记录，目的是对基础概念的理解&lt;br&gt;&lt;a href=&quot;https://edu.aliyun.com/roadmap/cloudnative&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原课程&lt;/a&gt;  &lt;/p&gt;
    
    </summary>
    
    
      <category term="k8s" scheme="http://yoursite.com/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>node.js基础</title>
    <link href="http://yoursite.com/2019/12/07/node-js%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/12/07/node-js基础/</id>
    <published>2019-12-07T02:50:49.000Z</published>
    <updated>2019-12-13T00:56:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>调整一下学习的顺序，从先看libuv，再看node.js。</p><ul><li>v8引擎  </li><li>libuv  </li><li>node.js  &lt;=  </li></ul><p>本文是本系列最后一篇，先来看看node.js的一些api，然后稍介绍一下node.js的源码。  </p><p>主要参考：<a href="https://nodejs.org/dist/latest-v12.x/docs/api/" target="_blank" rel="noopener">官网</a>  </p><a id="more"></a><h1 id="node-js的api"><a href="#node-js的api" class="headerlink" title="node.js的api"></a>node.js的api</h1><p><img src="node-class-diagram.png"></p><p>这张图的node版本是v0.8.12，当下最新的版本是v13.3.0，增加了很多新的类，但核心EventEmitter、stream、net.Server、net.Socket、dgram.Socket、http系列的已经在图中了。这里只对主要的几个类进行简单的介绍。  </p><h2 id="EventEmitter"><a href="#EventEmitter" class="headerlink" title="EventEmitter"></a>EventEmitter</h2><p>EventEmitter是大部分node类的父类，也体现了node的异步理念。  </p><p><a href="https://nodejs.org/dist/latest-v12.x/docs/api/events.html" target="_blank" rel="noopener">api地址</a>  </p><p>最主要的接口是： </p><ul><li><p>on(eventName, listener)<br>将listener添加到event的listener最后，如果第一个可以任务是注册。</p></li><li><p>emit(eventName[, …args])<br>异步调用eventName的每一个listeners</p></li><li><p>eventNames()<br>返回注册的所有event</p></li><li><p>listeners(eventName)<br>返回eventName的全部listeners</p></li></ul><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>stream再libuv中也已经介绍过，是node.js的第二大概念。将很多稳定的数据当做流来处理，如基于tcp的网络数据以及fs等。<br>包括：只读流readable、只写流writable、双向流duplex等内容,duplex = readble + writable  </p><p>stream与Buffer往往是连用的，本质是读取的数据都是二进制流，只不过可以转换成string或者object</p><p><a href="https://nodejs.org/dist/latest-v12.x/docs/api/stream.html" target="_blank" rel="noopener">api地址</a></p><ul><li><p>readable  </p><p>2个event: readable vs data<br>1个function:   read([size])</p><ul><li><p>readable vs data  </p><p>在api中并没有说明这两个事件的差异，stackoverflow中有比较好的解释：  </p><p>The ‘data’ example calls your function with a chunk, and you have no choice but to handle it, or else it will be lost forever. In the ‘readable’ example, the function tells you that data is available, but you can read it at any time. This allows the underlying system to know whether or not you have dealt with the data yet so it is very simple to support a concept called backpressure.</p><p>For example, in a networked stream, if a client is sending data over a TCP connection to a server and the server is super busy, it will receive readable events, but it could choose to wait to read the data until it actually has the resources to deal with the data. By not reading the data, the stream will buffer it and as that buffer approaches a maximum size, the stream will stop reading packets from the operating system to avoid taking up too much RAM. Then the operating system will start dropping packets, and since the packets were dropped, the client that is sending the data will reduce the speed at which it is sending data to try to make fewer packets drop.</p><p>这也解释了官方说的：data是将一chunck数据的控制权交给用户。</p></li><li><p>read([size])<br>如果size不写，在内部缓存中的数据会全部返回</p></li></ul></li><li><p>writable  </p><ul><li>drain 事件　与　write()函数<br>写失败后，当可以再次写入的时候，会发送drain事件，通知写端继续write</li></ul></li></ul><h2 id="net"><a href="#net" class="headerlink" title="net"></a>net</h2><h3 id="net-Server"><a href="#net-Server" class="headerlink" title="net.Server"></a>net.Server</h3><p><a href="https://nodejs.org/dist/latest-v12.x/docs/api/net.html" target="_blank" rel="noopener">api地址</a>  </p><p>net.Server是从EventEmitter派生  </p><p>主要的接口  </p><ul><li><p>listening事件<br>该事件可以认为是server开张的事件</p></li><li><p>connect事件<br>当有新连接创建时，该事件就触发了。对比开张事件，这是接到客的事件  </p></li><li><p>net.createServer()函数<br>创建server的函数  </p></li><li><p>server.listen()函数<br>server.listen([port[, host[, backlog]]][, callback])</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server.listen(&#123;</span><br><span class="line">  host: <span class="string">'localhost'</span>,</span><br><span class="line">  port: <span class="number">80</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="net-Socket"><a href="#net-Socket" class="headerlink" title="net.Socket"></a>net.Socket</h3><p>socket与server连用，socket是server接到的客，它是从Duplex stream派生而来，也就继承了stream的data事件与drain事件，write()、read()函数，另外主要的事件还应该包括  </p><ul><li><p>connect事件<br>代表连接的成功建立</p></li><li><p>close事件<br>连接的断开  </p></li><li><p>connect()函数<br>socket.connect(port[, host][, connectListener])<br>这里的的connectListener回调，可以看做是connect事件的listener  </p></li><li><p>end()函数<br>socket.end([data[, encoding]][, callback])<br>半关闭socket，如果传递的data，可以认为是先write()data，然后再end()</p></li></ul><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><h3 id="http-Server"><a href="#http-Server" class="headerlink" title="http.Server"></a>http.Server</h3><p>http.server 从 net.Server派生  </p><ul><li><p>request事件<br>与tcp的connect事件不同，这里“来客”的事件是:request  </p></li><li><p>upgrade事件<br>比如，http升级成websocket的使用</p></li><li><p>clientError事件  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.end();</span><br><span class="line">&#125;);</span><br><span class="line">server.on(<span class="string">'clientError'</span>, (err, socket) =&gt; &#123;</span><br><span class="line">  socket.end(<span class="string">'HTTP/1.1 400 Bad Request\r\n\r\n'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">8000</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="http-ClientRequest"><a href="#http-ClientRequest" class="headerlink" title="http.ClientRequest"></a>http.ClientRequest</h3><p><a href="https://nodejs.org/dist/latest-v12.x/docs/api/http.html#http_class_http_clientrequest" target="_blank" rel="noopener">示例</a>  </p><p>ClientRequest是一个http的客户端，它包含了Socket，另外也包含了http协议的Header等内容。  </p><ul><li><p>http.request() 进行创建</p></li><li><p>connect事件<br>与server连接成功之后，会emit该事件</p></li><li><p>request.setHeader() 与 request.getHeader()  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">request.setHeader(<span class="string">'content-type'</span>, <span class="string">'text/html'</span>);</span><br><span class="line">request.setHeader(<span class="string">'Content-Length'</span>, Buffer.byteLength(body));</span><br><span class="line">request.setHeader(<span class="string">'Cookie'</span>, [<span class="string">'type=ninja'</span>,<span class="string">'language=javascript'</span>]);</span><br><span class="line"><span class="keyword">const</span> contentType = request.getHeader(<span class="string">'Content-Type'</span>);</span><br><span class="line"><span class="comment">// 'contentType' is 'text/html'</span></span><br><span class="line"><span class="keyword">const</span> contentLength = request.getHeader(<span class="string">'Content-Length'</span>);</span><br><span class="line"><span class="comment">// 'contentLength' is of type number</span></span><br><span class="line"><span class="keyword">const</span> cookie = request.getHeader(<span class="string">'Cookie'</span>);</span><br><span class="line"><span class="comment">// 'cookie' is of type string[]</span></span><br></pre></td></tr></table></figure></li><li><p>request.Socket()<br>虽然是socket，但这里的socket是http协议下的socket，不会发送‘readable’事件。</p></li><li><p>request.write()<br>写数据</p></li><li><p>示例：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; URL &#125; = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create an HTTP tunneling proxy</span></span><br><span class="line"><span class="keyword">const</span> proxy = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123; <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span> &#125;);</span><br><span class="line">  res.end(<span class="string">'okay'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">proxy.on(<span class="string">'connect'</span>, (req, cltSocket, head) =&gt; &#123;</span><br><span class="line">  <span class="comment">// Connect to an origin server</span></span><br><span class="line">  <span class="keyword">const</span> &#123; port, hostname &#125; = <span class="keyword">new</span> URL(<span class="string">`http://<span class="subst">$&#123;req.url&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">const</span> srvSocket = net.connect(port || <span class="number">80</span>, hostname, () =&gt; &#123;</span><br><span class="line">    cltSocket.write(<span class="string">'HTTP/1.1 200 Connection Established\r\n'</span> +</span><br><span class="line">                    <span class="string">'Proxy-agent: Node.js-Proxy\r\n'</span> +</span><br><span class="line">                    <span class="string">'\r\n'</span>);</span><br><span class="line">    srvSocket.write(head);</span><br><span class="line">    srvSocket.pipe(cltSocket);</span><br><span class="line">    cltSocket.pipe(srvSocket);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now that proxy is running</span></span><br><span class="line">proxy.listen(<span class="number">1337</span>, <span class="string">'127.0.0.1'</span>, () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make a request to a tunneling proxy</span></span><br><span class="line">  <span class="keyword">const</span> options = &#123;</span><br><span class="line">    port: <span class="number">1337</span>,</span><br><span class="line">    host: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    method: <span class="string">'CONNECT'</span>,</span><br><span class="line">    path: <span class="string">'www.google.com:80'</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> req = http.request(options);</span><br><span class="line">  req.end();</span><br><span class="line"></span><br><span class="line">  req.on(<span class="string">'connect'</span>, (res, socket, head) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'got connected!'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make a request over an HTTP tunnel</span></span><br><span class="line">    socket.write(<span class="string">'GET / HTTP/1.1\r\n'</span> +</span><br><span class="line">                 <span class="string">'Host: www.google.com:80\r\n'</span> +</span><br><span class="line">                 <span class="string">'Connection: close\r\n'</span> +</span><br><span class="line">                 <span class="string">'\r\n'</span>);</span><br><span class="line">    socket.on(<span class="string">'data'</span>, (chunk) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(chunk.toString());</span><br><span class="line">    &#125;);</span><br><span class="line">    socket.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">      proxy.close();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>  创建了一个http代理，用req与代理连接，然后发送数据</p><h3 id="http-ServerResponse"><a href="#http-ServerResponse" class="headerlink" title="http.ServerResponse"></a>http.ServerResponse</h3><p>由server创建的对象，在request事件的监听回调中，作为第二个参数。<br>这是用来与requestClient进行通信用的。  </p><ul><li>response.setHeader(name, value)</li><li>response.getHeader(name)</li><li>response.write(chunk[, encoding][, callback])</li><li>response.end([data[, encoding]][, callback])</li></ul><h3 id="http-IncomingMessage"><a href="#http-IncomingMessage" class="headerlink" title="http.IncomingMessage"></a>http.IncomingMessage</h3><p>这个server接到的客，属性包括：  </p><ul><li>message.headers</li><li>message.httpVersion</li><li>message.method</li><li><p>message.rawHeaders<br>原始的头，并不是键值对形式的，而是在一个list中的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Prints something like:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// [ 'user-agent',</span></span><br><span class="line"><span class="comment">//   'this is invalid because there can be only one',</span></span><br><span class="line"><span class="comment">//   'User-Agent',</span></span><br><span class="line"><span class="comment">//   'curl/7.22.0',</span></span><br><span class="line"><span class="comment">//   'Host',</span></span><br><span class="line"><span class="comment">//   '127.0.0.1:8000',</span></span><br><span class="line"><span class="comment">//   'ACCEPT',</span></span><br><span class="line"><span class="comment">//   '*/*' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(request.rawHeaders);</span><br></pre></td></tr></table></figure></li></ul><h2 id="fs"><a href="#fs" class="headerlink" title="fs"></a>fs</h2><p><a href="https://nodejs.org/dist/latest-v12.x/docs/api/fs.html" target="_blank" rel="noopener">api地址</a>  </p><ul><li>fs.open(path[, flags[, mode]], callback)</li><li><p>fs.openSync(path[, flags, mode])</p></li><li><p>fs.opendir(path[, options], callback)</p></li><li><p>fs.opendirSync(path[, options])</p></li><li><p>fs.readdir(path[, options], callback)</p></li><li><p>fs.readdirSync(path[, options])</p></li><li><p>fs.readFile(path[, options], callback)</p></li><li><p>fs.readFileSync(path[, options])</p></li><li><p>fs.writeFile(file, data[, options], callback)</p></li><li><p>fs.writeFileSync(file, data[, options])</p></li><li><p>fs.close(fd, callback)</p></li><li>fs.closeSync(fd)</li></ul><h1 id="node-js源码节选赏析"><a href="#node-js源码节选赏析" class="headerlink" title="node.js源码节选赏析"></a>node.js源码节选赏析</h1><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p><img src="node启动.png" alt="node启动.png">  </p><h2 id="internal模块"><a href="#internal模块" class="headerlink" title="internal模块"></a>internal模块</h2><p>internal模块是在init过程将模块注册到V8的堆栈中:</p><p>每个internal模块都有一个Initialize()函数，通过Envirment::SetMethod()注册成V8的Funtion Template，用于js代码来调用。  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> Environment::SetMethod(v8::Local&lt;v8::Object&gt; that,</span><br><span class="line">                                   <span class="keyword">const</span> <span class="keyword">char</span>* name,</span><br><span class="line">                                   v8::FunctionCallback callback) &#123;</span><br><span class="line">  v8::Local&lt;v8::Context&gt; context = isolate()-&gt;GetCurrentContext();</span><br><span class="line">  v8::Local&lt;v8::Function&gt; function =</span><br><span class="line">      NewFunctionTemplate(callback, v8::Local&lt;v8::Signature&gt;(),</span><br><span class="line">                          v8::ConstructorBehavior::kThrow,</span><br><span class="line">                          v8::SideEffectType::kHasSideEffect)</span><br><span class="line">          -&gt;GetFunction(context)</span><br><span class="line">          .ToLocalChecked();</span><br><span class="line">  <span class="comment">// kInternalized strings are created in the old space.</span></span><br><span class="line">  <span class="keyword">const</span> v8::NewStringType type = v8::NewStringType::kInternalized;</span><br><span class="line">  v8::Local&lt;v8::String&gt; name_string =</span><br><span class="line">      v8::String::NewFromUtf8(isolate(), name, type).ToLocalChecked();</span><br><span class="line">  that-&gt;Set(context, name_string, function).Check();</span><br><span class="line">  function-&gt;SetName(name_string);  <span class="comment">// NODE_SET_METHOD() compatibility.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个模块的最后都有<code>NODE_MODULE_CONTEXT_AWARE_INTERNAL(&lt;模块名&gt;, 模块的Initialize函数)</code>，<br>这个宏定义是再node_binding中定义的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NODE_MODULE_CONTEXT_AWARE_INTERNAL(modname, regfunc)                   \</span></span><br><span class="line">  NODE_MODULE_CONTEXT_AWARE_CPP(modname, regfunc, <span class="literal">nullptr</span>, NM_F_INTERNAL)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NODE_MODULE_CONTEXT_AWARE_CPP(modname, regfunc, priv, flags)           \</span></span><br><span class="line">  <span class="keyword">static</span> node::node_module _module = &#123;                                         \</span><br><span class="line">      NODE_MODULE_VERSION,                                                     \</span><br><span class="line">      flags,                                                                   \</span><br><span class="line">      <span class="literal">nullptr</span>,                                                                 \</span><br><span class="line">      __FILE__,                                                                \</span><br><span class="line">      <span class="literal">nullptr</span>,                                                                 \</span><br><span class="line">      (node::addon_context_register_func)(regfunc),                            \</span><br><span class="line">      NODE_STRINGIFY(modname),                                                 \</span><br><span class="line">      priv,                                                                    \</span><br><span class="line">      <span class="literal">nullptr</span>&#125;;                                                                \</span><br><span class="line">  <span class="keyword">void</span> _register_#<span class="meta">#modname() &#123; node_module_register(&amp;_module); &#125;</span></span><br></pre></td></tr></table></figure><p>通过宏定义，将创建了一个NM_F_INTERNAL类型的模块，声明了<em>register</em>&lt;模块名&gt; 的注册函数，先来看看这个注册函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> node_module* modlist_internal;</span><br><span class="line"><span class="keyword">static</span> node_module* modlist_linked;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">thread_local</span> node_module* thread_local_modpending;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is set by node::Init() which is used by embedders</span></span><br><span class="line"><span class="keyword">bool</span> node_is_initialized = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">node_module_register</span><span class="params">(<span class="keyword">void</span>* m)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node_module</span>* <span class="title">mp</span> = <span class="title">reinterpret_cast</span>&lt;struct node_module*&gt;(<span class="title">m</span>);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mp-&gt;nm_flags &amp; NM_F_INTERNAL) &#123;</span><br><span class="line">    mp-&gt;nm_link = modlist_internal;</span><br><span class="line">    modlist_internal = mp;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!node_is_initialized) &#123;</span><br><span class="line">    <span class="comment">// "Linked" modules are included as part of the node project.</span></span><br><span class="line">    <span class="comment">// Like builtins they are registered *before* node::Init runs.</span></span><br><span class="line">    mp-&gt;nm_flags = NM_F_LINKED;</span><br><span class="line">    mp-&gt;nm_link = modlist_linked;</span><br><span class="line">    modlist_linked = mp;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    thread_local_modpending = mp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">这个在不同的node版本中，node模块的类型有些不同。它将internal 模块放到 modlist_internal链表中，通过nm_link指向下一个模块。再来看看这些<span class="keyword">register</span>函数是如何被调用的。</span><br><span class="line"></span><br><span class="line">这些函数的调用正是再init时候的`RegisterBuiltinModules()`执行的：</span><br><span class="line"></span><br><span class="line">```C</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RegisterBuiltinModules</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> V(modname) _register_##modname();</span></span><br><span class="line">  NODE_BUILTIN_MODULES(V)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> V</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NODE_BUILTIN_MODULES(V)                                                \</span></span><br><span class="line">  NODE_BUILTIN_STANDARD_MODULES(V)                                             \</span><br><span class="line">  NODE_BUILTIN_OPENSSL_MODULES(V)                                              \</span><br><span class="line">  NODE_BUILTIN_ICU_MODULES(V)                                                  \</span><br><span class="line">  NODE_BUILTIN_REPORT_MODULES(V)                                               \</span><br><span class="line">  NODE_BUILTIN_PROFILER_MODULES(V)                                             \</span><br><span class="line">  NODE_BUILTIN_DTRACE_MODULES(V)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NODE_BUILTIN_STANDARD_MODULES(V)                                       \</span></span><br><span class="line">  V(async_wrap)                                                                \</span><br><span class="line">  V(buffer)                                                                    \</span><br><span class="line">  V(cares_wrap)                                                                \</span><br><span class="line">  V(config)                                                                    \</span><br><span class="line">  V(contextify)                                                                \</span><br><span class="line">  V(credentials)                                                               \</span><br><span class="line">  V(domain)                                                                    \</span><br><span class="line">  V(errors)                                                                    \</span><br><span class="line">  V(fs)                                                                        \</span><br><span class="line">  V(fs_dir)                                                                    \</span><br><span class="line">  V(fs_event_wrap)                                                             \</span><br><span class="line">  V(heap_utils)                                                                \</span><br><span class="line">  V(http2)                                                                     \</span><br><span class="line">  V(http_parser)                                                               \</span><br><span class="line">  V(inspector)                                                                 \</span><br><span class="line">  V(js_stream)                                                                 \</span><br><span class="line">  V(messaging)                                                                 \</span><br><span class="line">  V(module_wrap)                                                               \</span><br><span class="line">  V(native_module)                                                             \</span><br><span class="line">  V(options)                                                                   \</span><br><span class="line">  V(os)                                                                        \</span><br><span class="line">  V(performance)                                                               \</span><br><span class="line">  V(pipe_wrap)                                                                 \</span><br><span class="line">  V(process_wrap)                                                              \</span><br><span class="line">  V(process_methods)                                                           \</span><br><span class="line">  V(serdes)                                                                    \</span><br><span class="line">  V(signal_wrap)                                                               \</span><br><span class="line">  V(spawn_sync)                                                                \</span><br><span class="line">  V(stream_pipe)                                                               \</span><br><span class="line">  V(stream_wrap)                                                               \</span><br><span class="line">  V(string_decoder)                                                            \</span><br><span class="line">  V(symbols)                                                                   \</span><br><span class="line">  V(task_queue)                                                                \</span><br><span class="line">  V(tcp_wrap)                                                                  \</span><br><span class="line">  V(timers)                                                                    \</span><br><span class="line">  V(trace_events)                                                              \</span><br><span class="line">  V(tty_wrap)                                                                  \</span><br><span class="line">  V(types)                                                                     \</span><br><span class="line">  V(udp_wrap)                                                                  \</span><br><span class="line">  V(url)                                                                       \</span><br><span class="line">  V(util)                                                                      \</span><br><span class="line">  V(uv)                                                                        \</span><br><span class="line">  V(v8)                                                                        \</span><br><span class="line">  V(wasi)                                                                      \</span><br><span class="line">  V(worker)                                                                    \</span><br><span class="line">  V(zlib)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;调整一下学习的顺序，从先看libuv，再看node.js。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;v8引擎  &lt;/li&gt;
&lt;li&gt;libuv  &lt;/li&gt;
&lt;li&gt;node.js  &amp;lt;=  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文是本系列最后一篇，先来看看node.js的一些api，然后稍介绍一下node.js的源码。  &lt;/p&gt;
&lt;p&gt;主要参考：&lt;a href=&quot;https://nodejs.org/dist/latest-v12.x/docs/api/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网&lt;/a&gt;  &lt;/p&gt;
    
    </summary>
    
    
      <category term="node.js" scheme="http://yoursite.com/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>libuv记录</title>
    <link href="http://yoursite.com/2019/11/24/libuv%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/11/24/libuv记录/</id>
    <published>2019-11-24T02:58:23.000Z</published>
    <updated>2019-12-13T08:44:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>调整一下学习的顺序，从先看libuv，再看node.js。</p><ul><li>v8引擎  </li><li>libuv     &lt;=  </li><li>node.js  </li></ul><p>主要参考：<a href="http://docs.libuv.org/en/v1.x" target="_blank" rel="noopener">官网</a><br><a id="more"></a></p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>libuv不仅仅是一个在不同I/O轮询机制之上的简单抽象，它为sockets提供更高层次的’handles’与’streams’抽象，跨平台的文件I/O，线程、进程等功能。如图：<br><img src="概览.png" alt="概览.png">  </p><ul><li><p>事件循环(event loop)<br><img src="事件循环.png" alt="事件循环.png">  </p><p>事件循环是libuv的核心，它与一个独立的线程绑定。所有的网络I/O都在非阻塞的socket上执行。作为循环迭代的一部分，等待socket上I/O活动时，循环会阻塞，回调函数会立即触发，并指示socket的状态（可读、可写等），这样handles可以执行读写操作。</p><ul><li>首先执行是到期的times  </li><li>其次执行的是被挂起的callbacks，这些callback在本次轮询的前面，为什么会再前面呢，因为它们是在一次轮询前，推迟到本次的。  </li><li>空闲的handles  </li><li>prepare handles、I/O轮询、check handles，这三个可以是轮询的前中后，AOP编程的思维，像是Nest框架中的Interceptors</li></ul><p>在事件驱动的编程中，应用向表示对特定事件的兴趣，当事件发生时进行相应。从操作系统收集事件，监视其他资源的工作由libuv来完成。用户可以注册回调，当事件触发时被调用。  </p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;uv.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uv_loop_t</span> *loop = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">uv_loop_t</span>));</span><br><span class="line">    uv_loop_init(loop);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Now quitting.\n"</span>);</span><br><span class="line">    uv_run(loop, UV_RUN_DEFAULT);</span><br><span class="line"></span><br><span class="line">    uv_loop_close(loop);</span><br><span class="line">    <span class="built_in">free</span>(loop);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>handles 与 requests </p><ul><li><p>定义<br>libuv提供两个抽象：handle与request，它们与event loop结合使用。<br>handles： 代表可执行某些操作的持久对象，例如tcp server handle，一有新连接到来，就会执行回调函数。<br>requests: 代表可以行某些操作的短期对象，即可以在handle里执行，也可以直接再event loop里执行。例如getaddrinfo request</p><p>前文讲到，需要向libuv表示对某些事件的兴趣，这个怎么表示呢？这通过创建一个相应的handle来完成，handle可以简单表示成：uv_TYPE_t.例如：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Handle types. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_stream_s</span> <span class="title">uv_stream_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_tcp_s</span> <span class="title">uv_tcp_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_udp_s</span> <span class="title">uv_udp_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_pipe_s</span> <span class="title">uv_pipe_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_tty_s</span> <span class="title">uv_tty_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_poll_s</span> <span class="title">uv_poll_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_timer_s</span> <span class="title">uv_timer_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_prepare_s</span> <span class="title">uv_prepare_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_check_s</span> <span class="title">uv_check_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_idle_s</span> <span class="title">uv_idle_t</span>;</span></span><br></pre></td></tr></table></figure></li><li><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;uv.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int64_t</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait_for_a_while</span><span class="params">(<span class="keyword">uv_idle_t</span>* handle)</span> </span>&#123;</span><br><span class="line">    counter++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (counter &gt;= <span class="number">10e6</span>)</span><br><span class="line">        uv_idle_stop(handle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uv_idle_t</span> idler;</span><br><span class="line"></span><br><span class="line">    uv_idle_init(uv_default_loop(), &amp;idler);</span><br><span class="line">    uv_idle_start(&amp;idler, wait_for_a_while);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Idling...\n"</span>);</span><br><span class="line">    uv_run(uv_default_loop(), UV_RUN_DEFAULT);</span><br><span class="line"></span><br><span class="line">    uv_loop_close(uv_default_loop());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Streams 与 Buffers</p><p>最基本的handle是stream(uv_stream_t),TCP socket、文件I/O的管道、IPC都是stream的子类。<br>初始化之后，stream的基本操作如下：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_read_start</span><span class="params">(<span class="keyword">uv_stream_t</span>*, uv_alloc_cb alloc_cb, uv_read_cb read_cb)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_read_stop</span><span class="params">(<span class="keyword">uv_stream_t</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_write</span><span class="params">(<span class="keyword">uv_write_t</span>* req, <span class="keyword">uv_stream_t</span>* handle,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> <span class="keyword">uv_buf_t</span> bufs[], <span class="keyword">unsigned</span> <span class="keyword">int</span> nbufs, uv_write_cb cb)</span></span>;</span><br></pre></td></tr></table></figure><p>当uv_read_start()调用后，libuv自动从stream中持续读取数据，直到uv_read_stop()调用。<br>每个单位的数据是buffer- uv_buf_t。两个基本属性：uv_buf_t.base，指向数据的指针；uv_buf_t.len，数据的长度。</p></li></ul><h1 id="Filesystem"><a href="#Filesystem" class="headerlink" title="Filesystem"></a>Filesystem</h1><p>在概览图中，文件I/O是建立再线程池基础之上的。Socket操作使用操作系统提供的非阻塞函数，而File操作内部使用是阻塞函数，通过线程池来触发该函数。  </p><ul><li><p>主要函数  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_fs_open</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop, <span class="keyword">uv_fs_t</span>* req, <span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">int</span> flags, <span class="keyword">int</span> mode, uv_fs_cb cb)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_fs_close</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop, <span class="keyword">uv_fs_t</span>* req, uv_file file, uv_fs_cb cb)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(<span class="keyword">uv_fs_t</span>* req)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_fs_read</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop, <span class="keyword">uv_fs_t</span>* req, uv_file file, <span class="keyword">const</span> <span class="keyword">uv_buf_t</span> bufs[], <span class="keyword">unsigned</span> <span class="keyword">int</span> nbufs, <span class="keyword">int64_t</span> offset,   uv_fs_cb cb)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_fs_write</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop, <span class="keyword">uv_fs_t</span>* req, uv_file file, <span class="keyword">const</span> <span class="keyword">uv_buf_t</span> bufs[], <span class="keyword">unsigned</span> <span class="keyword">int</span> nbufs, <span class="keyword">int64_t</span> offset,   uv_fs_cb cb)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>直接读取方式：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">on_open</span><span class="params">(<span class="keyword">uv_fs_t</span> *req)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The request passed to the callback is the same as the one the call setup</span></span><br><span class="line">    <span class="comment">// function was passed.</span></span><br><span class="line">    assert(req == &amp;open_req);</span><br><span class="line">    <span class="keyword">if</span> (req-&gt;result &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        iov = uv_buf_init(buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">        uv_fs_read(uv_default_loop(), &amp;read_req, req-&gt;result,</span><br><span class="line">                   &amp;iov, <span class="number">1</span>, <span class="number">-1</span>, on_read);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"error opening file: %s\n"</span>, uv_strerror((<span class="keyword">int</span>)req-&gt;result));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">on_read</span><span class="params">(<span class="keyword">uv_fs_t</span> *req)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (req-&gt;result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Read error: %s\n"</span>, uv_strerror(req-&gt;result));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (req-&gt;result == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">uv_fs_t</span> close_req;</span><br><span class="line">        <span class="comment">// synchronous</span></span><br><span class="line">        uv_fs_close(uv_default_loop(), &amp;close_req, open_req.result, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (req-&gt;result &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        iov.len = req-&gt;result;</span><br><span class="line">        uv_fs_write(uv_default_loop(), &amp;write_req, <span class="number">1</span>, &amp;iov, <span class="number">1</span>, <span class="number">-1</span>, on_write);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">on_write</span><span class="params">(<span class="keyword">uv_fs_t</span> *req)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (req-&gt;result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Write error: %s\n"</span>, uv_strerror((<span class="keyword">int</span>)req-&gt;result));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        uv_fs_read(uv_default_loop(), &amp;read_req, open_req.result, &amp;iov, <span class="number">1</span>, <span class="number">-1</span>, on_read);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    uv_fs_open(uv_default_loop(), &amp;open_req, argv[<span class="number">1</span>], O_RDONLY, <span class="number">0</span>, on_open);</span><br><span class="line">    uv_run(uv_default_loop(), UV_RUN_DEFAULT);</span><br><span class="line"></span><br><span class="line">    uv_fs_req_cleanup(&amp;open_req);</span><br><span class="line">    uv_fs_req_cleanup(&amp;read_req);</span><br><span class="line">    uv_fs_req_cleanup(&amp;write_req);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个边读边写的示例，再onCreate中，开始读一定的量，然后写到write_req中，再write_req的回调中，再触发读。<br>libuv对操作系统的api进行了完整的封装，详细内容查看libuv的api</p></li><li><p>stream方式</p><p>除了直接读取，还可以通过stream的方式来使用，通过将文件fd与pipe绑定来创建一个file pipe如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    loop = uv_default_loop();</span><br><span class="line"></span><br><span class="line">    uv_pipe_init(loop, &amp;stdin_pipe, <span class="number">0</span>);</span><br><span class="line">    uv_pipe_open(&amp;stdin_pipe, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    uv_pipe_init(loop, &amp;stdout_pipe, <span class="number">0</span>);</span><br><span class="line">    uv_pipe_open(&amp;stdout_pipe, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uv_fs_t</span> file_req;</span><br><span class="line">    <span class="keyword">int</span> fd = uv_fs_open(loop, &amp;file_req, argv[<span class="number">1</span>], O_CREAT | O_RDWR, <span class="number">0644</span>, <span class="literal">NULL</span>);</span><br><span class="line">    uv_pipe_init(loop, &amp;file_pipe, <span class="number">0</span>);</span><br><span class="line">    uv_pipe_open(&amp;file_pipe, fd);</span><br><span class="line"></span><br><span class="line">    uv_read_start((<span class="keyword">uv_stream_t</span>*)&amp;stdin_pipe, alloc_buffer, read_stdin);</span><br><span class="line"></span><br><span class="line">    uv_run(loop, UV_RUN_DEFAULT);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">alloc_buffer</span><span class="params">(<span class="keyword">uv_handle_t</span> *handle, <span class="keyword">size_t</span> suggested_size, <span class="keyword">uv_buf_t</span> *buf)</span> </span>&#123;</span><br><span class="line">    *buf = uv_buf_init((<span class="keyword">char</span>*) <span class="built_in">malloc</span>(suggested_size), suggested_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_stdin</span><span class="params">(<span class="keyword">uv_stream_t</span> *stream, <span class="keyword">ssize_t</span> nread, <span class="keyword">const</span> <span class="keyword">uv_buf_t</span> *buf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nread &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (nread == UV_EOF)&#123;</span><br><span class="line">            <span class="comment">// end of file</span></span><br><span class="line">            uv_close((<span class="keyword">uv_handle_t</span> *)&amp;stdin_pipe, <span class="literal">NULL</span>);</span><br><span class="line">            uv_close((<span class="keyword">uv_handle_t</span> *)&amp;stdout_pipe, <span class="literal">NULL</span>);</span><br><span class="line">            uv_close((<span class="keyword">uv_handle_t</span> *)&amp;file_pipe, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        write_data((<span class="keyword">uv_stream_t</span> *)&amp;stdout_pipe, nread, *buf, on_stdout_write);</span><br><span class="line">        write_data((<span class="keyword">uv_stream_t</span> *)&amp;file_pipe, nread, *buf, on_file_write);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// OK to free buffer as write_data copies it.</span></span><br><span class="line">    <span class="keyword">if</span> (buf-&gt;base)</span><br><span class="line">        <span class="built_in">free</span>(buf-&gt;base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="Networking"><a href="#Networking" class="headerlink" title="Networking"></a>Networking</h1><h2 id="tcp"><a href="#tcp" class="headerlink" title="tcp"></a>tcp</h2><p>这个过程与直接使用操作系统的过程类似</p><ul><li><p>server</p><p>服务器通过:init、bind、listen、accept来使用  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    loop = uv_default_loop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uv_tcp_t</span> server;</span><br><span class="line">    uv_tcp_init(loop, &amp;server);</span><br><span class="line"></span><br><span class="line">    uv_ip4_addr(<span class="string">"0.0.0.0"</span>, DEFAULT_PORT, &amp;addr);</span><br><span class="line"></span><br><span class="line">    uv_tcp_bind(&amp;server, (<span class="keyword">const</span> struct sockaddr*)&amp;addr, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> r = uv_listen((<span class="keyword">uv_stream_t</span>*) &amp;server, DEFAULT_BACKLOG, on_new_connection);</span><br><span class="line">    <span class="keyword">if</span> (r) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Listen error %s\n"</span>, uv_strerror(r));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uv_run(loop, UV_RUN_DEFAULT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">on_new_connection</span><span class="params">(<span class="keyword">uv_stream_t</span> *server, <span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"New connection error %s\n"</span>, uv_strerror(status));</span><br><span class="line">        <span class="comment">// error!</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uv_tcp_t</span> *client = (<span class="keyword">uv_tcp_t</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">uv_tcp_t</span>));</span><br><span class="line">    uv_tcp_init(loop, client);</span><br><span class="line">    <span class="keyword">if</span> (uv_accept(server, (<span class="keyword">uv_stream_t</span>*) client) == <span class="number">0</span>) &#123;</span><br><span class="line">        uv_read_start((<span class="keyword">uv_stream_t</span>*) client, alloc_buffer, echo_read);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>  注意这里read数据时，是使用stream来使用  </p><ul><li><p>client  </p><p>client端通过connect来使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uv_tcp_t</span>* socket = (<span class="keyword">uv_tcp_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">uv_tcp_t</span>));</span><br><span class="line">uv_tcp_init(loop, socket);</span><br><span class="line"></span><br><span class="line"><span class="keyword">uv_connect_t</span>* connect = (<span class="keyword">uv_connect_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">uv_connect_t</span>));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">dest</span>;</span></span><br><span class="line">uv_ip4_addr(<span class="string">"127.0.0.1"</span>, <span class="number">80</span>, &amp;dest);</span><br><span class="line"></span><br><span class="line">uv_tcp_connect(connect, socket, (<span class="keyword">const</span> struct sockaddr*)&amp;dest, on_connect);</span><br></pre></td></tr></table></figure></li></ul><h2 id="udp"><a href="#udp" class="headerlink" title="udp"></a>udp</h2><p>libuv并不为udp提供stream，使用非阻塞的uv_udp_t handle与 uv_udp_send_t request来使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uv_loop_t</span> *loop;</span><br><span class="line"><span class="keyword">uv_udp_t</span> send_socket;</span><br><span class="line"><span class="keyword">uv_udp_t</span> recv_socket;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    loop = uv_default_loop();</span><br><span class="line"></span><br><span class="line">    uv_udp_init(loop, &amp;recv_socket);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">recv_addr</span>;</span></span><br><span class="line">    uv_ip4_addr(<span class="string">"0.0.0.0"</span>, <span class="number">68</span>, &amp;recv_addr);</span><br><span class="line">    uv_udp_bind(&amp;recv_socket, (<span class="keyword">const</span> struct sockaddr *)&amp;recv_addr, UV_UDP_REUSEADDR);</span><br><span class="line">    uv_udp_recv_start(&amp;recv_socket, alloc_buffer, on_read);</span><br><span class="line"></span><br><span class="line">    uv_udp_init(loop, &amp;send_socket);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">broadcast_addr</span>;</span></span><br><span class="line">    uv_ip4_addr(<span class="string">"0.0.0.0"</span>, <span class="number">0</span>, &amp;broadcast_addr);</span><br><span class="line">    uv_udp_bind(&amp;send_socket, (<span class="keyword">const</span> struct sockaddr *)&amp;broadcast_addr, <span class="number">0</span>);</span><br><span class="line">    uv_udp_set_broadcast(&amp;send_socket, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uv_udp_send_t</span> send_req;</span><br><span class="line">    <span class="keyword">uv_buf_t</span> discover_msg = make_discover_msg();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">send_addr</span>;</span></span><br><span class="line">    uv_ip4_addr(<span class="string">"255.255.255.255"</span>, <span class="number">67</span>, &amp;send_addr);</span><br><span class="line">    uv_udp_send(&amp;send_req, &amp;send_socket, &amp;discover_msg, <span class="number">1</span>, (<span class="keyword">const</span> struct sockaddr *)&amp;send_addr, on_send);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> uv_run(loop, UV_RUN_DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">on_read</span><span class="params">(<span class="keyword">uv_udp_t</span> *req, <span class="keyword">ssize_t</span> nread, <span class="keyword">const</span> <span class="keyword">uv_buf_t</span> *buf, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">unsigned</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nread &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Read error %s\n"</span>, uv_err_name(nread));</span><br><span class="line">        uv_close((<span class="keyword">uv_handle_t</span>*) req, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">free</span>(buf-&gt;base);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> sender[<span class="number">17</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    uv_ip4_name((<span class="keyword">const</span> struct sockaddr_in*) addr, sender, <span class="number">16</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Recv from %s\n"</span>, sender);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... DHCP specific code</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> *as_integer = (<span class="keyword">unsigned</span> <span class="keyword">int</span>*)buf-&gt;base;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ipbin = ntohl(as_integer[<span class="number">4</span>]);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> ip[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        ip[i] = (ipbin &gt;&gt; i*<span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Offered IP %d.%d.%d.%d\n"</span>, ip[<span class="number">3</span>], ip[<span class="number">2</span>], ip[<span class="number">1</span>], ip[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(buf-&gt;base);</span><br><span class="line">    uv_udp_recv_stop(req);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>libuv中还对线程、进程、进程通信等进行了封装，我觉得这些不是libuv的核心，这里不做详细的介绍了。</p><ul><li><p>线程  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tracklen = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">uv_thread_t</span> hare_id;</span><br><span class="line">    <span class="keyword">uv_thread_t</span> tortoise_id;</span><br><span class="line">    uv_thread_create(&amp;hare_id, hare, &amp;tracklen);</span><br><span class="line">    uv_thread_create(&amp;tortoise_id, tortoise, &amp;tracklen);</span><br><span class="line"></span><br><span class="line">    uv_thread_join(&amp;hare_id);</span><br><span class="line">    uv_thread_join(&amp;tortoise_id);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进程  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uv_loop_t</span> *loop;</span><br><span class="line"><span class="keyword">uv_process_t</span> child_req;</span><br><span class="line"><span class="keyword">uv_process_options_t</span> options;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    loop = uv_default_loop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* args[<span class="number">3</span>];</span><br><span class="line">    args[<span class="number">0</span>] = <span class="string">"mkdir"</span>;</span><br><span class="line">    args[<span class="number">1</span>] = <span class="string">"test-dir"</span>;</span><br><span class="line">    args[<span class="number">2</span>] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    options.exit_cb = on_exit;</span><br><span class="line">    options.file = <span class="string">"mkdir"</span>;</span><br><span class="line">    options.args = args;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> ((r = uv_spawn(loop, &amp;child_req, &amp;options))) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, uv_strerror(r));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Launched process with ID %d\n"</span>, child_req.pid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> uv_run(loop, UV_RUN_DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><ul><li>event loop</li><li>handle 与 request</li><li>stream</li><li>file</li><li>tcp &amp;&amp; udp</li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li><p>为什么文件读取用的是线程池？</p></li><li><p>为什么tcp是一个stream，而udp不是一个stream？</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;调整一下学习的顺序，从先看libuv，再看node.js。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;v8引擎  &lt;/li&gt;
&lt;li&gt;libuv     &amp;lt;=  &lt;/li&gt;
&lt;li&gt;node.js  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主要参考：&lt;a href=&quot;http://docs.libuv.org/en/v1.x&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="libuv" scheme="http://yoursite.com/tags/libuv/"/>
    
  </entry>
  
  <entry>
    <title>v8引擎学习记录</title>
    <link href="http://yoursite.com/2019/10/21/v8%E5%BC%95%E6%93%8E%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/10/21/v8引擎记录/</id>
    <published>2019-10-21T13:41:28.000Z</published>
    <updated>2019-11-25T06:25:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用node.js也有一段时间了，一直没有深入的研究一下node，这次就对node.js相关的技术，进行从上层到底层的学习，内容包括：</p><ul><li>v8引擎     &lt;=</li><li>libuv  </li><li>node.js  </li></ul><p>libuv的避免不了unix环境编程的api，这一块与node.js有点距离，不放在这个系列中了。  </p><a id="more"></a><p>本文主要引用：<br><a href="https://zhuanlan.zhihu.com/p/27628685" target="_blank" rel="noopener">认识v8引擎</a><br><a href="https://v8.dev/docs" target="_blank" rel="noopener">v8 doc文档</a>  </p><h1 id="V8简介"><a href="#V8简介" class="headerlink" title="V8简介"></a>V8简介</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>v8的背景是webkit内核的浏览器，webkit的架构如下：<br><img src="webkit内核.png" alt="webkit内核.png">  </p><p>这里：  </p><ul><li>WebCore 是各个浏览器使用的共享部分，包括HTML解析器、CSS解析器、DOM和SVG等</li><li>JSCore是WebKit的默认引擎，在谷歌系列产品中被替换为V8引擎。Javascript的引擎，或者类比Java的虚拟机  </li><li>WebKit Eembedding API是平台差异的,不同的浏览器实现不同</li></ul><p>这样就很容易看出V8的定位，解析执行JavaScript语言，JavaScript是一种解释性语言，与C、c++编译型语言不同，以及Java的半编译半解释性语言不同，它需要一遍执行一遍解析。</p><p>编译型语言的一般过程： 源代码 –&gt; 抽象语法树 –&gt;  中间表示 –&gt; 机器码<br>V8的过程: 源代码 –&gt; 抽象语法树 –&gt; 字节码 –&gt; JIT –&gt; 机器码</p><p>源代码：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象语法树：<br><img src="js抽象语法树.png" alt="js抽象语法树.png">  </p><p>字节码:<br><img src="字节码.png" alt="字节码"></p><p>v8 在5.9版本之前，不生成字节码，直接由抽象语法树经JIT运行，在5.9版本增加了Ignition字节码编译器。这一部分内容参考<a href="https://zhuanlan.zhihu.com/p/28590489" target="_blank" rel="noopener">v8字节码</a>  </p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>JavaScript代码编译的过程大致为：  </p><ul><li>Script类调用Compiler类的Compile函数为其生成本地代码。 </li><li>Compile函数先使用Parser类生成AST(抽象语法树)    </li><li>FullCodeGenerator类来生成本地代码。本地代码与具体的硬件平台密切相关，FullCodeGenerator使用多个后端来生成与平台相匹配的本地汇编代码。  </li><li>AstVisitor用于遍历AST（访问者模式） </li></ul><p><img src="js代码编译过程.jpg" alt="js代码编译过程.jpg">  </p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><ul><li>Script表示JavaScript代码，即包含源代码，又包含编译之后生成的本地代码，即是编译入口，又是运行入口；</li><li>Execution：运行代码的辅组类，包含一些重要函数，如Call函数，它辅组进入和执行Script代码；</li><li>JSFunction：需要执行的JavaScript函数表示类；</li><li>Runtime：运行这些本地代码的辅组类，主要提供运行时所需的辅组函数，如：属性访问、类型转换、编译、算术、位操作、比较、正则表达式等；</li><li>Heap：运行本地代码需要使用的内存堆类；</li><li>MarkCompactCollector：垃圾回收机制的主要实现类，用来标记、清除和整理等基本的垃圾回收过程；</li><li>SweeperThread：负责垃圾回收的线程。</li></ul><p><img src="js代码执行过程.jpg" alt="js代码执行过程.jpg">  </p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p><a href="https://zhuanlan.zhihu.com/p/33816534" target="_blank" rel="noopener">v8内存</a>  </p><ul><li>构成  </li></ul><p>一个 V8 进程的内存通常由以下几个块构成：</p><ol><li>新生代内存区（new space）<br>大多数的对象都会被分配在这里，这个区域很小但是垃圾回收比较频繁；</li><li>老生代内存区（old space）<br>属于老生代，这里只保存原始数据对象，这些对象没有指向其他对象的指针；</li><li>大对象区（large object space）<br>这里存放体积超越其他区大小的对象，每个对象有自己的内存，垃圾回收其不会移动大对象区；</li><li>代码区（code space）<br>代码对象，会被分配在这里。唯一拥有执行权限的内存；</li><li>map 区（map space）<br>存放 Cell 和 Map，每个区域都是存放相同大小的元素，结构简单。</li></ol><ul><li>生命周期</li></ul><p>假设代码中有一个对象 jerry ，这个对象从创建到被销毁，刚好走完了整个生命周期，通常会是这样一个过程：</p><ol><li>这个对象被分配到了 new space；</li><li>随着程序的运行，new space 塞满了，gc 开始清理 new space 里的死对象，jerry 因为还处于活跃状态，所以没被清理出去；</li><li>gc 清理了两遍 new space，发现 jerry 依然还活跃着，就把 jerry 移动到了 old space；</li><li>随着程序的运行，old space 也塞满了，gc 开始清理 old space，这时候发现 jerry 已经没有被引用了，就把 jerry 给清理出去了。</li></ol><h1 id="嵌入v8"><a href="#嵌入v8" class="headerlink" title="嵌入v8"></a>嵌入v8</h1><p>为什么介绍嵌入v8呢，因为node.js就是嵌入v8的。  </p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>isolate： 有自己堆的VM实例  </li><li>handle: 指向一个对象的指针，所有的V8对象都可以通过handle来访问</li><li>handle scope: 存放handle的容器，当删除handle scoppe，会自动删除其中的handle,从而也会触发删除v8对象  </li><li>context: 可以独立运行JavaScript脚本的可执行环境，要想运行一个JavaScript脚本，必须明确指明其context</li></ul><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><ul><li><p>Handles </p><p>handle是一个指针，指向在heap中JavaScript对象的地址。当这些对象没有被handle指向时，垃圾收集器GC就会回收这些存储。前边提到过，对象在heap中的位置会被GC移动，移动后，GC会更新所有指向这个对象的handle。  </p><p>最常见的有2种handle：local handle与Persistent handle<br>local handle存储在一个stack上，这个stack可以认为是前边的handle scope。用Local<sometype>来定义<br>Persistent handle也是指向一个在heap上分配的JavaScript对象，但它不在stack上。用UniquePersistent<sometype>与 Persistent<sometype>来定义。</sometype></sometype></sometype></p><p><img src="handle图解.png" alt="handle图解.png"> </p></li></ul><ul><li><p>context  </p><p>context是一个独立的可执行环境，它其中就包括了JavaScript内置的函数与对象。既然每个context都包含这些内置的函数与对象，加载的过程就比较耗时，v8做了一些优化，第一次创建context时候，会解析创建内置对象的JS代码，并创建对象，以后再创建context就只创建对象，而不再解析JS代码了。并且为第一创建也提供了快照功能，也会加快解析。  </p><p>你也可以多次进入、退出一个context，也可进入多个context，但只有一个当前的context。<br><img src="context图解.png" alt="context图解.png">  </p></li><li><p>template  </p><p>模板可以将C++的函数或者数据结构封装进一个JavaScript对象，这样可以再JavaScript中去操作这些对象。 在一个context下，一个template只能有一个实例。  </p><p>JavaScript有强烈的函数、对象二元性。这也反应在template上。有2种类型的template：</p><ul><li><p>Function template<br>通过调用template的GetFunction方法，在context中创建一个template的实例。可以将一个C++的回调函数与function template连接，这样当Js实例调用时，触发相应的C++函数。</p></li><li><p>Object template<br>每一个function template都与一个object template相连。用作配置被function示例化的对象（这里function当做类使用）。可以讲2种c++回调与object template关联。<br>accessor: 当一个Js对象的指定属性被访问使，触发<br>interceptor: 当一个Js对象的任意属性被访问时，触发</p></li></ul></li><li><p>Security model  </p><p>同源策略禁止一个origin的script访问另外一个origin的script的属性（数据）。origin在此指的是域名(<a href="http://www.example.com)、协议(https)、端口的结合。这3个相同，才可以认为是同源。" target="_blank" rel="noopener">www.example.com)、协议(https)、端口的结合。这3个相同，才可以认为是同源。</a><br>在V8中，“origin”被定义为context。默认禁止从任何一个context中访问另外一个context。既然默认禁止，那就有不默认的方式来访问。如果要从一个context访问另外一个context，就需要使用security token。可以在创建context时通过setSecurityToken手动创建，或者v8自动生成一个。当然时，v8的安全系统会检查调用者的token与被调用者的token，如果匹配，就允许访问，反之，就进一个回调来判断是否允许。</p></li><li><p>Exception  </p><p>当一个脚本执行不成功，V8返回空句柄。所以在继续执行之前，必须检查返回值是否是空句柄。<br>想要捕获异常，使用TryCatch，例如：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TryCatch <span class="title">trycatch</span><span class="params">(isolate)</span></span>;</span><br><span class="line">Local&lt;Value&gt; v = script-&gt;Run();</span><br><span class="line"><span class="keyword">if</span> (v.IsEmpty()) &#123;</span><br><span class="line">  Local&lt;Value&gt; exception = trycatch.Exception();</span><br><span class="line">  String::<span class="function">Utf8Value <span class="title">exception_str</span><span class="params">(exception)</span></span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Exception: %s\n"</span>, *exception_str);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式有点像unix，通过返回值标识是否错误，通过主动get错误信息来打印。</p></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>  官方给出3个示例，这里给出process这里示例的地址:<br>  <a href="https://github.com/v8/v8/blob/master/samples/process.cc" target="_blank" rel="noopener">process.cc</a><br>  <a href="https://github.com/v8/v8/blob/master/samples/count-hosts.js" target="_blank" rel="noopener">js脚本</a>  </p><p>  这个示例实现的是，统计访问host的个数，progess函数通过js来实现，保存在全局对象中，通过以下代码讲Js的函数引用到C++ process_对象中</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Local&lt;String&gt; process_name =</span><br><span class="line">  String::NewFromUtf8(GetIsolate(), <span class="string">"Process"</span>, NewStringType::kNormal)</span><br><span class="line">      .ToLocalChecked();</span><br><span class="line">Local&lt;Value&gt; process_val;</span><br><span class="line"><span class="comment">// If there is no Process function, or if it is not a function,</span></span><br><span class="line"><span class="comment">// bail out</span></span><br><span class="line"><span class="keyword">if</span> (!context-&gt;Global()-&gt;Get(context, process_name).ToLocal(&amp;process_val) ||</span><br><span class="line">    !process_val-&gt;IsFunction()) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// It is a function; cast it to a Function</span></span><br><span class="line">Local&lt;Function&gt; process_fun = Local&lt;Function&gt;::Cast(process_val);</span><br><span class="line">  </span><br><span class="line"><span class="comment">// Store the function in a Global handle, since we also want</span></span><br><span class="line"><span class="comment">// that to remain after this call returns</span></span><br><span class="line">process_.Reset(GetIsolate(), process_fun);</span><br></pre></td></tr></table></figure><p>  然后，写了一个Process函数，来调用，这个Process函数有些像代理一样  </p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> argc = <span class="number">1</span>;</span><br><span class="line">Local&lt;Value&gt; argv[argc] = &#123;request_obj&#125;;</span><br><span class="line">v8::Local&lt;v8::Function&gt; process =</span><br><span class="line">    v8::Local&lt;v8::Function&gt;::New(GetIsolate(), process_);</span><br><span class="line">Local&lt;Value&gt; result;</span><br><span class="line"><span class="keyword">if</span> (!process-&gt;Call(context, context-&gt;Global(), argc, argv).ToLocal(&amp;result)) &#123;</span><br><span class="line">  String::Utf8Value error(GetIsolate(), try_catch.Exception());</span><br><span class="line">  Log(*error);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  以上可以认为是C++调用JavaScript的函数，另外还有JavaScript使用C++的数据对象。<br>  既然是计数，最好的方式就是map，这里C++的实现就是用的Map来实现。然后将Map封装到全局的template下，就可以在脚本中直接使用该对象了。(原代码封装了2个对象,opts与output) </p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">bool</span> JsHttpRequestProcessor::InstallMaps(<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;* opts,</span><br><span class="line">                                         <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;* output) &#123;</span><br><span class="line">  HandleScope handle_scope(GetIsolate());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Wrap the map object in a JavaScript wrapper</span></span><br><span class="line">  Local&lt;Object&gt; opts_obj = WrapMap(opts);</span><br><span class="line"></span><br><span class="line">  v8::Local&lt;v8::Context&gt; context =</span><br><span class="line">      v8::Local&lt;v8::Context&gt;::New(GetIsolate(), context_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set the options object as a property on the global object.</span></span><br><span class="line">  context-&gt;Global()</span><br><span class="line">      -&gt;Set(context,</span><br><span class="line">            String::NewFromUtf8(GetIsolate(), <span class="string">"options"</span>, NewStringType::kNormal)</span><br><span class="line">                .ToLocalChecked(),</span><br><span class="line">            opts_obj)</span><br><span class="line">      .FromJust();</span><br><span class="line"></span><br><span class="line">  Local&lt;Object&gt; output_obj = WrapMap(output);</span><br><span class="line">  context-&gt;Global()</span><br><span class="line">      -&gt;Set(context,</span><br><span class="line">            String::NewFromUtf8(GetIsolate(), <span class="string">"output"</span>, NewStringType::kNormal)</span><br><span class="line">                .ToLocalChecked(),</span><br><span class="line">            output_obj)</span><br><span class="line">      .FromJust();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Js中使用output<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Process</span>(<span class="params">request</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (options.verbose) &#123;</span><br><span class="line">    log(<span class="string">"Processing "</span> + request.host + request.path +</span><br><span class="line">        <span class="string">" from "</span> + request.referrer + <span class="string">"@"</span> + request.userAgent);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!output[request.host]) &#123;</span><br><span class="line">    output[request.host] = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    output[request.host]++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用node.js也有一段时间了，一直没有深入的研究一下node，这次就对node.js相关的技术，进行从上层到底层的学习，内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;v8引擎     &amp;lt;=&lt;/li&gt;
&lt;li&gt;libuv  &lt;/li&gt;
&lt;li&gt;node.js  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;libuv的避免不了unix环境编程的api，这一块与node.js有点距离，不放在这个系列中了。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="v8" scheme="http://yoursite.com/tags/v8/"/>
    
  </entry>
  
  <entry>
    <title>微积分-其他</title>
    <link href="http://yoursite.com/2019/10/13/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%85%B6%E4%BB%96/"/>
    <id>http://yoursite.com/2019/10/13/微积分-其他/</id>
    <published>2019-10-13T13:40:25.000Z</published>
    <updated>2019-11-07T09:35:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是微积分复习的最后一篇，教材使用《普林斯顿微积分读本》，涵盖第27章-第30章的内容。  </p><ul><li>函数与微分  </li><li>积分  </li><li>级数  </li><li>其他      &lt;=</li></ul><p>本文的内容覆盖4章，包括：参数方程和极坐标、复数、体积弧长和表面积、微分方程。在函数中引入中间变量，过度到了参数方程，极坐标可以看作特殊的参数方程; 复数即可以用笛卡尔坐标系来表示，也可以用极坐标系来表示（欧拉公式），这两章的内容较近。体积、弧长与表面积一章是用微积分代入空间几何，可以看作一种应用，在3D中有很好的应用场景; 微分方程应用场景更宽广一些，这里介绍了3种微分方程的解法。  </p><a id="more"></a><h1 id="参数方程和极坐标"><a href="#参数方程和极坐标" class="headerlink" title="参数方程和极坐标"></a>参数方程和极坐标</h1><h2 id="参数方程"><a href="#参数方程" class="headerlink" title="参数方程"></a>参数方程</h2><ul><li><p>示例<br>x和y都是另外一个变量t的函数，例如：<br>x = 3cos(t) 和 y = 3sin(t)<br>图像为: <img src="参数方程示例.png" alt="参数方程示例.png">  </p></li><li><p>参数方程的导数<br><img src="参数方程的导数.png" alt="参数方程的导数.png">  </p></li></ul><h2 id="极坐标"><a href="#极坐标" class="headerlink" title="极坐标"></a>极坐标</h2><ul><li><p>极坐标与笛卡尔坐标互换<br>极坐标到笛卡尔坐标：x = rcos(θ) 和 y = rsin(θ)<br><img src="坐标变化1.png" alt="坐标变化1.png">  </p><p>笛卡尔坐标到极坐标：r<sup>2</sup> = x<sup>2</sup> + y<sup>2</sup> 和 tan(θ) = y/x, x不等于0， 需要检查象限<br><img src="极坐标的示例.png" alt="极坐标的示例.png">  </p></li><li><p>极坐标中的曲线<br>极坐标中的函数 r=f(θ), θ在给定的范围内取值。一般先画出r=f(θ)在笛卡尔坐标系下的图像，然后再画在极坐标中的图像<br>如 r=3sin(θ)</p><p><img src="极坐标画图.png" alt="极坐标画图.png"><br><img src="极坐标画图2.png" alt="极坐标画图2.png">  </p><p><img src="一些漂亮的极坐标曲线.png" alt="一些漂亮的极坐标曲线.png">  </p></li><li><p>极坐标曲线的切线<br>我们有r = f(θ)， 并且有 x = rcos(θ)一级 y = rsin(θ)<br>于是 x = f(θ)cos(θ) 和 y = f(θ)sin(θ)  </p><p>这样依据参数方式的切线方法 dy/dx = dy/dθ  /  dx/dθ</p><p>示例： r = 1+2cos(θ)，求穿过极坐标为（2, π/3）点的切线方程。</p><p>x = rcos(θ) = (1+2cos(θ))cos(θ)<br>y = rsin(θ) = (1+2cos(θ))sin(θ)<br>求导:<br>dy/dθ = -2sin<sup>2</sup>(θ) + (1+2cos(θ))cos(θ)<br>dx/dθ = -sin(θ)(1+4cos(θ))</p></li></ul><p>所以 dy/dx = dy/dθ / dx/dθ  将 θ = π/3代入得：<img src="极坐标切线.png" alt="极坐标切线.png">  代入点x = 2cos(π/3)=1 和 y = 2 sin(π/3) = √3</p><ul><li><p>极坐标曲线的围成的面积<br><img src="极坐标的面积.png" alt="极坐标的面积.png"><br><img src="极坐标的面积2.png" alt="极坐标的面积2.png">  </p><p>这里有个很有趣的例子：r = 1+2cos(θ)围成的图形的面积。<br><img src="极坐标面积示例.png" alt="极坐标面积示例.png"><br>直接从[0,2π]进行积分求处的面积是<img src="极坐标面积示例2.png" alt="极坐标面积示例2.png">图形的，问题在于θ 位于 2π/3 和 4π/3 之间时 , r 为负。由于面积公式包含r<sup>2</sup>无法辨别正负面积。（这与笛卡儿坐标下的情况大不相同,在笛卡儿坐标系中,y轴以下都为负）。<br>正解是通过通过完全的面积减去2倍小圈中的面积.<br>小圈中的面积为：<img src="极坐标面积示例3.png" alt="极坐标面积示例3.png"></p></li></ul><h1 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>复数的加、减、乘、除法则比较简单，不进行介绍了，主要介绍复数的指数化e<sup>z</sup><br>复指数也满足指数的法则 e<sup>z</sup>e<sup>w</sup> = e<sup>z+w</sup><br>证明的过程可以借鉴指数的泰勒级数：<br><img src="复指数函数-1.png" alt="复指数函数-1.png"><br><img src="复指数函数-2.png" alt="复指数函数-2.png"></p><h2 id="欧拉公式"><a href="#欧拉公式" class="headerlink" title="欧拉公式"></a>欧拉公式</h2><p><img src="欧拉公式.png" alt="欧拉公式.png"><br>欧拉公式的证明可以通过泰勒级数展开的方式进行证明。<br>不管怎么看，它都太简单，太美丽了，完美的定义了复数的极坐标形式<br><img src="复平面.png" alt="复平面.png"><br><img src="复平面示例1.png" alt="复平面示例1.png">  </p><p><img src="欧拉公式证明1.png" alt="欧拉公式证明1.png"><br><img src="欧拉公式证明2.png" alt="欧拉公式证明2.png">  </p><h2 id="复数的高次幂"><a href="#复数的高次幂" class="headerlink" title="复数的高次幂"></a>复数的高次幂</h2><p>为什么要使用极坐标形式呢？一个原因是，极坐标形式比较容易进行乘法跟取幂运算。<br>如：<br><img src="复数的高次幂.png" alt="复数的高次幂.png">  </p><h2 id="解Zn-w"><a href="#解Zn-w" class="headerlink" title="解Zn = w"></a>解Z<sup>n</sup> = w</h2><p><img src="解复数的幂-1.png" alt="解复数的幂-1.png"><br><img src="解复数的幂-2.png" alt="解复数的幂-2.png"><br><img src="解复数的幂-3.png" alt="解复数的幂-3.png"></p><p>这里的 5θ = 5π/6 + 2πk</p><p>因为极坐标方式很容易求指数方式，所以，复数的次幂，都是转换成极坐标方式进行求解。</p><h2 id="解-ez-w"><a href="#解-ez-w" class="headerlink" title="解 ez = w"></a>解 e<sup>z</sup> = w</h2><p><img src="e的复数次幂-1.png" alt="e的复数次幂-1.png"><br>z = x + iy<br><img src="e的复数次幂-2.png" alt="e的复数次幂-2.png">  </p><p>与复数的次幂类似，也转换成极坐标的方式来进行求解。  </p><h1 id="体积、弧长和表面积"><a href="#体积、弧长和表面积" class="headerlink" title="体积、弧长和表面积"></a>体积、弧长和表面积</h1><p>本章是微积分在空间几何中的应用，主要是求体积与求表面积2大目标，弧长的求解是表面积求解的引子</p><h2 id="旋转体的体积"><a href="#旋转体的体积" class="headerlink" title="旋转体的体积"></a>旋转体的体积</h2><p><img src="圆盘法-1.png" alt="圆盘法-1.png">  </p><ul><li><p>圆盘法<br>圆盘法是黎曼和积分的扩展。<br>求此图形绕x轴旋转得到图形的体积  </p><p><img src="圆盘法-2.png" alt="圆盘法-2.png"><br><img src="圆盘法-3.png" alt="圆盘法-3.png"><br>将体积看作面积的积分。  </p></li><li><p>壳法<br>求此图形绕y轴旋转得到图形的体积</p><p><img src="壳法-1.png" alt="壳法-1.png"><br>壳法比圆盘法理解更新奇一点,这里想想此图形y轴方向截开，形成长方体的体积。<br><img src="壳法-2.png" alt="壳法-2.png"><br><img src="壳法-3.png" alt="壳法-3.png">  </p></li><li><p>总结  </p><ul><li>若每个小条的dx边平行于旋转轴，运用圆盘法  </li><li>若咩个小条的dx边垂直于旋转轴，运用壳法</li></ul></li></ul><h2 id="一般立方体体积"><a href="#一般立方体体积" class="headerlink" title="一般立方体体积"></a>一般立方体体积</h2><p>一般立方体的体积求法也是考虑体积是面积的积分。需要注意是面积的选择与积分区间的选择。<br>基本上,你的选择是:选择一个轴,所有的切片将垂直于这个轴.一旦选定了轴,后续的思路就清晰了:求得每个垂直于该轴的切片的横截面面积.不同的切片有不同的面积。</p><ul><li>选定一个轴  </li><li>求轴上点x处的横截面面积，称该面积为A(x)  </li><li><img src="一般体积求法.png" alt="一般体积求法.png">  </li></ul><p><img src="一般体积求法示意图.png" alt="一般体积求法示意图.png">  </p><p>这些面积的求解都依赖于原始的曲线方程，那如果生活中一个物体，要求其体积如何来做呢。大概可以考虑拟合出曲线来，然后用公式求解，更一般的也许就类似与草冲称象了。  </p><h2 id="弧长"><a href="#弧长" class="headerlink" title="弧长"></a>弧长</h2><p><img src="弧长公式图像.png" alt="弧长公式图像.png"><br><img src="弧长公式-1.png" alt="弧长公式-1.png"><br><img src="弧长公式-2.png" alt="弧长公式-2.png"><br>这里有一点很有趣的变化，就是将(dx)<sup>2</sup>提到的根号外边。原文称这个变化需要进行证明但证明超越原书范围。<br>弧长公式也有参数形式: <img src="弧长公式-3.png" alt="弧长公式-3.png">  </p><ul><li>示例：<br><img src="弧长公式示例1.png" alt="弧长公式示例1.png"><br>t在[3,5]之间</li></ul><p><img src="弧长公式示例2.png" alt="弧长公式示例2.png"><br>根号内化简得到：36(t + 2)<sup>2</sup>  </p><ul><li>物理中的应用<br>定义在时间 t 秒处的蚂蚁位置是(x(t), y(t)). 那么,蚂蚁在时间 t 的速率是多少?<br><img src="速率.png" alt="速率.png">  </li></ul><p>把速率进行积分，就是蚂蚁走过曲线的弧长  </p><h2 id="旋转体的表面积"><a href="#旋转体的表面积" class="headerlink" title="旋转体的表面积"></a>旋转体的表面积</h2><p><img src="表面积示意图.png" alt="表面积示意图.png"><br>表面积看作周长的积分</p><p><img src="表面积公式1.png" alt="表面积公式1.png"><br><img src="表面积公式2.png" alt="表面积公式2.png">  </p><h1 id="微分方程"><a href="#微分方程" class="headerlink" title="微分方程"></a>微分方程</h1><p>微分方程就是包含导数的方程，它对于描述现实世界中量的变化非常有用，比如了解种群增长快慢，或者还清贷款等，都可以有微分方程来建模。  </p><h2 id="可分离变量的一阶微分方程"><a href="#可分离变量的一阶微分方程" class="headerlink" title="可分离变量的一阶微分方程"></a>可分离变量的一阶微分方程</h2><p>可分离变量的一阶微分方程指的是所有关于y的部分(包括dy)放到一边，所有关于x的部分(包括dx)放到另外一边。<br>这种方程比较好求解，只需要两边求积分即可，这里只介绍一个简单的示例：  </p><p><img src="可分离变量-1.png" alt="可分离变量-1.png"><br><img src="可分离变量-2.png" alt="可分离变量-2.png"><br><img src="可分离变量-3.png" alt="可分离变量-3.png">  </p><h2 id="一阶线性微分方程"><a href="#一阶线性微分方程" class="headerlink" title="一阶线性微分方程"></a>一阶线性微分方程</h2><ul><li><p>定义：<br>一阶线性微分方程：<img src="一阶线性方程形式.png" alt="一阶线性方程形式.png">。dy/dx 与 y的幂次都是1  </p></li><li><p>解法：<br>这种方程的解法是使用配方法，将左侧进行变换，转换成可分离变量的形式。进行的变化可以借鉴乘法的导数法则。<br><img src="一阶线性微分方程.png" alt="一阶线性微分方程.png">  </p><p><img src="配方法解释-1.png" alt="配方法解释-1.png"><br><img src="配方法解释-2.png" alt="配方法解释-2.png">  </p><p>这是一种解法，也可以参考下一节的常系数微分方程的解法</p></li><li><p>示例：<br><img src="一阶线性微分方程1.png" alt="一阶线性微分方程1.png"><br>两边乘e<sup>2x<sup>3</sup></sup>得：<br><img src="一阶线性微分方程2.png" alt="一阶线性微分方程2.png"><br><img src="一阶线性微分方程3.png" alt="一阶线性微分方程3.png">  </p></li></ul><h2 id="常系数微分方程"><a href="#常系数微分方程" class="headerlink" title="常系数微分方程"></a>常系数微分方程</h2><ul><li><p>定义：<br><img src="常系数微分方程.png" alt="常系数微分方程.png"><br>a<sub>n</sub> 只是一些普通的常实数。  </p></li><li><p>解法：<br>解法一般显示解齐次(右侧为0)，然后再解非齐次的特解，然后再合并。有些像线代中的解法，这里只介绍1次与2次。  </p></li><li><p>一阶齐次解法：<br><img src="一阶齐次.png" alt="一阶齐次.png"><br>y = Ae<sup>-ax</sup>  </p></li><li><p>二阶齐次解法：<br><img src="二阶齐次方程.png" alt="二阶齐次方程.png"><br><img src="二阶齐次方程解法.png" alt="二阶齐次方程解法.png">  </p><p>那为什么这种解法适用？<img src="二阶齐次解法解释.png" alt="二阶齐次解法解释.png">  </p></li><li><p>二阶非齐次<br>求一个特解，非齐次的解= 一般解 + 特解<br>特解归纳如下：<br><img src="特解的求法归纳.png" alt="特解的求法归纳.png">  </p></li><li><p>示例<br><img src="常系数示例1.png" alt="常系数示例1.png"><br>先求齐次部分：<br>t<sup>2</sup> -4t + 4 = 0，只有一个解，t=2<br><img src="常系数示例2.png" alt="常系数示例2.png"><br>特解形式为： <img src="常系数示例3.png" alt="常系数示例3.png"><br>代入方程求解的：C=-4 D=-3.<br><img src="常系数示例4.png" alt="常系数示例4.png">  </p></li></ul><h2 id="微分方程建模"><a href="#微分方程建模" class="headerlink" title="微分方程建模"></a>微分方程建模</h2><p>微分方程以上都是工具，建模部分是核心，它告诉我们，微分方程能如何使用。可惜的是，这部分原书中示例很少，只有一个细菌培养的例子。  </p><p><img src="微分方程建模1.png" alt="微分方程建模1.png"><br><img src="微分方程建模2.png" alt="微分方程建模2.png"><br>这是一个一阶线性微分方程，套用上边解法即可  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是微积分复习的最后一篇，教材使用《普林斯顿微积分读本》，涵盖第27章-第30章的内容。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数与微分  &lt;/li&gt;
&lt;li&gt;积分  &lt;/li&gt;
&lt;li&gt;级数  &lt;/li&gt;
&lt;li&gt;其他      &amp;lt;=&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文的内容覆盖4章，包括：参数方程和极坐标、复数、体积弧长和表面积、微分方程。在函数中引入中间变量，过度到了参数方程，极坐标可以看作特殊的参数方程; 复数即可以用笛卡尔坐标系来表示，也可以用极坐标系来表示（欧拉公式），这两章的内容较近。体积、弧长与表面积一章是用微积分代入空间几何，可以看作一种应用，在3D中有很好的应用场景; 微分方程应用场景更宽广一些，这里介绍了3种微分方程的解法。  &lt;/p&gt;
    
    </summary>
    
      <category term="理论" scheme="http://yoursite.com/categories/%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="微积分" scheme="http://yoursite.com/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>微积分-级数</title>
    <link href="http://yoursite.com/2019/09/28/%E5%BE%AE%E7%A7%AF%E5%88%86-%E7%BA%A7%E6%95%B0/"/>
    <id>http://yoursite.com/2019/09/28/微积分-级数/</id>
    <published>2019-09-28T06:41:25.000Z</published>
    <updated>2019-11-07T09:35:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是微积分复习的第三篇，教材使用《普林斯顿微积分读本》，涵盖第22章-第26章的内容。  </p><ul><li>函数与微分  </li><li>积分      </li><li>级数      &lt;=</li><li>其他</li></ul><p>级数的进入是从数列开始的，首先是数列的收敛性，然后是级数的收敛性，然后过度到泰勒级数，最后是对泰勒级数的应用（估值问题）。<br>级数是积分概念在离散数列的延伸，正向理解，是对离散数据的求和，反向理解，是对函数的分解。就分解而言，在工程领域得到了充分的应用。</p><a id="more"></a><h1 id="级数的收敛性"><a href="#级数的收敛性" class="headerlink" title="级数的收敛性"></a>级数的收敛性</h1><h2 id="数列收敛性"><a href="#数列收敛性" class="headerlink" title="数列收敛性"></a>数列收敛性</h2><p>谈到收敛性，就离不开极限，而数列从函数那里继承了很多极限的性质：  </p><ul><li>数列继承了函数的极限性质  </li><li>三明治定理  </li><li>连续函数保持极限，lim g(x) -&gt; L 则lim f(g(x)) -&gt; f(L)</li></ul><h2 id="级数收敛性简介"><a href="#级数收敛性简介" class="headerlink" title="级数收敛性简介"></a>级数收敛性简介</h2><p>级数就是和，就是将数列a<sub>n</sub>的所有项都加起来;<br>级数对等的是积分，无穷级数的收敛性对等反常积分对无限的积分，这样对反常积分收敛性的4种判别方法，就可以应用到级数上，另外级数也有几种独有的级数。  </p><h2 id="反常积分的方法"><a href="#反常积分的方法" class="headerlink" title="反常积分的方法"></a>反常积分的方法</h2><ul><li><p>第n项判别法<br><img src="第n项判别法.png" alt="第n项判别法"><br>注意：第n项判别法不能用于级数收敛性的判别，即lim a<sub>n</sub> = 0未必收敛。 </p></li><li><p>极限比较判别法<br><img src="极限比较判别法.png" alt="极限比较判别法.png">   </p></li><li><p>p判别法<br><img src="p值判断法.png" alt="p值判断法.png">  </p></li><li><p>绝对收敛判别法<br><img src="绝对收敛判别法.png" alt="绝对收敛判别法.png">  </p></li></ul><h2 id="特有的方法"><a href="#特有的方法" class="headerlink" title="特有的方法"></a>特有的方法</h2><p>以上是从反常积分继承来的判别法，以下是级数特有的判别法，包括：比式判别法、根式判别法、积分判别法和交错级数判别法<br>比式判别法与根式判别法不之间判断源数列，而是构建一个新的数列，通过判断新数列的收敛性来判断级数的收敛性  </p><ul><li><p>比式判别法</p><p>构建一个新的数列b<sub>n</sub>，定义其为数列相邻两项之的绝对值, 若b<sub>n</sub>收敛于一个小于1的数，则原级数收敛;大于1的数，则原级数发散;等于1，则不应该用比式判别法。  </p><p><img src="比式判别法.png" alt="比式判别法.png"></p></li><li><p>根式判别法  </p><p>根式判别式构建的新数列为第n项绝对值的n次方根，若b<sub>n</sub>收敛于一个小于1的数，则原级数收敛;大于1的数，则原级数发散;等于1，则不应该用根式判别法。  </p><p><img src="根式判别法.png" alt="根式判别法.png"></p></li><li><p>积分判别法  </p><p><img src="积分判别法.png" alt="积分判别法.png">  </p><p>若函数的f(x)的积分<img src="积分判别法-2.png" alt="积分判别法-2.png">收敛，则对应级数也收敛  </p></li><li><p>交错级数判别法  </p><p>若级数是交错的，且各项的绝对值递减趋于0,则级数收敛<br>这里引出一个条件收敛的概念，若一个级数收敛二其绝对值发散，就称为条件收敛<br>示例：  <img src="交错级数.png" alt="交错级数.png">  </p></li></ul><h2 id="使用总结"><a href="#使用总结" class="headerlink" title="使用总结"></a>使用总结</h2><p><img src="判断法使用总结.png" alt="判断法使用总结.png">  </p><p>特有方法的使用优先级高于继承方法的优先级  </p><h1 id="泰勒级数与幂级数"><a href="#泰勒级数与幂级数" class="headerlink" title="泰勒级数与幂级数"></a>泰勒级数与幂级数</h1><h2 id="泰勒定理"><a href="#泰勒定理" class="headerlink" title="泰勒定理"></a>泰勒定理</h2><p><img src="泰勒近似定理.png" alt="泰勒近似定理.png">  </p><p><img src="泰勒定理.png" alt="泰勒定理.png">  </p><p>若想证明一个函数在某些x处等于它的泰勒级数，需要证明当N → ∞ 时 R<sub>N</sub>(x) → 0.<br><img src="一个极限.png" alt="一个极限.png"> 对所有x都成立。  </p><h2 id="幂级数与泰勒级数"><a href="#幂级数与泰勒级数" class="headerlink" title="幂级数与泰勒级数"></a>幂级数与泰勒级数</h2><p>幂级数是以a<sub>0</sub>+a<sub>1</sub>x + a<sub>2</sub>x<sup>2</sup> + a<sub>3</sub>x<sup>3</sup> + a<sub>4</sub>x<sup>4</sup> + …<br>也可以写成![幂级数一般形式.png])<br>在x=a处的幂级数：<img src="幂级数形式.png" alt="幂级数形式.png">  </p><p>从这个形式处，可以看出泰勒级数是一种特殊的幂级数: <img src="幂级数与泰勒级数.png" alt="幂级数与泰勒级数.png">  </p><p>这里有一个麦克劳林级数，它是泰勒级数的在x=0处的特例：<img src="麦克劳林级数.png" alt="麦克劳林级数.png">  </p><h1 id="求解估值问题"><a href="#求解估值问题" class="headerlink" title="求解估值问题"></a>求解估值问题</h1><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>用二阶泰勒多项式估算e<sup>1/3</sup>，并估算误差  </p><table><thead><tr><th>n</th><th>f<sup>(n)</sup>(x)</th><th>f<sup>(n)</sup>(0)</th></tr></thead><tbody><tr><td>0</td><td>e<sup>x</sup></td><td>1</td></tr><tr><td>1</td><td>e<sup>x</sup></td><td>1</td></tr><tr><td>2</td><td>e<sup>x</sup></td><td>1</td></tr><tr><td>3</td><td>e<sup>x</sup></td><td>1</td></tr></tbody></table><p><img src="估值示例1-1.png" alt="估值示例1-1.png"><br><img src="估值示例1-2.png" alt="估值示例1-2.png"><br><img src="估值示例1-3.png" alt="估值示例1-3.png">  </p><p><img src="估值示例1-4.png" alt="估值示例1-4.png"><br><img src="估值示例1-5.png" alt="估值示例1-5.png"></p><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>估算sqart(27)，误差不大于1/250    </p><p><img src="估值示例2-1.png" alt="估值示例2-1.png"><br><img src="估值示例2-2.png" alt="估值示例2-2.png"><br>求得N = 1即可。P<sub>1</sub>(27) = 5 + 1/10 *(27-25) = 26/5</p><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><p>用三阶泰勒级数估算 cos(π/3 − 0.01) 的值 ,<br><img src="估值示例3-1.png" alt="估值示例3-1.png"><br><img src="估值示例3-2.png" alt="估值示例3-2.png"><br>求得N=3<br><img src="估值示例3-3.png" alt="估值示例3-3.png">  </p><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><h2 id="幂级数收敛半径与收敛区间"><a href="#幂级数收敛半径与收敛区间" class="headerlink" title="幂级数收敛半径与收敛区间"></a>幂级数收敛半径与收敛区间</h2><p>幂级数的收敛性判断，大多数时间使用比值判别法，有时可以使用根式判别法。<br><img src="幂级数收敛半径.png" alt="幂级数收敛半径.png"><br><img src="幂级数收敛半径-1.png" alt="幂级数收敛半径-1.png"><br><img src="幂级数收敛半径-2.png" alt="幂级数收敛半径-2.png"><br>当|x|&lt; 1 时绝对收敛，当|x| &gt; 1时绝对发散。<br>再考虑 x = 1 与 x = -1情况：<br>当x = 1 时<img src="幂级数收敛半径-3.png" alt="幂级数收敛半径-3.png">它发散<br>当x = -1时 <img src="幂级数收敛半径-4.png" alt="幂级数收敛半径-4.png">条件收敛  </p><h2 id="利用现有泰勒级数求其他泰勒级数"><a href="#利用现有泰勒级数求其他泰勒级数" class="headerlink" title="利用现有泰勒级数求其他泰勒级数"></a>利用现有泰勒级数求其他泰勒级数</h2><p><img src="麦克劳林级数1.png" alt="麦克劳林级数1.png"><br><img src="麦克劳林级数2.png" alt="麦克劳林级数2.png">  </p><p>可以通过换元、求导、求积分的方式求其他级数  </p><ul><li><p>换元<br><img src="麦克劳林级数-换元.png" alt="麦克劳林级数-换元.png">  </p><p><img src="麦克劳林级数-换元2.png" alt="麦克劳林级数-换元2.png"><br><img src="麦克劳林级数-换元2-2.png" alt="麦克劳林级数-换元2-2.png">  </p></li><li><p>求导<br><img src="麦克劳林级数-求导.png" alt="麦克劳林级数-求导.png">  </p></li><li><p>求积分<br><img src="麦克劳林级数-求积分.png" alt="麦克劳林级数-求积分.png">  </p></li></ul><h2 id="利用麦克劳林求极限"><a href="#利用麦克劳林求极限" class="headerlink" title="利用麦克劳林求极限"></a>利用麦克劳林求极限</h2><p>利用麦克劳林级数求极限时，将所有的函数，换算成多项式，然后进行合并求解即可<br><img src="泰勒级数求极限.png" alt="泰勒级数求极限.png"><br><img src="泰勒级数求极限-2.png" alt="泰勒级数求极限-2.png"><br><img src="泰勒级数求极限-3.png" alt="泰勒级数求极限-3.png"><br><img src="泰勒级数求极限-4.png" alt="泰勒级数求极限-4.png"><br><img src="泰勒级数求极限-5.png" alt="泰勒级数求极限-5.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是微积分复习的第三篇，教材使用《普林斯顿微积分读本》，涵盖第22章-第26章的内容。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数与微分  &lt;/li&gt;
&lt;li&gt;积分      &lt;/li&gt;
&lt;li&gt;级数      &amp;lt;=&lt;/li&gt;
&lt;li&gt;其他&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;级数的进入是从数列开始的，首先是数列的收敛性，然后是级数的收敛性，然后过度到泰勒级数，最后是对泰勒级数的应用（估值问题）。&lt;br&gt;级数是积分概念在离散数列的延伸，正向理解，是对离散数据的求和，反向理解，是对函数的分解。就分解而言，在工程领域得到了充分的应用。&lt;/p&gt;
    
    </summary>
    
      <category term="理论" scheme="http://yoursite.com/categories/%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="微积分" scheme="http://yoursite.com/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>微积分-积分</title>
    <link href="http://yoursite.com/2019/09/06/%E5%BE%AE%E7%A7%AF%E5%88%86-%E7%A7%AF%E5%88%86/"/>
    <id>http://yoursite.com/2019/09/06/微积分-积分/</id>
    <published>2019-09-06T13:36:30.000Z</published>
    <updated>2019-10-18T00:59:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是微积分复习的第二篇，教材使用《普林斯顿微积分读本》，涵盖第15章-第21章的内容。  </p><ul><li>函数与微分  </li><li>积分       &lt;=</li><li>级数</li><li>其他</li></ul><a id="more"></a><h1 id="积分定义"><a href="#积分定义" class="headerlink" title="积分定义"></a>积分定义</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>积分是从级数求和引入的，比如第一例子：<br><img src="级数求和.png" alt="级数求和.png"><br>这种引入方式即暗示积分的求（有向）面积，求位移做铺垫，也为后边级数做准备。</p><h2 id="伸缩级数"><a href="#伸缩级数" class="headerlink" title="伸缩级数"></a>伸缩级数</h2><p>比较有趣的一个例子:<br><img src="伸缩级数.png" alt="伸缩级数.png"><br>书中用伸缩级数的方法，推导出了平方和级数的和公式：<br><img src="伸缩级数推动-1.png" alt="伸缩级数推动-1.png"><br>将等式左侧整理后得到<br><img src="伸缩级数推动-2.png" alt="伸缩级数推动-2.png"><br><img src="伸缩级数推动-3.png" alt="伸缩级数推动-3.png">  </p><h2 id="有向面积"><a href="#有向面积" class="headerlink" title="有向面积"></a>有向面积</h2><p>这一段主要从直观上看级数到积分的一个过度<br><img src="有向面积.png" alt="有向面积.png"><br><img src="有向面积-2.png" alt="有向面积-2.png">  </p><h1 id="定积分"><a href="#定积分" class="headerlink" title="定积分"></a>定积分</h1><h2 id="定积分定义（黎曼和）"><a href="#定积分定义（黎曼和）" class="headerlink" title="定积分定义（黎曼和）"></a>定积分定义（黎曼和）</h2><p>定积分是一种定义，是一种求某段[a,b]曲线y=f(x)，与X轴形成闭合图形的面积。可以看出，定积分面向的是一个具体的问题，然后再次抽象之后才出现了不定积分。  </p><p>这个图形面积的求法，就需要借鉴上一节有向面积。将上一节的公式区间长度趋向于0,就是这个图像的面积，也就是积分。<br><img src="黎曼和.png" alt="黎曼和.png"><br>上一节的求和部分，也别称作黎曼和。<br>积分的定义也离不开极限。这里发散一下，这个叫黎曼和，也就与黎曼有关，而黎曼是19世纪人物，微积分是17世纪创立的，也就是这个定义，是很久之后才确定的。</p><h2 id="定积分性质"><a href="#定积分性质" class="headerlink" title="定积分性质"></a>定积分性质</h2><p>有了定义，就有了几个简单的性质：  </p><ol><li><img src="定积分性质-1.png" alt="定积分性质-1.png">  </li><li><img src="定积分性质-2.png" alt="定积分性质-2.png"></li><li><img src="定积分性质-3.png" alt="定积分性质-3.png"></li><li><img src="定积分性质-4.png" alt="定积分性质-4.png"></li><li><img src="定积分性质-5.png" alt="定积分性质-5.png"></li></ol><p>对这几个性质只说一点：在矩阵中，我们说线性变换符合两个公式：<br>T(v+w) = T(v) + T(w); T(cv) = cT(v)。如果把f(x)看作v，g(x)看作w，那积分就可以看作成一种线性变换了。  </p><h2 id="估算积分"><a href="#估算积分" class="headerlink" title="估算积分"></a>估算积分</h2><p>积分既然可以看作成一种面积，面积就有大小之分<br><img src="积分的简单估算.png" alt="积分的简单估算.png"><br>这样就看出，积分是在[m(b-a), M(b-a)]之间</p><h2 id="积分中值定理"><a href="#积分中值定理" class="headerlink" title="积分中值定理"></a>积分中值定理</h2><p>有了最大值与最小值，也就想到平均值。<br><img src="积分中值定理.png" alt="积分中值定理.png"><br><img src="积分中值定理2.png" alt="积分中值定理2.png"><br>f(c)就可以看作是f(x)在区间[a,b]上的平均值。  </p><h1 id="微积分基本定理"><a href="#微积分基本定理" class="headerlink" title="微积分基本定理"></a>微积分基本定理</h1><p>注意，这里说的是微积分基本定理，将积分与微分联合到一起的定理。主要有2个基本定理，一个阐述积分与微分之间的关系，从这里引出了不定积分，另一是积分函数与被积函数的关系，从而引出了不定积分的计算方法。</p><h2 id="第一基本定理"><a href="#第一基本定理" class="headerlink" title="第一基本定理"></a>第一基本定理</h2><p><img src="微积分第一基本定理.png" alt="微积分第一基本定理.png"><br>这里看出，微积分基本定理是与定积分相关的定理，也就是包含积分的上下限，以后的很多文章都是在上下限中做的。  </p><p>其证明源自:<br><img src="微积分第一定理的证明.png" alt="微积分第一定理的证明.png"><br><img src="微积分第一定理的证明2.png" alt="微积分第一定理的证明2.png">  </p><p>对比不定积分与导数：<br><img src="不定积分.png" alt="不定积分.png">  </p><h2 id="第二基本定理"><a href="#第二基本定理" class="headerlink" title="第二基本定理"></a>第二基本定理</h2><p><img src="微积分第二基本定理.png" alt="微积分第二基本定理.png"><br>微积分第二基本定理的证明书中没有画图，画图的话会很简单，就是阴影部分面积的减法运算。  </p><p>证明:<br><img src="微积分第二定理证明.png" alt="微积分第二定理证明.png"><br>函数到a部分的面积是F(a)，函数到b部分的面积是F(b)，那[a,b]之间的面积自然就是F(b)-F(a)了。</p><h2 id="积分上下限是函数"><a href="#积分上下限是函数" class="headerlink" title="积分上下限是函数"></a>积分上下限是函数</h2><p>积分上限是函数：  </p><p>这句话说全了是这样：求积分式的导数，如果积分上限是函数。解题时，其实是将上限设成另外一个变量，然后再隐函数求导。如：</p><p><img src="积分上限是函数.png" alt="积分上限是函数.png"><br><img src="积分上限是函数2.png" alt="积分上限是函数2.png"><br>这里需要注意，dy/du中积出的函数变量是u，后边要用x替换掉。  </p><p>积分下限是函数与上限是函数相同，做一个相反数即可转换成，这里不做介绍</p><ul><li>积分与导数公式  </li></ul><p><img src="积分公式.png" alt="积分公式.png"></p><h1 id="微积分基本方法1"><a href="#微积分基本方法1" class="headerlink" title="微积分基本方法1"></a>微积分基本方法1</h1><h2 id="换元法"><a href="#换元法" class="headerlink" title="换元法"></a>换元法</h2><ul><li><p>示例1</p><p><img src="换元法示例1-1.png" alt="换元法示例1-1.png"><br>这里设t = x<sup>3</sup>，将t导入得<br> (1/3)sin(x<sup>3</sup>) + C</p></li><li><p>示例2<br><img src="换元法示例2.png" alt="换元法示例2.png"><br>这里设t = x<sup>3</sup> + 7x - 9<br>从示例2看出的公式是这样：<br><img src="换元法公式1.png" alt="换元法公式1.png">  </p></li><li><p>示例3<br><img src="换元法示例3.png" alt="换元法示例3.png">  </p></li><li><p>示例4<br><img src="换元法示例4.png" alt="换元法示例4.png"><br> 这里的t = e<sup>x</sup>  </p></li><li><p>示例5<br> <img src="换元法示例5-1.png" alt="换元法示例5-1.png"><br> 这个与上边的例子有很大不同，这个需要一次函数的根式形式，需要将t设置成这个根式。<br> <img src="换元法示例5-2.png" alt="换元法示例5-2.png">  </p></li><li><p>理论解释<br><img src="换元法理论解释.png" alt="换元法理论解释.png"><br>这个解释其实只解释了前4个示例，第5个示例并不在此之列</p></li></ul><h2 id="分部积分法"><a href="#分部积分法" class="headerlink" title="分部积分法"></a>分部积分法</h2><ul><li><p>公式<br><img src="分部积分法公式.png" alt="分部积分法公式.png">  </p><p>分部积分法跟贝叶斯公式有点相似</p></li><li><p>示例1<br><img src="分部积分法示例1.png" alt="分部积分法示例1.png">  </p><p>多项式与指数函数</p></li><li><p>示例2<br><img src="分部积分法示例2.png" alt="分部积分法示例2.png"><br> 然后以相同德办法处理等式右边第二项</p><p>多项式与三角函数</p></li><li><p>示例3<br><img src="分部积分法示例3.png" alt="分部积分法示例3.png"><br> 利用三角函数两次求解后便会原值的特点</p><p>三角函数与指数函数  </p></li><li><p>示例4<br>以上三种都是两种基本初等函数的组合方式，e<sup>x</sup> &gt; sin(x) &gt; x 这种顺序<br>以下这些则反之，可以认为它们比 x 还小  </p><p><img src="分部积分法示例4-1.png" alt="分部积分法示例4-1.png"><br><img src="分部积分法示例4-2.png" alt="分部积分法示例4-2.png">  </p></li></ul><h2 id="部分积分法"><a href="#部分积分法" class="headerlink" title="部分积分法"></a>部分积分法</h2><p>部分积分法是处理，有理函数(两个多项式函数的比值)的方法. 通过一些代数运算把它分解成几个更简单的有理函数和的形式, 然后再对真写简单的有理函数求积分.  </p><ul><li><p>步骤  </p><ol><li>要确保分母的次幂大于分子的次幂,否则,通过除法方式,转换成此形式</li><li>对分母做因式分解<br>对于二次函数,查看判别式,若大于0,则可以因式分解</li><li><p>分部<br>分部是将因式分解之后的乘积形式,变成和形式的过程<br><img src="分部积分法1.png" alt="分部积分法1.png"><br><img src="分部积分法2.png" alt="分部积分法2.png"><br>这有些像基向量的样子,在每个基向量的常数倍.</p></li><li><p>计算常量的值</p></li><li>求解分母为线性项次幂的积分</li><li>对分母是二次函数的被积函数求积分</li></ol></li><li><p>示例1:<br><img src="分部积分法3.png" alt="分部积分法3.png">  </p></li><li><p>示例2:<br><img src="部分积分法示例2.png" alt="部分积分法示例2.png"></p></li><li><p>示例3:<br><img src="部分积分法示例3.png" alt="部分积分法示例3.png"><br>再次将进行分部,第一部分用换元法, 第二部分借用<img src="部分积分公式.png" alt="部分积分公式.png">来计算<br><img src="部分积分法示例3-2.png" alt="部分积分法示例3-2.png">  </p></li></ul><h1 id="微积分基本方法2"><a href="#微积分基本方法2" class="headerlink" title="微积分基本方法2"></a>微积分基本方法2</h1><h2 id="三角恒等式的积分"><a href="#三角恒等式的积分" class="headerlink" title="三角恒等式的积分"></a>三角恒等式的积分</h2><p>通过几个三角恒等式进行变化,将不易求的积分转变成易求的积分.恒等式包括:</p><ol><li>倍角公式: <img src="倍角公式.png" alt="倍角公式.png">  </li><li>毕达哥拉斯恒等式: <img src="毕达哥拉斯恒等式.png" alt="毕达哥拉斯恒等式.png">  </li><li>和差公式: <img src="和差公式.png" alt="和差公式.png">  </li></ol><p>这一部分的示例太多了,而且没有统一的解法,只做几个示例:  </p><ul><li><p>示例1<br><img src="三角恒等式示例1-1.png" alt="三角恒等式示例1-1.png"><br>给sec(x)上次幂,转换成2次进行<br><img src="三角恒等式示例1-2.png" alt="三角恒等式示例1-2.png"><br><img src="三角恒等式示例1-3.png" alt="三角恒等式示例1-3.png">  </p></li><li><p>示例2<br><img src="三角恒等式示例2.png" alt="三角恒等式示例2.png">  </p></li></ul><h2 id="三角函数的幂积分"><a href="#三角函数的幂积分" class="headerlink" title="三角函数的幂积分"></a>三角函数的幂积分</h2><p>三角函数的幂积分,很繁琐.不同的三角函数,技巧不相同.</p><ul><li><p>sinx或者cosx<br>如果是奇数次幂,则可以将一个奇数取出,转变积分<br>如果是偶数次幂,则使用倍角公式,将次幂转变成倍角</p></li><li><p>tan(x)<br>1次幂的tan(x),转换成sinx / cosx 的形式来计算<br>偶次幂的tan(x)求导很有趣,使用tan(x)与secx之间的关系,能不断的降幂,每次将2幂来完成</p></li><li><p>sec(x)<br>1次幂的secx求导很有技巧,(sec(x) + tan(x))/(sex(x) + tan(x))相乘之后,一下便可求出<br>偶次幂的sec(x),与偶次幂的tan(x)求法类似,但更复杂一些,不管的降幂,直到求出.</p></li><li><p>其他<br>cot(x) 同 tan(x), csc(x) 同 sec(x)</p></li><li><p>示例1<br><img src="三角函数幂积分示例1.png" alt="三角函数幂积分示例1.png"><br>将cos(x),转变成sin(x),然后将单独的cosx 放进积分中即可.</p></li><li><p>示例2<br><img src="三角函数幂积分示例2.png" alt="三角函数幂积分示例2.png"><br>将等式右侧展看,多变成多项式形式,偶次幂继续升角,奇次幂利用换元法求解</p></li><li><p>示例3<br><img src="tanx的积分.png" alt="tanx的积分.png">  </p></li><li><p>示例4<br><img src="tanx的2次幂积分.png" alt="tanx的2次幂积分.png">  </p></li><li><p>示例5<br><img src="tanx的4次幂积分.png" alt="tanx的4次幂积分.png">  </p></li><li><p>示例6<br><img src="secx的积分.png" alt="secx的积分.png"><br>sec(x)的二次幂积分为tan(x)+c  </p></li><li><p>示例7<br><img src="secx的6次幂积分1.png" alt="secx的6次幂积分1.png"><br><img src="secx的6次幂积分2.png" alt="secx的6次幂积分2.png"><br><img src="secx的6次幂积分3.png" alt="secx的6次幂积分3.png"><br>这里采用了分部积分法,并且只用来降成4次幂. 4次幂的过程仍然要继续采用此方法.  </p></li><li><p>总结  </p></li></ul><p>tan(x)与sex(x)的偶次幂,都是采用了类似数学归纳法的方式,不断降维来求解</p><h2 id="三角换元法"><a href="#三角换元法" class="headerlink" title="三角换元法"></a>三角换元法</h2><p>三角换元法不再求解的是三角函数,而是利用三角函数的特点来求解根式的积分.  </p><p><img src="三角换元法.png" alt="三角换元法.png"><br>进行换元之后,脱离根式,然后进行求解.  </p><ul><li><p>示例1<br><img src="三角换元法示例1.png" alt="三角换元法示例1.png"><br>用x = 3sin(θ)来进行换元<br><img src="三角换元法示例2.png" alt="三角换元法示例2.png">  </p></li><li><p>示例2<br><img src="三角换元法示例3.png" alt="三角换元法示例3.png"><br><img src="三角换元法示例3-1.png" alt="三角换元法示例3-1.png">  </p></li></ul><h1 id="反常积分"><a href="#反常积分" class="headerlink" title="反常积分"></a>反常积分</h1><p>反常积分要么在函数定义域内存在垂直渐进线,要么区间趋向无穷的定积分.这两种积分都涉及用极限来求积分的基本方法.在这种基本方法之上,演化出了常用的3中通用判别方法:比较判别法,极限比较判别法,p判别法,一种不太通用的判别法:绝对值判别法.这些判别法用于判断反常积分是否存在,或者称收敛.<br>原文中以2章的在讲述反常积分,其中,一章讲理论,一章讲示例.这里仅用一章将理论,不在积分花费更多的时间了.  </p><h2 id="2个定义"><a href="#2个定义" class="headerlink" title="2个定义"></a>2个定义</h2><p><img src="反常积分定义1.png" alt="反常积分定义1.png"><br>这是在下界的定义,在上界的定义同理  </p><p><img src="反常积分定义2.png" alt="反常积分定义2.png"><br>区间无穷的定义</p><h2 id="比较判别法"><a href="#比较判别法" class="headerlink" title="比较判别法"></a>比较判别法</h2><p>比较判别法可以从积分的面积定义上找到源头.  </p><p><img src="比较判别法表达式.png" alt="比较判别法表达式.png"><br><img src="比较判别法图像.png" alt="比较判别法图像.png"><br>如图,如果g(x)在区间[a,b]上收敛,则f(x)也一定收敛. 反命题不成立<br>逆反命题是如果f(x)在区间[a,b]上发散,则g(x)也一定发散.  </p><h2 id="极限比较判别法"><a href="#极限比较判别法" class="headerlink" title="极限比较判别法"></a>极限比较判别法</h2><p><img src="极限比较判别法.png" alt="极限比较判别法.png"><br>这个有同样的意义应该理解为:有相同的收敛性. 同收敛,共发散.</p><p>如: 在x -&gt; 0时, tan(x) ~ x, sin(x) ~ x, e<sup>x</sup>-1 ~x</p><h2 id="p判别法"><a href="#p判别法" class="headerlink" title="p判别法"></a>p判别法</h2><p>p判别法,应该是最接近运用的判别法<br><img src="p判别法.png" alt="p判别法.png"><br><img src="p判别法图像.png" alt="p判别法图像.png">  </p><p>记忆的方法是,与y=x相比, 更接近x轴霍y轴的收敛,反之发散</p><h2 id="绝对值判别法"><a href="#绝对值判别法" class="headerlink" title="绝对值判别法"></a>绝对值判别法</h2><p><img src="绝对收敛判别法.png" alt="绝对收敛判别法.png"><br>其他的判别法即可判别发散,也可以判别收敛.绝对值判别法,只能用来判别收敛.<br>在应用上,比较适合使用在sin(x)的判别上,即sin(x) &lt;= |sin(x)| &lt;= 1</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是微积分复习的第二篇，教材使用《普林斯顿微积分读本》，涵盖第15章-第21章的内容。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数与微分  &lt;/li&gt;
&lt;li&gt;积分       &amp;lt;=&lt;/li&gt;
&lt;li&gt;级数&lt;/li&gt;
&lt;li&gt;其他&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="理论" scheme="http://yoursite.com/categories/%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="微积分" scheme="http://yoursite.com/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>微积分-函数与微分</title>
    <link href="http://yoursite.com/2019/08/08/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%87%BD%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/"/>
    <id>http://yoursite.com/2019/08/08/微积分-函数与微分/</id>
    <published>2019-08-08T13:11:43.000Z</published>
    <updated>2019-08-20T06:44:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是微积分复习的第一篇，教材使用《普林斯顿微积分读本》，涵盖第1章-第14章的内容。 </p><ul><li>函数与微分  &lt;=</li><li>积分</li><li>级数</li><li>其他</li></ul><a id="more"></a><h1 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>函数是将一个对象转化成另外一个对象的规则。起始的对象称为输入，来自称为定义域的集合。返回的对象称为输出，来自称为值域的集合。<br>一个函数必须给每一有效的输入制定唯一的输出。</p><h2 id="定义域"><a href="#定义域" class="headerlink" title="定义域"></a>定义域</h2><p>定义据包括实数集尽可能多的部分，几种常见的情况：</p><ol><li>分母不能为0</li><li>不能取一个负数的平方根</li><li>不能取一个负数或0的对数</li></ol><h2 id="反函数"><a href="#反函数" class="headerlink" title="反函数"></a>反函数</h2><p>数据中有很多对称，例如有了函数就有反函数。<br>给定一个实数 y, 那么在 f 定义域中的哪个x满足 f(x) = y ？<br>变换 f<sup>-1</sup> 就像是 f 的撤销按钮: 如果你从 x 出发,并通过函数 f 将它变换为 y, 那么你可以通过在 y 上的反函数 f<sup>-1</sup> 来撤销这个变换的效果,取回 x<br><img src="反函数图像.png" alt="反函数图像"><br>图像关于y=x对称</p><h2 id="奇偶性"><a href="#奇偶性" class="headerlink" title="奇偶性"></a>奇偶性</h2><p>偶函数：f(x) = f(-x)，图像关于y轴具有镜面对称性。<br>奇函数：f(x) = -f(-x)， 图像关于原点有对称性。</p><h2 id="常见函数的图像"><a href="#常见函数的图像" class="headerlink" title="常见函数的图像"></a>常见函数的图像</h2><ul><li><p>多项式  p(x) = a<sub>n</sub>x<sup>n</sup> + a<sub>n-1</sub>x<sup>n-1</sup> + a<sub>1</sub>x<sup>1</sup> + a<sub>0</sub></p><p><img src="多项式函数图像.png" alt="多项式函数图像"><br>一般多项式函数图像很难画，但其左右两段的走势倒是很容易判断。主要是由首项系数决定的。  </p><p><img src="多项式函数走向.png" alt="多项式函数走向"></p></li><li><p>有理函数  p(x) / q(x)<br><img src="有理函数图像.png" alt="有理函数图像"></p></li><li><p>指数函数图像<br><img src="指数函数图像.png" alt="指数函数图像">  </p></li><li><p>对数函数图像<br><img src="对数函数图像.png" alt="对数函数图像">  </p></li><li><p>其他<br>绝对值函数，正值不变，负值关于x周对称<br>开方函数，将多项式关于镜像对称  </p></li></ul><h1 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h1><h2 id="x-a处的极限"><a href="#x-a处的极限" class="headerlink" title="x=a处的极限"></a>x=a处的极限</h2><p>从函数图像上，从左侧往右接近a时，就得到左极限; 反之从右往左接近是，就得到右极限。<br>当左极限等于右极限时，就称为双侧极限; 极限一般是指的双侧极限  </p><p>f(x)在x = a处有一条垂直渐进线，则在a处的左极限和右极限，至少有一个是∞或−∞。</p><p>左右极限不存在的例子：f(x) = sin(1/x)，在x=0,不存在左右极限。</p><p><img src="左右极限不存在.png" alt="左右极限不存在"></p><h2 id="在∞与-∞处的极限"><a href="#在∞与-∞处的极限" class="headerlink" title="在∞与-∞处的极限"></a>在∞与-∞处的极限</h2><p>当x-&gt;∞ f(x)有固定值，则函数有水平渐进线。</p><p><img src="导数与sin的结合.png" alt="导数与sin的结合"></p><p>函数与其渐进线可能会相交。</p><h2 id="三明治定理"><a href="#三明治定理" class="headerlink" title="三明治定理"></a>三明治定理</h2><p><img src="三明治定理.png" alt="三明治定理"><br><img src="三明治定理示例.png" alt="三明治定理示例"></p><h2 id="求解多项式的极限问题"><a href="#求解多项式的极限问题" class="headerlink" title="求解多项式的极限问题"></a>求解多项式的极限问题</h2><ul><li>x-&gt; a 有理函数,有理函数求解注意通分</li><li>x-&gt; a 平方根函数，注意乘共轭表达式</li><li>x-&gt; ∞ 有理函数，取决于首项及其系数</li><li>x-&gt; -∞ 时，若有函数需要开方时，注意取负数</li></ul><h1 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h1><p>连续性, 直观上,连续函数的图像必须能一笔画成;<br>可导性, 直观上,在可导函数的图像中不会出现尖角。</p><h2 id="连续性"><a href="#连续性" class="headerlink" title="连续性"></a>连续性</h2><ul><li><p>定义<br>如果在x=a处的极限 = f(x), 则在x=a处连续。<br>这个定义中包括：在x=a处有双侧极限，并且在x=a处有定义，或者f(a)存在，他们相等。</p></li><li><p>区间连续定义<br>f(x)在[a,b]区间上连续，在区间每一点都连续，且两个端点的单侧极限存在。</p></li><li><p>介值定理<br>如果f(x) 在[a,b]上连续，并且f(a)f(b)&lt;0，则在区间(a,b)上至少有一点c，使得f(c) = 0存在。</p></li><li><p>最值定理<br>如果f(x) 在[a,b]上连续，则在[a,b]上至少有一个最大值和一个最小值。</p></li></ul><h2 id="可导性"><a href="#可导性" class="headerlink" title="可导性"></a>可导性</h2><ul><li><p>定义<br><img src="可导性-切线斜率.png" alt="可导性-切线斜率.png">  </p><p><img src="可导性-表达式.png" alt="可导性-表达式.png"></p><p><img src="导数微分.png" alt="导数微分.png">.<br>后来有dx表示x中十分微笑的彪悍，dy表示y中十分微笑的变化。dy就是微分。</p></li><li><p>不存在导数的情况<br>双侧的导数不相同，直观上，就是有尖角。</p></li><li><p>如果一个函数f在x上可导，则它在x上连续。</p></li></ul><h2 id="求导法则"><a href="#求导法则" class="headerlink" title="求导法则"></a>求导法则</h2><ul><li><p>乘法法则<br><img src="求导-乘法法则.png" alt="求导-乘法法则.png"></p><p><img src="乘法法则的直观展示.png" alt="乘法法则的直观展示.png"><br>两个变量相乘直观的展示是图中矩形的面积，长与宽都是x的函数，当x有一个小变化∆x,时，面积S如何变化。<br>∆S = ∆(uv) = v∆u + u∆v + (∆u)(∆v)。 其中(∆u)(∆v)是更高阶的无穷小，可以忽略。</p></li><li><p>除法法则<br><img src="求导-商法则.png" alt="求导-商法则.png"></p></li><li><p>链式法则<br><img src="链式求导法则.png" alt="链式求导法则.png"><br>以 y=f(u) u=g(x) 为例：<br>∆y = f’(u)∆u<br>∆u = g’(x)∆x</p><p>代入 ∆y = f’(u)g’(x)∆x<br>由此  ∆y/∆x = f’(u)g’(x)</p></li><li><p>常见应用<br>几何：切线<br>物理：加速度<br>代数：导数伪装的极限  </p><p><img src="通过导数求极限-1.png" alt="通过导数求极限-1.png"></p></li></ul><h1 id="函数的导数"><a href="#函数的导数" class="headerlink" title="函数的导数"></a>函数的导数</h1><h2 id="多项式函数"><a href="#多项式函数" class="headerlink" title="多项式函数"></a>多项式函数</h2><p><img src="多项式求导.png" alt="多项式求导.png"></p><h2 id="三角函数的极限与导数"><a href="#三角函数的极限与导数" class="headerlink" title="三角函数的极限与导数"></a>三角函数的极限与导数</h2><ul><li><p>极限<br><img src="sinx与x.png" alt="sinx与x.png">  </p><p><img src="sinx与x的极限.png" alt="sinx与x的极限.png"><br><img src="tanx的0极限.png" alt="tanx的0极限.png"></p><p>x可以换成其他函数代入与x<sup>2</sup> 、5x等</p><p><img src="x、sinx、tanx极限的直观解释.png" alt="x、sinx、tanx极限的直观解释.png"><br>扇形面积= x/2，内三角形面积= sin(x)/2, 外三角形面积= tan(x)/2， 当x趋近0时，它们相等。<br>变换：1 &gt; sin(x)/x &gt; cos(x)，利用三明治定理，可以得到结论。</p><p><img src="sinx除以x图像.png" alt="sinx除以x图像.png"><br><strong>小波函数</strong></p></li><li><p>导数  </p><p> sin’(x) = cos(x)<br> cos’(x) = -sin(x)  </p><p> tan’(x) = sec<sup>2</sup>(x)<br> cot’(x) = -csc<sup>2</sup>(x)  </p><p> sec’(x) = sec(x)tan(x)<br> csc’(x) = -csc(x)cot(x)</p><p> 记忆：正的导数都是正好，余的导数都是负数</p></li><li><p>一个有趣的函数</p><p>f(x) = x<sup>2</sup>sin(1/x)</p><p>根据求导公式，其在0处导数不存在</p><p><img src="导函数不连续.png" alt="导函数不连续.png"><br>这样改之后，用导数定义，发现其在0处f’(0) = 0，但它同样不连续。</p><p><img src="导函数不连续图像.png" alt="导函数不连续图像.png">  </p></li><li><p>小结<br>本节的sin(x)/x函数，是一个很漂亮的函数。貌似在小波中见过。<br>关于最后这个f(x) = x<sup>2</sup>sin(1/x)。导函数在0处存在，但却不连续。这种情况基本都出在sin(1/x)这种情况内，倒数使趋向无穷大变成了趋向无穷小。</p></li></ul><h2 id="指数函数与对数函数"><a href="#指数函数与对数函数" class="headerlink" title="指数函数与对数函数"></a>指数函数与对数函数</h2><ul><li><p>对数基础<br>log<sub>b</sub>(1) = 0  </p><p>log<sub>b</sub>(xy) = log<sub>b</sub>(x) + log<sub>b</sub>(y)<br>log是可以将乘法变成加法的运算。  </p><p>log<sub>b</sub>(x/y) = log<sub>b</sub>(x) - log<sub>b</sub>(y)  </p><p>log<sub>b</sub>(x<sup>y</sup>) = ylog<sub>b</sub>(x)<br>对数可以处理指数与对数都是函数的情况。  </p><p>log<sub>b</sub>(x) =   log<sub>c</sub>(x) /  log<sub>c</sub>(b)<br>这意味着，所有不同底数的对数，其实都互为常数倍。 log<sub>b</sub>(x) =  Klog<sub>c</sub>(x) K=1/log<sub>c</sub>(b)</p></li><li><p>e的定义<br>e一种由来，可以从计算复利而得来：当年利率一定，每年结算的的次数越多，最终的金额也就越多。当次数取向无穷时，其最终金额不会趋向无穷，而是一个常数。  </p><p><img src="e.png" alt="e.png"><br><img src="e2.png" alt="e2.png">  </p></li><li><p>导数<br>介绍e的定义，主要用于计算对数的导数。<br><img src="对数导数.png" alt="对数导数.png"><br><img src="自然对数导数.png" alt="自然对数导数.png">  </p><p>根据反函数求导<br><img src="指数函数导数.png" alt="指数函数导数.png"><br><img src="指数函数导数2.png" alt="指数函数导数2.png">  </p></li><li><p>极限<br><img src="指数与多项式极限.png" alt="指数与多项式极限.png"><br><img src="对数与多项式.png" alt="对数与多项式.png">  </p></li><li><p>取对数求导法<br>y = x<sup>sin(x)</sup><br>=&gt; ln(y) = sin(x)ln(x)<br>=&gt; <img src="取对求导-1.png" alt="取对求导-1.png"><br>=&gt; <img src="取对求导-2.png" alt="取对求导-2.png"><br>=&gt; <img src="取对求导-3.png" alt="取对求导-3.png">  </p></li><li><p>指数增长与指数衰减  </p><p><img src="微分方程.png" alt="微分方程.png"><br>y变化率取决于这个量的大小。当k是正数就是指数增长，负数就是指数衰减。  </p><p>指数增长就是指的： P(t) = P<sub>0</sub>e<sup>kt</sup><br>这时候, dP/dt = kP<br>常见例子是无限条件下，兔子的增长。  </p><p>指数衰减：P(t) = P<sub>0</sub>e<sup>-kt</sup><br>dP/dt = -kP<br>常见例子是放射性原子的衰减。</p></li><li><p>双曲函数<br>![双曲函数.png])(双曲函数.png)<br><img src="双曲函数图像.png" alt="双曲函数图像.png">  </p><p>双曲函数有些像三角函数：</p><ol><li>cosh<sup>2</sup> - sinh<sup>2</sup> = 1</li><li>d(sinh(x))/dx = cosh(x) 及 d(cosh(x))/dx = sinh(x)  </li></ol><p><a href="https://www.zhihu.com/question/21239693" target="_blank" rel="noopener">双曲函数产生</a>  </p></li><li><p>小结：<br>从对称性上，我们可以看到初等函数可以分成很多空间，多项式函数、三角函数、指对函数。他们在很多时候，都在自己空间内玩。比如求导运算，多项式求导之后还是多项式，三角函数求导也还是三角函数。但对数函数却打破了这种规律，它的求导变成了有理函数，这真有趣。  </p><p>另一个是e，从定义上，就可以看到e是多么神奇的一个数字。</p></li></ul><h2 id="隐函数导数"><a href="#隐函数导数" class="headerlink" title="隐函数导数"></a>隐函数导数</h2><p>隐函数求导，比较适合于求等式的导数。</p><ul><li><p>示例<br>x<sup>2</sup> + y<sup>2</sup> = 4  </p><p>2x + 2y dy/dx = 0<br>dy/dx = -x/y  </p></li></ul><p>等式求导，一般关注于特定点，在特定点时，可以将等式求导之后，立即代入点，然后整理。对于二阶导，要等到求导2次之后再代入。</p><p>应用场景：求某个时刻的变化率问题，思路：<br>1、列出等式<br>2、等式求导  </p><h2 id="反函数导数"><a href="#反函数导数" class="headerlink" title="反函数导数"></a>反函数导数</h2><ul><li><p>导数与反函数存在<br>在区间内单调则反函数存在，单调意味着: f’(x)&gt;=0,或者f’(x)&lt;=0,且等于0的点有限。</p></li><li><p>公式<br><img src="反函数求导.png" alt="反函数求导.png"><br><img src="反函数求导-2.png" alt="反函数求导-2.png"><br> 把反函数表示出来，然后再代入原函数的导数，并求其倒数</p></li><li><p>示例<br>h(x) = x<sup>3</sup><br>h’(x) = 3x<sup>2</sup><br>反函数： y=x <sup>1/3</sup>  </p><p>代入可得反函数的导数 1/(3x<sup>2/3</sup>) </p></li></ul><h1 id="导数与图像"><a href="#导数与图像" class="headerlink" title="导数与图像"></a>导数与图像</h1><ul><li><p>函数的极值<br>假设函数 f 定义在开区间 (a, b) 内,并且点 c 在 (a, b) 区间内.如果点 c 为函数的局部最大值或最小值,那么点 c 一定为该函数的临界点.也就是说,f’(c) = 0 或 f’(c) 不存在  </p><p>闭区间[a,b]的最值，求f’(x) = 0的点，再加两个端点进行比较。</p></li><li><p>罗尔定理<br>假设函数 f 在闭区间[a, b]内连续,在开区间(a, b)内可导.如果 f(a) = f(b），那么在开区间 (a, b) 内至少存在一点 c, 使得 f‘(c) = 0.</p><p>也就是一定有极值点。</p></li><li><p>中值定理<br>假设函数 f 在闭区间[a, b]内连续,在开区间(a, b)内可导,那么在开区间(a, b)内至少有一点 c 使得：<br><img src="中值定理.png" alt="中值定理.png"><br><img src="中值定理图像.png" alt="中值定理图像.png"><br>可以看出，罗尔定理是中值定理的特例。  </p></li><li><p>二阶导数  </p><p>二级导数&gt;0时，图像像是一个凹向上的，像是碗的一部分;二阶导书&lt;0时，图像是凹向下的，像是倒着的碗。<br>拐点：在c点两侧，二阶导符号相异，则为拐点。<br><img src="拐点图像.png" alt="拐点图像.png"><br>这个感激挺有趣，经常听房价拐点、经济拐点，感觉像是在说极值点。这里的拐点却不是。<br>拐点处f’’(c) = 0，但反过来并不成立，比如f(x) = x<sup>4</sup>  </p></li></ul><h1 id="导数的应用"><a href="#导数的应用" class="headerlink" title="导数的应用"></a>导数的应用</h1><p>最优化涉及找出各种可能情况中最好的一种；<br>线性化是一种对难以计算的量找出其估算值的有用技术</p><h2 id="最优化"><a href="#最优化" class="headerlink" title="最优化"></a>最优化</h2><ol><li>找到变量  </li><li>找出等式  </li><li>消元  </li><li>求最值，可能用到隐函数求导  </li></ol><p>书上给出3个实例，这里不多介绍了  </p><h2 id="线性化"><a href="#线性化" class="headerlink" title="线性化"></a>线性化</h2><p>线性化其实是用直线（一阶函数）来拟合原函数（曲线），以求解问题。<br>f(a+∆x) ≈ f(a) + f’(a)∆x.<br><img src="线性化图像.png" alt="线性化图像.png">  </p><p>微分： 其中量df = f’(a)∆x，称为f在 x=a 处的微分。<br>误差： r(x) = f(x) - L(x)<br>      r(x) = f‘’(c)(x − a)<sup>2</sup> , 其中 c 为在 x 和 a 之间的某个数  </p><p>示例：  </p><ol><li>估算 (6.01)<sup>2</sup><br>f’(x) = 2x<br>df = f’(a)∆x = f’(6)(0.01) = 12 × (0.01) = 0.12<br>(6.01)<sup>2</sup> ≈ 36.12</li></ol><h2 id="估算零点的牛顿法"><a href="#估算零点的牛顿法" class="headerlink" title="估算零点的牛顿法"></a>估算零点的牛顿法</h2><p>牛顿法求0值，是线性化的一个应用  </p><p>假设现在要解一个形为 f (x) = 0 的方程,但你死活都解不出来.所以你退而求其次,试着猜测该方程有一个解,并把它记为 a. </p><p><img src="牛顿法图像.png" alt="牛顿法图像.png"><br><img src="牛顿法.png" alt="牛顿法.png">  </p><p>失效的情况：  </p><ul><li><p>f‘(a) 的值接近于 0.<br> <img src="牛顿法失效-1.png" alt="牛顿法失效-1.png">  </p></li><li><p>近似可能越来越糟<br> f (x) = x<sup>1/3</sup>，唯一解是 0 ，<br> 代入公式：b = -2a，除非从0开始，否则越来越糟糕  </p></li><li><p>可能限于左右循环<br> <img src="牛顿法失效-3.png" alt="牛顿法失效-3.png">  </p></li></ul><h2 id="洛必答法则"><a href="#洛必答法则" class="headerlink" title="洛必答法则"></a>洛必答法则</h2><p>洛必答法则本身容易记住，重点是使用时的变形，要点是是对不定式使用<br>除法情况：<br><img src="洛必达法则-1.png" alt="洛必达法则-1.png">  </p><p>除法=乘法，只须将一种一个变成倒数即可  </p><p>减法情况，需要将减法进行通分，变成除法  </p><p>指数情况，需要进行取对数，将指数编程乘法</p><p>示例：<br><img src="洛必答法则示例-1.png" alt="洛必答法则示例-1.png"><br><img src="洛必答法则示例-2.png" alt="洛必答法则示例-2.png"><br><img src="洛必答法则示例-3.png" alt="洛必答法则示例-3.png"><br><img src="洛必答法则示例-4.png" alt="洛必答法则示例-4.png">  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是微积分复习的第一篇，教材使用《普林斯顿微积分读本》，涵盖第1章-第14章的内容。 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数与微分  &amp;lt;=&lt;/li&gt;
&lt;li&gt;积分&lt;/li&gt;
&lt;li&gt;级数&lt;/li&gt;
&lt;li&gt;其他&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="理论" scheme="http://yoursite.com/categories/%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="微积分" scheme="http://yoursite.com/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>typeorm使用总结</title>
    <link href="http://yoursite.com/2019/07/11/typeorm%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/07/11/typeorm使用总结/</id>
    <published>2019-07-11T14:23:08.000Z</published>
    <updated>2019-07-15T00:17:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>总结一下typeorm常用的使用方法  </p><a id="more"></a><h1 id="entity"><a href="#entity" class="headerlink" title="entity"></a>entity</h1><h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><p>typeorm中，每个entity必须有主键</p><ul><li><p>普通主键</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Entity()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">TunnelPart</span></span>&#123;</span><br><span class="line">  @PrimaryGeneratedColumn()</span><br><span class="line">  id: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>uuid主键  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Entity()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseFileEntity</span> </span>&#123;</span><br><span class="line">  @PrimaryGeneratedColumn(<span class="string">"uuid"</span>)</span><br><span class="line">  id: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的主键，就是uuid  </p></li><li><p>多列主键  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Entity()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">StructureTeam</span> </span>&#123;</span><br><span class="line">    @PrimaryColumn(&#123; <span class="attr">type</span>: <span class="string">'int'</span> &#125;)</span><br><span class="line">    teamId: number;</span><br><span class="line"></span><br><span class="line">    @PrimaryColumn(&#123; <span class="attr">type</span>: <span class="string">'int'</span> &#125;)</span><br><span class="line">    structureId: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，就形成了一个有多列形成的主键  </p></li></ul><h2 id="ManyToOne与oneToMany"><a href="#ManyToOne与oneToMany" class="headerlink" title="ManyToOne与oneToMany"></a>ManyToOne与oneToMany</h2><p>ManyToOne 与 oneToMany是最常用的关系，两者可同时使用，ManyToOne可以单独使用，基本操作，如：保存、查询、级联删除等，放到后边下边来写，这里只写关系的建立  </p><h2 id="只建立ManyToOne"><a href="#只建立ManyToOne" class="headerlink" title="只建立ManyToOne"></a>只建立ManyToOne</h2>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Entity()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">TunnelSection</span></span>&#123;</span><br><span class="line">    @PrimaryGeneratedColumn()</span><br><span class="line">    id: number;</span><br><span class="line"></span><br><span class="line">    @Column(<span class="string">'int'</span>)</span><br><span class="line">    length: number;</span><br><span class="line"></span><br><span class="line">    @ManyToOne(<span class="function"><span class="params">type</span>=&gt;</span>TunnelMethod)</span><br><span class="line">    method: TunnelMethod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在ManyToOne的创建中，只提用一个参数即可，这个参数是一个箭头函数，指向One所对应的表<br>  关系在建立的时候，可以指明一些参数，比如OnDetete,当用<code>CASCADE</code>时，可以用作级联删除。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@ManyToOne(<span class="function"><span class="params">type</span>=&gt;</span>TunnelMethod, &#123; <span class="attr">onDelete</span>: <span class="string">'CASCADE'</span> &#125;)</span><br><span class="line">    method: TunnelMethod;</span><br></pre></td></tr></table></figure><h2 id="同时建立ManyToOne-与-OneToMany"><a href="#同时建立ManyToOne-与-OneToMany" class="headerlink" title="同时建立ManyToOne 与 OneToMany"></a>同时建立ManyToOne 与 OneToMany</h2>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Entity()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">TunnelFixture</span></span>&#123;</span><br><span class="line">    @PrimaryGeneratedColumn()</span><br><span class="line">    id: number;</span><br><span class="line"></span><br><span class="line">    @Column(<span class="string">'varchar'</span>, &#123;<span class="attr">length</span>: <span class="number">128</span>&#125;)</span><br><span class="line">    name: string;</span><br><span class="line"></span><br><span class="line">    @OneToMany(<span class="function"><span class="params">type</span> =&gt;</span> TunnelProcedure, procedure =&gt; procedure.fixture)</span><br><span class="line">    procedures: TunnelProcedure[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Entity()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">TunnelProcedure</span></span>&#123;</span><br><span class="line">    @PrimaryGeneratedColumn()</span><br><span class="line">    id: number;</span><br><span class="line"></span><br><span class="line">    @Column(<span class="string">"varchar"</span>, &#123;<span class="attr">length</span>: <span class="number">128</span>&#125;)</span><br><span class="line">    name: string;</span><br><span class="line"></span><br><span class="line">    @ManyToOne(<span class="function"><span class="params">type</span> =&gt;</span> TunnelFixture, fixture =&gt; fixture.procedures)</span><br><span class="line">    fixture: TunnelFixture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在建立双向关系时，除了指明所在的entity，还要指明对方entity的属性</p><h1 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h1><h2 id="relation查询"><a href="#relation查询" class="headerlink" title="relation查询"></a>relation查询</h2><p>  创建ManyToOne与OneToMany的关系以后，可以通过repository来查询</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Entity()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Photo</span> </span>&#123;</span><br><span class="line">    @PrimaryGeneratedColumn()</span><br><span class="line">    id: number;</span><br><span class="line"></span><br><span class="line">    @Column()</span><br><span class="line">    url: string;</span><br><span class="line"></span><br><span class="line">    @ManyToOne(<span class="function"><span class="params">type</span> =&gt;</span> User, user =&gt; user.photos)</span><br><span class="line">    user: User;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Entity()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    @PrimaryGeneratedColumn()</span><br><span class="line">    id: number;</span><br><span class="line"></span><br><span class="line">    @Column()</span><br><span class="line">    name: string;</span><br><span class="line"></span><br><span class="line">    @OneToMany(<span class="function"><span class="params">type</span> =&gt;</span> Photo, photo =&gt; photo.user)</span><br><span class="line">    photos: Photo[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userRepository = connection.getRepository(User);</span><br><span class="line"><span class="keyword">const</span> users = <span class="keyword">await</span> userRepository.find(&#123; <span class="attr">relations</span>: [<span class="string">"photos"</span>] &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> photoRepository = connection.getRepository(Photo);</span><br><span class="line"><span class="keyword">const</span> photos = <span class="keyword">await</span> photoRepository.find(&#123; <span class="attr">relations</span>: [<span class="string">"user"</span>] &#125;);</span><br></pre></td></tr></table></figure><h2 id="也可以用createQueryBuilder形式"><a href="#也可以用createQueryBuilder形式" class="headerlink" title="也可以用createQueryBuilder形式"></a>也可以用createQueryBuilder形式</h2>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> users = <span class="keyword">await</span> connection</span><br><span class="line">  .getRepository(User)</span><br><span class="line">  .createQueryBuilder(<span class="string">"user"</span>)</span><br><span class="line">  .leftJoinAndSelect(<span class="string">"user.photos"</span>, <span class="string">"photo"</span>)</span><br><span class="line">  .getMany();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> photos = <span class="keyword">await</span> connection</span><br><span class="line">  .getRepository(Photo)</span><br><span class="line">  .createQueryBuilder(<span class="string">"photo"</span>)</span><br><span class="line">  .leftJoinAndSelect(<span class="string">"photo.user"</span>, <span class="string">"user"</span>)</span><br><span class="line">  .getMany();</span><br></pre></td></tr></table></figure><p>  一直觉得relations只在findOne中，可用，看了官网，发现都可以。<br>  有些情况下，都是自己创建id字段来连接另外一个表使用，这种情况下，只能使用createQueryBuilder，查询出来的是地卡尔乘积的结果，有些情况下，需要经过去重处理。<br>  这里要注意<code>leftJoinAndSelect</code>与<code>leftJoin</code>的区别。leftJoin不会查询出join表的字段</p><h2 id="Raw查询"><a href="#Raw查询" class="headerlink" title="Raw查询"></a>Raw查询</h2><p>  getRawMany()时，注意给列起别名，否则列名包括了表名。查询的数据不是entity时，采用raw方式查询。包括联表的自定义字段、SUM、COUNT等函数</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">async</span> getMaterialList(subprojId:number, type?:string):<span class="built_in">Promise</span>&lt;Material[]&gt;&#123;</span><br><span class="line">      <span class="keyword">let</span> param = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">      param.subprojId = subprojId;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> condition = <span class="string">"material.subprojId=:subprojId "</span></span><br><span class="line">      <span class="keyword">if</span>(!isNullOrUndefined(type))&#123;</span><br><span class="line">          param.type = type</span><br><span class="line">          condition += <span class="string">" and material.type=:type"</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.materialRepos.createQueryBuilder(<span class="string">"material"</span>)</span><br><span class="line">              .select(<span class="string">"material.id"</span>, <span class="string">"id"</span>)</span><br><span class="line">              .addSelect(<span class="string">"material.type"</span>, <span class="string">"type"</span>)</span><br><span class="line">              .addSelect(<span class="string">"material.name"</span>, <span class="string">"name"</span>)</span><br><span class="line">              .addSelect(<span class="string">"material.unit"</span>, <span class="string">"unit"</span>)</span><br><span class="line">              .addSelect(<span class="string">"material.metaQuantityId"</span>, <span class="string">"metaQuantityId"</span>)</span><br><span class="line">              .addSelect(<span class="string">"material.subprojId"</span>, <span class="string">"subprojId"</span>)</span><br><span class="line">              .addSelect(<span class="string">"material.createAt"</span>, <span class="string">"createAt"</span>)</span><br><span class="line">              .addSelect(<span class="string">'materialPrice.price'</span>, <span class="string">"price"</span>)</span><br><span class="line">              .leftJoin(<span class="string">"material.price"</span>, <span class="string">"materialPrice"</span>)</span><br><span class="line">              .where(condition, param)</span><br><span class="line">              .getRawMany();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  注意join都是迪卡尔积，会有重复。<br>  OneToOne关系比较适合，不会用重复</p><h1 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h1><h2 id="LessThan、MoreThan、Between"><a href="#LessThan、MoreThan、Between" class="headerlink" title="LessThan、MoreThan、Between"></a>LessThan、MoreThan、Between</h2><p>  这里在repository中查询时，使用了以上区间函数;<br>  同样可以使用createQueryBuilder的当时完成相同的操作。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">async</span> getMaterialPriceList(materialId:number, startDate?:string, endDate?:string)&#123;</span><br><span class="line">  <span class="keyword">let</span> condition = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  condition.materialId = materialId;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(startDate!=<span class="literal">null</span> &amp;&amp; endDate==<span class="literal">null</span>)&#123;</span><br><span class="line">      condition.createAt =  MoreThan(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.parse(startDate)));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(startDate==<span class="literal">null</span> &amp;&amp; endDate!=<span class="literal">null</span>)&#123;</span><br><span class="line">      condition.createAt =  LessThan(<span class="keyword">new</span> <span class="built_in">Date</span>(endDate));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(startDate!=<span class="literal">null</span> &amp;&amp; endDate!=<span class="literal">null</span>)&#123;</span><br><span class="line">      condition.createAt = Between(<span class="keyword">new</span> <span class="built_in">Date</span>(startDate), <span class="keyword">new</span> <span class="built_in">Date</span>(endDate));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.priceRepos.find(&#123;...condition&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用createQueryBuilder完成区间查询："><a href="#用createQueryBuilder完成区间查询：" class="headerlink" title="用createQueryBuilder完成区间查询："></a>用createQueryBuilder完成区间查询：</h2>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">async</span> getMaterialPriceList(materialId:number, startDate?:string, endDate?:string)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.priceRepos.createQueryBuilder(<span class="string">"materialPice"</span>)</span><br><span class="line">          .where(<span class="string">'materialPice.materialId = :materialId'</span>)</span><br><span class="line">          .andWhere(<span class="string">'materialPice.createAt &gt;= :startDate'</span>)</span><br><span class="line">          .andWhere(<span class="string">'materialPice.createAt &lt;= :endDate'</span>)</span><br><span class="line">          .setParameters(&#123;<span class="attr">materialId</span>:materialId, <span class="attr">startDate</span>:<span class="keyword">new</span> <span class="built_in">Date</span>(startDate),<span class="attr">endDate</span>:<span class="keyword">new</span> <span class="built_in">Date</span>(endDate)&#125;)</span><br><span class="line">          .getMany();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h1><p>同样是使用skip与take来完成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> users = <span class="keyword">await</span> getRepository(User)</span><br><span class="line">    .createQueryBuilder(<span class="string">"user"</span>)</span><br><span class="line">    .leftJoinAndSelect(<span class="string">"user.photos"</span>, <span class="string">"photo"</span>)</span><br><span class="line">    .skip(<span class="number">5</span>)</span><br><span class="line">    .take(<span class="number">10</span>)</span><br><span class="line">    .getMany();</span><br></pre></td></tr></table></figure><h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><p>子查询是两个查询的嵌套，通常发生在where与from中</p><h2 id="where中"><a href="#where中" class="headerlink" title="where中"></a>where中</h2>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> posts = <span class="keyword">await</span> connection.getRepository(Post)</span><br><span class="line">  .createQueryBuilder(<span class="string">"post"</span>)</span><br><span class="line">  .where(<span class="function"><span class="params">qb</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> subQuery = qb.subQuery()</span><br><span class="line">          .select(<span class="string">"user.name"</span>)</span><br><span class="line">          .from(User, <span class="string">"user"</span>)</span><br><span class="line">          .where(<span class="string">"user.registered = :registered"</span>)</span><br><span class="line">          .getQuery();</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"post.title IN "</span> + subQuery;</span><br><span class="line">  &#125;)</span><br><span class="line">  .setParameter(<span class="string">"registered"</span>, <span class="literal">true</span>)</span><br><span class="line">  .getMany();</span><br></pre></td></tr></table></figure><p>  或者写成</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userQb = <span class="keyword">await</span> connection.getRepository(User)</span><br><span class="line">  .createQueryBuilder(<span class="string">"user"</span>)</span><br><span class="line">  .select(<span class="string">"user.name"</span>)</span><br><span class="line">  .where(<span class="string">"user.registered = :registered"</span>, &#123; <span class="attr">registered</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> posts = <span class="keyword">await</span> connection.getRepository(Post)</span><br><span class="line">  .createQueryBuilder(<span class="string">"post"</span>)</span><br><span class="line">  .where(<span class="string">"post.title IN ("</span> + userQb.getQuery() + <span class="string">")"</span>)</span><br><span class="line">  .setParameters(userQb.getParameters())</span><br><span class="line">  .getMany();</span><br></pre></td></tr></table></figure><h2 id="from中"><a href="#from中" class="headerlink" title="from中"></a>from中</h2>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> posts = <span class="keyword">await</span> connection</span><br><span class="line">  .createQueryBuilder()</span><br><span class="line">  .select(<span class="string">"user.name"</span>, <span class="string">"name"</span>)</span><br><span class="line">  .from(<span class="function"><span class="params">subQuery</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> subQuery</span><br><span class="line">          .select(<span class="string">"user.name"</span>, <span class="string">"name"</span>)</span><br><span class="line">          .from(User, <span class="string">"user"</span>)</span><br><span class="line">          .where(<span class="string">"user.registered = :registered"</span>, &#123; <span class="attr">registered</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">  &#125;, <span class="string">"user"</span>)</span><br><span class="line">  .getRawMany();</span><br></pre></td></tr></table></figure><p>  from中的“user“是别名，或者写成</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userQb = <span class="keyword">await</span> connection.getRepository(User)</span><br><span class="line">  .createQueryBuilder(<span class="string">"user"</span>)</span><br><span class="line">  .select(<span class="string">"user.name"</span>, <span class="string">"name"</span>)</span><br><span class="line">  .where(<span class="string">"user.registered = :registered"</span>, &#123; <span class="attr">registered</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> posts = <span class="keyword">await</span> connection</span><br><span class="line">  .createQueryBuilder()</span><br><span class="line">  .select(<span class="string">"user.name"</span>, <span class="string">"name"</span>)</span><br><span class="line">  .from(<span class="string">"("</span> + userQb.getQuery() + <span class="string">")"</span>, <span class="string">"user"</span>)</span><br><span class="line">  .setParameters(userQb.getParameters())</span><br><span class="line">  .getRawMany();</span><br></pre></td></tr></table></figure><h1 id="全列查询"><a href="#全列查询" class="headerlink" title="全列查询"></a>全列查询</h1><p>全表查询指的是对全部字段进行模糊查询，网上找资料看到一些方式，通过引入插件，再用函数的方式来实现，这样的实现在typeorm中很难实现。  </p><ul><li><p>列少时，可以考虑多列的模糊</p><p><code>select * from t where phonenum=&#39;digoal&#39; or info ~ &#39;digoal&#39; or c1=&#39;digoal&#39;</code>  </p></li><li><p>将所有字段记录在1列中，从一列中查询</p></li><li><p>pgsql中使用::text<br><code>select * from structure where structure::text like %大河%</code></p></li></ul><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;getManager&#125; <span class="keyword">from</span> <span class="string">"typeorm"</span>;</span><br><span class="line"><span class="keyword">await</span> getManager().transaction(<span class="keyword">async</span> transactionalEntityManager =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> transactionalEntityManager.save(users);</span><br><span class="line">    <span class="keyword">await</span> transactionalEntityManager.save(photos);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>事物可以使用装饰器方式来书写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Transaction()</span><br><span class="line">save(@TransactionManager() manager: EntityManager, <span class="attr">user</span>: User) &#123;</span><br><span class="line">    <span class="keyword">return</span> manager.save(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Transaction()</span><br><span class="line">save(user: User, @TransactionRepository(User) userRepository: Repository&lt;User&gt;) &#123;</span><br><span class="line">    <span class="keyword">return</span> userRepository.save(user);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在事务中指明隔离级别</p><h1 id="migration"><a href="#migration" class="headerlink" title="migration"></a>migration</h1><ul><li>需要注意其ormconfig.json配置文件的书写</li><li>其原理是通过检测migration中的文件，来执行文件，并且在数据库中创建一个migrations的数据表，用来存储执行过的文件。在执行的时候，会对比文件夹中的文件与数据库执行过的文件，并选择new的进行执行。</li><li>这种方式需要看一个revert如果执行。</li><li>migration其实是一种命令模式。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结一下typeorm常用的使用方法  &lt;/p&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
      <category term="nest.js" scheme="http://yoursite.com/tags/nest-js/"/>
    
  </entry>
  
</feed>
