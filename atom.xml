<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>思 见</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-29T07:27:31.138Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>sun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>docker中pgsql数据的导入导出</title>
    <link href="http://yoursite.com/2019/01/10/docker%E4%B8%ADpgsql%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"/>
    <id>http://yoursite.com/2019/01/10/docker中pgsql数据的导入导出/</id>
    <published>2019-01-10T02:28:42.000Z</published>
    <updated>2019-01-29T07:27:31.138Z</updated>
    
    <content type="html"><![CDATA[<p> 测试环境中录入了一些数据，这些数据不想重复再在运行环境中录入，就想着通过导入导出的方式来解决。<br><a id="more"></a></p><h1 id="pgsql数据库、数据表的导出导入"><a href="#pgsql数据库、数据表的导出导入" class="headerlink" title="pgsql数据库、数据表的导出导入"></a>pgsql数据库、数据表的导出导入</h1>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">导出表：pg_dump -U root -d builder -t 表名 &gt; ~/表名.sql</span><br><span class="line">导出库：pg_dump -U root -d builder &gt; ~/库名.sql</span><br><span class="line">导 入：psql -d  builder  -f  ~/*.sql</span><br><span class="line"></span><br><span class="line">ps: -U: User </span><br><span class="line">    -d: database </span><br><span class="line">    -t: table </span><br><span class="line">    -f: file</span><br></pre></td></tr></table></figure><h1 id="docker中传输文件到运行机器"><a href="#docker中传输文件到运行机器" class="headerlink" title="docker中传输文件到运行机器"></a>docker中传输文件到运行机器</h1><p>  docker中安装scp<br>  <code>apt-get update</code><br>  <code>apt-get install openssh-client</code></p><p>  传输文件<br>  <code>scp 源文件 用户名@主机：路径</code><br>  <code>scp ~/表名.sql root@baidu.com:/home/root/</code></p><h1 id="运行机器将文件copy到docker中"><a href="#运行机器将文件copy到docker中" class="headerlink" title="运行机器将文件copy到docker中"></a>运行机器将文件copy到docker中</h1><p>  从主机copy文件到容器，在主机中执行：<br>  <code>docker cp /opt/test/file.txt mycontainer：/opt/testnew/</code></p><p>  从容器copy文件到主机：<br>  <code>docker cp mycontainer：/opt/testnew/file.txt /opt/test/</code></p><h1 id="docker中导入表"><a href="#docker中导入表" class="headerlink" title="docker中导入表"></a>docker中导入表</h1><p>  <code>psql -d  builder  -f  ~/*.sql</code></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p> <a href="https://blog.csdn.net/allen_oscar/article/details/9061573" target="_blank" rel="noopener">postgresql的导入、导出</a><br> <a href="https://blog.csdn.net/dongdong9223/article/details/71425077" target="_blank" rel="noopener">docker与主机的copy</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 测试环境中录入了一些数据，这些数据不想重复再在运行环境中录入，就想着通过导入导出的方式来解决。&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>ssh免密配置</title>
    <link href="http://yoursite.com/2019/01/09/ssh%E5%85%8D%E5%AF%86%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/01/09/ssh免密配置/</id>
    <published>2019-01-09T06:07:01.000Z</published>
    <updated>2019-01-29T07:27:20.626Z</updated>
    
    <content type="html"><![CDATA[<p> 本文是第一篇转到md写的文档，作为对问题的总结，也作为使用md语法的开始。<br> <a id="more"></a></p><h1 id="ssh简介"><a href="#ssh简介" class="headerlink" title="ssh简介"></a>ssh简介</h1><p> ssh(Secure Shell)是一种加密的网络传输协议，在网络中创建安全隧道来实现ssh客户端与服务器之间的连接。<br> 虽然任何网络服务都可以通过ssh实现安全传输，ssh最常见的用途是远程登录系统。在设计上ssh是Telnet和非安全shell的替代品，telnet等协议采用明文传输，不使用不可靠的密码，容易遭到监听、嗅探和中间人攻击。ssh旨在保护非安全网络环境中信息加密完整可靠。<br> ssh以非对称加密实现身份验证，人工生成一对公钥和私钥，通过生成的密钥进行认证，这样就可以在不输入密码的情况下登录。公钥需要放在待访问的计算机之中，而对应的私钥需要由用户自行保管。认证过程基于生成出来的私钥，但整个认证过程中私钥本身不会传输到网络中。<br> 核实未知密钥来源都是重要的事情，因为SSH只验证提供用户是否拥有与公钥相匹配的私钥，只要接受公钥而且密钥匹配服务器就会授予许可。这样的话，一旦接受了恶意攻击者的公钥，那么系统也会把攻击者视为合法用户。</p><h1 id="ssh原理"><a href="#ssh原理" class="headerlink" title="ssh原理"></a>ssh原理</h1><p> <a href="https://www.jianshu.com/p/33461b619d53" target="_blank" rel="noopener">图解SSH原理</a><br>  简单概述一下：原来是通过ssh user@host申请，然后server应答后，输入password，但这样会造成中间人攻击，就是代理截获了client与server之间的通信，伪装server骗取client的密码，然后对server进行攻击。<br>  于是有了公钥认证的过程，就是俗称的免密，其过程就是客户端生成一段密钥对，然后把公钥设置到服务器的authorized_keys中，这样client与server都各有一对密钥，同时握有对方的公钥，只要进行配对认证，就可以不再输入密码了。</p><h1 id="ssh免密配置"><a href="#ssh免密配置" class="headerlink" title="ssh免密配置"></a>ssh免密配置</h1><ul><li><p>client端生成密钥对<br>cd ~/.ssh<br>ssh-keygen -t rsa -C “名字” -f “名字_rsa”</p></li><li><p>放到server的~/.ssh/authorized_keys中<br>上传到服务器有好几种方式，可以手动打开粘帖进去，也可以在客户端使用命令：<br><code>ssh-copy-id -i 公钥 用户名@服务器</code></p></li><li><p>client配置~/.ssh/config</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host xw</span><br><span class="line">    HostName 47.98.197.178</span><br><span class="line">    User root</span><br><span class="line">    Port 22</span><br><span class="line">    PubKeyAuthentication yes</span><br><span class="line">    IdentityFile ~/.ssh/chenjing_rsa</span><br></pre></td></tr></table></figure></li></ul><ul><li>问题：<br> signing failed: agent refused operation问题：<br> 一般情况下设置完如上操作，就可以访问了，若出现：sign_and_send_pubkey: signing failed: agent refused operation，则需要在client端将key增加到agent，操作如下：<br> <code>ssh-add ~/.ssh/your-key-name</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 本文是第一篇转到md写的文档，作为对问题的总结，也作为使用md语法的开始。&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="ssh" scheme="http://yoursite.com/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>谷歌软件测试之道</title>
    <link href="http://yoursite.com/2019/01/01/%E8%B0%B7%E6%AD%8C%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B9%8B%E9%81%93/"/>
    <id>http://yoursite.com/2019/01/01/谷歌软件测试之道/</id>
    <published>2019-01-01T07:23:57.000Z</published>
    <updated>2019-01-29T07:29:24.783Z</updated>
    
    <content type="html"><![CDATA[<p> 测试是开发过程中必不可少的一部分，当开发过程和测试一起不分彼此之时，即是得到质量<br> 本博文是摘自《谷歌软件测试之道》，尚未看完，陆续更新中</p><a id="more"></a><h1 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h1><ul><li><p>SWE： software engineer<br>创建设计文档，选择最优的数据结构和整体架构，代码实现与代码审核。<br>需要编写测试代码，包括测试驱动的设计、单元测试、参与构建各种大小规模的测试等。</p></li><li><p>SET： software engineer in test<br>工作重心：可测性和通用测试基础框架上<br>参与设计评审，增加可测性。<br>编写单元测试框架和自动化测试框架。</p></li><li><p>TE： test engineer<br>把用户放在第一位来思考，代表用户的利益。有时会花费大量时间在模拟用户的使用场景和自动化脚本或代码的编写上，分析、解释、测试运行结果，驱动测试执行，构建端到端的自动化测试。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 测试是开发过程中必不可少的一部分，当开发过程和测试一起不分彼此之时，即是得到质量&lt;br&gt; 本博文是摘自《谷歌软件测试之道》，尚未看完，陆续更新中&lt;/p&gt;
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="测试" scheme="http://yoursite.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>linux内核导读</title>
    <link href="http://yoursite.com/2018/12/17/linux%E5%86%85%E6%A0%B8%E5%AF%BC%E8%AF%BB/"/>
    <id>http://yoursite.com/2018/12/17/linux内核导读/</id>
    <published>2018-12-17T04:46:44.000Z</published>
    <updated>2019-01-21T07:09:22.876Z</updated>
    
    <content type="html"><![CDATA[<p>本博文从《linux内核设计与实现》第三版的笔记，主要是任务调度、终端、内存管理、虚拟文件系统等部分。作为导读来存在，为以后看源码做点准备。</p><a id="more"></a><h1 id="内核开发的特点"><a href="#内核开发的特点" class="headerlink" title="内核开发的特点"></a>内核开发的特点</h1><ul><li><p>内核编程既不能访问C库，也不能访问标准的C头文件<br>内核不能链接使用标准C函数库，因为C函数库依赖系统调用（操作系统），而且C库对于内核，太大太低效。但大部分常用的C库函数在内核中都已经得到实现。</p></li><li><p>内核编程必须使用GNU C<br>内核并不完全符合ANSI C标准。它总是用到gcc提供的许多语言的扩展部分。</p></li><li><p>内核编程时缺乏像用户空间那样的内存保护机制<br>用户进程访问非法内存时，内核就会发现错误，并发送SIGSEGV信号。但内核如果访问了非法内存，那就很难控制了。<br>内核中的内存不分页。也就是说，没掉一个字节，物理内存就减少一个字节。</p><p>CPU通过寻址来访问内存。32位CPU的寻址宽度是4G，就是可支持的物理内存最大是4G，但如果物理内存小于4G，程序不得不降低内存占用。为解决此类问题，现在CPU引入MMU（内存管理单元），思想就是利用虚拟地址来替代物理地址，即CPU寻址时使用虚拟地址替代物理地址，即CPU寻址时，使用虚拟地址，由MMU负责将虚拟地址映射为物理地址。<br>内存分页（Paging）是在使用MMU的基础上，提出的内存管理机制。它将虚拟地址和物理地址按固定大小（4K）分割成页（page）和页帧（page frame），并保证页与页帧的大小相同。</p></li><li><p>内核变成时难以执行浮点运算。<br>用户空间的进程进行浮点操作的时候，内核会完成从整数操作到浮点数操作的模式转换。而内核并不完美支持浮点操作，因为它本身不能陷入。在内核中使用浮点数时，除了人工保存和恢复浮点寄存器，还有一些琐碎的事情要做。</p></li><li><p>内核给每个进程只有一个很小的定长堆栈<br>内核空间的栈比较小，一般就2页，即32位的内核是8KB，64位是16KB。</p></li><li><p>由于内核支持异步中断、抢占和SMP<br>SMP：（Symmetric mutliprocessing）是一种多处理器的计算硬件构架，在对称多处理架构下，每个处理器的地位都是平等的，对资源的使用权相同。有两个或更多的相同的处理器共享同一主存，由一个操作系统控制。<br>SMP，里那个以上的cpu内核有可能访问共享的同一资源<br>中断是异步的，中断处理程序就可能访问同一资源<br>inux内核可以抢占，内核中一段正在执行的代码可能会被另一段代码抢占，从而还是访问相同的资源。<br>常用的解决办法是自旋锁和信号量。</p></li></ul><h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><p>虚拟机制<br>进程提供了2种虚拟机制：虚拟处理器和虚拟内存。虽然多个进程正在共享一个处理，但虚处理器给进程一种假象，让这些进程觉得自己在独享处理器。而虚拟内存让进程在分配和管理内存时觉得自己拥有整个系统的所有内存资源。</p></li><li><p>进程描述符pid与任务结构task_struct<br>内核中通常把进程叫做任务（task）<br><img src="进程任务队列.png" alt=""></p></li><li><p>任务结构task_struct<br><img src="内核栈与进程描述.png" alt=""><br>thread_info,指针指向task_struct，通过slab分配器分配task_struct，这样能达到对象复用和缓存的目的。放在内核站的尾端是为了通过栈指针就能找到它的位置。</p></li><li><p>进程的状态<br><img src="进程状态转化.png" alt=""></p></li><li><p>进程树<br>所有进城都是通过fork()来实现，所以就有了父子进程的关系，在task_struct中有父进程的指针，以及子进程的列表。</p></li><li><p>进程创建<br>资源： 地址空间（VM）、文件系统资源(FS)、文件描述符(FILES)、信号处理程序(SIGHAND)<br>fork()： 大体是从父进程拷贝相同的task_struct，然后将描述符、资源从父进程分离。对于线程，就可以有些资源就不分离而已。</p></li><li><p>进程终结<br>首先会回收task_struct中的资源，并给其子进程找到合适的父进程，然后返回到其父进程，然后删除进程描述符。</p></li></ul><h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>进程调度系统可以看作在运行态P35<br>抢占式与非抢占式的区别</p><p>进程调度历史<br>简单调动 =》 O（1）调度程序 =》 完全公平调度算法（CFS）</p><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><p>调度程序角度对进程的划分：I/O消耗型与cpu消耗型<br>调度策略的平衡：进程响应迅速（响应时间短）和最大系统利用率（高吞吐量）<br>进程优先级，2套优先级范围：<br>nice值（人越nice越礼让，进程nice越大优先级越低），范围-20 到 +19<br>rtprio实时优先级，其值可配置，范围是0-99。越高优先级越高。任何实时进程的优先级都高于普通的进程，实时优先级与nice优先级处于互补相交的两个范畴。<br>时间片<br>调度策略必须规定一个默认的时间片，时间过长会导致系统对交互的响应欠佳（I/O消耗型），时间片太短会明显增大进程切换带来的cpu耗时。但linux的CFS调度器并没有直接分配时间片到进程，它是将处理器的使用比划分给了进程，这样进程所获得的时间片其实是个系统负载密切相关的。CFS调度器，其抢占时机决定于新的可运行程序消耗了多少处理器使用比，如果消耗的使用比比当前进程小，则新进程立即投入运行，抢占当前进程。</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>假设有2个运行进程，在标准Unix调度模型中，我们先运行其中一个5ms，然后再运行另一个5ms。但它们任何一个运行时都将占有100%的处理器。而在理想情况下，完美的多任务处理器模型应该是：我们在10ms内同时运行两个进程，它们各自使用处理器一半的能力。</p><p>CFS的做法是允许每个进程运行一段时间、循环论转、选择运行最少的集成作为下一个运行进程，而不再采用分配给每个进程时间片的做饭，CFS在所有可运行进程总数基础上计算出一个进程应该运行多久，而不是依靠nice值来计算时间片。nice值在CFS中被作为进程获得的处理器运行比的权重。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li><p>时间记账<br>多数Unix系统中，分配一个时间片给每一个进程，当系统时钟节拍发生时，时间片都会减少每一个节拍周期，当一个进程的时间片减少至0,它就会被另一进程抢占。</p><p>CFS不再用时间片的概念，但它也必须维护每一个进程运行的时间到帐。vruntime变量存放进程的虚拟运行时间，该运行是经过所有可运行进程总数的标准化，跟定时器节拍不再相关。vruntime变量来记录一个程序到底运行了多长时间以及它还应该再运行多久。</p><p> update_curr()函数来实现记账功能，它是有系统定时器周期性调用，curr-&gt;vruntime每次都增加一个 delta_exec_weighted，而这个delta_exec_weighted是根据当前任务的本次间隔delta_exec来，以及所有其他进程的delta_exec来计算的。</p><p> 应该这个权重是考虑了nice值的，但没有看到vruntime对任务调度的影响的部分代码，应该是在update_min_vruntime(cfs_rq)中产生了影响。</p></li><li><p>进程选择<br>当CFS需要选择下一个运行进程时，它会挑选一个具有最小vruntime的进程。CFS使用红黑树来组织可运行进程队列，红黑树是一个自平衡二叉搜索树小于节点在其左节点，大于在右节点，且是一种平衡的二茶树。</p></li><li><p>调度器入口<br>入口为schedule()，在kernel/sched.c中，它会找到一个最高优先级的调度类，然后有最高优先级的调度类下一该运行的进程。<br>CFS是对普通进程的调度类，而系统运行的绝大多数进程都是普通进程。</p></li><li><p>休眠<br>休眠的进程处于不可执行状态，需要从红黑树里移出，放入等待队列。待唤醒后，再从等待队列移出，放入红黑树。</p></li><li><p>总结<br>CFS就是通过vruntime实现对所有进程运行时间归一化的处理，处理过程肯定有nice值、以及进程数的参与。然后每次选取最小vruntime的去调度。</p></li></ul><h3 id="抢占"><a href="#抢占" class="headerlink" title="抢占"></a>抢占</h3><ul><li><p>上下文切换<br>抢占就需要进行上下文的切换，上下文切换主要负责：</p><ol><li>把虚拟内存从上一个进程切换到新进程中</li><li>调用switch_to()，从上一个进程的处理器状态切换到新进程的处理器状态。这包括保存、恢复栈信息和寄存器信息，还有其他任何与体系结构相关的状态信息。</li></ol></li><li><p>用户抢占<br>内核将返回用户空间的时候，如果need_resched标志被设置，会导致schedule()被调用，此时就会发生用户抢占。用户抢占发生在：</p><ol><li>从系统调用返回用户空间时</li><li>从中断处理程序返回用户空间时</li></ol></li><li><p>内核抢占<br>Linux完整支持内核抢占，不支持抢占的内核中，内核代码可以一直执行，到它去完成为止，调度程序没法在一个内核级任务正在执行的时候重新调度。Linux内核就可以在任何时间抢占正在执行的任务。内核抢占发生在：</p><ol><li>中断处理程序正在执行，且返回内核空间之前。</li><li>内核代码再一次具有可抢占性的时候</li><li>内核中的任务显式调用schedule()</li><li>内核中的任务阻塞</li></ol></li></ul><h3 id="实时调度策略"><a href="#实时调度策略" class="headerlink" title="实时调度策略"></a>实时调度策略</h3><p>linux提供了两种实时调度策略： SCHED_FIFO 和 SCHED_RR。<br>SCHED_FIFO实现了一种简单那的,先入先出的调度算法: 一旦一个SCHED_FIFO进程处于可执行状态,就会一直执行,知道它自己受阻或显式释放处理器,它不基于时间片,可以一直执行下去.只有更高优先级的SCHED_FIFO或者SCHED_RR任务才能抢占SCHED_FIFO人任务,且高优先级的SCHED_FIFO可以立即抢占低有线的.<br>SCHED_RR与SCHED_FIFO大体相同,只是SCHED_RR带有时间片.当时间片耗尽,它在统一优先级的其他实时进程被轮流调度,时间片之用来重新调度同一优先级的进程.即使时间片耗尽,低优先级的也不能抢占SCHED_RR高优先级的任务.</p><p>一点疑问: SCHED_FIFO是一种先入先出的队列,如果一个高优先级的紧挨在一个低优先级的后面,那会发生什么? 低优先级先运行,接着被高优先级的抢占,并将低优先级任务处于TASK_INTERRUPTABLE状态,并指导高优先级的运行完,再去运行低优先级的.<br>反过来,低优先级在一个高优先级的后边,会发生什么? 高优先级的先运行,低优先级的会继续在队列里,还是在其他的等待对立里?</p><p>优先级范围<br>实时优先级从0 到 MAX_RT_PRIO-1(99),SCHED_NORMAL级进程的nice值共享了这个取值空间,它的取值从MAX_RT_PRIO 到 (MAX_RT_PRIO + 40),也就是说 nice从-20到+19对应着 100到139的实时优先级范围.</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>时间片理解<br>对传统unix的时间片还有有些疑问,首先时间片是按nice值来进行分配,当高优先级运行完再运行低优先级的,当都运行完呢? 应该由调度程序继续来划分时间片,再继续运行,那这样,高优先级的任务也会等较久的时间啦,如果有100个任务,轮过一遍还是挺费事的.<br>不对,传统unix的时间片是固定的,什么样的优先级对应的时间片是固定的,那就需要有一个队列,时间片运行完后,将任务放到队列的后面,继续运行.且队列不能按优先级排序,因为一排序,它就又到前面了.不排序就会造成低优先级的比高优先级的先运行的情况,又会造成问题.</li></ul><h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在os中，内核提供了用户进程与内核进程进行交互的一组接口，这些接口让应用程序受限地访问硬件设备，提供了创建新进程并与已有进程进行通信的机制，也提供了申请操作系统其他资源的能力。</p><p>在linux中，系统调用是用户空间访问内核的唯一手段。</p><h2 id="系统调用-与-应用程序接口（API）"><a href="#系统调用-与-应用程序接口（API）" class="headerlink" title="系统调用 与 应用程序接口（API）"></a>系统调用 与 应用程序接口（API）</h2><p>大约关系是，内核提供系统调用接口，供用户空间的应用程序使用，但一般都会将系统调用进行进一步的封装变成应用程序编程接口API，这些接口中最流行的标准是POSIX，最后应用程序直接使用的是这些编程接口。以C库为中printf()调用为例：<br><img src="系统调用与API.png" alt=""><br>C库提供了POSIX绝大部分API</p><h2 id="系统调用-1"><a href="#系统调用-1" class="headerlink" title="系统调用"></a>系统调用</h2><p>在Linux系统中，每个syscall被赋予一个系统调用号，通过这个独一无二的号就可以关联系统调用。当用户空间的进程执行一个系统调用的时候，这个系统调用号来指明到底是要执行哪个系统调用。如此可见，系统调用号是静态的，如果一个系统调用被删除，它占用的系统调用号不允许被回收。</p><p>如getpid()系统调用，它会返回当前进程的PID，内核中的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE0(getpid)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">return</span> task_tgid_vnr(current);   <span class="comment">//return current-&gt;tgid</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SYSCALL_DEFINE0是一个宏，它定义一个无参数的系统调用，展开后的代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_getpid</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br></pre></td></tr></table></figure></p><p>asmlinkage限定词，是一个编译指令，通知编译器仅从栈中提取该函数的参数。</p><h2 id="系统调用处理程序"><a href="#系统调用处理程序" class="headerlink" title="系统调用处理程序"></a>系统调用处理程序</h2><p>用户空间的程序无法直接执行内核代码，也不能直接调用内核空间的函数，因为内核驻留在受保护的地址空间上。<br>应用程序应该以某种方式通知系统，告诉内核自己需要执行一个系统调用，系统系统切换到内核态，这样内核就可以代表应用程序在内核空间执行系统调用。<br>通知内核的机制是靠软中断（中断号128）实现的。通过引发一个异常，促使系统切换到内核态去执行异常处理程序，这个异常处理程序就是系统调用的处理程序。</p><p>仅陷入内核空间是不够的。必须将系统调用号、函数的参数一并传给内核。这些传递，是通过寄存器来完成的，分别放在eax,ebx,ecx,edx,esi,edi（前5个参数）中。<br><img src="系统调用处理程序.png" alt=""></p><h2 id="系统调用上下文"><a href="#系统调用上下文" class="headerlink" title="系统调用上下文"></a>系统调用上下文</h2><p>内核在执行系统调用的时候，处于进程上下文中。current指针指向当前任务，即引发系统调用的那个进程。<br>在进程上线文中，内核可以休眠，可以被抢占。</p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><ul><li><p>参数验证<br>指针、权限等验证防止内核崩溃<br>内核提供了2个方法来完成内核空间与用户空间之间数据的来回拷贝。注意内核无论何时都不能轻率的接受来自用户空间的指针。（这就需要数据的拷贝了，但数据的拷贝本身就需要起止的指针）。copy_to_user（）与copy_from_user()</p></li><li><p>例子</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(silly_copy,</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span> * src,</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span> * dst,</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> buf;  <span class="comment">// 书中例子，直接一个long的buf就能使用？</span></span><br><span class="line">    <span class="keyword">if</span>(copy_from_user(&amp;buf, src, len))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    <span class="keyword">if</span>(copy_to_user(dst, &amp;buf, len))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  还有对权限的检验： capable(CAP_SYS_BOOT) 来进行用户权限的检验。</p><p>  还需要将这个系统掉哟个你注册：</p><ol><li>在系统调用表最后，增加新的一项，类似与枚举，用于获取新的系统调用号。</li><li>对于所有支持的体系结构，系统调用都必须定义于 &lt;asm/unistd.h&gt;中。</li><li><p>系统调用必须被编译进内核影像(不能被编译成模块)。这需要将实现放到kernel/下的一个相关文件中，比如sys.c（包含各种各样的系统调用）</p><p>这样虽然定义了系统调用，但在C库中肯定没有对它的支持，好在linux提供了一组宏，用户对系统掉哟个你进行直接访问</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NR_foo 283</span></span><br><span class="line">_syscall3(<span class="keyword">long</span>, silly_copy, src, dst, len)</span><br></pre></td></tr></table></figure></li></ol></li></ul><h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><ul><li><p>简介<br>中断也是老朋友了，就是硬件中，使能了某个引脚的中断，然后编写这个中断的响应函数来处理。只不过在操作系统中会稍微麻烦了一点，它将终端分为2部分，其中上半部用来响应硬件、恢复中断，下半部用来处理硬件的数据。</p></li><li><p>上、下半部的对比<br>中断处理程序是上半部，接收一个中断，它就立即开始执行，只做有限的工作，例如对接收的中断进行应答，或者复位硬件，这些工作都是在所有中断被禁止的情况下完成的。能够被允许稍后完成的工作会推迟到下半部去。</p></li><li><p>注册中断处理程序<br>中断处理程序是驱动程序的组成部分，驱动程序通过request_irq()函数&lt;linux/iterrupt.h&gt;中注册一个中断处理程序，并激活给定的中断线，以处理中断。<br>主要参数是中断号与中断处理程序。</p></li><li><p>中断上下文<br>当执行一个中断处理程序时，内核处于中断上下文中。回忆进程上下文，进程上下文是一种内核所处的操作模式，此时内核代表进程执行如系统调用，运行内核线程等任务，在进程上下文中，可以通过current宏关联当前进程，因为进程是以进程上下文的形式连接到内核中，因此，进程上下文可以睡眠，可以调用调度程序。<br>中断上下文则相反，它与进程无关，也就没有后备进程，所以不能睡眠，中断上下文具有严格的时间限制，因为它打断了其他代码。<br><img src="中断处理程序.png" alt=""></p><p>/proc/interrupts中存放与系统中中断的相关信息。</p></li><li><p>下半部<br>下半部就主要有三种选择：软中断、tasklet和工作队列，其中tasklet基于软中断，工作队列依靠内核线程实现。<br>对于后半部，如果有休眠的需要，工作队列是唯一选择，否则就用tasklet。软中断一般不会用，因为它就32个，且被整个系统严格格共享且规范使用。</p></li></ul><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><ul><li><p>页<br>内核以page(页)作为管理内存的基本单位，因为MMU(内存管理单元，把虚拟地址转换成物理地址的硬件)通常就是以页为单位进行处理。<br>32位体系结构支持4KB页，64位体系一般支持8KB页大小。<br>内核用struct page结构表示系统中的每个物理页，该结构位于&lt;linux/mm_types.h中&gt;<br>page结构与物理页相关，而并非虚拟页。保存着页是否脏页，引用计数，虚拟地址（高地址可能没有，null）。</p></li><li><p>区<br>由于硬件限制，内核并不能对所有的页一视同仁，只有特定物理地址上的page才能用于也写特定的任务，所以内核就把页划分为不同的区。<br>linux主要用于4个区：</p><ol><li>ZONE_DMA – 这个区包含的页用来执行DMA操作【好久不见DMA，印象中是内存不再cpu参与下，直接与I/O交互】</li><li>ZONE_DMA32 – 只能被32位设备访问的DMA</li><li>ZONE_NORMAL – 能正常映射的页</li><li>ZONE_HIGHM – 所谓的高端内存，其中的页并不能永久的映射到内核地址空间。<br>这些区不不是都会有，如在64位体系中，所有内存都被映射，ZONE_HIGHMEM就为空<br>在x86-32上</li></ol></li></ul><table><thead><tr><th>区</th><th style="text-align:right">物理内存</th></tr></thead><tbody><tr><td>ZONE_DMA</td><td style="text-align:right">&lt;16MB</td></tr><tr><td>ZONE_NORMAL</td><td style="text-align:right">16~896MB</td></tr><tr><td>ZONE_HIGHMEM</td><td style="text-align:right">&gt;896MB</td></tr></tbody></table><p>  这些区域一般在&lt;linux/mmzone.h&gt;中的struct zone中定义<br>  比较重要的有lock域，是一个自旋锁，它防止zone被并发访问，这个域只保护zone结构，而不是保护这个区中的所有页。watermark数组，持有该区的最小值、最低和最高水位值。内核使用水位为每个内存设置合适的内存消耗基准，该水位随空闲内存的多少而变化。</p><ul><li><p>每个cpu的内存分配<br>一般来说，每个CPU的数据存放在一个数组中，数组中的每一项对应系统上一个存在的处理器。按当前处理器确定这个元素的当前元素。这些数据对当前处理器来说是唯一的，且除了当前处理器，没有其他处理器可接触到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cpu;</span><br><span class="line">cpu = get_cpu();  <span class="comment">// 获取当前处理器，并禁止内核抢占</span></span><br><span class="line">...操作</span><br><span class="line">put_cpu();       <span class="comment">// 激活内核抢占</span></span><br></pre></td></tr></table></figure><p>2.6版本引入新接口，percup来创建和操作每个CPU的数据<br>编译时，定义每个CPU变量<br>DEFINE_PER_CPU(type, name) 它为系统中的每一个处理器都创建一个类型为type，名字为name的变量。<br>DECLARE_PER_CPU(type, name)这是声明一个变量<br>get_cpu_var(name) 和 put_cpu_var(name)返回当前处理器的中指定变量.</p><p>这里有个问题,什么样的数据适合放在为每个cpu分配的内存上呢?</p></li><li><p>内存分配的选择<br>如果需要连续的物理页，可以使用某个低级页分配器或者kmalloc()。这是内核中内存分配的常用方式，也就是大多数应该使用的内存分配方式。传递给这些函数通常的标志是GFP_ATOMIC和GFP_KERNEL。GFP_ATOMIC表示进行不睡眠的高优先级分配，这是终端处理程序和其他不能睡眠的代码段的需要。GFP_KERNEL表示可以睡眠的代码，比如进程上下文中。</p><p>如果想从高端内存进行分配，就是用alloc_pages()。alloc_pages()函数返回一个指向struct page结构体的指针，而不是指向某个逻辑地址的指针。因为高端内存很可能没有被映射，因此访问它的唯一方式就是通过相应的struct page结构。有时为了获得真正的指针，应该调用kmap()，把高端内存映射到内存的逻辑地址空间，kmap在高端内存用会永久映射高端内存，而在低端用就是获取内存地址。</p><p>如果不需要物理上连续的页，而仅仅需要虚拟地址上连续的页，那么就使用vmalloc()。vmallog()函数分配的内存虚地址是连续的，但它本身不保证物理上的连续。</p><p>如果要创建和撤销很大的内存结构，那么应该考虑slab高速缓存。slab层会给每个处理器维持一个对象高速缓存（空闲链表）。这种高速缓存会极大提高对象分配和回收的性能【就是提前new出好多空间，使用时直接使用，无需新建跟销毁】</p></li></ul><h1 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h1><ul><li><p>unix文件系统：文件、目录项、索引节点和安装点<br>从本质上讲文件系统是特殊的数据分层存储系统，它包含文件、目录和相关的控制信息。文件系统的通用操作包括创建、删除和安装。<br>文件可以做一个有序字符串，字符串的第一个字节是文件的头，最后一个字节是文件的尾。每一个文件为了便于系统和用户识别，都被分配了一个便于理解的名字。典型的文件系统有读、写、创建和删除。<br>在Unix中，目录属于普通文件，它列出包含在其中的所有文件，由于VFS把目录当作文件对待，所以可以对目录执行和文件相同的操作。<br>Unix系统将文件本身 和 文件的控制信息2个概念区分，例如访问控制权限、大小、拥有者、创建时间等信息。文件信息被存储在一个单独的数据结构中，该结构被称为索引节点（inode）。文件控制信息被存储磁盘的超级块中。</p></li><li><p>vfs对象及其数据结构<br>vfs采用面向对象的设计思路。VFS中四个主要的对象类型，它们分别是：<br>（super）超级块对象，它代表一个具体的已安装文件系统<br>（inode）索引节点对象，它代表一个具体文件<br>（dentry）目录项对象，它代表一个目录项，是路径的一个组成部分<br>（file）文件对象，它代表有进行打开的文件。<br>unix是用C实现了，也就不会有class等关键字，那如何来实现面向对象呢，4个主要的对象类型都是结构体，而对他们的操作都封装在一个操作对象里作为类型对象的属性，操作对象中包含指向操作其父对象的函数指针;这就是之前听说过的，用C来实现面向对象的技术。</p></li><li><p>超级块对象<br>super_block结构体，定义在&lt;linux/fs.h&gt;中，用于存储特定文件系统的信息<br>超级块对象的操作位于fs.super.c中，超级块对象通过alloc_super()函数创建并初始化。在文件系统安装时，文件系统会调用该函数从磁盘读取文件系统超级块，并且将其信息填充到内存中的超级块对象中。</p><ul><li>超级块操作<br>超级块对象中最重要的一个属性s_op，它指向超级块的操作函数表。该函数表由super_operations结构体表示，定义在linux/fs.h中。<br>所有的操作都在进程上下文中调用。除了dirty_inode()，其他函数都可以阻塞。</li></ul></li><li><p>索引节点对象<br>一个索引节点代表文件系统的一个文件，它也可以是设备或管道这样的特殊文件。索引节点对象必须在内存中创建，以便于文件系统使用。<br>索引节点对象包含了对象操作文件或目录时需要的全部信息。对于Unix风格的文件系统，这些信息可以从磁盘索引节点直接读入，但有些文件系统需要特殊的转换，不管哪种情况，索引节点对象必须在内存中创建，以便VFS使用。<br>inode 结构体在 &lt;linux/fs.h&gt;中</p></li><li><p>目录项对象<br>目录项对象是为了简化索引对象对目录的操作而来的，在磁盘上并没有一个目录项的文件与之对应，是在访问的过程中，在内存中创建的对象。<br>路径中的每一项都属于目录项对象：/mnt/cdrom/foo中，/、mnt、cdrom和foo都属于目录项对象。VFS在执行目录操作时，会现场创建目录项对象<br>dentry 结构体在&lt;linux/dcache.h&gt;中</p><p>目录项状态： 被使用、未被使用、负状态; 被使用与未被使用的状态都对应一个有效的索引节点，而负状态则没有对应的有效节点。</p><p>如果VFS层便利路径中所有的元所将他们逐个解析成目录项对象，还要到达最深层的目录，将是一个非常费力的工作，会浪费大量的时间。所以内核将目录项对象缓存在目录项缓存中。使用时，先在目录项缓存中去查找，如果知道则直接使用，反之就按路径逐层解析、搜索，找到后，将目录项加入dcache中。</p></li><li><p>文件对象<br>文件对象表示进程已打开的文件在内存中的表示。该对象由相应的open()系统调用创建，而由close()调用撤销。所有这些文件相关的调用实际上都是文件操作表中定义的方法。<br>多个进程可以同时打开和操作一个文件，所以同一个文件可能存在多个文件对象。<br>文件系统仅仅在进程观点上代表已打开文件，它反过来指向目录项对象，又指向索引节点。<br>file结构体在 &lt;linux/fs.h&gt;中</p><p>常见的ioctl()、read（）、write()等都是在文件操作对象中定义的</p></li><li><p>其他</p><ul><li><p>vfsmount 当文件系统被安装时，将有一个vfsmount结构体在安装时被创建，用来代表文件系统的实例–也就是代表一个安装点</p></li><li><p>进程相关的数据结构<br>file_struct:进程与文件对象的关联，像是中间表那样<br>fs_struct：进程当前的工作目录(pwd)和根目录<br>namespace: 它使得没一个进程在系统中都看到唯一的安装文件系统（不仅是唯一的根目录，而且是唯一的文件系统层次结构）。</p></li></ul></li></ul><h1 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h1><p>linux采用虚拟内存技术，系统中的所有进程以虚拟方式共享内存。对于一个进程而言，它好像可以访问整个系统的所有物理内存。更重要的是，即使单独一个进程，它拥有的地址空间也可以远远大于系统物理内存。</p><ul><li><p>地址空间<br>每个进程都有一个32或者64位独立、连续的平台地址空间。尽管一个进程可以寻址4GB虚拟内存（32位），但并不代表它就有权访问所有的虚拟地址，进程只能访问有效内存区域内的内存地址。如果进程访问了无效的内存区域，内核会终止进程，并返回段错误。可被访问的有效地址被称为内存区域(memory areas)</p><p>内存区域包含各种内存对象：<br> – 可执行文件代码的内存映射：代码段<br> – 可执行文件已初始化全局变量的内存映射：数据段<br> – 包含未初始化全局变量的内存映射：bss<br> – 用于进程用户空间栈的内存映射：栈，局部变量<br> – 匿名的内存映射，malloc()分配的内存： 堆，<br> – 任何共享内存段<br> – 任何内存映射文件<br> – 动态链接程序等共享库的代码段、数据段、bss</p></li><li><p>内存描述符mm_struct<br>mm_struct结构体，定义在&lt;linux/sched.h&gt;中，内核使用mm_struct表示进程的地址空间，该结构包含了和进程地址空间有关的全部信息。<br>内存描述符mm_struct与进程一一对应，描述的是进程各段使用的地址，而各段使用的地址用vm_area_struct结构体来表示，各段的起止地址在mm_struct中都有属性来记录，还保存虚拟页到实际物理地址的映射：pgd_t</p><p>fork() =&gt; copy_mm()函数来完成创建mm_struct</p><p>内核线程的使用不一样，因为内核线程没有进程地址空间，也就没有内存描述符，所以在进程描述符中，mm域为空。<br>当一个进程被调度时，该进程的mm域指向的地址空间被装载到内存，进程描述符中的active_mm域会被更新，指向新的地址空间。内核县城没有地址空间，mm域为NULL，当一个内核线程被调度的时候，内核发现mm域为NULL，会保留前一个进程的地址空间，随后内核更新内核县城对应的进程描述符中的active_mm域，使其只想前一进程的内存描述符。<br>内核线程如此使用，是因为内核线程是需要使用页表的（虚拟内存到物理内存的映射）。</p></li><li><p>虚拟内存区域vm_area_struct(VMA)<br>vm_area_struct结构体描述了制定地址空间内连续区间上的一个独立内存范围。内核将每个内存区域作为一个单独的内存对象管理，每个内存区域都拥有一致的属性，如访问权限等。<br>vm_area_struct在&lt;linux/mm_types.h&gt;中。<br>主要就是区间的首尾地址，VMA形成的链表，访问权限，mm_struct指针<br>使用中可以使用pmap <pid> 打印出进程的各个VMA。<br>比如C库中的物理内存1212KB空间，内存中只映射一份，将这些地址空间以只读的方式映射进每个引用的进程中即可.某个vm_area_struct就可以映射一份即可。</pid></p><p>mmap() 和 do_mmap（）创建地址空间。其实如果是地址空间跟一个已经存在的地址空间相邻，并且访问权限相同，两个空间就合并（类似与扩展）。反之就创建一新的VMA，并把地址加到进程的地址空间中。</p></li><li><p>页表<br>应用程序操作的是虚拟内存，但CPU直接操作确是物理内存，所以当程序访问虚拟内存时，必须将虚拟内存转换成物理内存，CPU才能解析地址访问请求。地址转换工作通过查询页表完成。<br>linux中使用三级页表完成地址转换：<br>顶层页表PGD（页全局目录），它包含了一个pgd_t类型数组<br>二级页表PMD(页中间目录)，是一个pmd_t类型数组<br>底层页表PTE，包含了pte_t类型的页表，指向物理页面<br>搜索页面的工作一部分是由硬件完成的，对应的结构提依赖具体的体系结构，定义在&lt;asm/page.h&gt;中<br><img src="页表.png" alt=""> </p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本博文从《linux内核设计与实现》第三版的笔记，主要是任务调度、终端、内存管理、虚拟文件系统等部分。作为导读来存在，为以后看源码做点准备。&lt;/p&gt;
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>对js中{}的思考</title>
    <link href="http://yoursite.com/2018/11/29/%E5%AF%B9js%E4%B8%AD&#39;%7B%7D&#39;%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://yoursite.com/2018/11/29/对js中&#39;{}&#39;的思考/</id>
    <published>2018-11-29T08:31:47.000Z</published>
    <updated>2019-01-21T07:05:12.900Z</updated>
    
    <content type="html"><![CDATA[<p>这次在现场对于新给的工程量的解析与存储时，又发现对于js中”{}”的使用又存在着疑惑，这个疑惑在以前分析过，但记录确实找不到了，现对它再次进行分析。<br><a id="more"></a></p><h1 id="js中的”-”与C-中的map"><a href="#js中的”-”与C-中的map" class="headerlink" title="js中的”{}”与C++中的map"></a>js中的”{}”与C++中的map</h1><p>  c++中的map与js中的”{}”都是一种键值对的结构，键是唯一的，可以通过键快速的访问value。</p><p>  在c++的STL的map中，我们可以将一个类的对象作为键值放在key的位置，value的位置可以放任意数据，key位置的数据需要实现&lt;的比较运算即可，但”{}”的键值对是片面的键值对，因为其只能是字符串-值的。</p><p>  这里可以再引申一下js中的Map，这个Map号称是键值对，它也确实可以将对象存在key的位置上，但它是巨坑的实现，因为它的key位置的唯一不是按key对象的值来判断的，而是按地址来判断的。</p><h1 id="js中的”-”与C-中的struct"><a href="#js中的”-”与C-中的struct" class="headerlink" title="js中的”{}”与C++中的struct"></a>js中的”{}”与C++中的struct</h1><p>  前文说到”{}”其实是字符串-值的一种结构，它的名字叫对象，那它与静态语言中的对象有什么异同呢？ 拿c++的struct来与”{}”来做个对比</p><p>  struct与”{}”都可以仅放数据，也可以放数据与函数，在C++使用时一般沿用C的方式，将struct只放数据，而用class来当类来使用。</p><p>  比如在做一个Student对象时：<br>  C++中需要先声明一个Strudent的结构体：<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">  <span class="built_in">string</span> name;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  <span class="built_in">string</span> sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 然后用这个结构体来实例化对象：<br> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student s1 = &#123;<span class="string">"张三"</span>,<span class="number">13</span>,<span class="string">"男"</span>&#125;</span><br><span class="line">Student s2 = &#123;<span class="string">"李四"</span>，<span class="number">14</span>,<span class="string">"男"</span>&#125;</span><br></pre></td></tr></table></figure></p><p> 而在js中的”{}”需要：<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = &#123;<span class="string">"name"</span>:<span class="string">"张三"</span>, <span class="string">"age"</span>:<span class="number">13</span>, <span class="string">"sex"</span>:<span class="string">"男"</span>&#125;</span><br><span class="line"><span class="keyword">let</span> s2 = &#123;<span class="string">"name"</span>:<span class="string">"李四"</span>, <span class="string">"age"</span>:<span class="number">14</span>, <span class="string">"sex"</span>:<span class="string">"男"</span>&#125;</span><br></pre></td></tr></table></figure></p><p> 这样我们看到，js中的对象由于没有类型，所以需要把变量信息也包含在对象内部。数据效率相对低一些。<br> 访问时都是： s1.name</p><h1 id="对”-”的理解"><a href="#对”-”的理解" class="headerlink" title="对”{}”的理解"></a>对”{}”的理解</h1><p>前便说到”{}”中是变量信息放在了key的位置上，这句话需要再解释一下。<br>我们完全可以创建一个这样的对象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> zs = &#123;<span class="string">"张三"</span>:<span class="number">13</span>&#125;</span><br></pre></td></tr></table></figure></p><p>这样的结果是key的位置上，其实是一个之前的name，是一个信息，而不是简单的变量名的概念。访问时可以是zs.张三。（当然，也可以认为变量名是汉字，虽然一般人都不会这样玩，但C++的变量名确实也可以是汉字。） </p><p>综上： 对”{}”的理解最到位的就是 字符串-值结构的对象。</p><p>既然只能是字符串，那对象如何来做key值，方法呼之欲出，将对象转换成string来使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s3 = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> keyObj = &#123;<span class="string">"张三"</span>:<span class="string">"3班"</span>&#125;</span><br><span class="line"><span class="keyword">let</span> k = <span class="built_in">JSON</span>.stringify(keyObj)</span><br><span class="line">s3[k] = <span class="number">14</span></span><br></pre></td></tr></table></figure><h1 id="js中的”-”与python中的”-”"><a href="#js中的”-”与python中的”-”" class="headerlink" title="js中的”{}”与python中的”{}”"></a>js中的”{}”与python中的”{}”</h1><p>“{}”在js与python中的差异性更不明显一些。”{}”在python中叫字典，在js中叫对象。</p><p>在使用上它们都可以如此使用：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">"a"</span>:<span class="number">1</span>&#125;</span><br><span class="line">a[<span class="string">"a"</span>]      // <span class="number">1</span></span><br><span class="line">a.get(<span class="string">"a"</span>)  // <span class="number">1</span></span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;<span class="string">"a"</span>:<span class="number">1</span>&#125;</span><br><span class="line">a[<span class="string">"a"</span>]   <span class="comment">// 1</span></span><br><span class="line">a.a      <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>但他们在深层次上是不同的，python中的””更像是动态语言中的map，因为它不能包括函数，而是当作一种数据结构来使用。而js中的”{}”更接近与动态语言中的struct，因为它不仅可以包含函数，更可以通过”.”来访问数据。<br>如在js中<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.fun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">111</span>)&#125;</span><br><span class="line">a.fun()</span><br></pre></td></tr></table></figure></p><p>但在python中则不能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次在现场对于新给的工程量的解析与存储时，又发现对于js中”{}”的使用又存在着疑惑，这个疑惑在以前分析过，但记录确实找不到了，现对它再次进行分析。&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>android开发记录</title>
    <link href="http://yoursite.com/2018/11/28/android%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2018/11/28/android开发记录/</id>
    <published>2018-11-28T10:25:37.000Z</published>
    <updated>2019-01-21T07:04:28.124Z</updated>
    
    <content type="html"><![CDATA[<p> 随着开发深入，又要开始用Java来开发android了，上次没有总结出一篇像样的android博客出来，这次补上，随着开发陆续完善。</p><a id="more"></a><h1 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h1><h2 id="对于android与react开发的对比"><a href="#对于android与react开发的对比" class="headerlink" title="对于android与react开发的对比"></a>对于android与react开发的对比</h2><ul><li><p>相同：<br>android在开发时，最基础的过程是布局、activity、view，其中布局用于确定一个页面中有哪些组件以及他们之间的位置关系; activity通过findViewById得到布局中的view(组件)，来进行控制，包括获取数据已经控制显示数据; 对于view的事件（如button的点击），可以在布局中去指定，也可以在activity中去指定响应函数。 </p><p>对比react中的开发，布局对应着app.js中对不同组件组合以及css中布局的控制; activity中内容像是组件中的控制，包括document.getElementById()来获取元素，以及onClick（）响应等，包括组件之间的通信，以及与后端的通信，都可以在activity中去实现（不过大多都将module层抽象出来）; android中的view跟标签有些类似，当然可以自建view 对应着fragment，对应着react中的component(组建)</p></li><li><p>区别：<br>react的数据流是自上而下的流动， 而android中数据流可以自由流动;<br>react中大的封装用页面，且页面之间基本无法通信， 页面之间的封装用component; 在android中教为自由，毕竟大家都在一个进程中，数据是共享的，封装用布局来完成，页面控制由activity来完成。<br>react中component封装了view与对view的控制，而且本身也当作view来使用，是一种组合模式; 在android中将显示由基本的view与布局来完成，控制由activity来完成。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 随着开发深入，又要开始用Java来开发android了，上次没有总结出一篇像样的android博客出来，这次补上，随着开发陆续完善。&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>CSS布局总结</title>
    <link href="http://yoursite.com/2018/11/28/css%E6%A0%B7%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/11/28/css样式总结/</id>
    <published>2018-11-28T08:00:00.000Z</published>
    <updated>2019-01-21T07:04:39.308Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要汇总开发中前端布局，遇到的小问题以及对小问题的研究</p><a id="more"></a><h1 id="框模型：元素本身大小的控制"><a href="#框模型：元素本身大小的控制" class="headerlink" title="框模型：元素本身大小的控制"></a>框模型：元素本身大小的控制</h1><h2 id="关于width-heigh-padding-border-margin的关系"><a href="#关于width-heigh-padding-border-margin的关系" class="headerlink" title="关于width,heigh,padding,border,margin的关系"></a>关于width,heigh,padding,border,margin的关系</h2><p>  <img src="框模型.png" alt=""></p><p>  对于框模型已经较为熟悉了，但有一点height与width属性都是内容部分的属性，而不是整个元素的属性。元素的宽度 = width + 2<em>padding + 2</em>border + 2*margin<br>  <img src="框模型宽度计算.png" alt=""></p><ul><li><p>100%的设置尺寸问题<br>子元素继承父元素的width是content，子元素尺寸100%的设置时，不能再设置padding、border、magin等宽度，否则就会超出限制</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="selector-class">.child</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">50px</span> solid green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的child元素的尺寸会超出父元素parent，因为child元素的尺寸已经是100%父元素的内容了，父元素没有设置border，而子元素增加border的宽度，这样就会超出了100px。</p></li><li><p>居中的一种实现：<br>.center-me { margin: 0 auto; }</p></li></ul><h2 id="子元素与父元素尺寸（width，-height）关系"><a href="#子元素与父元素尺寸（width，-height）关系" class="headerlink" title="子元素与父元素尺寸（width， height）关系"></a>子元素与父元素尺寸（width， height）关系</h2><p>若父元素与子元素都设置了尺寸，则各自按照自己的设置进行。</p><p>height展现了一种自下向上的尺寸影响路线：子元素设置的height,会决定父元素的height；父元素的height不会影响子元素的height。</p><p>width展示了从上而下的影响路线：父元素设置的width，会决定子元素的width；子元素的width设置不会影响父元素的width。</p><h1 id="position-元素位置的控制"><a href="#position-元素位置的控制" class="headerlink" title="position: 元素位置的控制"></a>position: 元素位置的控制</h1><h2 id="关于position-top-right-bottom-left的使用"><a href="#关于position-top-right-bottom-left的使用" class="headerlink" title="关于position,top,right,bottom,left的使用"></a>关于position,top,right,bottom,left的使用</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">position: relative/absolute/fixed </span><br><span class="line"><span class="selector-tag">top</span>: 10<span class="selector-tag">px</span></span><br><span class="line"><span class="selector-tag">right</span>: 10<span class="selector-tag">px</span></span><br><span class="line"><span class="selector-tag">bottom</span>: 10<span class="selector-tag">px</span></span><br><span class="line"><span class="selector-tag">left</span>: 10<span class="selector-tag">px</span></span><br></pre></td></tr></table></figure><h2 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h2><p>将窗体自上而下分成一行行, 并在每行中按从左至右的顺序排放元素,即为文档流。<br>只有三种情况会使得元素脱离文档流，分别是：浮动、相对定位和固定定位。</p><ul><li><p>静态定位<br>static，无特殊定位，它是html元素默认的定位方式，即我们不设定元素的position属性时默认的position值就是static，它遵循正常的文档流对象，对象占用文档空间，该定位方式下，top、right、bottom、left、z-index等属性是无效的。</p></li><li><p>相对定位相对的是它在文档流中的位置而进行偏移，且不脱离文档流</p></li><li><p>绝对定位：absolute</p><p>使用absoult定位的元素脱离文档流后，就只能根据祖先类元素(父类以上)进行定位，而这个祖先类还必须是以postion非static方式定位的</p><p>relative和static方式在最外层时是以body标签为定位原点的，而absoulte方式在无父级是position非static定位时是以html作为原点定位。html和body元素相差9px左右</p><p>absoulte定位要加 top:0; left:0。因为我们如果使用absoulte或fixed定位的话，必须指定 left、right、 top、 bottom 属性中的至少一个，否则left/right/top/bottom属性会使用它们的默认值 auto，简单讲就是都变成relative。</p><p>少了left/right/top/bottom属性不行，那如果我们多设了呢？例如，我们同时设置了top和bottom的属性值，那元素又该往哪偏移好呢？记住下面的规则：<br>如果top和bottom一同存在的话，那么只有top生效。<br>如果left和right一同存在的话，那么只有left生效。</p><p>absoulte是根据祖先类的border进行的定位</p></li><li><p>固定定位：fixed</p><p>fixed定位，又称为固定定位，它和absoult定位一样，都脱离了文档流，并且能够根据top、right、left、bottom属性进行定位，但不同的是fixed是根据窗口为原点进行偏移定位的，也就是说它不会根据滚动条的滚动而进行偏移。</p></li><li><p>z-index属性</p><p>z-index，又称为对象的层叠顺序，它用一个整数来定义堆叠的层次，整数值越大，则被层叠在越上面，当然这是指同级元素间的堆叠，如果两个对象的此属性具有同样的值，那么将依据它们在HTML文档中流的顺序层叠，写在后面的将会覆盖前面的。需要注意的是，父子关系是无法用z-index来设定上下关系的，一定是子级在上父级在下。</p><p>使用static 定位z-index属性是无效的</p></li></ul><h1 id="flex-浮动"><a href="#flex-浮动" class="headerlink" title="flex: 浮动"></a>flex: 浮动</h1><p>  display: flex<br>  待整理…<br>  <a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">阮一峰：Flex 布局教程</a></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul><li><p>屏幕适应<br>待整理</p></li><li><p>css文档流与DOM树<br>待整理<br>css是按DOM树的叶子节点还是根节点进行样式的刷新的。<br>屏幕宽度与文档宽度的差异</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要汇总开发中前端布局，遇到的小问题以及对小问题的研究&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>js中this的理解</title>
    <link href="http://yoursite.com/2018/11/28/js%E4%B8%ADthis%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/11/28/js中this的理解/</id>
    <published>2018-11-28T02:00:00.000Z</published>
    <updated>2019-01-21T07:12:28.996Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要汇总开发中后端、语言，遇到的小问题以及对小问题的研究</p><a id="more"></a><h1 id="一句话"><a href="#一句话" class="headerlink" title="一句话"></a>一句话</h1><p> 一句话： this是函数的运行时环境<br> 解释： 谁调用的函数，this就是谁</p><p> 例如：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> var a = 1</span><br><span class="line"></span><br><span class="line"> function test() &#123;</span><br><span class="line">   console.log(this.a)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;&#125;</span><br><span class="line">obj.a = 2</span><br><span class="line">obj.t = test</span><br><span class="line"></span><br><span class="line">obj.t()           // 2</span><br><span class="line">t()               // 1</span><br></pre></td></tr></table></figure></p><h1 id="两个注意"><a href="#两个注意" class="headerlink" title="两个注意"></a>两个注意</h1><h2 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h2><p>函数的this可以通过bind来绑定，使其不受调用者的影响</p><p>function test (){}<br>test.bind(this)</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>箭头函数() =&gt; {}，this始终指向定义者，而不受调用者的影响。</p><h1 id="内存解释"><a href="#内存解释" class="headerlink" title="内存解释"></a>内存解释</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; foo:  5 &#125;;</span><br></pre></td></tr></table></figure><p>它在内存中先创建一个 {foo:5} 对象，然后再将这个对象的地址用obj来表示</p><p><img src="变量-2.png" alt=""></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;foo: funciton()&#123;&#125;&#125;</span><br></pre></td></tr></table></figure><p>函数与变量捎有不同，它先将函数独立存储在内存中（应该在代码段里），然后再将函数的地址赋值给foo属性的value值，也就是说foo那里存储的是函数的地址。</p><p><img src="函数.png" alt=""></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="http://www.ruanyifeng.com/blog/2018/06/javascript-this.html" target="_blank" rel="noopener">阮一峰： JavaScript的this原理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要汇总开发中后端、语言，遇到的小问题以及对小问题的研究&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>js中的模块</title>
    <link href="http://yoursite.com/2018/11/28/js%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2018/11/28/js中的模块/</id>
    <published>2018-11-28T02:00:00.000Z</published>
    <updated>2019-01-21T07:13:53.191Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要汇总开发中后端、语言，遇到的小问题以及对小问题的研究</p><a id="more"></a><h1 id="require"><a href="#require" class="headerlink" title="require"></a>require</h1><p>   node使js可以运行于后台，于是就有了对模块的需要。<br>   require的解决方式是将模块中的所有对象（变量、函数、类）都成为一个对象module.exports对象的子对象，然后在其他模块中直接通过require模块名来引用导出的molule.exports对象，来直接访问。<br>   使用：</p><p>   test.js<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123; </span><br><span class="line">    a : function()&#123;&#125;,</span><br><span class="line">    b : &apos;test&apos;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var t = require(&apos;./test&apos;);</span><br><span class="line">t.a();</span><br></pre></td></tr></table></figure><h1 id="AMD与CMD"><a href="#AMD与CMD" class="headerlink" title="AMD与CMD"></a>AMD与CMD</h1><p>  require在服务端优势明显，因为加载的模块在服务器硬盘上，而在浏览器端确需要等待网络传输，加载完成后才可以使用模块中的对象，这种同步方式不符合js异步的理念，于是就有了AMD与CMD两种异步加载方式。<br>  AMD: Asynchronous Module Definition<br>  CMD: Common Module Definition<br>  AMD是将对依赖加载模块部分都放到异步函数中完成</p><p>  math.js<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define([&apos;Lib&apos;], function(Lib)&#123;</span><br><span class="line">　　　　function foo()&#123;</span><br><span class="line">　　　　　　Lib.doSomething();</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　return &#123;</span><br><span class="line">　　　　　　foo : foo</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require([&apos;math&apos;], function (math) &#123;</span><br><span class="line">　      math.add(2, 3);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="ES6的import"><a href="#ES6的import" class="headerlink" title="ES6的import"></a>ES6的import</h1><p>  ES6应该也是一种异步加载方式，具体原理没有深入了解<br>  它是通过解构的方式来导入、到处，这样就可以不用引用所有对象。另外有一个default语法糖，每个模块都有只一个default，这样在import时可以不写解构的过程。<br>  与default语法糖相关的是as关键字，像是SQL的as，起一个别名，default就是这个别名。<br>  export还是的到处可以放在每个对象上定义，而不是放在一个exports对象里。</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export &#123; name1, name2, …, nameN &#125;;</span><br><span class="line">export &#123; variable1 as name1, variable2 as name2, …, nameN &#125;;</span><br><span class="line">export default expression;</span><br><span class="line"></span><br><span class="line">import &#123; member &#125; from &quot;module-name&quot;;</span><br><span class="line">import &#123; member as alias &#125; from &quot;module-name&quot;;</span><br><span class="line">import defaultMember from &quot;module-name&quot;</span><br></pre></td></tr></table></figure></code></pre><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://www.cnblogs.com/libin-1/p/7127481.html" target="_blank" rel="noopener">彻底搞清楚javascript中的require、import和export</a></p><p><a href="http://imweb.io/topic/582293894067ce9726778be9" target="_blank" rel="noopener">Node中没搞明白require和import，你会被坑的很惨</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要汇总开发中后端、语言，遇到的小问题以及对小问题的研究&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>React基础</title>
    <link href="http://yoursite.com/2018/11/08/2018-11-8React%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/11/08/2018-11-8React基础/</id>
    <published>2018-11-08T05:00:35.000Z</published>
    <updated>2019-01-21T07:04:14.972Z</updated>
    
    <content type="html"><![CDATA[<p>主要介绍React基础：包括React元素、React组件、React数据流、表单、列表等内容<br> <a href="https://react.docschina.org/docs/introducing-jsx.html" target="_blank" rel="noopener">React官方文档</a><br><a id="more"></a></p><h1 id="React基础"><a href="#React基础" class="headerlink" title="React基础"></a>React基础</h1><h2 id="React元素"><a href="#React元素" class="headerlink" title="React元素"></a>React元素</h2><h3 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">&lt;h1 className=<span class="string">"greeting"</span>&gt;</span><br><span class="line">   Hello, world</span><br><span class="line">)</span><br><span class="line">&lt;<span class="regexp">/h1&gt;</span></span><br></pre></td></tr></table></figure><p>Babel转译器把JSX转换成:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = React.createElement(</span><br><span class="line"><span class="string">"h1"</span>,</span><br><span class="line"> &#123;<span class="attr">className</span>:<span class="string">"greeting"</span>&#125;,</span><br><span class="line"> <span class="string">"Hello, world!"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>createElement会返回一个类似于下面的对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line"> type: <span class="string">'h1'</span>,</span><br><span class="line"> props: &#123;</span><br><span class="line">   className: <span class="string">'greeting'</span>,</span><br><span class="line">   children: <span class="string">'Hello, world'</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将React元素渲染到根DOM节点中,通常使用ReactDOM.render()<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &lt;h1&gt;Hello, world&lt;/h1&gt;</span><br><span class="line">ReactDOM.render(element, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>))</span><br></pre></td></tr></table></figure></p><p>ReactDOM的渲染只会更新渲染文本节点中发生变化的内容.</p><h3 id="JSX-和-HTML-的区别"><a href="#JSX-和-HTML-的区别" class="headerlink" title="JSX 和 HTML 的区别"></a>JSX 和 HTML 的区别</h3><ul><li><p>class<br>在JSX中不能使用class，因为是ES6的关键字，而使用className</p></li><li><p>style 属性<br> style属性接受一个对象，而不是分号分割的字符串。CSS使用驼峰命名发</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> styles = &#123;</span><br><span class="line">  fontSize = <span class="string">'2em'</span>,</span><br><span class="line">  lineHeight: <span class="string">'1.6'</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> em = &lt;em style=&#123;styles&#125;&gt;</span><br></pre></td></tr></table></figure></li><li><p>JSX 中所有标签都需要闭合</p></li><li><p>用驼峰明明属性，像onClick<br>所有以data-与aria-开头的属性例外</p></li></ul><h3 id="子代"><a href="#子代" class="headerlink" title="子代"></a>子代</h3><p>在包含开始和结束标签的JSX表达式中，标记之间的内容作为特殊的参数传递：props:children。</p><ul><li><p>字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent&gt;Hello world!&lt;/MyComponent&gt;</span><br></pre></td></tr></table></figure><p>props.children就是字符串</p></li><li><p>JSX<br>你可以通过子代嵌入更多的 JSX 元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyContainer&gt;</span><br><span class="line"> &lt;MyFirstComponent /&gt;</span><br><span class="line"> &lt;MySecondComponent /&gt;</span><br><span class="line">&lt;<span class="regexp">/MyContainer&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>javascript表达式</p></li><li>函数</li></ul><h2 id="React组件"><a href="#React组件" class="headerlink" title="React组件"></a>React组件</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>组件可以将UI切分成一些独立的、可复用的部件，它可以接受任意的输入值(称之为”props”)，并返回一个在页面上显示的React元素</p><p>函数定义<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>类定义<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">   render() &#123;</span><br><span class="line">     <span class="keyword">return</span> &lt;h1&gt; Hello, &#123;this.props.name&#125;&lt;/h1&gt;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>React元素，除了是DOM标签，也可以是用户自定义的组件<br>const element = <welcom name="Sara"><br>而且一个组件可以包含其他组建作为React元素<br>由此可见，我们React其实是一种组合模式，组件与组件的组合是一致对待的。<br>而且定义组件像是定义一个类，而组为React元组时，就是实例化的过程（CreateElement）</welcom></p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="react生命周期.png" alt=""></p><h3 id="props与state"><a href="#props与state" class="headerlink" title="props与state"></a>props与state</h3><p>组件内部绝不能修改它自己的的props。props保存了由父元素传递进来的数据，这些数据不可以在props中进行修改。</p><p>state可以根据用户操作、网络响应、或其他状态变化，使组件动态的响应并改变组件的输出。<br>state其实就是保存组件内部的数据变化，在使用中，可以通过生命成员变量的方式来使用。</p><p>内部的状态一般就是通过用户的操作（action），以及网络请求来触发状态的变化。action操作时，需要注意响应函数的this问题，一般用箭头函数来避免直接bind。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this is:'</span>， <span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;button onClick = &#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">  Click me</span><br><span class="line">&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">handleClick()&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this is:'</span>,<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;button onClick = &#123;(e) =&gt; <span class="keyword">this</span>.handleClick(e)&#125;&gt;</span><br><span class="line">  Click Me</span><br><span class="line">&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><h2 id="React组件间数据流"><a href="#React组件间数据流" class="headerlink" title="React组件间数据流"></a>React组件间数据流</h2><h3 id="自顶向下数据流"><a href="#自顶向下数据流" class="headerlink" title="自顶向下数据流"></a>自顶向下数据流</h3><p>React是一种自顶向下的数据传输,从父组件传递数据到子组件，因为从父组件传递给子组件的数据存放在props中，不能修改。</p><h3 id="反向数据流"><a href="#反向数据流" class="headerlink" title="反向数据流"></a>反向数据流</h3><p>但为什么还有反向数据流呢？ 因为可以从父组件传递回调函数进去，子组件通过回调函数，将数据作为参数传递，而达到反向数据传输的目的。这样其实需要把数据的存储从子组件提升到父组件中去。这在React中称谓状态提升（因为react喜欢把数据放在state中）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TemperatureInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.props.onTemperatureChange(e.target.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> temperature = <span class="keyword">this</span>.props.temperature;</span><br><span class="line">    <span class="keyword">const</span> scale = <span class="keyword">this</span>.props.scale;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;fieldset&gt;</span><br><span class="line">        &lt;legend&gt;在&#123;scaleNames[scale]&#125;:中输入温度数值&lt;<span class="regexp">/legend&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input value=&#123;temperature&#125;</span></span><br><span class="line"><span class="regexp">               onChange=&#123;this.handleChange&#125; /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/fieldset&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h2><ul><li><p>map<br>用来遍历数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> listItems = numbers.map(<span class="function">(<span class="params">number</span>) =&gt;</span></span><br><span class="line">  &lt;li&gt;&#123;number&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  &lt;ul&gt;&#123;listItems&#125;&lt;/u</span>l&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>&amp;&amp;<br>false、null、undefined 和 true 都是有效的子代，但它们不会直接被渲染。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Mailbox</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> unreadMessages = props.unreadMessages;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello!&lt;/h1&gt;</span><br><span class="line">      &#123;unreadMessages.length &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        &lt;h2&gt;</span><br><span class="line">          You have &#123;unreadMessages.length&#125; unread messages.</span><br><span class="line">        &lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>三目运算符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line"> <span class="keyword">const</span> isLoggedIn = <span class="keyword">this</span>.state.isLoggedIn;</span><br><span class="line"> <span class="keyword">return</span> (</span><br><span class="line">   &lt;div&gt;</span><br><span class="line">     &#123;isLoggedIn ? (</span><br><span class="line">       &lt;LogoutButton onClick=&#123;<span class="keyword">this</span>.handleLogoutClick&#125; /&gt;</span><br><span class="line">     ) : (</span><br><span class="line">       &lt;LoginButton onClick=&#123;<span class="keyword">this</span>.handleLoginClick&#125; /&gt;</span><br><span class="line">     )&#125;</span><br><span class="line">   &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"> );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p> 列表的key属性，在DOM中的某些元素增加或删除的时候帮助React识别哪些元素发生了变化，因此应当给数组中的每一元素赋予一个确定的标识。<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> listItems = numbers.map(<span class="function">(<span class="params">n</span>) =&gt;</span> </span><br><span class="line"> &lt;li key=&#123;n.toString()&#125;&gt;</span><br><span class="line">   n</span><br><span class="line"> &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure></p><p>  元素的key只有在它和它的兄弟节点对比时才有意义,而且应该唯一。 比如上例中，将<li>封装到一个组件ListItem中，那么key就不能放到li中了，而是放在ListItem下<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ListItem key=&#123;n.toString()&#125; value=&#123;n&#125; /&gt;</span><br></pre></td></tr></table></figure></li></p><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><h3 id="受控组件与非受控组件"><a href="#受控组件与非受控组件" class="headerlink" title="受控组件与非受控组件"></a>受控组件与非受控组件</h3><p>在HTML中，像<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>和<code>&lt;select&gt;</code>这类的表单元素会自己维持自身的状态，并根据用户输入自动进行刷新，这在React中被称谓非受控组件。<br>但在React中，可变的状态通常都保存在足组件的state中，并只能通过setState()方法控制其更新。这就称谓受控组建。</p><ul><li><p>受控组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameForm</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">value</span>: <span class="string">''</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.handleSubmit = <span class="keyword">this</span>.handleSubmit.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(event) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: event.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    alert(<span class="string">'A name was submitted: '</span> + <span class="keyword">this</span>.state.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          Name:</span><br><span class="line">          &lt;input type=<span class="string">"text"</span> value=&#123;<span class="keyword">this</span>.state.value&#125; onChange=&#123;<span class="keyword">this</span>.handleChange&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input type="submit" value="Submit" /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>由于 value 属性是在我们的表单元素上设置的，因此显示的值将始终为 React数据源上this.state.value 的值。由于每次按键都会触发 handleChange 来更新当前React的state，所展示的值也会随着不同用户的输入而更新。<br>它可以对每次的输入进行检验,需要设置value属性来完成，并在每次的点击时使用onChange（）来进行处理，并在onChange()通过setState（）进行重新渲染。</p></li><li><p>非受控组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">NameForm</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">   <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleSubmit = <span class="keyword">this</span>.handleSubmit.bind(<span class="keyword">this</span>);</span><br><span class="line">   </span><br><span class="line">   handleSubmit(event) &#123;</span><br><span class="line">    alert(<span class="string">'A name was submitted: '</span> + <span class="keyword">this</span>.input.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">   </span><br><span class="line">   render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          Name:</span><br><span class="line">          &lt;input type=<span class="string">"text"</span> ref=&#123;(input) =&gt; <span class="keyword">this</span>.input = input&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input type="submit" value="Submit" /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">   </span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>在 React 的生命周期中，表单元素上的 value 属性将会覆盖 DOM 中的值。使用非受控组件时，通常你希望 React 可以为其指定初始值，但不再控制后续更新。要解决这个问题，你可以指定一个 defaultValue 属性而不是 value。value值总是与文本框的最新内容保持一</p></li></ul><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p> Refs 提供了一种方式，用于访问在 render 方法中创建的 DOM 节点或 React 元素。<br> 通过ref将render中DOM节点或React元素进行指向。<br> 当一个 ref 属性被传递给一个 render 函数中的元素时，可以使用 ref 中的 current 属性对节点的引用进行访问。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomTextInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">   <span class="keyword">super</span>(props);</span><br><span class="line">   <span class="comment">// 创建 ref 存储 textInput DOM 元素</span></span><br><span class="line">   <span class="keyword">this</span>.textInput = React.createRef();</span><br><span class="line">   <span class="keyword">this</span>.focusTextInput = <span class="keyword">this</span>.focusTextInput.bind(<span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> focusTextInput() &#123;</span><br><span class="line">   <span class="comment">// 直接使用原生 API 使 text 输入框获得焦点</span></span><br><span class="line">   <span class="comment">// 注意：通过 "current" 取得 DOM 节点</span></span><br><span class="line">   <span class="keyword">this</span>.textInput.current.focus();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> render() &#123;</span><br><span class="line">   <span class="comment">// 告诉 React 我们想把 &lt;input&gt; ref 关联到构造器里创建的 `textInput` 上</span></span><br><span class="line">   <span class="keyword">return</span> (</span><br><span class="line">     &lt;div&gt;</span><br><span class="line">       &lt;input</span><br><span class="line">         type=<span class="string">"text"</span></span><br><span class="line">         ref=&#123;<span class="keyword">this</span>.textInput&#125; /&gt;</span><br><span class="line"></span><br><span class="line">         </span><br><span class="line">       &lt;input</span><br><span class="line">         type=<span class="string">"button"</span></span><br><span class="line">         value=<span class="string">"Focus the text input"</span></span><br><span class="line">         onClick=&#123;<span class="keyword">this</span>.focusTextInput&#125;</span><br><span class="line">       /&gt;</span><br><span class="line">     &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">   );</span></span><br><span class="line"><span class="regexp"> &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p> 回调Refs：<br> 不同于传递 createRef() 创建的 ref 属性，你会传递一个函数。这个函数接受 React 组件的实例或 HTML DOM 元素作为参数，以存储它们并使它们能被其他地方访问。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">CustomTextInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.textInput = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.setTextInputRef = <span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.textInput = element;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.focusTextInput = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 直接使用原生 API 使 text 输入框获得焦点</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.textInput) <span class="keyword">this</span>.textInput.focus();</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// 渲染后文本框自动获得焦点</span></span><br><span class="line">    <span class="keyword">this</span>.focusTextInput();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 使用 `ref` 的回调将 text 输入框的 DOM 节点存储到 React</span></span><br><span class="line">    <span class="comment">// 实例上（比如 this.textInput）</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"text"</span></span><br><span class="line">          ref=&#123;<span class="keyword">this</span>.setTextInputRef&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"button"</span></span><br><span class="line">          value=<span class="string">"Focus the text input"</span></span><br><span class="line">          onClick=&#123;<span class="keyword">this</span>.focusTextInput&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="React理念"><a href="#React理念" class="headerlink" title="React理念"></a>React理念</h2><ul><li>把UI划分出组件层级</li><li>用React创建一个静态版本</li><li>定义UI状态的最小且完整表示</li><li>确定State应该位于哪里</li><li>添加反向数据流</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要介绍React基础：包括React元素、React组件、React数据流、表单、列表等内容&lt;br&gt; &lt;a href=&quot;https://react.docschina.org/docs/introducing-jsx.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;React官方文档&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://yoursite.com/2018/10/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/10/24/设计模式/</id>
    <published>2018-10-24T01:00:00.000Z</published>
    <updated>2019-01-21T07:04:07.488Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍12种的设计模式，包括策略模式、装饰器模式、适配器模式、外观模式、模板模式、代理模式; 观察者模式、命令模式; 工厂模式、组合模式；状态模式、迭代器模式。<br>本文是学习《Head First设计模式》整理的博客。<br><a id="more"></a></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="OO基础"><a href="#OO基础" class="headerlink" title="OO基础"></a>OO基础</h2><ul><li>封装</li><li>继承</li><li>多态<h2 id="OO原则"><a href="#OO原则" class="headerlink" title="OO原则"></a>OO原则</h2></li><li><p>封装变化<br>找出应用中可能需要变化之处，把它们独立出来，不要和那不需要变化的代码混在一起</p></li><li><p>针对接口编程，不针对实现编程</p></li><li><p>多用组合，少用继承<br>继承是一种Is-A行为，而组合是一种Has-A行为<br>is-A比Has-A有更强的关系<br>has-A可以通过has接口，来实现has具体内容的多态，比is有更好的灵活性</p></li><li><p>类应该对扩展开发，对修改关闭<br>允许类容易扩展，在不修改现有代码的情况下，就可搭配新的行为<br>遵循开发-关闭原则，通常会引入新的抽象层次，增加代码复杂度。需要把注意力集中在设计中，最有可能改变的地方，然后应用，而不是每个部分都这样设计。</p></li></ul><h2 id="UML规定"><a href="#UML规定" class="headerlink" title="UML规定"></a>UML规定</h2><ul><li><p>继承： 实线空箭头</p></li><li><p>实现： 虚线空箭头</p></li><li><p>组合： 实线实箭头</p></li></ul><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>鸭子的故事：<br>绿头鸭：会飞行， 叫起来呱呱叫<br>红头鸭：会飞行, 叫起来吱吱叫<br>普通鸭：不会飞行，叫起来呱呱叫<br>橡皮鸭：不会飞行，叫起来唧唧叫<br>…</p><p>首先看到了鸭子，以及不同种类的鸭子<br>其次是看到了鸭子的2种行为，飞行与叫;<br>具体的飞行与叫声并不一一对应，不同的鸭子可能有相同的飞行行为与叫的行为</p><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="策略模式.png" alt=""></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>策略模式本质本质上是对动作、函数、算法等变化时的一种封装，将算法封装成算法族，一方面使之可以相互替换，另一方面增加了复用。<br>这里看到了一种n-m的情况，将n抽象,将m也抽象，然后前者组合后者。<br>也可降维使用，只有1-m的情况</p><h1 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h1><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><h2 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h2><p><img src="装饰器模式-1.png" alt=""></p><p><img src="装饰器模式-2.png" alt=""></p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><ul><li><p>装饰器(Decorator)在使用上有2个抽象维度，1个分类维度看作主维度（横向维度），另一个是次维度（纵向维度），在第二个维度上的各个量，是修饰第一个维度上的各个量，并且第二个维度上的各个量之间，没有先后次序，且可以累加使用。第二个维度上也应该是多个量，如果是单个量，也没必要如此使用</p></li><li><p>装饰器(Decorator)与代理有一些相似之处：</p><ul><li><p>相同之处：<br>首先对于装饰类与代理类都从一个父类来继承，拥有相同的接口，<br>而且都持有被装饰类与被代理类的引用。在调用接口时分不清代理与被代理或者装饰器与被装饰器。</p></li><li><p>不同之处：<br>装饰器模式，装饰类与被装饰类都有多个，是多对多的关系，而代理被代理一般是一对一的使用。<br>装饰器可以累加的使用，且没有先后关系的限制； 代理是在一个代理类中完成访问控制，至于控制的先后顺序，应该有关。</p></li></ul></li><li><p>应用：<br>感觉在预处理模块中，也可以使用，但需要写死被装饰的顺序，这点有些耦合过高。</p></li></ul><h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><p>适配器模式示例现实生活中有很多，比如前几天买的手机USB接口与PC的USB接口的转换器;或者head first中的不同插座之间的适配器。<br><img src="适配器模式-1.png" alt=""></p><h2 id="类图-2"><a href="#类图-2" class="headerlink" title="类图"></a>类图</h2><p><img src="适配器模式-2.png" alt=""></p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>适配器模式将一个类的接口，转换成客户期望的另一接口。让原本不兼容的类可以兼容。<br>适配器就涉及3个对象，被适配者、适配器、使用方，正对应于图1的三个部分。<br>系统出了新的接口，并面先行的接口编程，但为了兼容老的接口，便生成adapter，来转换老的接口。</p><h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><p>外观模式head first给出的实例是家庭影院，买了很多的设备，为了设置家庭影院，需要调灯光、调音箱，调投影仪，爆米花，关闭的时候还需要进行相反的关闭操作。</p><h2 id="类图-3"><a href="#类图-3" class="headerlink" title="类图"></a>类图</h2><p><img src="外观模式.png" alt=""></p><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>外观模式就是增加一个外观类，来完成对这些对象的调用配置，其实就是一个封装。</p><p>提出了与适配器模式不同的对比：<br>适配器模式中，只做接口的转换，而外观模式是封装对多个对象的调用，为客户提供统一的接口而已。</p><p>还提出一个原则：<br>最少知识原则：即，只和你的密友交谈。对于用户，涉及的对象越少越好。</p><h1 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h1><h2 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h2><p>head first给出了例子是煮咖啡与沏茶的例子：他俩的的过程相同，需要烧水，冲泡，倒到杯子里，加调料。他们的不同之处是冲泡的内容不同，添加的提案不同。<br>这样就设计了一个抽象类，用于将算法的逻辑写好，然后实现烧水、倒到杯子，将冲泡与加调料设置为抽象方法，而咖啡与茶只要去实现冲泡与加调料，就可以完成整个过程。</p><h2 id="类图-4"><a href="#类图-4" class="headerlink" title="类图"></a>类图</h2><p><img src="模板模式.png" alt=""></p><p>模板模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的步骤。</p><h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>从类图上看，模板模式很简单，就是一个继承结构，它的思想却挺有趣，首先一个算法是分几个步骤（函数）来实现的，在父类中将这个步骤的调用过程固定下来，并将需要子类实现的步骤定义为abstract类型，子类只需实现这些接口，就可以完成真个算法。</p><p>这样存在一个问题，即所有的步骤调用太固定，若有差异不够灵活，后来有了一些变易，它可以提前准备一些hook函数，子类通过实现不同的hook，来使整个算法的逻辑发生一点改变。</p><p>在应用上，像是sort函数需要传入compareaTo，就是这种思想的一种体现。</p><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><p>好莱坞原则：高层对待低层组建的方式，别调用我们，我们调用你。<br><img src="好莱坞原则.png" alt=""></p><p>我们在抽象工厂模式中，见过这种高层与低层组建关系的原则：依赖颠倒原则，即分离高层与低层的组件，让他们都以来接口。那时候的高层是工厂类，而低层是产品类接口。</p><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><h2 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h2><p>代理模式中，head first给出了3种：远程代理、虚拟代理、保护代理<br>远程代理： 远程代理指的是用一个电脑上的类、代理另外一台电脑上的一个类。例子是想统计想统计在经历的机器上来显示其他电脑上各糖果机器的情况。</p><p>虚拟代理： 就是缓存代理，对于大的对象，在对象时候的时候再去创建它。例子是从网络加载图像，通过虚拟代理，创建一个新的线程来加载图像，在没有加载完成一直使用虚拟带来应答，加载完成后，将请求再交给真实对象。</p><p>保护代理： 也就是动态代理，这里是把Java的动态代理讲的最明白的。动态代理意思是在运行时，才生成的代理对象。</p><h2 id="类图-5"><a href="#类图-5" class="headerlink" title="类图"></a>类图</h2><p><img src="代理模式-1.png" alt=""></p><p>代理模式为另一个对象提供一个替身或者占位符以控制对这个对象的访问。使用代理模式创建代表对象，让代表对象控制某对象的访问，被代理的对象可以是远程的对象、创建开销大的对象或需要安全控制的对象。</p><h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><ul><li><p>远程代理<br><img src="代理模式-远程代理.png" alt=""><br>Java提供远程代理的实现，由Java的命令（工具）自动实现客户辅助对象与服务辅助对象的创建，也就封装了代理对象（客户对象）与被代理对象（服务对象）之间的通讯。但还需要程序员去实现代理对象与被代理对象。<br>Java用的比较少一些，对于远程代理没用用过，而且现在的使用场合也不太确定，如果是BS或者CS之间的通信，用http、tcp/ip就可以完成通信；如果是S与S之间的通信，可以通过数据库+数据总线的方式来实现。</p></li><li><p>动态代理<br><img src="代理模式-动态代理.png" alt=""><br>这里是我觉得对Java的动态代理讲的最清楚的地方。它将代理包含在两个类中：Proxy以及InvocationHandler中，其中Proxy提供访问被代理类的接口，InvocationHandler真正访问被代理类，控制对被代理类的访问。<br>在使用上，先创建InvocationHandler类，并传入被代理的对象，在实现的Invoke接口中进行控制，通过控制的调用被代理对象的方法，在使用是，通过new Proxy对象（Proxy的创建会传入被代理类的接口，即他俩接口相同），并将InvocationHandler类来传入来实现真正的控制访问。</p></li></ul><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h2><h2 id="类图-6"><a href="#类图-6" class="headerlink" title="类图"></a>类图</h2><p><img src="观察者模式-2.png" alt=""></p><h2 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h2><p>  <img src="观察者模式-1.png" alt=""></p><ul><li><p>观察者模式是一方对多方单方发送数据的模型。<br>首先它是一方对多方，其中一的一方是Subject(或者Observable)，多的一方是Observer.<br>Subject中有一个Observer的列表， 当数据发生变化时，调用Observer的接口函数，将数据发送给列表中的各个Observer</p><p>其次它是单方发送据的，Observer只负责接收数据。<br>这里隐含一个变化，如果一个Observer要把数据发送给其他的Observer，是可以再调用Suject的set数据的函数，来完成数据分发的。</p></li><li><p>应用：<br>一个是flux中的pub与sub<br>另一个是android里的与后端通信，获取数据，然后使用数据的情况。</p></li></ul><h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><h2 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h2><p>Head First给出的示例是多功能遥控器<br>遥控器有一个插槽，可以插不同的遥控器，比如电视的、电灯的、风扇的等，最多有7种。<br>对于这些遥控器，预留出7对按钮，分别控制on与off</p><h2 id="类图-7"><a href="#类图-7" class="headerlink" title="类图"></a>类图</h2><p><img src="命令模式.png" alt=""></p><h2 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h2><ul><li><p>解析<br>命令模式中，由4种角色组成，命令执行者（命令接收者 receiver）、命令(commond)、命令的创建者、命令调用者(invoker)<br>命令本身封装了命令执行者，以及较固定的函数（exec()、undo()等）<br>命令的创建者创建命令以及执行者，并将执行者set进命令的地方。创建者是一个隐含的地方，可以是一个函数，并一定是类。<br>命令调用者负责调用命令的执行（exec）函数。</p><p>命令模式真正是通过对命令与命令执行者的封装，完成了命令创建者与命令调用者的解耦， 其实也完成了调用者与执行者的解耦。<br>在命令模式的例子中，执行者是电视、电灯，创建者是在main函数中，调用者是遥控器</p><p>这样，命令的调用者既可以用单个命令变量来存放命令，也可以用一个数组来存放多个命令，然后在执行时，便利去执行。在这种情况下涉及到一个问题，如果一个问题的处理需要一连串的命令，按顺序执行来完成，后一个命令的执行依赖于前一个命令执行的数据，这种情况下，是否适合使用命令模式？</p></li><li><p>应用<br>队列请求：<br>创建者将命令创建后，放如一个队列中，执行者在多个线程中快速并行调用这行命令。</p><p>重做日志：<br>命令模式还用于数据库的重做日志，将命令实现序列化的方法，store/load等接口进行持久化，然后在发生故障时，load命令进行执行，即可。</p></li><li><p>对比<br>其实有些像观察者模式，与观察者模式最大的不同在于，观察者模式中发布与订阅是一个一对多的关系，而在命令中，命令的创建者与调用者是一对一的关系。<br>另一个不同是，观察者模式中发送的只是一个小对象，比如一个字符串，或者一个bean。而在命令模式中，确是封装了执行者的命令。</p></li></ul><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><h2 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h2><p>批萨店做批萨;<br>不同地区的批萨店，对于同款产品，区域特点不一样;<br>同一批萨店，对于同款产品，有不同风味的做饭，采用的原料有一些差异</p><h2 id="类图-8"><a href="#类图-8" class="headerlink" title="类图"></a>类图</h2><ul><li><p>工厂模式<br><img src="工厂模式.png" alt=""><br>工厂模式：定义一个创建对象的接口，但由子类决定要实例化的类是哪一个，把类的实例化推迟到子类。</p></li><li><p>抽象工厂模式<br><img src="抽象工厂模式.png" alt=""><br>抽象工厂模式： 提用一个接口，用于创建相关或者以来对象的家族，而不需要指定具体类</p><h2 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h2><p>以前看的应该是抽象工厂模式，工厂模式较之类图结构更简单一些<br>工厂模式是抽象出了2个层级： 第一是创建者或者工厂，第二是产品类，由工厂来创建产品。产品类全部都继承自产品类本身，这样其实是把隐含的系列给隐掉了。</p></li></ul><p>抽象工厂也是有2个层级：创建者与产品。 创建者的层级与工厂模式类似，不同的是产品层级，产品层级细分，细分基本是依据创建者来分开的（具体情况下，不同工厂也会用相同的产品）。 其实在各个原料上，如Dough、Sauce、Cheese它们可以抽象成Ingredient（原料）类。这样以来，就会看出跟工厂模式更多的相似之处。创建者与产品之间的关系也必须是具体的，或者写死的。</p><p>另外一个不同可以看到，它将工厂变成的接口，是一个大的接口，必须包含所有的创建者的行为，即使在某个工厂中不需要这种行为，也得实现。</p><h2 id="原则-1"><a href="#原则-1" class="headerlink" title="原则"></a>原则</h2><p>依赖倒置原则：要依赖抽象，不要以来具体类。不能让高层组件依赖具体的低层组件，高层与低层组件，两者都应该依赖于抽象。</p><ul><li><p>变量不可以持有具体类的引用。<br>使用new事，就会持有具体的引用，可以使用工厂来避开这种做法</p></li><li><p>不要让类派生自具体的类。<br>如果派生自具体类，就会以来具体类，应该派生自一个接口</p></li><li><p>尽量不要覆盖基类中已实现的方法<br>基类中已实现的方法，应该由所有的子类共有。</p></li></ul><p>PS： 应该在有封装变化的时候，尽量靠近这些原则，而不是随时都要使用这些原则<br>    如一个不会改变的类，就可以在代码中直接实例化。</p><h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><h2 id="示例-9"><a href="#示例-9" class="headerlink" title="示例"></a>示例</h2><p>组合模式的实例也是与菜单相关，除了上边提到的3餐的菜单，餐厅想提供一份单独的甜点菜单，比如加到晚餐里。<br>这样菜单的结构发生了改变，它使得咖啡厅的晚餐菜单包括一个子菜单<br><img src="组合模式-1.png" alt=""></p><h2 id="类图-9"><a href="#类图-9" class="headerlink" title="类图"></a>类图</h2><p><img src="组合模式-2.png" alt=""></p><p><img src="组合模式-3.png" alt=""></p><p>组合模式允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。</p><h2 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h2><p>组合模式可以认为是将树在类中去实现。使用者对是组合还是单个对象而透明。</p><h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><h2 id="示例-10"><a href="#示例-10" class="headerlink" title="示例"></a>示例</h2><p>糖果售货机，投入硬币，摇动把手，出货;<br>若没有货，也会提示没货，然后退出硬币;<br>投入硬币后也可以直接退回硬币</p><p>这样有这样几种状态：无货， 未投币， 已投币， 出货<br><img src="状态模式-1.png" alt=""></p><h2 id="类图-10"><a href="#类图-10" class="headerlink" title="类图"></a>类图</h2><p><img src="状态模式-2.png" alt=""></p><p>状态模式允许对象在内部状态发生改变时，改变它的行为，对象看起来好像修改了它的类。</p><h2 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h2><p><img src="状态模式-3.png" alt=""></p><p><img src="状态模式-4.png" alt=""><br>在实现上，Context类中有所有的状态类（这里有4个），还有一个当前状态变量。State接口包括着所有可以执行的操作（引起状态变化的动作），具体状态实现所有的接口，然后在自己状态对应的操作里实现功能代码，并在这个操作里调用Context的设置状态函数，设置下一个状态。</p><p>这样状态转换的逻辑是放在状态中去掌握的，其实可以放在Context中去把握，我感觉更好一些。因为如果有别的Contex时，可以复用这些状态，而他们的状态转换逻辑可以放在自己的代码中。</p><h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><h2 id="示例-11"><a href="#示例-11" class="headerlink" title="示例"></a>示例</h2><p>不同餐厅的菜单用不同的数据结构来实现的，早点摊位用的是数组，午餐食堂用的是List，晚餐咖啡厅用的是HashMap。<br>现在有一个服务员，需要根据这些不同的菜单提供服务，非迭代器方式下，服务员需要对这些不同的菜单定义不同的遍历方法。而迭代器模式会使用使遍历使用相同的接口。</p><h2 id="类图-11"><a href="#类图-11" class="headerlink" title="类图"></a>类图</h2><p><img src="迭代器模式.png" alt=""></p><p>迭代器模式提供一种方法，能够顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。</p><h2 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h2><p>从类图上看，迭代器模式有些像工厂模式，毕竟每一个具体的Aggregate对象都对应唯一的Iterator对象。为不同的数据结构提供了统一的遍历接口。</p><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>一个类应该只有一个引起变化的原因。<br>类的每个职责都有改变的潜在区域。超过一个责任，意味着超过一个改变的区域。<br>内聚：当一个模块或者类被设计成只支持一组相关的功能时，我们说它具有高内聚，单一职责的原则的类，很容易就有高内聚，比低内聚的更容易维护。</p><p>可看作成封装的粒度建议。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍12种的设计模式，包括策略模式、装饰器模式、适配器模式、外观模式、模板模式、代理模式; 观察者模式、命令模式; 工厂模式、组合模式；状态模式、迭代器模式。&lt;br&gt;本文是学习《Head First设计模式》整理的博客。&lt;br&gt;
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>CSS基础</title>
    <link href="http://yoursite.com/2018/08/30/2018-8-30css/"/>
    <id>http://yoursite.com/2018/08/30/2018-8-30css/</id>
    <published>2018-08-30T03:29:35.000Z</published>
    <updated>2019-01-21T07:08:12.584Z</updated>
    
    <content type="html"><![CDATA[<p>主要介绍css与css3<br><a id="more"></a></p><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;<span class="attribute">color</span>:black;&#125;</span><br><span class="line"><span class="selector-tag">h1</span> &#123;<span class="attribute">color</span>:blue;&#125;</span><br><span class="line"><span class="selector-tag">h2</span> &#123;<span class="attribute">color</span>:silver;&#125;</span><br><span class="line"><span class="selector-tag">body</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">p</span>, <span class="selector-tag">table</span>, <span class="selector-tag">th</span>, <span class="selector-tag">td</span>, <span class="selector-tag">pre</span>, <span class="selector-tag">strong</span>, <span class="selector-tag">em</span> &#123;<span class="attribute">color</span>:gray;&#125;</span><br></pre></td></tr></table></figure><h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器 ."></a>类选择器 .</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.important</span> &#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.important</span> &#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure><h3 id="ID选择器"><a href="#ID选择器" class="headerlink" title="ID选择器"></a>ID选择器</h3><p><code>#intro {font-weight:bold;}</code></p><h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器 []"></a>属性选择器 []</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href]</span> &#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line"><span class="selector-tag">img</span><span class="selector-attr">[alt]</span> &#123;<span class="attribute">border</span>: <span class="number">5px</span> solid red;&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href="http://www.w3school.com.cn/about_us.asp"]</span> &#123;<span class="attribute">color</span>: red;&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[class~="important"]</span> &#123;<span class="attribute">color</span>: red;&#125;</span><br></pre></td></tr></table></figure><h3 id="后代选择器-空格"><a href="#后代选择器-空格" class="headerlink" title="后代选择器 空格"></a>后代选择器 空格</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h1 em &#123;color:red;&#125;</span><br></pre></td></tr></table></figure><h3 id="子元素选择器-gt"><a href="#子元素选择器-gt" class="headerlink" title="子元素选择器 &gt;"></a>子元素选择器 &gt;</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h1 &gt; strong &#123;color:red;&#125;</span><br><span class="line">table.company td &gt; p</span><br></pre></td></tr></table></figure><p>上面的选择器会选择作为 td 元素子元素的所有 p 元素，这个 td 元素本身从 table 元素继承，该 table 元素有一个包含 company 的 class 属性。</p><h3 id="兄弟选择器"><a href="#兄弟选择器" class="headerlink" title="兄弟选择器 +"></a>兄弟选择器 +</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h1 + p &#123;margin-top:50px;&#125;</span><br></pre></td></tr></table></figure><p>选择紧接在 h1 元素后出现的段落，h1 和 p 元素拥有共同的父元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">html &gt; body table + ul &#123;margin-top:20px;&#125;</span><br></pre></td></tr></table></figure><p>这个选择器解释为：选择紧接在 table 元素后出现的所有兄弟 ul 元素，该 table 元素包含在一个 body 元素中，body 元素本身是 html 元素的子元素。</p><h3 id="伪类"><a href="#伪类" class="headerlink" title="伪类 :"></a>伪类 :</h3><p>语法selector : pseudo-class {property: value}<br>锚伪类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a:link &#123;color: #FF0000&#125;/* 未访问的链接 */</span><br><span class="line"></span><br><span class="line">a:visited &#123;color: #00FF00&#125;/* 已访问的链接 */</span><br><span class="line"></span><br><span class="line">a:hover &#123;color: #FF00FF&#125;/* 鼠标移动到链接上 */</span><br><span class="line"></span><br><span class="line">a:active &#123;color: #0000FF&#125;/* 选定的链接 */</span><br><span class="line"></span><br><span class="line">:first-child 伪类</span><br><span class="line">p:first-child &#123;font-weight: bold;&#125;</span><br><span class="line"></span><br><span class="line">:lang 伪类</span><br><span class="line">:lang 伪类使你有能力为不同的语言定义特殊的规则。在下面的例子中，:lang 类为属性值为 no 的 q 元素定义引号的类型：</span><br></pre></td></tr></table></figure><h3 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素  :"></a>伪元素  :</h3><p>selector.class:pseudo-element {property:value;}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">:first-line 伪元素</span><br><span class="line">  p:first-line</span><br><span class="line">  &#123;</span><br><span class="line">  color:#ff0000;</span><br><span class="line">  font-variant:small-caps;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">:first-letter 伪元素</span><br><span class="line">  p:first-letter</span><br><span class="line">  &#123;</span><br><span class="line">  color:#ff0000;</span><br><span class="line">  font-size:xx-large;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>:before 伪元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">:before&quot; 伪元素可以在元素的内容前面插入新内容。</span><br><span class="line">  h1:before</span><br><span class="line">  &#123;</span><br><span class="line">  content:url(logo.gif);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">:after 伪元素</span><br><span class="line">  h1:after</span><br><span class="line">  &#123;</span><br><span class="line">  content:url(logo.gif);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li><p>background-color 背景色</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">background-color</span>: gray;&#125;</span><br></pre></td></tr></table></figure></li><li><p>background-image 背景图 </p><p>background:url();</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;<span class="attribute">background-image</span>: <span class="built_in">url</span>(/i/eg_bg_04.gif);&#125;</span><br></pre></td></tr></table></figure><p>css3中支持多重背景：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="attribute">background-image</span>:<span class="built_in">url</span>(bg_flower.gif),<span class="built_in">url</span>(bg_flower_2.gif);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>background-repeat 背景重复，与背景图结合使用</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span></span><br><span class="line">&#123; </span><br><span class="line"> <span class="attribute">background-image</span>: <span class="built_in">url</span>(/i/eg_bg_03.gif);</span><br><span class="line"> <span class="attribute">background-repeat</span>: repeat-y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>background-position 背景定位</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span></span><br><span class="line">&#123; </span><br><span class="line">  <span class="attribute">background-image</span>:<span class="built_in">url</span>(<span class="string">'/i/eg_bg_03.gif'</span>);</span><br><span class="line">  <span class="attribute">background-repeat</span>:no-repeat;</span><br><span class="line">  <span class="attribute">background-position</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 属性值包括：center，top，right，bottom，left；百分比；具体数值等。</p></li><li><p>background-attachment 背景关联<br>  如果文档比较长，那么当文档向下滚动时，背景图像也会随之滚动。当文档滚动到超过图像的位置时，图像就会消失。<br>  background-attachment:fixed</p></li><li><p>background-size CSS3中增加背景大小属性<br>%,px,em,ex等。</p></li><li><p>background-origin属性<br>值为context-box,padding-box,border-box等</p></li></ul><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><ul><li><p>font-family字体系列属性</p><p>CSS定义了五种通用字体系列：</p><p>Serif字体</p><p>Sans-serif字体</p><p>Monospace字体</p><p>Cursive字体</p><p>Fantasy字体</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;<span class="attribute">font-family</span>: sans-serif;&#125;</span><br></pre></td></tr></table></figure></li><li><p>font-style字体风格</p><p>该属性有三个值：</p><p>normal - 文本正常显示</p><p>italic - 文本斜体显示</p><p>oblique - 文本倾斜显示</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.normal</span> &#123;<span class="attribute">font-style</span>:normal;&#125;</span><br></pre></td></tr></table></figure></li><li><p>font-weight字体加粗属性</p><p>100 ~ 900 为字体指定了 9 级加粗度。100 对应最细的字体变形，900 对应最粗的字体变形。数字 400 等价于 normal，而 700 等价于 bold。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.thick</span> &#123;<span class="attribute">font-weight</span>:bold;&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.thicker</span> &#123;<span class="attribute">font-weight</span>:<span class="number">900</span>;&#125;</span><br></pre></td></tr></table></figure></li><li><p>font-size字体大小属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;<span class="attribute">font-size</span>:<span class="number">60px</span>;&#125;</span><br><span class="line"><span class="selector-tag">h2</span> &#123;<span class="attribute">font-size</span>:<span class="number">40px</span>;&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">font-size</span>:<span class="number">14px</span>;&#125;</span><br></pre></td></tr></table></figure></li><li><p>CSS3 @font-face 规则</p><p>通过 CSS3，web 设计师可以使用他们喜欢的任意字体。</p><p>当您您找到或购买到希望使用的字体时，可将该字体文件存放到 web 服务器上，它会在需要时被自动下载到用户的计算机上。</p><p>您“自己的”的字体是在 CSS3 @font-face 规则中定义的。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt; </span><br><span class="line">@<span class="keyword">font-face</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">font-family</span>: myFirstFont;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">'Sansation_Light.ttf'</span>),</span><br><span class="line">    <span class="built_in">url</span>(<span class="string">'Sansation_Light.eot'</span>); <span class="comment">/* IE9+ */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">font-family</span>:myFirstFont;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><ul><li><p>text-indent首行缩进<br>p {text-indent: 5em;}</p></li><li><p>text-align水平对齐<br>left\right\center</p></li><li><p>word-spacing字间距<br>p.spread {word-spacing: 30px;}</p></li><li><p>letter-spacing 字母间距<br>h4 {letter-spacing: 20px}</p></li><li><p>text-transform 字符转换<br>uppercase<br>lowercase<br>capitalize：首字母大写</p></li><li><p>text-decoration字体装饰<br>underline<br>overline<br>line-through<br>blink</p></li><li><p>direction 文本放下<br>影响块级元素中文本的书写方向、表中列布局的方向、内容水平填充其元素框的方向、以及两端对齐元素中最后一行的位置。</p></li><li><p>text-shadow css3中支持文本阴影：与box-shadow类似</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="attribute">text-shadow</span>: <span class="number">5px</span> <span class="number">5px</span> <span class="number">5px</span> <span class="number">#FF0000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>word-wrap分词CSS3属性</p></li><li><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">word-wrap</span>:break-word;&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>针对以下四种状态设置颜色、背景、字体修饰等等</p><p>  a:link - 普通的、未被访问的链接</p><p>  a:visited - 用户已访问的链接</p><p>  a:hover - 鼠标指针位于链接的上方</p><p>  a:active - 链接被点击的时刻</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ul><li><p>list-style-type列表类型</p><p>square</p></li><li><p>list-style-image列表图像</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span> &#123;<span class="attribute">list-style-image </span>: <span class="built_in">url</span>(xxx.gif)&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><ul><li><p>border<br>设置表格边框</p><ul><li><p>边框</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">table</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">border-collapse</span>:collapse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">table</span>,<span class="selector-tag">th</span>, <span class="selector-tag">td</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有boder-collapse,table的边框与th、td的边框会分离，成为2层</p></li><li><p>其他属性</p><p>表格的宽度与高度属性：width，height;<br>表格文本对齐属性:text-align<br>背景颜色<br>内边距等等</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">table</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">th</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>:green;</span><br><span class="line">  <span class="attribute">color</span>:white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">td</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">text-align</span>:right;</span><br><span class="line">  <span class="attribute">padding</span>:<span class="number">15px</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>轮廓outline</p><ul><li>outline是在border外了一层框</li><li>outline-color</li><li>outline-style</li><li>outline-width</li></ul></li></ul></li></ul><h2 id="框模型"><a href="#框模型" class="headerlink" title="框模型"></a>框模型</h2><ul><li><p>模型</p><p>从内至外：元素element、内边距padding、边框border、外边距margin</p><p><img src="框模型.png" alt="框模型"></p></li><li><p>padding</p><p>可以按照上、右、下、左的顺序分别设置各边的内边距<br><code>h1 {padding: 10px 0.25em 2ex 20%;}</code><br>等价于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">h1 &#123;</span><br><span class="line">  padding-top: 10px;</span><br><span class="line">  padding-right: 0.25em;</span><br><span class="line">  padding-bottom: 2ex;</span><br><span class="line">  padding-left: 20%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>border</p><p>border有3个属性：类型style，颜色color，宽度width<br>每一种属性都可以从top\right\bottom\left的角度来设置。<br><code>p {border:solid red 1px}</code></p></li><li><p>border-radius</p><p>css3中新增属性，用于圆角矩形<br><code>border-radius:25px;</code></p></li><li><p>box-shadow<br>增加边框的阴影效果<br><code>box-shadow: 10px 10px 5px #888888;</code><br>边框的相对位置，虚化，颜色</p></li><li><p>margin<br>与padding类似<br><code>h1 {margin : 10px 0px 15px 5px;}</code></p></li></ul><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><h3 id="display"><a href="#display" class="headerlink" title="display"></a>display</h3><p>div、h1 或 p 元素常常被称为块级元素。这意味着这些元素显示为一块内容，即“块框”。与之相反，span 和 strong 等元素称为“行内元素”，这是因为它们的内容显示在行中，即“行内框”。</p><p>您可以使用 display 属性改变生成的框的类型。这意味着，通过将 display 属性设置为 block，可以让行内元素（比如 <code>&lt;a&gt;</code> 元素）表现得像块级元素一样。还可以通过把 display 设置为 none，让生成的元素根本没有框。这样的话，该框及其所有内容就不再显示，不占用文档中的空间。</p><h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><ul><li><p>相对定位：移动后原位置保留</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#box_relative</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="相对定位.png" alt="相对定位"></p><p>在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框</p></li><li><p>绝对定位：移动后原位置不保留</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#box_relative</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="绝对定位.png" alt="绝对定位"></p><p>相对定位是“相对于”元素在文档中的初始位置,而绝对定位是“相对于”最近的已定位祖先元素，如果不存在已定位的祖先元素，那么“相对于”最初的包含块。</p></li></ul><h3 id="float"><a href="#float" class="headerlink" title="float"></a>float</h3><ul><li><p>简介</p><p>浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。</p></li><li><p>浮动</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.news</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.news</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clear</span> &#123;</span><br><span class="line"><span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三个框都向左移动，那么框 1 向左浮动直到碰到包含框，另外两个框向左浮动直到碰到前一个浮动框。</p><p><img src="浮动框并列.png" alt="浮动框并列"></p><p>如果包含框太窄，无法容纳水平排列的三个浮动元素，那么其它浮动块向下移动，直到有足够的空间</p><p><img src="浮动框下沉.png" alt="浮动框下沉"></p></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h3><h4 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h4><ul><li><p>如何水平对齐块级元素<br>块级元素指的是占据占据全部可用宽度的元素，并在其前后都会换行。<br><code>&lt;h1&gt;</code><br><code>&lt;p&gt;</code><br><code>&lt;div&gt;</code></p></li><li><p>使用margin来水平对齐<br>可通过将左和右外边距设置为 “auto”，来对齐块元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.center</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="attribute">margin</span>:auto;</span><br><span class="line"> <span class="attribute">width</span>:<span class="number">70%</span>;</span><br><span class="line"> <span class="attribute">background-color</span>:<span class="number">#b0e0e6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用position来进行左右对齐<br>当像这样对齐元素时，对 <body> 元素的外边距和内边距进行预定义是一个好主意。这样可以避免在不同的浏览器中出现可见的差异。</body></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line"> <span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="attribute">position</span>:absolute;</span><br><span class="line"> <span class="attribute">right</span>:<span class="number">0px</span>;</span><br><span class="line"> <span class="attribute">width</span>:<span class="number">300px</span>;</span><br><span class="line"> <span class="attribute">background-color</span>:<span class="number">#b0e0e6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用float属性来对齐</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.right</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="attribute">float</span>:right;</span><br><span class="line"> <span class="attribute">width</span>:<span class="number">300px</span>;</span><br><span class="line"> <span class="attribute">background-color</span>:<span class="number">#b0e0e6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h4><ul><li><p>height:元素的高度</p></li><li><p>width：元素的宽度</p></li><li><p>line-height:行高</p></li><li><p>max-height:最大高度</p></li><li>min-height</li><li>max-width：最大宽度</li><li>min-width</li></ul><h4 id="图片浮动"><a href="#图片浮动" class="headerlink" title="图片浮动"></a>图片浮动</h4>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">float</span>:right;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">120px</span>;</span><br><span class="line"><span class="attribute">margin</span>:<span class="number">0</span> <span class="number">0</span> <span class="number">15px</span> <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">padding</span>:<span class="number">15px</span>;</span><br><span class="line"><span class="attribute">border</span>:<span class="number">1px</span> solid black;</span><br><span class="line"><span class="attribute">text-align</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/i/eg_cute.gif"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">CSS is fun!</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="首字母"><a href="#首字母" class="headerlink" title="首字母"></a>首字母</h4>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">span</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">float</span>:left;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">0.7em</span>;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">400%</span>;</span><br><span class="line"><span class="attribute">font-family</span>:algerian,courier;</span><br><span class="line"><span class="attribute">line-height</span>:<span class="number">80%</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;span&gt;T&lt;/span&gt;his is some text.</span><br></pre></td></tr></table></figure><h4 id="无表格首页"><a href="#无表格首页" class="headerlink" title="无表格首页"></a>无表格首页</h4>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type="text/css"&gt;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.container</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">border</span>:<span class="number">1px</span> solid gray;</span><br><span class="line">  <span class="attribute">line-height</span>:<span class="number">150%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.header</span>,<span class="selector-tag">div</span><span class="selector-class">.footer</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">padding</span>:<span class="number">0.5em</span>;</span><br><span class="line">  <span class="attribute">color</span>:white;</span><br><span class="line">  <span class="attribute">background-color</span>:gray;</span><br><span class="line">  <span class="attribute">clear</span>:left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-class">.header</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.left</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">float</span>:left;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">160px</span>;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>:<span class="number">1em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.content</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">margin-left</span>:<span class="number">190px</span>;</span><br><span class="line">  <span class="attribute">border-left</span>:<span class="number">1px</span> solid gray;</span><br><span class="line">  <span class="attribute">padding</span>:<span class="number">1em</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="图片库"><a href="#图片库" class="headerlink" title="图片库"></a>图片库</h3><h4 id="图片库-1"><a href="#图片库-1" class="headerlink" title="图片库"></a>图片库</h4>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.img</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">3px</span>;</span><br><span class="line">  <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#bebebe</span>;</span><br><span class="line">  <span class="attribute">height</span>:auto;</span><br><span class="line">  <span class="attribute">width</span>:auto;</span><br><span class="line">  <span class="attribute">float</span>:left;</span><br><span class="line">  <span class="attribute">text-align</span>:center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.img</span> <span class="selector-tag">img</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="attribute">display</span>:inline;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">3px</span>;</span><br><span class="line">  <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#bebebe</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.img</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">img</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#333333</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.desc</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="attribute">text-align</span>:center;</span><br><span class="line">  <span class="attribute">font-weight</span>:normal;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>:<span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">10px</span> <span class="number">5px</span> <span class="number">10px</span> <span class="number">5px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">href</span>=<span class="string">"/i/tulip_ballade.jpg"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/i/tulip_ballade_s.jpg"</span> <span class="attr">alt</span>=<span class="string">"Ballade"</span> <span class="attr">width</span>=<span class="string">"160"</span> <span class="attr">height</span>=<span class="string">"160"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"desc"</span>&gt;</span>在此处添加对图像的描述<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>div的类为class包括链接与desc说明，其中链接是以图片为链接src的。<br>最值得注意的是，将a中的img设置为inline，而不是a</p><h4 id="图片透明度"><a href="#图片透明度" class="headerlink" title="图片透明度"></a>图片透明度</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">IMG</span> <span class="selector-pseudo">:HOVER</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">OPACITY</span>:<span class="number">0.4</span>;</span><br><span class="line"><span class="attribute">FILTER</span>:<span class="built_in">ALPHA</span>(OPACITY=40); <span class="comment">/* 针对 IE8 以及更早的版本 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="透明框中的文本"><a href="#透明框中的文本" class="headerlink" title="透明框中的文本"></a>透明框中的文本</h5>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.background</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">266px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">'/i/tulip_peach_blossom_w.jpg'</span>) no-repeat;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.transbox</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">338px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">204px</span>;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">  <span class="comment">/* for IE */</span></span><br><span class="line">  <span class="attribute">filter</span>:<span class="built_in">alpha</span>(opacity=60);</span><br><span class="line">  <span class="comment">/* CSS3 standard */</span></span><br><span class="line">  <span class="attribute">opacity</span>:<span class="number">0.6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.transbox</span> <span class="selector-tag">p</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">30px</span> <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"background"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"transbox"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  This is some text that is placed in the transparent box.</span><br><span class="line">  This is some text that is placed in the transparent box.</span><br><span class="line">  This is some text that is placed in the transparent box.</span><br><span class="line">  This is some text that is placed in the transparent box.</span><br><span class="line">  This is some text that is placed in the transparent box.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对backgroud设置背景图片与大小，然后在其中设置文本框，包括边距、透明度、背景颜色为白色很重要。透明度也是在白色背景基础上完成的。</p><h3 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h3><p>导航栏 = 链接列表</p><h4 id="水平菜单"><a href="#水平菜单" class="headerlink" title="水平菜单"></a>水平菜单</h4>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">float</span>:left;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line"><span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line"><span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line"><span class="attribute">list-style-type</span>:none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">float</span>:left;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">7em</span>;</span><br><span class="line"><span class="attribute">text-decoration</span>:none;</span><br><span class="line"><span class="attribute">color</span>:white;</span><br><span class="line"><span class="attribute">background-color</span>:purple;</span><br><span class="line"><span class="attribute">padding</span>:<span class="number">0.2em</span> <span class="number">0.6em</span>;</span><br><span class="line"><span class="attribute">border-right</span>:<span class="number">1px</span> solid white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Link one<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Link two<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Link three<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Link four<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="垂直菜单"><a href="#垂直菜单" class="headerlink" title="垂直菜单"></a>垂直菜单</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line"><span class="selector-tag">ul</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">list-style-type</span>:none;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">display</span>:block;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>:<span class="number">#dddddd</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h4 id="水平菜单-1"><a href="#水平菜单-1" class="headerlink" title="水平菜单"></a>水平菜单</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line"><span class="selector-tag">ul</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">list-style-type</span>:none;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">overflow</span>:hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">float</span>:left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">display</span>:block;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>:<span class="number">#dddddd</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h1 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h1><h2 id="2D转换transform"><a href="#2D转换transform" class="headerlink" title="2D转换transform"></a>2D转换transform</h2><ul><li><p>translate()移动</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(50px,100px);</span><br><span class="line">  <span class="attribute">-ms-transform</span>: <span class="built_in">translate</span>(50px,100px);<span class="comment">/* IE 9 */</span></span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">translate</span>(50px,100px);<span class="comment">/* Safari and Chrome */</span></span><br><span class="line">  <span class="attribute">-o-transform</span>: <span class="built_in">translate</span>(50px,100px);<span class="comment">/* Opera */</span></span><br><span class="line">  <span class="attribute">-moz-transform</span>: <span class="built_in">translate</span>(50px,100px);<span class="comment">/* Firefox */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>rotate()旋转</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="attribute">transform</span>: <span class="built_in">rotate</span>(30deg);</span><br><span class="line"> <span class="attribute">-ms-transform</span>: <span class="built_in">rotate</span>(30deg);<span class="comment">/* IE 9 */</span></span><br><span class="line"> <span class="attribute">-webkit-transform</span>: <span class="built_in">rotate</span>(30deg);<span class="comment">/* Safari and Chrome */</span></span><br><span class="line"> <span class="attribute">-o-transform</span>: <span class="built_in">rotate</span>(30deg);<span class="comment">/* Opera */</span></span><br><span class="line"> <span class="attribute">-moz-transform</span>: <span class="built_in">rotate</span>(30deg);<span class="comment">/* Firefox */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>scale()拉伸</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="attribute">transform</span>: <span class="built_in">scale</span>(2,4);</span><br><span class="line"> <span class="attribute">-ms-transform</span>: <span class="built_in">scale</span>(2,4);<span class="comment">/* IE 9 */</span></span><br><span class="line"> <span class="attribute">-webkit-transform</span>: <span class="built_in">scale</span>(2,4);<span class="comment">/* Safari 和 Chrome */</span></span><br><span class="line"> <span class="attribute">-o-transform</span>: <span class="built_in">scale</span>(2,4);<span class="comment">/* Opera */</span></span><br><span class="line"> <span class="attribute">-moz-transform</span>: <span class="built_in">scale</span>(2,4);<span class="comment">/* Firefox */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>skew()倾斜</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="attribute">transform</span>: <span class="built_in">skew</span>(30deg,20deg);</span><br><span class="line"> <span class="attribute">-ms-transform</span>: <span class="built_in">skew</span>(30deg,20deg);<span class="comment">/* IE 9 */</span></span><br><span class="line"> <span class="attribute">-webkit-transform</span>: <span class="built_in">skew</span>(30deg,20deg);<span class="comment">/* Safari and Chrome */</span></span><br><span class="line"> <span class="attribute">-o-transform</span>: <span class="built_in">skew</span>(30deg,20deg);<span class="comment">/* Opera */</span></span><br><span class="line"> <span class="attribute">-moz-transform</span>: <span class="built_in">skew</span>(30deg,20deg);<span class="comment">/* Firefox */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>matrix():</p><p>需要六个参数，包含数学函数，允许您：旋转、缩放、移动以及倾斜元素。</p></li></ul><h2 id="3D转换"><a href="#3D转换" class="headerlink" title="3D转换"></a>3D转换</h2><p>就是2D转换后加X、Y、Z、3D等表示在那个轴进行</p><p>如translate3d(x,y,z),translateX(x),translateY(y),translateZ(z)</p><h2 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h2><p>CSS3 过渡是元素从一种样式逐渐改变为另一种的效果。</p><p>  要实现这一点，必须规定两项内容：</p><p>  规定您希望把效果添加到哪个 CSS 属性上</p><p>  规定效果的时长</p><h3 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h3>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt; </span><br><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>:yellow;</span><br><span class="line">  <span class="attribute">transition</span>:width <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">-moz-transition</span>:width <span class="number">2s</span>; <span class="comment">/* Firefox 4 */</span></span><br><span class="line">  <span class="attribute">-webkit-transition</span>:width <span class="number">2s</span>; <span class="comment">/* Safari and Chrome */</span></span><br><span class="line">  <span class="attribute">-o-transition</span>:width <span class="number">2s</span>; <span class="comment">/* Opera */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt; </span><br><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>:yellow;</span><br><span class="line">  <span class="attribute">transition</span>:width <span class="number">2s</span>, height <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">-moz-transition</span>:width <span class="number">2s</span>, height <span class="number">2s</span>, -moz-transform <span class="number">2s</span>; <span class="comment">/* Firefox 4 */</span></span><br><span class="line">  <span class="attribute">-webkit-transition</span>:width <span class="number">2s</span>, height <span class="number">2s</span>, -webkit-transform <span class="number">2s</span>; <span class="comment">/* Safari and Chrome */</span></span><br><span class="line">  <span class="attribute">-o-transition</span>:width <span class="number">2s</span>, height <span class="number">2s</span>, -o-transform <span class="number">2s</span>; <span class="comment">/* Opera */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">transform</span>:<span class="built_in">rotate</span>(180deg);</span><br><span class="line">  <span class="attribute">-moz-transform</span>:<span class="built_in">rotate</span>(180deg); <span class="comment">/* Firefox 4 */</span></span><br><span class="line">  <span class="attribute">-webkit-transform</span>:<span class="built_in">rotate</span>(180deg); <span class="comment">/* Safari and Chrome */</span></span><br><span class="line">  <span class="attribute">-o-transform</span>:<span class="built_in">rotate</span>(180deg); <span class="comment">/* Opera */</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h2 id="动画-keyframes及animation"><a href="#动画-keyframes及animation" class="headerlink" title="动画@keyframes及animation"></a>动画@keyframes及animation</h2><p>如需在 CSS3 中创建动画，您需要学习 @keyframes 规则。</p><p>@keyframes 规则用于创建动画。在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果。</p><p>先用@keyframes创建动画，然后用animation绑定到div元素上。动画其实是上述过渡的更进一步。需要对各个浏览器进行匹配。</p><h3 id="背景色"><a href="#背景色" class="headerlink" title="背景色"></a>背景色</h3>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt; </span><br><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line"><span class="attribute">background</span>:red;</span><br><span class="line"><span class="attribute">animation</span>:myfirst <span class="number">5s</span>;</span><br><span class="line"><span class="attribute">-moz-animation</span>:myfirst <span class="number">5s</span>; <span class="comment">/* Firefox */</span></span><br><span class="line"><span class="attribute">-webkit-animation</span>:myfirst <span class="number">5s</span>; <span class="comment">/* Safari and Chrome */</span></span><br><span class="line"><span class="attribute">-o-animation</span>:myfirst <span class="number">5s</span>; <span class="comment">/* Opera */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">keyframes</span> myfirst</span><br><span class="line">&#123;</span><br><span class="line">0%   &#123;<span class="attribute">background</span>:red;&#125;</span><br><span class="line">25%  &#123;<span class="attribute">background</span>:yellow;&#125;</span><br><span class="line">50%  &#123;<span class="attribute">background</span>:blue;&#125;</span><br><span class="line">100% &#123;<span class="attribute">background</span>:green;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-<span class="keyword">moz</span>-<span class="keyword">keyframes</span> myfirst /* Firefox */</span><br><span class="line">&#123;</span><br><span class="line">0%   &#123;<span class="attribute">background</span>:red;&#125;</span><br><span class="line">25%  &#123;<span class="attribute">background</span>:yellow;&#125;</span><br><span class="line">50%  &#123;<span class="attribute">background</span>:blue;&#125;</span><br><span class="line">100% &#123;<span class="attribute">background</span>:green;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-<span class="keyword">webkit</span>-<span class="keyword">keyframes</span> myfirst /* Safari and Chrome */</span><br><span class="line">&#123;</span><br><span class="line">0%   &#123;<span class="attribute">background</span>:red;&#125;</span><br><span class="line">25%  &#123;<span class="attribute">background</span>:yellow;&#125;</span><br><span class="line">50%  &#123;<span class="attribute">background</span>:blue;&#125;</span><br><span class="line">100% &#123;<span class="attribute">background</span>:green;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-<span class="keyword">o</span>-<span class="keyword">keyframes</span> myfirst /* Opera */</span><br><span class="line">&#123;</span><br><span class="line">0%   &#123;<span class="attribute">background</span>:red;&#125;</span><br><span class="line">25%  &#123;<span class="attribute">background</span>:yellow;&#125;</span><br><span class="line">50%  &#123;<span class="attribute">background</span>:blue;&#125;</span><br><span class="line">100% &#123;<span class="attribute">background</span>:green;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h3>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">animation</span>: myfirst <span class="number">5s</span> linear <span class="number">2s</span> infinite alternate;</span><br><span class="line"><span class="comment">/* Firefox: */</span></span><br><span class="line"><span class="attribute">-moz-animation</span>: myfirst <span class="number">5s</span> linear <span class="number">2s</span> infinite alternate;</span><br><span class="line"><span class="comment">/* Safari 和 Chrome: */</span></span><br><span class="line"><span class="attribute">-webkit-animation</span>: myfirst <span class="number">5s</span> linear <span class="number">2s</span> infinite alternate;</span><br><span class="line"><span class="comment">/* Opera: */</span></span><br><span class="line"><span class="attribute">-o-animation</span>: myfirst <span class="number">5s</span> linear <span class="number">2s</span> infinite alternate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多列"><a href="#多列" class="headerlink" title="多列"></a>多列</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>通过 CSS3，您能够创建多个列来对文本进行布局 - 就像报纸那样！</p><p>多列属性：</p><p>column-count</p><p>column-gap</p><p>column-rule </p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt; </span><br><span class="line"><span class="selector-class">.newspaper</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">-moz-column-count</span>:<span class="number">3</span>; <span class="comment">/* Firefox */</span></span><br><span class="line"><span class="attribute">-webkit-column-count</span>:<span class="number">3</span>; <span class="comment">/* Safari and Chrome */</span></span><br><span class="line"><span class="attribute">column-count</span>:<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">-moz-column-gap</span>:<span class="number">30px</span>; <span class="comment">/* Firefox */</span></span><br><span class="line"><span class="attribute">-webkit-column-gap</span>:<span class="number">30px</span>; <span class="comment">/* Safari and Chrome */</span></span><br><span class="line"><span class="attribute">column-gap</span>:<span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要介绍css与css3&lt;br&gt;
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>HTML基础</title>
    <link href="http://yoursite.com/2018/08/30/2018-8-30html/"/>
    <id>http://yoursite.com/2018/08/30/2018-8-30html/</id>
    <published>2018-08-30T03:28:35.000Z</published>
    <updated>2019-01-21T07:03:59.480Z</updated>
    
    <content type="html"><![CDATA[<p>主要整理了html，html5</p><a id="more"></a><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><ul><li>HTML意思为超文本文档，首先是“文档”，类比word文档，有标题<code>&lt;h1&gt;-&lt;h6&gt;</code>，有段落<code>&lt;p&gt;</code>，有表格<code>&lt;table&gt;</code>，有图片<code>&lt;img&gt;</code>。其次是“超文本”，会有更多的元素，包括超链接<code>&lt;a href=&quot;&quot;&gt;</code>，视频，音频等等。所有这些元素各有各的属性、内容，用于对不同元素进行充实。</li><li>元素由三部分组成：标签、属性、内容。标签用于说明元素的类型，属性用来如何展示内容，内容是显示元素。</li></ul><h2 id="头部head"><a href="#头部head" class="headerlink" title="头部head"></a>头部head</h2><ul><li>title:标题，添加到收藏夹时显示的标题，</li><li>base定义页面上所有链接的默认地址。</li><li>link本文档与外部资源『文档』的关系</li><li>style：定义文档的样式信息。</li><li>script:客户端脚本</li><li>meta：关于HTML文档的元数据，包括作者，版权，描述，关键字，可用作搜素</li></ul><h2 id="js脚本"><a href="#js脚本" class="headerlink" title="js脚本"></a>js脚本</h2><ul><li><p><code>&lt;script&gt;</code>元素type=”text/javascript”，document.write来写入</p></li><li><p>位置</p><p>可以包含在header中，这样只有等js加载完成网页才能显示</p><p>js思想中推荐放在<code>&lt;body&gt;</code>最后，这样可以加速加载，具体使用看情况</p></li></ul><h2 id="文本元素"><a href="#文本元素" class="headerlink" title="文本元素"></a>文本元素</h2><p>包括align(对齐)、bgcolor（背景色）、color（字体颜色）等，都用style(样式)来替代。样式的好处可以直接添加到HTML元素，并将可以将样式在css文件中实现。</p><ul><li>对齐 style=”text-align:center”</li><li>字体 style=”font-family:verdana;color:red;font-size:20px;”</li><li><p>背景色 style=”background-color:red”</p></li><li><p>字体修改（b粗体、i斜体、big/small大小体、del删除、ins下划线、sub/sup上下标等各式）；</p></li><li>计算机输出（编程代码：code代码,var变量，kbd输入，samp代码样本，pre预各式）；</li><li>引用和属术语定义(abbr定义缩写，acronym首字母缩写，title属性显示完全内容，address定义地址)。</li></ul><h2 id="超文本元素"><a href="#超文本元素" class="headerlink" title="超文本元素"></a>超文本元素</h2><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><ul><li>链接有2种方式：href超链接，指向另一个文档的链接；另一个指向由name元素创建的文档内的书签。</li><li>超链接可以是文本，也可以是图像。</li><li>target=”_blank”，属性可以用来在新的文档中打开。</li></ul><h3 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h3><ul><li><code>&lt;img src=&quot;boat.gif&quot; alt=&quot;Big Boat&quot;&gt;</code></li><li>属性align=”bottom” “top” “middle” “left” “right”</li><li>属性width,height </li><li><p>map area</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">map</span> <span class="attr">name</span>=<span class="string">"planetmap"</span> <span class="attr">id</span>=<span class="string">"planetmap"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">area</span></span></span><br><span class="line"><span class="tag">  <span class="attr">shape</span>=<span class="string">"circle"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">coords</span>=<span class="string">"180,139,14"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">href</span>=<span class="string">"/example/html/venus.html"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">target</span>=<span class="string">"_blank"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">alt</span>=<span class="string">"Venus"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">area</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><ul><li><code>&lt;table&gt;&lt;/table&gt;</code> :border bgcolor background frame=”above” “box” “hsizes”</li><li>tr(table row)</li><li>td(table data) &amp;nbsp</li><li>th(table head)</li><li>caption</li><li>cellpadding</li><li>cellspacing</li></ul><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ul><li>无序列表<code>&lt;ul&gt;:&lt;li&gt;</code> 属性type=”circle” “square” “disc”</li><li>有序列表<code>&lt;ol&gt;</code>属性type=”A” “a” “I” “i”</li><li>定义列表dl,<code>&lt;dt&gt;</code>定义项目<code>&lt;dd&gt;</code>定义描述。</li></ul><h2 id="块与布局"><a href="#块与布局" class="headerlink" title="块与布局"></a>块与布局</h2><h3 id="块"><a href="#块" class="headerlink" title="块"></a>块</h3><ul><li>通过<code>&lt;div&gt;</code>与<code>&lt;span&gt;</code>将HTML元素组合起来。</li><li><p>块元素其实是模块化思想的结果。同CSS一起使用,<code>&lt;div&gt;</code>元素可以用于对大的内容块设置样式属性。另一个常见的用途是文档布局，它取代了使用表格定义布局的老式方法。 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"color:#00ff00"</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>&lt;span&gt;</code>更多的是对行内的进行修改。如注：这种情况。</p></li></ul><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul><li>对块进行分类，使我们能为元素的类定义CSS样式。</li><li>div标签的class = “cities”属性</li></ul><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><ul><li><code>&lt;div&gt;</code>元素用作布局，并能轻松通过CSS对其进行定位。</li><li>在head元素中的<code>&lt;style&gt;</code>元素来定义各个类的颜色、位置等信息。</li><li>在body元素中使用定义的类来显示内容。</li><li>header,footer,nav,section</li></ul><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><h3 id="响应式设计RWD"><a href="#响应式设计RWD" class="headerlink" title="响应式设计RWD"></a>响应式设计RWD</h3><ul><li>RWD能够以可变尺寸传递网页，对于平板和移动设备是必须的。</li><li>使用现成的CSS框架，Bootstrap。</li><li>meta charset=”utf-8”</li><li><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;http://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css&quot;&gt;</code></li><li>link之后可以在div中使用类”container”,”jumbotron”,”row”,”col-md-4”等属性来控制样式。</li></ul><h3 id="frame"><a href="#frame" class="headerlink" title="frame"></a>frame</h3><ul><li>所谓框架，就是在一个页面中，使用一定的布局来显示多个html文档</li><li>frameset标签</li><li>rows/columns属性，规定了每行或者每列的占屏比例。</li><li><code>&lt;frame src=&quot;frame_a.html&quot; noresize=&quot;noresize&quot;&gt;</code></li></ul><h3 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h3><p>可以在body元素中使用，并可通过name属性命名，可通过target=””来选择内联框架使用。类似于”_blank”</p><h2 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h2><ul><li>类似于C语言中的\作用，转义：<ul><li>空格   &amp;nbsp</li><li><code>&lt;</code>   &amp;lt</li><li><code>&gt;</code>   &amp;gt</li><li><code>&amp;</code>   &amp;amp</li><li><code>&quot;</code>   &amp;quot</li><li><code>*</code>   &amp;times</li><li><code>/</code>  &amp;divides</li></ul></li></ul><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><h3 id="form"><a href="#form" class="headerlink" title="form"></a>form</h3><p>  <code>&lt;form&gt;</code>表单用于收集用户的输入</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">.</span><br><span class="line">表单元素</span><br><span class="line">.</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  表单元素指的是不同类型的输入元素、复选框、单选按钮、提交按钮等等。</p><h3 id="input"><a href="#input" class="headerlink" title="input"></a>input</h3><ul><li><p>type</p><p>| 类型      | 描述              |<br>| -        | -:                |<br>| text     | 定义常规文本输入     |<br>| radio    | 单选按钮            |<br>| checkbox | 复选框             |<br>| button   | 按钮，响应onclick   |<br>| submit   | 提交按钮           |<br>| password | 字符会被做掩码处理  |<br>| file     | 上传文档          |<br>| image    | 上传图片          |<br>| email    | html5增加，检查@   |<br>| number   | html5增加，检查数字 |<br>| range    | html5增加，滑动块   |<br>| date     | html5增加，日期     |<br>| datetime | html5增加，日期时间 |<br>| color    | html5增加，颜色 |<br>| url      | html5增加，url |</p></li></ul><pre><code><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">name</span>=<span class="string">"points"</span> <span class="attr">min</span>=<span class="string">"0"</span> <span class="attr">max</span>=<span class="string">"10"</span> <span class="attr">step</span>=<span class="string">"3"</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"male"</span> <span class="attr">checked</span>&gt;</span>Male</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"female"</span>&gt;</span>Female</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"alert('Hello World!')"</span> <span class="attr">value</span>=<span class="string">"Click Me!"</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">Birthday:</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"date"</span> <span class="attr">name</span>=<span class="string">"bday"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></code></pre><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>  下拉框</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"cars"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"volvo"</span>&gt;</span>Volvo<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"saab"</span>&gt;</span>Saab<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"fiat"</span>&gt;</span>Fiat<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"audi"</span>&gt;</span>Audi<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="textarea"><a href="#textarea" class="headerlink" title="textarea"></a>textarea</h3><p>  多行输入</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">"message"</span> <span class="attr">rows</span>=<span class="string">"10"</span> <span class="attr">cols</span>=<span class="string">"30"</span>&gt;</span></span><br><span class="line">The cat was playing in the garden.</span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="datalist"><a href="#datalist" class="headerlink" title="datalist"></a>datalist</h3><p>  datalist也是下拉框，但可以输入数据，可以看到预设的option</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"action_page.php"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">list</span>=<span class="string">"browsers"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">"browsers"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Internet Explorer"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Firefox"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Chrome"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li><p>autocomplete</p><p>表单的记忆功能，对input与form都有效，与private类似，父标签声明对子标签有用，子标签的声明大于的声明。</p></li><li><p>autofocus</p><p>自定义焦点，对于input可能会更有用一些。</p></li><li><p>表单的form属性</p><p>实现了在form外声明表单的可能。</p></li><li><p>formaction属性</p><p>为submit标签，提供了，重载action的方法。</p></li><li><p>list属性</p><ul><li>规定输入域的datalist（选项列表） </li><li>list=”url_list”</li><li><code>&lt;datalist id=&quot;url_list&quot;&gt;</code></li></ul></li><li><p>multiple属性</p><ul><li>规定输入框中可以选择多个值</li><li><code>&lt;input type=&quot;file&quot; name=&quot;img&quot; multiple=&quot;multiple&quot; /&gt;</code></li></ul></li><li><p>novalidate属性</p><ul><li>novalidate属性规定在提交表单时不应该验证form或input域</li><li><code>&lt;form action=&quot;demo_form.asp&quot; method=&quot;get&quot; novalidate=&quot;true&quot;&gt;</code></li><li>在这种情况下，type=”email”时就不再验证@</li></ul></li><li><p>pattern属性</p><ul><li>用于验证ipnut域的模式，正则表达式</li><li><code>&lt;input type=&quot;text&quot; name=&quot;country_code&quot; pattern=&quot;[A-Z]{3}&quot; title=&quot;three letter country code&quot; /&gt;</code></li></ul></li><li><p>placeholder</p><ul><li>属性提供一种提示，描述输入域所期待的值</li><li><code>&lt;input type=&quot;search&quot; name=&quot;user_search&quot; placeholder=&quot;Search W3School&quot; /&gt;</code></li></ul></li><li><p>required</p><ul><li>required属性规定必须在提交之前写输入域（不能为空）</li><li><code>&lt;input type=&quot;text&quot; name=&quot;usr_name&quot; required=&quot;required&quot; /&gt;</code></li></ul></li></ul><h1 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li>RIA技术</li><li>服务器、浏览器的交互历史：文本、图片、声音、动画、可交互游戏、游戏</li><li>flex、sliverlight、flash、html5</li></ul><h3 id="发展简史"><a href="#发展简史" class="headerlink" title="发展简史"></a>发展简史</h3><ul><li>html1.0 (1993) </li><li>html 2.0 (1994) </li><li>html4.0(1999),使用最多。</li><li>w3c组织–&gt; xhtml –&gt; xhtml2.0 (xml标准)这个版本被主流浏览器公司有意见</li><li>主流浏览器厂商组织WHATGW，2004年提出html5.0草案 –&gt; 合并成一个2008年提出html5.0</li></ul><h3 id="HTML5-约等于-HTML-CSS3-Javascript-APIs"><a href="#HTML5-约等于-HTML-CSS3-Javascript-APIs" class="headerlink" title="HTML5 约等于 HTML+CSS3+Javascript APIs"></a>HTML5 约等于 HTML+CSS3+Javascript APIs</h3><ul><li><p>HTML5支持了Css3的强大的选择器和动画等功能， 再加上支持了Javascript的新的函数API，所以就很强大了。</p></li><li><p>chrome、firefox、opera；UC、QQ、百度等</p></li></ul><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li><p>增加了<code>&lt;header&gt;&lt;footer&gt;</code>标签，做到内容与结构分离，我们很多网页都有头和尾</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span>网页的头部<span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">hell,world</span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span>网页的尾部<span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>增加了<code>&lt;canvas&gt;</code>标签，画布标签，程序员可以在这里绘制图形，在一定程度上可替代flash</p></li><li><p>增加了<code>&lt;video&gt;</code> 和 <code>&lt;audio&gt;</code>标签，用于音频和视频的嵌入功能<br>使视频与音频的嵌入变得简单<br>1、这里的video支持ogg格式与mp4格式<br>2、如果把这个html5_2.html放在apache下，就可以看这个视频。</p></li><li><p>增加离线存储功能</p></li></ul><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">width</span>=<span class="string">"320"</span> <span class="attr">height</span>=<span class="string">"240"</span> <span class="attr">controls</span>=<span class="string">"controls"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"/i/movie.ogg"</span> <span class="attr">type</span>=<span class="string">"video/ogg"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>video的属性包括</p><ul><li>autoplay </li><li>controls</li><li>height/width</li><li>loop</li><li>preload</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span>=<span class="string">"controls"</span> <span class="attr">autoplay</span>=<span class="string">"autoplay"</span> <span class="attr">loop</span>=<span class="string">"loop"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>video + dom 进行控制</p><ul><li><p><code>&lt;video&gt;</code>元素同样拥有方法、属性和事件。<br>方法用于播放、暂停以及加载等。<br>属性（时长、音量等）可以被读取或设置<br>其中的DOM事件能够通知您，如<code>&lt;video&gt;</code>元素开始播放、已暂停、已停止等。</p></li><li><p>示例：<br>先用<code>&lt;div&gt;</code>画出<code>&lt;button&gt;</code>与<code>&lt;video&gt;</code>，在<code>&lt;button&gt;</code>中指定槽函数<br>然后用<code>&lt;script&gt;</code>脚本，来获取到<code>&lt;video&gt;</code>元素，在槽函数的实现中，完成对<code>&lt;video&gt;</code>的控制如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"playPause()"</span>&gt;</span>播放/暂停<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"makeBigger"</span>&gt;</span>大<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"makeSmaller"</span>&gt;</span>小<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">video</span> <span class="attr">id</span>=<span class="string">"v1"</span> <span class="attr">controls</span>=<span class="string">"controls"</span> <span class="attr">width</span>=<span class="string">"400"</span> <span class="attr">heigh</span>=<span class="string">"400"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"/example/html5/move.bbb.mp4"</span> <span class="attr">type</span>=<span class="string">"video/mp4"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> testVedio = <span class="built_in">document</span>.getElementById(<span class="string">"v1"</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">playPause</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="undefined">  &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span>(testVedio.paused)</span></span><br><span class="line"><span class="undefined">    testVedio.play();</span></span><br><span class="line"><span class="javascript">  <span class="keyword">else</span></span></span><br><span class="line"><span class="undefined">    testVedio.pause();</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">makeBigger</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="undefined">  &#123;</span></span><br><span class="line"><span class="undefined">    testVedio.width += 20;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">makeSmaller</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="undefined">  &#123;</span></span><br><span class="line"><span class="undefined">    testVedio.width -= 20;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">scipt</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>总结：先用<code>&lt;div&gt;</code>将控件、视频等画出，在通过<code>&lt;script&gt;</code>将使用的函数实现。类似于C的全局实现</p></li><li><p>方法、属性以及事件<br>方法：play()、pause()、load()<br>  属性：paused、height、width、muted、volume、ended；可以通过对属性的控制来实现方法的控制。可以都认为是public<br>  事件：play/pause/ended等等。</p></li></ul></li></ul><h3 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h3><ul><li><p>示例1</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">"song.ogg"</span> <span class="attr">controls</span>=<span class="string">"controls"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>示例2</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>=<span class="string">"controls"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"song.ogg"</span> <span class="attr">type</span>=<span class="string">"audio/ogg"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"song.mp3"</span> <span class="attr">type</span>=<span class="string">"audio/mp3"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;audio&gt;</code>元素允许有多个source。source元素可以链接不同的音频文件。浏览器将使用第一个可视频的格式。</p></li><li><p>标签属性</p><p>与视频相同属性包括：controls/autoplay/loop/preload<br>还包括一种src</p></li></ul><h3 id="画布"><a href="#画布" class="headerlink" title="画布"></a>画布</h3><p> <code>&lt;canvas&gt;</code>使用JavaScript在网页上绘制图像。画图是一个矩形区域，您可以控制其每一个像素。canvas拥有每种绘制路径、矩形、圆形、字符以及添加图像的方法。</p><ul><li><p>基本运用</p><ul><li><p>创建Canvas元素 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"myCanvas"</span> <span class="attr">width</span>=<span class="string">"200"</span> <span class="attr">height</span>=<span class="string">"100"</span> <span class="attr">style</span>=<span class="string">"border:1px solid #c3c3c3;"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>通过JavaScript来绘制</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javacript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> c=<span class="built_in">document</span>.getElementById(<span class="string">"myCanvas"</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> cxt=c.getContext(<span class="string">"2d"</span>);</span></span><br><span class="line"><span class="javascript">cxt.fillStyle = <span class="string">"#FF0000"</span>;</span></span><br><span class="line"><span class="undefined">cxt.fillRect(0,0,150,75);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Javascript的绘制函数</p><ul><li><p>直线</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cxt.moveTo(10,10);   //移动到起始位置</span><br><span class="line">cxt.lineTo(150,50);  //画线到（150，50）</span><br><span class="line">cxt.lineTo(10,50);   //从(150,10),画到(10,50)</span><br><span class="line">cxt.stroke();</span><br></pre></td></tr></table></figure></li><li><p>画圆</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cxt.fillStyle="#FF0000";</span><br><span class="line">cxt.beginPath();</span><br><span class="line">cxt.arc(70,18,15,0,Math.PI*2,true);  // 圆心（70，18）半径15</span><br><span class="line">cxt.closePath();</span><br><span class="line">cxt.fill();    // 与stroke()等类似</span><br></pre></td></tr></table></figure></li><li><p>渐变色</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var grd=cxt.createLinearGradient(0,0,175,50);  //创建线性梯度/斜率</span><br><span class="line">grd.addColorStop(0, "#FF0000");  </span><br><span class="line">grd.addColorStop(1, "#00FF00");  // 从红色到绿色的渐进</span><br><span class="line">cxt.fillStyle=grd;</span><br><span class="line">cxt.fillRect(0,0,170,50);</span><br></pre></td></tr></table></figure></li><li><p>图像</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var img=new Image();</span><br><span class="line">img.src="flower.png";</span><br><span class="line">cxt.drawImage(img,0,0);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h3><ul><li><p>基本概念</p><ul><li>SVG可伸缩矢量图形(Scalable Vector Graphics)</li><li>用于定义网络的基于矢量的图形</li><li>使用XML格式定义图形</li><li>图像在放大或者缩小时，图形质量不会有损失</li></ul></li><li><p>优势</p><ul><li>可通过文本编辑器来创建和修改</li><li>在任何分辨率下被高质量的打印，在图像质量不下降的情况下放大。</li></ul></li><li><p>实例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/2000/svg"</span> <span class="attr">version</span>=<span class="string">"1.1"</span> <span class="attr">height</span>=<span class="string">"190"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">polygon</span> <span class="attr">points</span>=<span class="string">"100,40 40,180 190,60 10,60 160,180"</span> </span></span><br><span class="line"><span class="tag">               <span class="attr">style</span>=<span class="string">"fill:red;stroke:blue;stroke-width:3;fill-rule:evenodd;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>说明<br>// 画多边形，从一个点到另一个点</p><p>// 动词fill为填充，stroke为线</p></li><li><p>SVG VS 画布</p><ul><li><p>Canvas</p><ul><li>依赖分辨率</li><li>不支持事件处理器</li><li>弱的文本渲染能力</li><li>最适合图像密集型游戏，其中的许多对象会被频繁重绘</li></ul></li><li><p>SVG</p><ul><li>不依赖分辨率</li><li>支持事件处理器</li><li>最适合带有大型渲染区域的应用（谷歌地图）</li><li>复杂度高会减慢渲染速度</li><li>不适合游戏应用，（由于复杂度高，频繁重绘效率低下）</li></ul></li></ul></li></ul><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="地理定位"><a href="#地理定位" class="headerlink" title="地理定位"></a>地理定位</h3><ul><li><p>简介</p><p>地理定位使用navigator.geolocation.getCurrentPosition();函数来实现</p><p>航海家.地理位置.获取当前坐标。可以传递函数作为参数。</p></li><li><p>实例</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span>点击这个按钮，获得您的坐标：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"getLocation()"</span>&gt;</span>试一下<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> x=<span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">getLocation</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="undefined">&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">if</span> (navigator.geolocation)</span></span><br><span class="line"><span class="undefined">    &#123;</span></span><br><span class="line"><span class="undefined">    navigator.geolocation.getCurrentPosition(showPosition,showError);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">else</span>&#123;x.innerHTML=<span class="string">"Geolocation is not supported by this browser."</span>;&#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">showPosition</span>(<span class="params">position</span>)</span></span></span><br><span class="line"><span class="undefined">&#123;</span></span><br><span class="line"><span class="javascript">  x.innerHTML=<span class="string">"Latitude: "</span> + position.coords.latitude + </span></span><br><span class="line"><span class="javascript">  <span class="string">"&lt;br /&gt;Longitude: "</span> + position.coords.longitude;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">showError</span>(<span class="params">error</span>)</span></span></span><br><span class="line"><span class="undefined">&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">switch</span>(error.code) </span></span><br><span class="line"><span class="undefined">    &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">case</span> error.PERMISSION_DENIED:</span></span><br><span class="line"><span class="javascript">      x.innerHTML=<span class="string">"User denied the request for Geolocation."</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">case</span> error.POSITION_UNAVAILABLE:</span></span><br><span class="line"><span class="javascript">      x.innerHTML=<span class="string">"Location information is unavailable."</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">case</span> error.TIMEOUT:</span></span><br><span class="line"><span class="javascript">      x.innerHTML=<span class="string">"The request to get user location timed out."</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">case</span> error.UNKNOWN_ERROR:</span></span><br><span class="line"><span class="javascript">      x.innerHTML=<span class="string">"An unknown error occurred."</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">break</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>getCurrentPosition()方法</p><p>若成功是重返回纬度(latitude)经度(longitude)以及(accuracy)</p><p>  coords.latitude（纬度）</p><p>  coords.longitude（经度）</p><p>  coords.accuracy（经纬的精度）</p><p>  coords.altitude（海拔）</p><p>  coords.altitudeAccuracy(海拔精度)</p><p>  coords.heading（方向）</p><p>  coords.speed(速度）</p><p>  timestamp:时间戳</p></li></ul><h3 id="Web存储"><a href="#Web存储" class="headerlink" title="Web存储"></a>Web存储</h3><ul><li><p>简介</p><ul><li><p>HTML5提供两种客户端存储数据的方法：</p><p>localStorage：永久的存储</p><p>sessionStorage：基于会话的存储</p></li><li><p>对于不同网站，数据存储于不同区域，一个网站只能访问其自身的数据</p></li><li><p>HTML5使用Javascript来存储和访问数据。</p></li></ul></li><li><p>localStorage</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span>(localStorage.pagecount)</span></span><br><span class="line"><span class="undefined">&#123;</span></span><br><span class="line"><span class="javascript">    localStorage.pagecount = <span class="built_in">Number</span>(localStorage.pagecount)+<span class="number">1</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">else</span></span></span><br><span class="line"><span class="undefined">&#123;</span></span><br><span class="line"><span class="undefined">    localStorage.pagecount = 1;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="javascript">documents.write(<span class="string">"visits:"</span> + localStorage.pagecount + <span class="string">"times."</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>sessionStorage</p><p>sessionStorage与lacalStorage类似用法，只不过在关闭网页后，数据清空</p></li></ul><h3 id="应用存储"><a href="#应用存储" class="headerlink" title="应用存储"></a>应用存储</h3><ul><li><p>简介</p><ul><li><p>HTML5引入了应用程序缓存，应用可以从服务端缓存数据，在没有网络连接时，也可进行访问。</p></li><li><p>优势：</p><p>离线浏览</p><p>速度更快</p><p>减少服务器负载，浏览器只从服务器下载更新过的资源即可。</p></li></ul></li><li><p>实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html manifest=&quot;demo.appache&quot;&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p>Cache Manifest基础</p><ul><li>如需启动应用缓存，在<code>&lt;html&gt;</code>标签中包含manifest属性，并指定manifest文件，扩展 名为 .appache</li><li>浏览器根据manifest文件，对内容进行缓存</li></ul></li><li><p>Manifest文件</p><p>三部分：</p><p>  CACHE MANIFEST:首次打开后进行缓存</p><p>  NETWORK:必须联网，不缓存</p><p>  FALLBACK:断网时的回退界面</p></li><li><p>实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line"># 注释2012-02-21 v1.0.0</span><br><span class="line">/theme.css</span><br><span class="line">/logo.gif</span><br><span class="line">/main.js</span><br><span class="line"></span><br><span class="line">NETWORK:</span><br><span class="line">login.asp</span><br><span class="line"></span><br><span class="line">FALLBACK:</span><br><span class="line">/html5/ /404.html</span><br></pre></td></tr></table></figure></li></ul><h3 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h3><ul><li><p>简介</p><ul><li>当在HTML执行脚本是，页面的状态是堵塞的，知道脚本执行完成</li><li>web worker 是运行在后台的JavaScript，独立与其他脚本，不堵塞（多线程）</li></ul></li><li><p>实例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>计数：<span class="tag">&lt;<span class="name">output</span> <span class="attr">id</span>=<span class="string">"result"</span>&gt;</span><span class="tag">&lt;/<span class="name">output</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"startWorker()"</span>&gt;</span>开始Worker<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"stopWorker()"</span>&gt;</span>开始Worker<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> w;  <span class="comment">// 在此处直接定义会是定时技术延迟3个500ms</span></span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">startWorker</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="undefined">    &#123;</span></span><br><span class="line"><span class="undefined">      # 注意是否支持Woker</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span>(<span class="keyword">typeof</span>(Worker)!=<span class="string">"undefined"</span>)</span></span><br><span class="line"><span class="undefined">      &#123;</span></span><br><span class="line"><span class="undefined">      # 判断变量是否定义</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(<span class="keyword">typeof</span>(w)==<span class="string">"undefined"</span>)</span></span><br><span class="line"><span class="undefined">        &#123;</span></span><br><span class="line"><span class="undefined">          # 创建worker</span></span><br><span class="line"><span class="javascript">          w=<span class="keyword">new</span> Worker(<span class="string">"/example/html5/demo_workers.js"</span>);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        # 相应消息，注意function的写法</span></span><br><span class="line"><span class="javascript">        w.onMessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span></span></span><br><span class="line"><span class="undefined">        &#123;</span></span><br><span class="line"><span class="undefined">          # 注意内容的展示</span></span><br><span class="line"><span class="javascript">          <span class="built_in">document</span>.getElementeById(<span class="string">"result"</span>).innerHTML=event.data;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">"result"</span>).innerHTML=<span class="string">"您的浏览器不支持Worker"</span></span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">stopWorker</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="undefined">    &#123;</span></span><br><span class="line"><span class="undefined">      # 停止worker</span></span><br><span class="line"><span class="undefined">      w.terminate();</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>demo_workers.js的内容如下</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeCount</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  i=i+<span class="number">1</span>;</span><br><span class="line">  # 注意消息的发送</span><br><span class="line">  postMessage(i);</span><br><span class="line">  setTimeOut(<span class="string">"timeCount()"</span>, <span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line">timeCount();</span><br></pre></td></tr></table></figure></li><li><p>注意</p><p>由于worker存在与外部文件中，它无法访问一下的javascript对象</p><p>window对象</p><p>  document对象</p><p>  parent对象</p></li></ul><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><ul><li><p>简介</p><p>Server-Sent事件-单向消息传递</p><p>Server-Sent事件指的是网页自动获取来自服务器的更新。</p><p>  之前的做法是网页轮询是否有更新。但通过服务器发送事件，更新能自动到达</p></li><li><p>实例</p><ul><li><p>客户端</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;h1&gt;获取服务器更新&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">  &lt;div id="result"&gt;&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span>(EventSource)!==<span class="string">"undefined"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">var</span> source = <span class="keyword">new</span> EventSource(<span class="string">"/example/html5/demo_sse.php"</span>);</span><br><span class="line">      source.onmessage=<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">"result"</span>).innerHTML=event.data + <span class="string">"&lt;br /&gt;"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">"result"</span>).innerHTML=<span class="string">"您的浏览器不支持server-sent"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>服务端</p></li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">header(<span class="string">'Content-Type: text/event-stream'</span>);</span><br><span class="line">header(<span class="string">'Cache-Control: no-cache'</span>);</span><br><span class="line"></span><br><span class="line">$time = date(<span class="string">'r'</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"data: The server time is: &#123;$time&#125;\n\n"</span>;</span><br><span class="line">flush();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>疑问</p><p>在EventSource中已经定义了服务器脚本的存在，那岂不是在客户端自己这就可以产生此技术？</p><p>服务器的运行时怎样实现的？</p></li></ul></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>【控件】HTML的学习类似与Qt的学习，首先需要学习的是各个控件的使用，包括：按钮/输出/音频/视频/画布/SVG、地理定位/客户端存储/应用缓存/worker，还要学习各种表单的使用、表格/输入类型：下拉框/输入框，输入框的属性：自动完成、自动foucus、 属性提示、唯一性提示、多属性、不检查有效性等等。</li><li>【布局】除了部件的学习，还有布局的学习，布局大约使用CSS，可以等到CSS时深入学习</li><li>【操作】学习用JavaScript来实现槽函数的控制</li><li>【方式】对于前端、后端结构的理解</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要整理了html，html5&lt;/p&gt;
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>k8s简介</title>
    <link href="http://yoursite.com/2018/08/28/2018-8-28k8s%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2018/08/28/2018-8-28k8s简介/</id>
    <published>2018-08-28T09:01:37.000Z</published>
    <updated>2019-01-29T09:08:36.445Z</updated>
    
    <content type="html"><![CDATA[<p>本篇简介了k8s，是对k8s官方文档的摘要</p><a id="more"></a><h1 id="k8s架构"><a href="#k8s架构" class="headerlink" title="k8s架构"></a>k8s架构</h1><p><img src="k8s架构.png" alt="k8s架构图"></p><p><a href="https://kubernetes.io/docs/concepts/" target="_blank" rel="noopener">k8s官方文档</a></p><h2 id="Master-Components"><a href="#Master-Components" class="headerlink" title="Master Components"></a>Master Components</h2><ul><li><p>kube-apiserver<br>k8s的前端， 向外界暴露Kubernates API</p></li><li><p>etcd<br>高可用的key-value存储，用于保存所有集群数据。</p></li><li><p>kube-scheduler<br>监视新创建的、还没有分配node的pods，并选择一个node去运行。<br>调度时考虑的因素包括： 单个及集合的资源需要、软硬件策略的限制、数据本地性等等</p></li><li><p>kube-controller-manager<br>master中运行controller的部分。逻辑上，每一个controller都是独立的进程，但为了降低复杂度，他们被编译进一个二进制文件、运行在一个进程里。</p></li></ul><table><thead><tr><th>cotroller</th><th style="text-align:right">作用</th></tr></thead><tbody><tr><td>Node Controller</td><td style="text-align:right">负责发现、响应node下线</td></tr><tr><td>Replication Controller</td><td style="text-align:right">按replication controller对象的设置，维护正确数量的pod</td></tr><tr><td>Endpoints Controller</td><td style="text-align:right">填入Endpoint对象，意味着连接Service与Pod</td></tr><tr><td>Service Account&amp;Token Controllers</td><td style="text-align:right">为一个新的namespace, 创建默认账户以及API access tokens</td></tr></tbody></table><ul><li><p>cloud-controller-manager（CCM）<br>cloud-controller-manager（CCM）是kubernets 1.6发布的功能，它主要运行与基础云提供着相关的controller。而这些controller以前是在kube-controller-manager(KCM)中。现在，我们需要在KCM中失能相关的controller。</p><p>早期版本中,k8s核心代码依赖于云提供者， CCM的出现使云提供者代码与k8s代码解耦。</p><p>CCM主要运行以下Controller(依赖于云提供者)</p></li></ul><table><thead><tr><th>controller</th><th style="text-align:right">作用</th></tr></thead><tbody><tr><td>Node Controller</td><td style="text-align:right">当node停止响应后，检查云提供者，node是否已经删除</td></tr><tr><td>Router Controller</td><td style="text-align:right">在基础的云设施中，建立路由</td></tr><tr><td></td></tr></tbody></table><h2 id="Node-Components"><a href="#Node-Components" class="headerlink" title="Node Components"></a>Node Components</h2><ul><li>kubelet</li><li>kube-proxy</li><li>container runtime</li></ul><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>  k8s包含一些可以代表当前系统状态的抽象，比如部署容器化的应用和工作符合（workloads），与网络及硬件资源的联系等等，这些抽象被定义成了api的对象，这些对象可以分成2部分：基本对象与控制对象（Controllers）</p><ul><li><p>基本对象：</p><ul><li>Pod</li><li>Service</li><li>Volume</li><li>Namespace</li></ul></li><li><p>控制对象：</p><ul><li>ReplicaSet</li><li>Deployment</li><li>StatefulSet</li><li>Job</li></ul></li></ul><h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇简介了k8s，是对k8s官方文档的摘要&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>docker基础</title>
    <link href="http://yoursite.com/2018/08/28/2018-8-28docker%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/08/28/2018-8-28docker基础/</id>
    <published>2018-08-28T07:56:35.000Z</published>
    <updated>2019-01-21T07:07:52.976Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.docker.com/get-started/" target="_blank" rel="noopener"></a><br>本文内容从docker官方文档摘抄，仅介绍基础概念，将与swarm相关的service、stack都没载入<br><a id="more"></a></p><h1 id="Docker基础"><a href="#Docker基础" class="headerlink" title="Docker基础"></a>Docker基础</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><p>image 与 container<br>A container is launched by running an image. An image is an executable package that includes everything needed to run an application–the code, a runtime, libraries, environment variables, and configuration files.<br>容器就是跑镜像的，镜像包括了程序运行的所有资源,包括代码，运行时，lib，环境变量，配置文件等</p></li><li><p>container 与 docker<br><img src="docker结构.png" alt="docker结构"><br>容器跑在docker上，每个容器之间相互独立。docker运行在host os之上</p><p><img src="纵观docker.png" alt="纵观docker"></p><p><img src="docker工作流程.png" alt="docker工作流程"></p></li></ul><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li><p>docker帮助<br>docker<br>docker COMMAND –help<br>docker container –help</p></li><li><p>docker版本<br>docker –version</p></li><li><p>docker的信息<br>docker info<br>列出docker的基本信息，包括Container状态，image个数等</p></li><li><p>运行image<br>docker run hello-world</p></li><li><p>列出image<br>docker image ls</p></li><li><p>列出container<br>docker container ls        # running<br>docker container ls –all  # all<br>docker container ls -aq    # all in quiet mode</p></li><li><p>列出云节点[对于swarms]<br>docker node ls</p></li><li><p>列出所有服务[对于swarms]<br>docker service ls</p></li><li><p>查看某个服务具体信息[对于swarms]<br> docker service ps 服务id</p></li></ul><h2 id="containers"><a href="#containers" class="headerlink" title="containers"></a>containers</h2><ul><li><p>层级结构<br>Container(底层)<br>Services: 定义container的行为[defines how containers behave in production]<br>Stack:  定义service的相互作用[defines the interacions of all the services]</p></li><li><p>Dockerfile</p><ol><li>映射容器内的资源与容器外的，如端口，磁盘等</li><li>指明需要从外部环境中copy到容器的文件</li></ol><p>创建一空目录，然后在里边创建一Dockerfile格式如下：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 引用一个官方的python镜像 Use an official Python runtime as a parent image</span><br><span class="line">FROM python:2.7-slim</span><br><span class="line"></span><br><span class="line"># 设置工作目录</span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"># 将当前目录copy到容器的/app下</span><br><span class="line">ADD . /app</span><br><span class="line"></span><br><span class="line"># 在容器内安装需要的包 Install any needed packages specified in requirements.txt</span><br><span class="line">RUN pip install --trusted-host pypi.python.org -r requirements.txt</span><br><span class="line"></span><br><span class="line"># 容器内暴露的虚拟端口80 </span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line"># 环境变量 </span><br><span class="line">ENV NAME World</span><br><span class="line"></span><br><span class="line"># 启动容器时运行命令 </span><br><span class="line">CMD [&quot;python&quot;, &quot;app.py&quot;]</span><br></pre></td></tr></table></figure><ul><li><p>app<br>在Dockerfile同级目录下创建2个文件，requirements.txt以及app.py.<br>其中requirements.txt是依赖包，而app.py可以拓展为应用代码<br>这样在Dockerfile被创建为image时，requirements.txt，以及app.py都会被copy到容器内部，由于ADD . /app命令，同时，也可以用80来访问了。<br>pip  install -r requirements.txt只是为python安装了Flask与Redis库，redis本身并没有运行。</p><p>requirements.txt  #依赖包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Flask </span><br><span class="line">Redis</span><br></pre></td></tr></table></figure><p>app.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">from redis import Redis, RedisError</span><br><span class="line">import os</span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line"># Connect to Redis</span><br><span class="line">redis = Redis(host=&quot;redis&quot;, db=0, socket_connect_timeout=2, socket_timeout=2)</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&quot;/&quot;)</span><br><span class="line">def hello():</span><br><span class="line">    try:</span><br><span class="line">        visits = redis.incr(&quot;counter&quot;)</span><br><span class="line">    except RedisError:</span><br><span class="line">        visits = &quot;&lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;&quot;</span><br><span class="line"></span><br><span class="line">    html = &quot;&lt;h3&gt;Hello &#123;name&#125;!&lt;/h3&gt;&quot; \</span><br><span class="line">           &quot;&lt;b&gt;Hostname:&lt;/b&gt; &#123;hostname&#125;&lt;br/&gt;&quot; \</span><br><span class="line">           &quot;&lt;b&gt;Visits:&lt;/b&gt; &#123;visits&#125;&quot;</span><br><span class="line">    return html.format(name=os.getenv(&quot;NAME&quot;, &quot;world&quot;), hostname=socket.gethostname(), visits=visits)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    app.run(host=&apos;0.0.0.0&apos;, port=80)</span><br></pre></td></tr></table></figure></li><li><p>构建app镜像<br>在同目录下执行：<br>docker build -t firendlshello </p></li><li><p>查看镜像<br>docker image ls</p></li><li><p>运行镜像<br>docker run -p 4000:80 friendlyhello<br>这样在外部需要用4000来访问，<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></p></li><li><p>查看运行中的container<br>docker container ls</p></li><li><p>停止container<br>docker container stop “CONTATINER ID”</p></li><li><p>分享镜像[暂时略过]<br>类似于github，有个dockerhub，可以通过docker push 来上传镜像</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://docs.docker.com/get-started/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;/a&gt;&lt;br&gt;本文内容从docker官方文档摘抄，仅介绍基础概念，将与swarm相关的service、stack都没载入&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>git配置</title>
    <link href="http://yoursite.com/2018/08/28/2018-8-28git%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/08/28/2018-8-28git配置/</id>
    <published>2018-08-28T04:02:35.000Z</published>
    <updated>2019-01-21T07:08:11.172Z</updated>
    
    <content type="html"><![CDATA[<p>主要就是git的配置，包括代理、多个git账户使用配置。</p><a id="more"></a><h1 id="git代理"><a href="#git代理" class="headerlink" title="git代理"></a>git代理</h1><h2 id="启动代理"><a href="#启动代理" class="headerlink" title="启动代理"></a>启动代理</h2><h2 id="http方式设置"><a href="#http方式设置" class="headerlink" title="http方式设置"></a>http方式设置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global https.proxy http://127.0.0.1:1080</span><br><span class="line">git config --global https.proxy https://127.0.0.1:1080</span><br></pre></td></tr></table></figure><p>其他设置（待验证）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy socks5://127.0.0.1:1080</span><br><span class="line">git config --global https.proxy socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure></p><h2 id="取消http设置"><a href="#取消http设置" class="headerlink" title="取消http设置"></a>取消http设置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure><h2 id="ssh方式设置"><a href="#ssh方式设置" class="headerlink" title="ssh方式设置"></a>ssh方式设置</h2><p>使用 <a href="mailto:git@xxoo.com" target="_blank" rel="noopener">git@xxoo.com</a> 这种方式，是用的 SSH 协议。需要在 ~/.ssh/config 目录下配置<br>Host xxoo.com(改成你的站点)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ProxyCommand connect -H 127.0.0.1:1080 %h %p</span><br></pre></td></tr></table></figure></p><h1 id="多个git账户使用"><a href="#多个git账户使用" class="headerlink" title="多个git账户使用"></a>多个git账户使用</h1><h2 id="生成新的ssh"><a href="#生成新的ssh" class="headerlink" title="生成新的ssh"></a>生成新的ssh</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"for duoda"</span></span><br></pre></td></tr></table></figure><h2 id="执行ssh-agent让ssh识别新的私钥"><a href="#执行ssh-agent让ssh识别新的私钥" class="headerlink" title="执行ssh-agent让ssh识别新的私钥"></a>执行ssh-agent让ssh识别新的私钥</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-agent bash</span><br><span class="line">ssh-add ~/.ssh/id_rsa_duoda</span><br></pre></td></tr></table></figure><h2 id="将新的ssh-pub放到gitlab的ssh下"><a href="#将新的ssh-pub放到gitlab的ssh下" class="headerlink" title="将新的ssh-pub放到gitlab的ssh下"></a>将新的ssh-pub放到gitlab的ssh下</h2><h2 id="配置-ssh-config"><a href="#配置-ssh-config" class="headerlink" title="配置.ssh/config"></a>配置.ssh/config</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Host jiangjunyouling.gitlab.com</span><br><span class="line">HostName gitlab.com</span><br><span class="line">User jiangyunyouling</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line"></span><br><span class="line"><span class="comment"># second </span></span><br><span class="line">Host duodasunyanfeng.gitlab.com</span><br><span class="line">HostName gitlab.com</span><br><span class="line">User duodasunyanfeng</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_duoda</span><br></pre></td></tr></table></figure><p>这一步花费了很多功夫，现解释一下：</p><p>Host类似与一个key值，用来代表其下的内容<br>HostName 这里需要写仓库的地址，gitlab.com才可，使用账号名是不好使的<br>User有人写的是git，这里我写的都是账号名，经过测试，并不影响结果<br>IndentityFile是私钥的位置</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>使用时可以先用ssh -T 进行测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@jiangjunyouling.gitlab.com</span><br><span class="line">ssh -T git@duodasunyanfeng.gitlab.com</span><br></pre></td></tr></table></figure><p>这里需要注意2点：</p><ul><li>要使用git@的形式才可，直接使用git -T jiangjunyouling.gitlab.com不可以</li><li>git@后面的值为Host的值，也就是key值，若Host为 duodasunyanfeng 则 ssh -T git@duodasunyanfeng 即可</li></ul><h2 id="clone代码库"><a href="#clone代码库" class="headerlink" title="clone代码库"></a>clone代码库</h2><p>在clone时，原来的地址：<a href="mailto:git@gitlab.com" target="_blank" rel="noopener">git@gitlab.com</a>:duobang/xxxx.git<br>要修改为：<a href="mailto:git@duodasunyanfeng.gitlab.com" target="_blank" rel="noopener">git@duodasunyanfeng.gitlab.com</a>:duobang/xxxx.git来指明使用那个进行clone</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要就是git的配置，包括代理、多个git账户使用配置。&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>git使用</title>
    <link href="http://yoursite.com/2018/08/28/2018-8-28git%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/08/28/2018-8-28git使用/</id>
    <published>2018-08-28T03:02:35.000Z</published>
    <updated>2019-01-21T07:20:16.099Z</updated>
    
    <content type="html"><![CDATA[<p>主要就是git仓库概念与分支概念，git比较多，链接几篇博文。<br><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">git仓库概念与基础命令</a><br><a href="https://www.jianshu.com/p/7d0026305569" target="_blank" rel="noopener">git分支管理</a><br><a href="https://www.jianshu.com/p/f7451177476a" target="_blank" rel="noopener">git回滚</a><br><a href="https://www.jianshu.com/p/cc740394faf5" target="_blank" rel="noopener">git分支重命名</a></p><p>以下内容从这几篇文章中摘抄了git仓库<br><a id="more"></a></p><h1 id="git仓库"><a href="#git仓库" class="headerlink" title="git仓库"></a>git仓库</h1><p><img src="git仓库.png" alt="git仓库概念"></p><p> Workspace：工作区<br> Index / Stage：暂存区<br> Repository：仓库区（或本地仓库）<br> Remote：远程仓库</p><h1 id="git分支"><a href="#git分支" class="headerlink" title="git分支"></a>git分支</h1><h2 id="master分支"><a href="#master分支" class="headerlink" title="master分支"></a>master分支</h2><p> 在我们没有创建分支时，git会默认给我们创建一个master分支。刚才讲的HEAD是指向分支的，即当前分支，在这就是指向master分支，而master才是指向提交的。<br> <img src="git的master分支.png" alt="git的master分支"></p><p> 每次提交，master分支都会向前进一步。<br> <img src="master分支移动.png" alt="master分支移动"></p><h2 id="dev分支"><a href="#dev分支" class="headerlink" title="dev分支"></a>dev分支</h2><p> 当我们创建一个分支dev时，Git会创建一个新的指针dev，dev指针会指向master相同的提交版本节点，而HEAD也会指向 dev分支上，即当前版本是dev上的当前最新版本。</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git branch dev       //创建分支</span><br><span class="line">git checkout dev   // 切换分支</span><br><span class="line">或</span><br><span class="line">git checkout -b dev //创建并切换分支</span><br></pre></td></tr></table></figure><p><img src="创建dev分支.png" alt="创建dev分支"></p><p>当我们创建分支并切换到该分支后，Git会将HEAD指向所创建的分支dev上，从而我们以后再提交时，master分支的指针将不会改变，而dev分支的指针会向前移动。<br><img src="dev指针移动.png" alt="dev指针移动"></p><h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><p>有创建就会有合并， 在dev上的工作做完后，就可以把dev分支和master分支合并，合并也非常简单，只需要将master指向dev的当前提交即可。合并之后，HEAD会指向master分支。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge dev //快速模式合并，直接将当前所处分支指针指向dev的当前提交版本。</span><br></pre></td></tr></table></figure></p><p><img src="合并dev分支.png" alt="合并dev分支"></p><p>合并冲突<br>在现实情况下，多多少少还是会出现在merge的时候出现冲突的，即同一个文件在两个分支中都被修改了，在合并时使用快速合并模式*就会产生冲突。<br><img src="分支冲突.png" alt="合并冲突"></p><h2 id="重命名分支"><a href="#重命名分支" class="headerlink" title="重命名分支"></a>重命名分支</h2><ul><li>重命名本地</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m oldName newName</span><br></pre></td></tr></table></figure><ul><li>重命名远程分支</li></ul><p>先重命名本地分支，然后删除远程分支，再把本地分支推动送到远程（创建远程分支），最后与远程分支与本地分支关联</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git branch -m oldName newName</span><br><span class="line"></span><br><span class="line">git push --delete origin oldName</span><br><span class="line"></span><br><span class="line">git push origin newName</span><br><span class="line"></span><br><span class="line">git branch --set-upstream-to origin/newName</span><br></pre></td></tr></table></figure><h2 id="工作区隐藏与分支"><a href="#工作区隐藏与分支" class="headerlink" title="工作区隐藏与分支"></a>工作区隐藏与分支</h2><p>在实际的开发过程中，我们需要去修复一个bug时，我们一般都会去创创建一个issue分支去修复这个bug，所以我们会把当前的工作现场存储起来。</p><p>将当前工作现场隐藏<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure></p><p>bug处理完成，删除issue分支</p><p>查看stash内的工作区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure></p><p>工作区恢复<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git stash apply stash@&#123;0&#125; //恢复现场</span><br><span class="line">git stash drop stash@&#123;0&#125; //删除stash内的stash@&#123;0&#125;工作区</span><br><span class="line">或</span><br><span class="line">git stash pop stash@&#123;0&#125; //恢复现场并删除stash@&#123;0&#125;工作区</span><br></pre></td></tr></table></figure></p><h1 id="git回滚相关"><a href="#git回滚相关" class="headerlink" title="git回滚相关"></a>git回滚相关</h1><h2 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h2><p>reset 为 重置到这次提交，将内容重置到指定的版本。git reset 命令后面是需要加2种参数的：–-hard 和 –-soft。这条命令默认情况下是 -–soft。</p><p>执行上述命令时，这该条commit号之 后（时间作为参考点）的所有commit的修改都会退回到git缓冲区中。使用git status 命令可以在缓冲区中看到这些修改。而如果加上-–hard参数，则缓冲区中不会存储这些修改，git会直接丢弃这部分内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft commit_id</span><br><span class="line">git reset --hard commit_id</span><br></pre></td></tr></table></figure><h2 id="反回滚"><a href="#反回滚" class="headerlink" title="反回滚"></a>反回滚</h2><p>你回滚之后，又后悔了，想恢复到新的版本怎么办？</p><p>用git reflog打印你记录你的每一次操作记录,然后再次执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br><span class="line">git reset --hard commit_id</span><br></pre></td></tr></table></figure><h1 id="git代码量统计"><a href="#git代码量统计" class="headerlink" title="git代码量统计"></a>git代码量统计</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --author=&quot;username&quot; --pretty=tformat: --numstat | awk &apos;&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %s\n&quot;, add, subs, loc &#125;&apos; -</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要就是git仓库概念与分支概念，git比较多，链接几篇博文。&lt;br&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;git仓库概念与基础命令&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.jianshu.com/p/7d0026305569&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;git分支管理&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.jianshu.com/p/f7451177476a&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;git回滚&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.jianshu.com/p/cc740394faf5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;git分支重命名&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以下内容从这几篇文章中摘抄了git仓库&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>mongo使用总结</title>
    <link href="http://yoursite.com/2018/08/25/2018-8-25mongo%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/08/25/2018-8-25mongo使用总结/</id>
    <published>2018-08-25T11:36:49.000Z</published>
    <updated>2019-01-21T07:01:26.460Z</updated>
    
    <content type="html"><![CDATA[<p>总结在8月份开发过程中对mongo使用经验</p><a id="more"></a><h1 id="mongo的基本操作"><a href="#mongo的基本操作" class="headerlink" title="mongo的基本操作"></a>mongo的基本操作</h1><p>数组中元素的修改都是基于这按元素查询$elemMatch而来，然后通过$来选择哪一个</p><h2 id="数组的元素查询"><a href="#数组的元素查询" class="headerlink" title="数组的元素查询"></a>数组的元素查询</h2><ul><li>实例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> this.db.collection(&quot;tunnelWorkSection&quot;).findOne(</span><br><span class="line">  &#123;</span><br><span class="line">       tunnelID:tunnelID,</span><br><span class="line">       workSectionList:&#123;$elemMatch:&#123;workSectionName: workSection&#125;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">       _id:0, &quot;workSectionList.$&quot;:1</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这样的结果竟然只查询了一个结果，即若workSectionName有多个匹配结果会只查出一个,即使使用find也是如此。</p><ul><li>倒不如用unwind方法来进行查询</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.tunnelWorkSection.aggregate([&#123;$match:&#123;tunnelID:tunnelID&#125;&#125;,&#123;$unwind:&quot;$workSectionList&quot;&#125;, &#123;$match:&#123;&quot;workSectionList.workSectionName&quot;: workSection&#125;&#125;])</span><br></pre></td></tr></table></figure><p>  如此查询的结果就是查询到了所有的，但是拍平的结果。</p><h2 id="数组中元素的修改"><a href="#数组中元素的修改" class="headerlink" title="数组中元素的修改"></a>数组中元素的修改</h2><ul><li>实例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">await this.db.collection(&quot;tunnelWorkSection&quot;).updateOne(</span><br><span class="line">  &#123;</span><br><span class="line">     tunnelID: tunnelID, </span><br><span class="line">     workSectionList:&#123;$elemMatch:&#123;workSectionName: workSection&#125;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;$inc: &#123;&apos;workSectionList.$.finishLength&apos;: finishLength &#125; &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="数组中元素的删除"><a href="#数组中元素的删除" class="headerlink" title="数组中元素的删除"></a>数组中元素的删除</h2><p>按之前的写法，应该很容易写成下边方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">await this.db.collection(&quot;tunnelWorkSection&quot;).updateOne(</span><br><span class="line">   &#123;</span><br><span class="line">      tunnelID: tunnelID, </span><br><span class="line">      workSectionList:&#123;$elemMatch:&#123;workSectionName: workSection&#125;&#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;$pull: &#123;workSectionList:&apos;workSectionList.$&apos;&#125; &#125;</span><br><span class="line"> )</span><br></pre></td></tr></table></figure><p>但很不幸的是，不好使。原因大概是’workSectionList.$’放在value上，只会被认为是字符串。经过几次测试，从数组中删除元素只需要如此即可，pull与pullAll：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.students.update(&#123;tunnelID:tunnelID&#125;,&#123;$pull:&#123;workSectionList:&#123;workSectionName:workSection&#125;&#125;&#125;)</span><br><span class="line"></span><br><span class="line">        await this.db.collection(this.tunnelFixtureCollection).updateOne(</span><br><span class="line">            &#123;tunnelId:tunnelId, fixtureType:fixtureType&#125;,</span><br><span class="line">            &#123;$pull:</span><br><span class="line">                &#123;</span><br><span class="line">                    designValueList:&#123;layer:layer, subCode:subCode&#125;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>完成了对mongo数组中操作的整理后，发现这方面的资料很少<br>于是有些怀疑在数组中放置对每个元素进行操作的这种设计：查询时最终的方案是通过unwind之后进行的查询，unwind造成的结果是本来数组中的元素被扁平到外部，这也暗示这如果用户对数组中的元素感兴趣，它完全可以能就忽视了外层的信息，也就说明，这数组中的元素应该放到单独的表中。</p><h1 id="mongo表的设计"><a href="#mongo表的设计" class="headerlink" title="mongo表的设计"></a>mongo表的设计</h1><h2 id="设计总结"><a href="#设计总结" class="headerlink" title="设计总结"></a>设计总结</h2><ul><li><p>内嵌 or 链接<br>内嵌文档可以将整个数据组织在一个集合中，隧道内嵌工作段，工作段内嵌进尺，进尺内嵌消耗量。但这种内嵌，一方面是内嵌层数变身以后带来的效率的下降，最重要的是操作实现上的难度。</p><p>字典内嵌<br>  字典应该不属于内嵌，因为它的key值相当于属性，只能通过update的unset与set进行删除与新增。访问上可以通过 “.” 来实现快速的查询。<br>  1对多关系中的数据不应该放在字典内嵌中，字典内嵌说明着这些数据地位是不同的，但多中每个1的地位是相同的。<br>  如果内嵌能实现的化，字典内嵌应该是最有希望的。</p><p>数组内嵌<br>  数组类型就是来存储这种1对多关系的，将多方作为元素放在1方的某个属性的value数组里。<br>  这种使用方式就是如mongo基本操作中的内容，如果这些数组作为整体来查询，或者删除比较适合，对于个体进行</p><p>链接<br> 链接就像是关系型数据库类似，通过增加一个字段来完成链接，或者是增加一个保存ID的数组来完成。<br> 链接也存在问题，因为mongo本身不提供join以及事务，多表操作会存在一定的风险。</p></li></ul><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li><p>mongo每条记录都是一个文档，都是Json扩展的Bson<br>所以mongo中每个集合中的文档，可以完全不同。<br>从使用上，我们将文档当作成表的行来使用。</p></li><li><p>mongo的多个记录组成了集合<br>使用上集合当作表来使用</p></li><li><p>mongo不支持事务</p></li><li><p>mongo没有多表的join查询</p><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><h3 id="一对很少"><a href="#一对很少" class="headerlink" title="一对很少"></a>一对很少</h3><p>采用内嵌文档<br>person集合中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   name:&apos;张三&apos;,</span><br><span class="line">   age:20,</span><br><span class="line">   address:[</span><br><span class="line">    &#123;country:&quot;中国&quot;，province:&quot;山西省&quot;，city:&quot;长治市&quot;&#125;，</span><br><span class="line">    &#123;country:&quot;中国&quot;，province:&quot;山西省&quot;，city:&quot;太原市&quot;&#125;</span><br><span class="line">   ]</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><p>优点：不需要单独执行一条语句去获取内嵌的内容<br>缺点：法把这些内嵌文档当做单独的实体去访问<br>适用场合：一对很少且不需要单独访问内嵌内容</p><h3 id="一对少"><a href="#一对少" class="headerlink" title="一对少"></a>一对少</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">person集合</span><br><span class="line">&#123;</span><br><span class="line">  _id:ObjectID(12个字节组成)</span><br><span class="line">  name:&quot;张三&quot;</span><br><span class="line">  age:23</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">人员组集合</span><br><span class="line">&#123;</span><br><span class="line">  name:&quot;一组&quot;，</span><br><span class="line">  persons:[</span><br><span class="line">    ObjectID(&quot;aaaaa&quot;),</span><br><span class="line">    ObjectID(&quot;AAABBB&quot;)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>适用场合：一对多且多的一端内容因为各种理由需要单独存在的情况下可以通过数组的方式引用多的一方的。</p><h3 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">company集合</span><br><span class="line">&#123;</span><br><span class="line">  _id:ObjectID(&quot;company01&quot;)</span><br><span class="line">  name:&quot;可为时代&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">员工集合</span><br><span class="line">&#123;</span><br><span class="line">  name:&quot;张三&quot;,</span><br><span class="line">  age:23,</span><br><span class="line">  company:ObjectID(&quot;company01&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>适用场合：一对非常多的情况下，请将一的那端引用嵌入进多的一端对象中。</p><h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><p>双向的连接，一对多，多对1</p><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><p>a.优先考虑内嵌，除非有什么迫不得已的原因。</p><p>b.需要单独访问一个对象，那这个对象就不适合被内嵌到其他对象中。</p><p>c.数组不应该无限制增长。如果many端有数百个文档对象就不要去内嵌他们可以采用引用ObjectID的方案；如果有数千个文档对象，那么就不要内嵌ObjectID的数组。该采取哪些方案取决于数组的大小。</p><p>d.在进行反范式设计时请先确认读写比。一个几乎不更改只是读取的字段才适合冗余到其他对象中。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li>分组TOP N</li><li>解析器 或 状态机</li><li>多条件查询</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结在8月份开发过程中对mongo使用经验&lt;/p&gt;
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Mongo" scheme="http://yoursite.com/tags/Mongo/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript ES6基础</title>
    <link href="http://yoursite.com/2018/08/10/2018-8-10JavaScript-ES6%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/08/10/2018-8-10JavaScript-ES6基础/</id>
    <published>2018-08-10T01:50:00.000Z</published>
    <updated>2019-01-21T07:01:18.212Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍es6，包括了块级作用域、数组对象的解构赋值、…操作符、基本类型的扩展、引用类型的扩展（Array、Set、Map），函数的扩展、对象的扩展、class、异步等内容，最后是装饰器的简单介绍，还有一些特性并未加入，比如Generator、yield，proxy等内容。</p><h1 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h1><p>在es5中，只有全局作用域与函数作用域，没有块级作用域。es6通过引入let与const，实际上新增了块级作用域。对于var还是与es5兼容。</p><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><ul><li><p>let命令所声明的变量，只在所在的代码块内有效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (let i=0; i&lt;10; i++)&#123;&#125;</span><br><span class="line">console.log(i);   // ReferenceError</span><br></pre></td></tr></table></figure></li><li><p>不存在变量提升<br>在es5中，var声明的变量，会发生变量提升，即脚本开始运行时，变量已经存在，但没有值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(foo)  // 输出undefined</span><br><span class="line">console.log(bar)  // Error</span><br><span class="line">var foo = 3;</span><br><span class="line">let bar = 4;</span><br></pre></td></tr></table></figure></li><li><p>不允许重复声明<br>let不允许在相同作用域内，重复声明同一个变量。</p></li></ul><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>const如其他语言的const，在JavaScript中，与let相同也是在块级作用域中。</p><h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><h2 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h2><p>  像是照搬了python的处理，也增加了自己的处理，如：</p><ul><li><p>初识<br>python中，可以使用 x,y,z = 1,2,3来定义变量<br>JavaScripty中，使用 let [x,y,z] = [1,2,3] 或者直接 [x,y,z]=[1,2,3]</p><p>python中可以使用 x,y = y,x来交换变量<br>JavaScripty中需要使用 [x,y]=[y,x] </p></li><li><p>默认值</p><p>var [x, y=”b”] = [“a”]   // x=’a’, y=’b’ </p><p>这里需要注意es6中使用 === undefined来判断是否有值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var [x=1] = [undefined];  // x = 1</span><br><span class="line">var [y=1] = [null];  //y=null</span><br></pre></td></tr></table></figure></li></ul><h2 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h2><ul><li>初识</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var &#123;foo,bar&#125; = &#123;foo:&quot;aaa&quot;, bar:&quot;bbb&quot;&#125;</span><br><span class="line">foo  // &quot;aaa&quot;</span><br><span class="line">bar  // &quot;bbb&quot;</span><br></pre></td></tr></table></figure><ul><li>数组元素是按次序排列的，变量取值由位置决定，而对象属性没有次序，变量必须与属性名相同。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var &#123;bar,foo&#125; = &#123;foo:&quot;aaa&quot;, bar:&quot;bbb&quot;&#125;</span><br><span class="line">foo  // &quot;aaa&quot;</span><br><span class="line">bar  // &quot;bbb&quot;</span><br></pre></td></tr></table></figure><ul><li>如果左边的变量名，与右边的属性名不一样，则必须如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123; first: &apos;hello&apos;, last: &apos;world&apos; &#125;;</span><br><span class="line">let &#123; first: one, last: two &#125; = obj; </span><br><span class="line">one // &apos;hello&apos;</span><br><span class="line">two // &apos;world&apos;</span><br></pre></td></tr></table></figure><h2 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const [a,b,c] = &quot;world&quot;</span><br><span class="line">a // &quot;w&quot;</span><br><span class="line">b // &quot;o&quot;</span><br><span class="line">c // &quot;r&quot;</span><br></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>解构赋值应用之一就是函数参数的结构赋值，但后边又有…操作符及默认传参。<br>返回参数通过这种方式倒是可以一起返回多个参数</p><ul><li>返回多个参数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function example() &#123;</span><br><span class="line">  return [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line">var [a, b, c] = example();</span><br></pre></td></tr></table></figure><ul><li>提取Json或者对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var jsonData = &#123;</span><br><span class="line">  id: 42,</span><br><span class="line">  status: &quot;OK&quot;,</span><br><span class="line">  data: [867, 5309]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let &#123; id, status, data: number &#125; = jsonData;</span><br><span class="line"></span><br><span class="line">console.log(id, status, number);</span><br><span class="line">// 42, &quot;OK&quot;, [867, 5309]</span><br></pre></td></tr></table></figure><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="spread运算符-…"><a href="#spread运算符-…" class="headerlink" title="spread运算符(…)"></a>spread运算符(…)</h2><ul><li>初识<br>将一个数组转为用逗号分隔的参数序列。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(...[1, 2, 3])</span><br><span class="line">// 1 2 3</span><br><span class="line"></span><br><span class="line">console.log(1, ...[2, 3, 4], 5)</span><br><span class="line">// 1 2 3 4 5</span><br></pre></td></tr></table></figure><ul><li>应用<ul><li>合并数组</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2].concat(more)  // es5</span><br><span class="line">[1, 2, ...more]   // es6</span><br></pre></td></tr></table></figure><ul><li>与解构赋值结合</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const [first, ...rest] = [1, 2, 3, 4, 5];</span><br><span class="line">first // 1</span><br><span class="line">rest  // [2, 3, 4, 5]</span><br></pre></td></tr></table></figure><ul><li>字符串</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...&apos;hello&apos;]</span><br><span class="line">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span><br></pre></td></tr></table></figure><ul><li>对象也可用<br>扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let z = &#123; a: 3, b: 4 &#125;;</span><br><span class="line">let n = &#123; ...z &#125;;</span><br><span class="line">n // &#123; a: 3, b: 4 &#125;</span><br></pre></td></tr></table></figure><h1 id="基本类型扩展"><a href="#基本类型扩展" class="headerlink" title="基本类型扩展"></a>基本类型扩展</h1><h2 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h2><ul><li>includes(), startsWith(), endsWith()<br>es5中只有indexOf()方法来判断一个字符串是否包含在另一个字符串中。es6新增以上3个。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;Hello world!&apos;;</span><br><span class="line"></span><br><span class="line">s.startsWith(&apos;Hello&apos;) // true</span><br><span class="line">s.endsWith(&apos;!&apos;) // true</span><br><span class="line">s.includes(&apos;o&apos;) // true</span><br></pre></td></tr></table></figure><p>  同时都支持第二个参数，表示开始搜索的位置</p><ul><li>repeat()<br>repeat方法返回一个新字符串，表示将原字符串重复n次</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;x&apos;.repeat(3) // &quot;xxx&quot;</span><br></pre></td></tr></table></figure><ul><li>padStart(), padEnd()<br>字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart用于头部补全，padEnd用于尾部补全。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;x&apos;.padStart(4, &apos;ab&apos;) // &apos;abax&apos;</span><br><span class="line">&apos;x&apos;.padEnd(4, &apos;ab&apos;) // &apos;xaba&apos;</span><br></pre></td></tr></table></figure><ul><li><p>模板字符串<br>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p><p>// 字符串中嵌入变量</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;Bob&quot;, time = &quot;today&quot;;</span><br><span class="line">`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`</span><br></pre></td></tr></table></figure><h2 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h2><ul><li><p>二进制与八进制<br>ES6提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。</p></li><li><p>Number.isFinite(), Number.isNaN()</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Number.isFinite()用来检查一个数值是否为有限的（finite）。</span><br><span class="line">Number.isNaN()用来检查一个值是否为NaN。</span><br><span class="line"></span><br><span class="line">Number.isFinite(15); // true</span><br><span class="line">Number.isFinite(0.8); // true</span><br><span class="line">Number.isFinite(NaN); // false</span><br><span class="line">Number.isFinite(Infinity); // false</span><br><span class="line">Number.isFinite(&apos;foo&apos;); // false</span><br><span class="line">Number.isFinite(&apos;15&apos;); // false</span><br><span class="line">Number.isFinite(true); // false</span><br><span class="line"></span><br><span class="line">Number.isNaN(NaN) // true</span><br><span class="line">Number.isNaN(15) // false</span><br><span class="line">Number.isNaN(&apos;15&apos;) // false</span><br><span class="line">Number.isNaN(true) // false</span><br><span class="line">Number.isNaN(9/NaN) // true</span><br><span class="line">Number.isNaN(&apos;true&apos;/0) // true</span><br></pre></td></tr></table></figure><ul><li>Number.isInteger()<br>Number.isInteger()用来判断一个值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Number.isInteger(25) // true</span><br><span class="line">Number.isInteger(25.0) // true</span><br><span class="line">Number.isInteger(25.1) // false</span><br></pre></td></tr></table></figure><ul><li>Number.EPSILON<br>ES6在Number对象上面，新增一个极小的常量Number.EPSILON。原因不言自明</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number.EPSILON</span><br><span class="line">// 2.220446049250313e-16</span><br></pre></td></tr></table></figure><h1 id="引用类型扩展"><a href="#引用类型扩展" class="headerlink" title="引用类型扩展"></a>引用类型扩展</h1><h2 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h2><ul><li>Array.from()<br>Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arrayLike = &#123;</span><br><span class="line">  &apos;0&apos;: &apos;a&apos;,</span><br><span class="line">  &apos;1&apos;: &apos;b&apos;,</span><br><span class="line">  &apos;2&apos;: &apos;c&apos;,</span><br><span class="line">  length: 3</span><br><span class="line">&#125;;</span><br><span class="line">let arr2 = Array.from(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br></pre></td></tr></table></figure><p>  我觉得，在Map、set向数组的转换比较有用，arrayLike本来就是数组，谁也不会那样定义，arguments感觉在es6中在弱化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Array.from(&apos;hello&apos;)</span><br><span class="line">// [&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;]</span><br><span class="line"></span><br><span class="line">let namesSet = new Set([&apos;a&apos;, &apos;b&apos;])</span><br><span class="line">Array.from(namesSet) // [&apos;a&apos;, &apos;b&apos;]</span><br></pre></td></tr></table></figure><p>  Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.from([1, 2, 3], (x) =&gt; x * x)  // [1, 4, 9]</span><br></pre></td></tr></table></figure><ul><li>Array.of()<br>Array.of方法用于将一组值，转换为数组。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Array.of(3, 11, 8) // [3,11,8]</span><br><span class="line">Array.of(3) // [ 3 ]</span><br><span class="line">Array.of(3).length // 1</span><br></pre></td></tr></table></figure><ul><li>数组实例的copyWithin()<br>数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组.<br>三个参数： target(必需)，开始替换位置; start（可选），开始读取位置，默认0; end（可选），到该位置前停止读取数据，默认等于数组长度。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5].copyWithin(0, 3)</span><br><span class="line">// [4, 5, 3, 4, 5]</span><br></pre></td></tr></table></figure><ul><li>数组实例的find()和findIndex()<br>数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员，没有则返回undefined</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[1, 4, -5, 10].find((n) =&gt; n &lt; 0)</span><br><span class="line">// -5</span><br><span class="line"></span><br><span class="line">[1, 5, 10, 15].find(function(value, index, arr) &#123;</span><br><span class="line"> return value &gt; 9;</span><br><span class="line">&#125;) // 10</span><br><span class="line"> </span><br><span class="line">[1, 5, 10, 15].findIndex(function(value, index, arr) &#123;</span><br><span class="line">   return value &gt; 9;</span><br><span class="line">&#125;) // 2</span><br></pre></td></tr></table></figure><ul><li>数组实例的fill()<br>fill方法使用给定值，填充一个数组。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new Array(3).fill(7)</span><br><span class="line">// [7, 7, 7]</span><br></pre></td></tr></table></figure><ul><li>数组实例的entries()，keys()和values()<br>entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历<br>对于数组感觉也很鸡肋</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) &#123;</span><br><span class="line">  console.log(index);</span><br><span class="line">&#125;</span><br><span class="line">// 0</span><br><span class="line">// 1</span><br><span class="line"></span><br><span class="line">for (let elem of [&apos;a&apos;, &apos;b&apos;].values()) &#123;</span><br><span class="line">  console.log(elem);</span><br><span class="line">&#125;</span><br><span class="line">// &apos;a&apos;</span><br><span class="line">// &apos;b&apos;</span><br><span class="line"></span><br><span class="line">for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) &#123;</span><br><span class="line">  console.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line">// 0 &quot;a&quot;</span><br><span class="line">// 1 &quot;b&quot;</span><br></pre></td></tr></table></figure><ul><li>数组实例的includes()<br>Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].includes(2);     // true</span><br></pre></td></tr></table></figure><ul><li>数组的空位<br>数组的空位指，数组的某一个位置没有任何值.空位不是undefined，一个位置的值等于undefined，依然是有值的.<br>ES5对空位的处理，已经很不一致了，大多数情况下会忽略空位。ES6则是明确将空位转为undefined</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Array.from([&apos;a&apos;,,&apos;b&apos;])</span><br><span class="line">// [ &quot;a&quot;, undefined, &quot;b&quot; ]</span><br><span class="line"></span><br><span class="line">扩展运算符（...）也会将空位转为undefined</span><br><span class="line">[...[&apos;a&apos;,,&apos;b&apos;]]</span><br><span class="line">// [ &quot;a&quot;, undefined, &quot;b&quot; ]</span><br></pre></td></tr></table></figure><h2 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h2><ul><li>函数参数的默认值<br>在ES6之前，不能直接为函数的参数指定默认值，ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。默认参数与C++类似，最好放在后边。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function log(x, y = &apos;World&apos;) &#123;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(&apos;Hello&apos;) // Hello World</span><br><span class="line">log(&apos;Hello&apos;, &apos;China&apos;) // Hello China</span><br></pre></td></tr></table></figure><p>  参数默认值可以与解构赋值的默认值，结合起来使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo(&#123;x, y = 5&#125;) &#123;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(&#123;&#125;) // undefined, 5</span><br><span class="line">foo(&#123;x: 1&#125;) // 1, 5</span><br><span class="line">foo(&#123;x: 1, y: 2&#125;) // 1, 2</span><br></pre></td></tr></table></figure><ul><li>函数的length属性<br>指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(function (a) &#123;&#125;).length  // 1</span><br><span class="line">(function (a, b, c = 5) &#123;&#125;).length // 2</span><br></pre></td></tr></table></figure><ul><li>rest参数<br>ES6引入rest参数（形式为“…变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。这个与python也类似，.args与..kargs</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function add(...values) &#123;</span><br><span class="line">  let sum = 0;</span><br><span class="line"></span><br><span class="line">  for (var val of values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(2, 5, 3) // 10</span><br><span class="line"></span><br><span class="line">var args = [0, 1, 2];</span><br><span class="line">add(...args);  // 3</span><br></pre></td></tr></table></figure><ul><li>箭头函数<br>参数多余一个用（），语句多于一条用{}</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125;</span><br></pre></td></tr></table></figure><p>  箭头函数可以与变量解构结合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const full = (&#123; first, last &#125;) =&gt; &#123;first +&apos; &apos; + last&#125;;</span><br><span class="line">// 等同于</span><br><span class="line">function full(person) &#123;</span><br><span class="line"> return person.first + &apos; &apos; + person.last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  箭头函数有几个使用注意点。<br>  （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。<br>  （2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。<br>  （3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。<br>  （4）不可以使用yield命令，因此箭头函数不能用作Generator函数。</p><ul><li><p>尾调用优化<br>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数，并返回，就是函数式变成可以链起来。<br>正面实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function f(x)&#123;</span><br><span class="line">  return g(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反面实例：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 情况一</span><br><span class="line">function f(x)&#123;</span><br><span class="line">  let y = g(x);</span><br><span class="line">  return y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 情况二</span><br><span class="line">function f(x)&#123;</span><br><span class="line">  return g(x) + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 情况三</span><br><span class="line">function f(x)&#123;</span><br><span class="line">  g(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除 f(x) 的调用帧，只保留 g(3) 的调用帧。</p><p>  这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</p><ul><li><p>尾递归<br>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p><p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p></li></ul><h2 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h2><ul><li><p>属性的简写<br>ES6允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁</p><p>变量</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var foo = &apos;bar&apos;;</span><br><span class="line">var baz = &#123;foo&#125;;</span><br><span class="line">baz // &#123;foo: &quot;bar&quot;&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">var baz = &#123;foo: foo&#125;;</span><br></pre></td></tr></table></figure><p>  函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">  method() &#123;</span><br><span class="line">    return &quot;Hello!&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 等同于  </span><br><span class="line">var o = &#123;</span><br><span class="line">  method: function() &#123;</span><br><span class="line">    return &quot;Hello!&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>Object.assign()<br>Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var target = &#123; a: 1 &#125;;</span><br><span class="line">var source1 = &#123; b: 2 &#125;;</span><br><span class="line">var source2 = &#123; c: 3 &#125;;</span><br><span class="line"></span><br><span class="line">Object.assign(target, source1, source2);</span><br><span class="line">target // &#123;a:1, b:2, c:3&#125;</span><br></pre></td></tr></table></figure><p>  Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</p><ul><li><p>属性的遍历<br>ES6一共有5种方法可以遍历对象的属性。</p><p>（1）for…in<br>for…in循环遍历对象自身的和继承的可枚举属性（不含Symbol属性）。</p><p>（2）Object.keys(obj)<br>Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）。</p><p>（3）Object.getOwnPropertyNames(obj)<br>Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）。</p><p>（4）Object.getOwnPropertySymbols(obj)<br>Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有Symbol属性。</p><p>（5）Reflect.ownKeys(obj)<br> Reflect.ownKeys返回一个数组，包含对象自身的所有属性，不管是属性名是Symbol或字符串，也不管是否可枚举。  </p></li><li><p>Object.keys()<br>ES5引入了Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。</p><p>var obj = { foo: “bar”, baz: 42 };<br>Object.keys(obj)<br>// [“foo”, “baz”]</p><p>Object.values(), Object.entries()在提案中。</p></li></ul><h2 id="set与map"><a href="#set与map" class="headerlink" title="set与map"></a>set与map</h2><p>这个大概是学习了C++</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var set = new Set([1, 2, 3, 4, 4]);</span><br><span class="line">[...set]</span><br><span class="line">// [1, 2, 3, 4]</span><br><span class="line">set.size // 4</span><br><span class="line"></span><br><span class="line">// 去除数组的重复成员</span><br><span class="line">[...new Set(array)]</span><br></pre></td></tr></table></figure><p>属性<br>Set.prototype.size：返回Set实例的成员总数。<br>Set实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。</p><p>操作方法：<br>add(value)：添加某个值，返回Set结构本身。<br>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。<br>has(value)：返回一个布尔值，表示该值是否为Set的成员。<br>clear()：清除所有成员，没有返回值。</p><p>遍历方法：<br>keys()：返回键名的遍历器<br>values()：返回键值的遍历器<br>entries()：返回键值对的遍历器<br>forEach()：使用回调函数遍历每个成员</p><p>WeakSet<br>WeakSet结构与Set类似，也是不重复的值的集合。但是，它与Set有两个区别。<br>首先，WeakSet的成员只能是对象，而不能是其他类型的值。<br>其次，WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul><li>初识<br>JavaScript的对象（Object），本质上是键值对的集合（Hash结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。<br>为了解决这个问题，ES6提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var map = new Map([</span><br><span class="line">  [&apos;name&apos;, &apos;张三&apos;],</span><br><span class="line">  [&apos;title&apos;, &apos;Author&apos;]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">map.size // 2</span><br><span class="line">map.has(&apos;name&apos;) // true</span><br><span class="line">map.get(&apos;name&apos;) // &quot;张三&quot;</span><br></pre></td></tr></table></figure><ul><li>注意<br>这个map与C++类似，但有一点需要注意：<br>只有对同一个对象的引用，Map结构才将其视为同一个键。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var map = new Map();</span><br><span class="line"></span><br><span class="line">map.set([&apos;a&apos;], 555);</span><br><span class="line">map.get([&apos;a&apos;]) // undefined</span><br></pre></td></tr></table></figure><p>  实际上这是两个[‘a’]值，内存地址是不一样的，因此get方法无法读取该键，返回undefined</p><ul><li><p>操作方法：<br>set(key, value)<br>get(key)<br>has(key)<br>delete(key)<br>clear()清空所有成员</p></li><li><p>遍历方法：<br>keys()：返回键名的遍历器。<br>values()：返回键值的遍历器。<br>entries()：返回所有成员的遍历器。<br>forEach()：遍历Map的所有成员。</p></li><li><p>相互转换<br>数组转成Map</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let newMap =  new Map([[true, 7], [false, 6]])</span><br><span class="line">  // Map &#123;true =&gt; 7, false =&gt; 7&#125;</span><br></pre></td></tr></table></figure><p>  Map转为数组<br>  […newMap]</p><p>  对象转成Map</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function objToStrMap(obj) &#123;</span><br><span class="line">  let strMap = new Map();</span><br><span class="line">  for (let k of Object.keys(obj)) &#123;</span><br><span class="line">    strMap.set(k, obj[k]);</span><br><span class="line">  &#125;</span><br><span class="line">  return strMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">objToStrMap(&#123;yes: true, no: false&#125;)</span><br><span class="line">// [ [ &apos;yes&apos;, true ], [ &apos;no&apos;, false ] ]</span><br></pre></td></tr></table></figure><p>  Map转成对象，如果所有Map键都是字符串，它可以转为对象，起始不是也可以先转换成字符串，再转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function strMapToObj(strMap) &#123;</span><br><span class="line">  let obj = Object.create(null);</span><br><span class="line">  for (let [k,v] of strMap) &#123;</span><br><span class="line">    obj[k] = v;</span><br><span class="line">  &#125;</span><br><span class="line">  return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myMap = new Map().set(&apos;yes&apos;, true).set(&apos;no&apos;, false);</span><br><span class="line">strMapToObj(myMap)</span><br><span class="line">// &#123; yes: true, no: false &#125;</span><br></pre></td></tr></table></figure><h1 id="class"><a href="#class" class="headerlink" title="class"></a>class</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>es6终于脱离了es5要使用构造函数与原型相结合的方法来完成类定义的方式，提供了class关键字,在class内部声明的函数就被定义在了原型上，class内部有construtor函数，在其中定义的属性，就是在构造函数上。</p><p>es5代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Point(x, y) &#123;</span><br><span class="line">  this.x = x;</span><br><span class="line">  this.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = function () &#123;</span><br><span class="line">  return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var p = new Point(1, 2);</span><br></pre></td></tr></table></figure><p>等同于es6的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  constructor(x, y) &#123;</span><br><span class="line">    this.x = x;</span><br><span class="line">    this.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类的数据类型就是函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typeof Point     //&quot;function&quot;</span><br><span class="line">Point === Point.prototype.constructor  // true</span><br></pre></td></tr></table></figure><h2 id="constructor方法"><a href="#constructor方法" class="headerlink" title="constructor方法"></a>constructor方法</h2><p>constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。</p><p>constructor方法默认返回实例对象（即this）。</p><h2 id="class表达式"><a href="#class表达式" class="headerlink" title="class表达式"></a>class表达式</h2><p>与函数一样，类也可以使用表达式的形式定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const MyClass = class Me &#123;</span><br><span class="line">  getClassName() &#123;</span><br><span class="line">    return Me.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">let inst = new MyClass();</span><br><span class="line">inst.getClassName();  // Me</span><br></pre></td></tr></table></figure><h2 id="class私有方法"><a href="#class私有方法" class="headerlink" title="class私有方法"></a>class私有方法</h2><p>es6中，并不直接提供私有方法。可以通过一些技术来模拟，但感觉都不好。</p><h2 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h2><p>类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。<br>以下边例子来说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Logger &#123;</span><br><span class="line">  printName(name = &apos;there&apos;) &#123;</span><br><span class="line">    this.print(`Hello $&#123;name&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  print(text) &#123;</span><br><span class="line">    console.log(text);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const logger = new Logger();</span><br><span class="line">const &#123; printName &#125; = logger;</span><br><span class="line">printName(); // TypeError: Cannot read property &apos;print&apos; of undefined</span><br></pre></td></tr></table></figure><p>我稍微有点不理解，好不容易封装的函数，再解构出来用，几个意思啊？</p><h2 id="class的继承"><a href="#class的继承" class="headerlink" title="class的继承"></a>class的继承</h2><p>es5中的继承麻烦的要命，既要用subClass的原型链的constructor指向superClass的实例来继承函数，还要通过在subClass的构造函数中去调用superClass.call(this,..)来继承对象，简直不想让人用啊。<br>好在es6中增加了extends关键字来简化了继承，下边来看一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class ColorPoint extends Point &#123;</span><br><span class="line">  constructor(x, y, color) &#123;</span><br><span class="line">    super(x, y); // 调用父类的constructor(x, y)</span><br><span class="line">    this.color = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    return this.color + &apos; &apos; + super.toString(); // 调用父类的toString()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造函数中调用super()应该用于从构造函数中继承对象，然后外边的函数类似于原型继承了。<br>子类必须在constructor方法中调用super方法，否则新建实例时会报错。</p><h2 id="类的prototype属性和proto属性"><a href="#类的prototype属性和proto属性" class="headerlink" title="类的prototype属性和proto属性"></a>类的prototype属性和<strong>proto</strong>属性</h2><p>Class作为构造函数的语法糖，同时有prototype属性和<strong>proto</strong>属性，因此同时存在两条继承链。<br>（1）子类的<strong>proto</strong>属性，表示构造函数的继承，总是指向父类。<br>（2）子类prototype属性的<strong>proto</strong>属性，表示方法的继承，总是指向父类的prototype属性。</p><h2 id="Class的取值（getter）和存值函数（setter）"><a href="#Class的取值（getter）和存值函数（setter）" class="headerlink" title="Class的取值（getter）和存值函数（setter）"></a>Class的取值（getter）和存值函数（setter）</h2><p>与ES5一样，在Class内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">  get prop() &#123;</span><br><span class="line">    return &apos;getter&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  set prop(value) &#123;</span><br><span class="line">    console.log(&apos;setter: &apos;+value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let inst = new MyClass();</span><br><span class="line"></span><br><span class="line">inst.prop = 123;</span><br><span class="line">// setter: 123</span><br><span class="line"></span><br><span class="line">inst.prop</span><br><span class="line">// &apos;getter&apos;</span><br></pre></td></tr></table></figure><h2 id="class的静态方法"><a href="#class的静态方法" class="headerlink" title="class的静态方法"></a>class的静态方法</h2><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用。<br>这个有点意思，我们看的构造函数（类）的prototype原型也就是静态的方法，又像Java/C++学习增加了static方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">  static classMethod() &#123;</span><br><span class="line">    return &apos;hello&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.classMethod() // &apos;hello&apos;</span><br><span class="line"></span><br><span class="line">var foo = new Foo();</span><br><span class="line">foo.classMethod()</span><br><span class="line">// TypeError: foo.classMethod is not a function</span><br></pre></td></tr></table></figure><p>父类的静态方法，可以被子类继承。</p><h2 id="class的静态属性和实例属性"><a href="#class的静态属性和实例属性" class="headerlink" title="class的静态属性和实例属性"></a>class的静态属性和实例属性</h2><p>只有这种写法可行，因为ES6明确规定，Class内部只有静态方法，没有静态属性。对于这条在TypeScirpt中已经该了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">  static myStaticProp = 42;   // 静态属性</span><br><span class="line">  myProp = 43;                // 实例属性</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    console.log(MyClass.myProp); // 42</span><br><span class="line">    console.log(this.myProp);   //43</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ES6诞生以前，异步编程的方法，大概有下面四种。<br>  回调函数<br>  事件监听<br>  发布/订阅<br>  Promise 对象<br>  ES6将JavaScript异步编程带入了一个全新的阶段，ES7的Async函数更是提出了异步编程的终极解决方案。</p><p>异步<br>  异步就像中断，启动一个耗时操作，然后程序可以继续运行，等耗时操作的中断返回再执行耗时操作的处理。</p><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(&apos;/etc/passwd&apos;, function (err, data) &#123;</span><br><span class="line">  if (err) throw err;</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取A文件之后，再读取B文件，代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(fileA, function (err, data) &#123;</span><br><span class="line">  fs.readFile(fileB, function (err, data) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>不难想象，如果依次读取多个文件，就会出现多重嵌套,Promise就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var readFile = require(&apos;fs-readfile-promise&apos;);</span><br><span class="line"></span><br><span class="line">readFile(fileA)</span><br><span class="line">.then(function(data)&#123;</span><br><span class="line">  console.log(data.toString());</span><br><span class="line">&#125;)</span><br><span class="line">.then(function()&#123;</span><br><span class="line">  return readFile(fileB);</span><br><span class="line">&#125;)</span><br><span class="line">.then(function(data)&#123;</span><br><span class="line">  console.log(data.toString());</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function(err) &#123;</span><br><span class="line">  console.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用了fs-readfile-promise模块，它的作用就是返回一个Promise版本的readFile函数。Promise提供then方法加载回调函数，catch方法捕捉执行过程中抛出的错误。</p><h2 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h2><p>ES7提供了async函数，使得异步操作变得更加方便。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var asyncReadFile = async function ()&#123;</span><br><span class="line">  var f1 = await readFile(&apos;/etc/fstab&apos;);</span><br><span class="line">  var f2 = await readFile(&apos;/etc/shells&apos;);</span><br><span class="line">  console.log(f1.toString());</span><br><span class="line">  console.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>返回值是Promise。async函数的返回值是Promise对象</p><p>注意：<br>  第一点，await命令后面的Promise对象，运行结果可能是rejected，，所以最好把await命令放在try…catch代码块中。</p><p>  一般写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async function myFunction() &#123;</span><br><span class="line">  await somethingThatReturnsAPromise()</span><br><span class="line">  .catch(function (err) &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  第二点，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let foo = await getFoo();</span><br><span class="line">let bar = await getBar();</span><br></pre></td></tr></table></figure><p>  getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发。</p><p>  let [foo, bar] = await Promise.all([getFoo(), getBar()]);</p><p>  第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  async function dbFuc(db) &#123;</span><br><span class="line">  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  // 报错</span><br><span class="line">  docs.forEach(function (doc) &#123;</span><br><span class="line">    await db.post(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上面代码会报错，因为await用在普通函数之中了。但是，如果将forEach方法的参数改成async函数，也有问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  async function dbFuc(db) &#123;</span><br><span class="line">  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  // 可能得到错误结果</span><br><span class="line">  docs.forEach(async function (doc) &#123;</span><br><span class="line">    await db.post(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  原因是这时三个db.post操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用for循环。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async function dbFuc(db) &#123;</span><br><span class="line">  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  for (let doc of docs) &#123;</span><br><span class="line">    await db.post(doc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Decorator"><a href="#Decorator" class="headerlink" title="Decorator"></a>Decorator</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>es的装饰器应该与python类似，使用闭包技术，将要修改的函数传入装饰函数即可。还有Generator,yield以及协程概念，都像是与python的相互借鉴。<br>修饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，修饰器能在编译阶段运行代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function testable(target) &#123;</span><br><span class="line">  target.isTestable = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@testable</span><br><span class="line">class MyTestableClass &#123;&#125;</span><br><span class="line"></span><br><span class="line">console.log(MyTestableClass.isTestable) // true</span><br></pre></td></tr></table></figure><p>@testable就是一个修饰器。它修改了MyTestableClass这个类的行为，为它加上了静态属性isTestable<br>如果觉得一个参数不够用，可以在修饰器外面再封装一层函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function testable(isTestable) &#123;</span><br><span class="line">  return function(target) &#123;</span><br><span class="line">    target.isTestable = isTestable;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@testable(true)</span><br><span class="line">class MyTestableClass &#123;&#125;</span><br><span class="line">MyTestableClass.isTestable // true</span><br><span class="line"></span><br><span class="line">@testable(false)</span><br><span class="line">class MyClass &#123;&#125;</span><br><span class="line">MyClass.isTestable // false</span><br></pre></td></tr></table></figure><h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><p>修饰器不仅可以修饰类，还可以修饰类的属性。<br>此时，修饰器函数一共可以接受三个参数，第一个参数是所要修饰的目标对象，第二个参数是所要修饰的属性名，第三个参数是该属性的描述对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  @readonly</span><br><span class="line">  name() &#123; return `$&#123;this.first&#125; $&#123;this.last&#125;` &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function readonly(target, name, descriptor)&#123;</span><br><span class="line">    // descriptor对象原来的值如下</span><br><span class="line">    // &#123;</span><br><span class="line">    //   value: specifiedFunction,</span><br><span class="line">    //   enumerable: false,</span><br><span class="line">    //   configurable: true,</span><br><span class="line">    //   writable: true</span><br><span class="line">    // &#125;;</span><br><span class="line">    descriptor.writable = false;</span><br><span class="line">    return descriptor;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>@log修饰器，可以起到输出日志的作用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Math &#123;</span><br><span class="line">  @log</span><br><span class="line">  add(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function log(target, name, descriptor) &#123;</span><br><span class="line">  var oldValue = descriptor.value;    // descriptor.value就是方法add</span><br><span class="line"></span><br><span class="line">  descriptor.value = function() &#123;     // 在这里重新赋值desciptor.value，应该包含对原函数的调用</span><br><span class="line">    console.log(`Calling &quot;$&#123;name&#125;&quot; with`, arguments);</span><br><span class="line">    return oldValue.apply(null, arguments);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return descriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const math = new Math();</span><br><span class="line"></span><br><span class="line">// passed parameters should get logged now</span><br><span class="line">math.add(2, 4);</span><br></pre></td></tr></table></figure></p><h2 id="装饰器不能用于函数"><a href="#装饰器不能用于函数" class="headerlink" title="装饰器不能用于函数"></a>装饰器不能用于函数</h2><p>修饰器只能用于类和类的方法，不能用于函数，因为存在函数提升</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要介绍es6，包括了块级作用域、数组对象的解构赋值、…操作符、基本类型的扩展、引用类型的扩展（Array、Set、Map），函数的扩展、对象的扩展、class、异步等内容，最后是装饰器的简单介绍，还有一些特性并未加入，比如Generator、yield，proxy等内
      
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript基础</title>
    <link href="http://yoursite.com/2018/08/08/2018-8-8JavaScript%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/08/08/2018-8-8JavaScript基础/</id>
    <published>2018-08-08T04:50:00.000Z</published>
    <updated>2019-01-21T07:01:07.336Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍JavaScript的发展、组成，在Http中的使用，基础语法，变量、执行环境、内存等内容</p><a id="more"></a><h1 id="JavaScript简介"><a href="#JavaScript简介" class="headerlink" title="JavaScript简介"></a>JavaScript简介</h1><h2 id="经历"><a href="#经历" class="headerlink" title="经历"></a>经历</h2><ul><li>由网景公司研发的，在网络带宽很低的年代，用于在浏览器端对表单的数据进行验证，而降低带宽而发明的</li><li>由于JaScript在浏览器的成功，微软也在IE中增加了JScript的实现。</li><li>以JavaScript1.1为版本的标准化<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2></li><li>核心：ECMAScript<br>语言基础：<ul><li>语法</li><li>类型</li><li>语句</li><li>关键字</li><li>保留字</li><li>操作符</li><li>对象</li></ul></li><li><p>文档对象模型：DOM<br>就是对XML解析的那个DOM</p></li><li><p>浏览器对象模型：BOM</p><ul><li>弹出新浏览器窗口的功能</li><li>移动、缩放和关闭浏览器的功能</li><li>提供浏览器详细信息的navigator对象</li><li>提供浏览器所加载页面的详细信息的location对象</li><li>提供用户显示器分辨率信息的screen对象</li><li>对cookies的支持</li><li>XMLHttpRequest这样的自定义对象</li></ul></li></ul><h2 id="在HTTP中的使用"><a href="#在HTTP中的使用" class="headerlink" title="在HTTP中的使用"></a>在HTTP中的使用</h2><ul><li>script元素<ul><li>async: 表示立即下载脚本，只对外部脚本文件有效</li><li>charset：表示src属性指定的代码的字符集</li><li>defer：表示脚本可以延迟到文件完全被解析和显示之后再执行，外部有效</li><li>src</li><li>type：text/javacript</li></ul></li><li><p>标签的位置<br>按惯例，script元素都应该放在页面的head元素中，但这样意味着必须等到全部的JS代码都被下载、分析执行完成后，才能展示页面，导致页面加载的延迟。为此，一般把全部JS放在boday元素中页面内容的后面</p></li><li><p>延迟脚本<br>有时会将script放在head中，而用derfer=”defer”属性，这样告诉浏览器立即下载，但延迟执行</p></li><li><p>异步脚本<br>async 目的是不让页面等待两个脚本的下载和执行，从而异步加载页面其他内容。书中建议，异步脚本不要在加载期间修改DOM</p></li></ul><h1 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h1><ul><li>typeof<br>作为一种动态语言，JS需要有一种手段来检测数据类型：typeof操作符（在C/C++中也有）<br>返回的类型包括：<br>“undefined”<br>“boolean”<br>“string”<br>“number”<br>“object”<br>“function”：这似乎意味着函数并不是对象</li></ul><h2 id="undefined与Null"><a href="#undefined与Null" class="headerlink" title="undefined与Null"></a>undefined与Null</h2><p>  有一段比较有趣：从类型上看，JS有一种Null类型，而”undefined”其实是从Null派生的.而执行typeof(Null对象)结果是object。<br>  声明而未初始化类型是”undefined”，声明对象后，直接赋值”Null”是告诉赋了个空值对象</p><h2 id="number"><a href="#number" class="headerlink" title="number"></a>number</h2><p>  JS也存在float禁止直接 == 的比较<br>  Infinity:Number.MIN_VALUE:一般为5e-324, Number.MAX_VALUE:1.79e+308，超过这些范围则为Infinity 或者-Infinity</p><ul><li><p>NaN:Not a Number<br>任意数/0 = NaN， NaN不与任意数相等，包括其自身</p></li><li><p>数值转换<br>Number()<br>parseInt()<br>parseFloat()</p></li><li><p>函数<br>toFixed(): 按参数的小数位返回数值的字符串表示</p><p>var num=10<br>alert(num.toFixed(2))  // “10.00”</p></li></ul><pre><code>toExponential(1)： 同上，不过是以e表示的toPrecision(1): 同上，参数表示的是数字的位数 </code></pre><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li><p>字符串特点<br>ECMAScprit中字符串是不可变的。字符串一旦创建，值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串。<br>这一点与python一致</p></li><li><p>转换为字符串<br>几乎每个值都有toStrig()方法，这个与Java类似<br>或者Stirng(变量)的方式在转换</p></li><li><p>函数<br>charAt(1) ： 在某个位置上的字符</p><p>var str = “hello world”<br>alert(str.CharAt(1))   // e</p></li></ul><p>  concat(): 拼接,参数个数不限，不修改原值<br>  alert(str.concat(“!”, “thanks”))</p><p>  切片：<br>  slice(起始，结束)， substring(起始，结束)，substr(起始，个数)<br>  str.slice(3, -1)</p><p>  位置:<br>  indexOf()和lastIndexOf()  与C++中的find（）与rfind（）类似<br>  str.indexOf(“or”)</p><p>  删除前后空格：<br>  trim()<br>  str.trim()</p><p>  大小写转换：<br>  toUpperCase()/toLowerCase()<br>  str.toUpperCase()</p><h2 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h2><p>  这个Object与Java的Object类似，就是说Object类型是所有其他实例的基础。<br>  Constructor():构造函数<br>  hasOwnProperty(属性名)，建材给定的属性在爱当前实例中。<br>  isPrototypeOf(object)，传入的对象是否是另一个对象的原型<br>  propertyIsEnumerable(属性名)，检查属性是否可以通过for-in来枚举<br>  toLocaleString()返回对象的字符串表示<br>  toString()：同上<br>  valueOf()：返回字符串、数值或者布尔值表示。</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>++ 与 – 类似与 C/</p><p>+操作符，就是正号，需要注意的是对非数值使用，该操作符回想Number()转型函数一样对这个数进行转换。</p><p> == 与 === :早期的ECMAScript版本中的相等和不相等–先转换再比较。===则仅比较而不转换。</p><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>with 语句：with语句的作用是将代码的作用域设置到一个特定对象中。这个有点像python的with语句。严格模式下不允许使用with语句，被认为是语法错误</p><h2 id="理解参数"><a href="#理解参数" class="headerlink" title="理解参数"></a>理解参数</h2><ul><li><p>ECMAScript中的所有参数传递都是值，不可能通过引用传递参数。</p></li><li><p>ECMAScript 函数并不介意传递进来多少个参数，也不在乎传入的参数是什么类型。<br>即使定义的函数只接收两个参数，在调用这个函数时，也未必一定要传递2个参数。<br>原因是ECMAScript中的参数在内部是用一个数组来表示。函数接收到的始终都是这个数组，而并不关心数组中包含哪些参数。在函数体内可以通过arguments对象来访问这个参数数组，从而获得传递给函数的每一个参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function doAdd()&#123;</span><br><span class="line">  if (arguments.length == 1)&#123;</span><br><span class="line">    return arguments[0]+10;</span><br><span class="line">    &#125; else if (arguments.length == 2)&#123;</span><br><span class="line">        return argument[0]+argument[1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = doAdd(10);</span><br><span class="line">let b = doAdd(10,20);</span><br></pre></td></tr></table></figure><p>关于arguments有一点比较有趣，它的值永远与对应命名参数的值保持同步。<br>但它们访问的内存空间是独立的，但它们的值会同步。但这种同步也是单向的，修改命名参数不会改变arguments中的对应值，而修改arguments会改变命名参数的。</p></li></ul><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h2><ul><li><p>基本类型与引用类型<br>ECMAScript变量可能包含2种不同数据类型的值：基本类型值和引用类型值。<br>基本类型包括5种：Null,Undefined,Number,String,Boolean<br>引用类型就是最有一种Object类型。<br>多数语言中String类型都是对象：如C++/Java，因而是引用类型，但JavaScript并不是。</p><p>基本类型在内存中都是按值来存储【这一点跟python还有一点区别，python的小整数都是相同的内存】<br>而引用类型跟C++/C的思路一直，变量名仅保留其指针，对变量名的复制仅仅是浅copy，内存中并不会创建一份新的引用类型。</p></li><li><p>传递参数<br>对于引用类型的传参，是挺有意思的，首先形参是重新定义了一个对象，传递的值是引用类型值的指针。若使用这个对象直接修改属性，则函数外的属性也会修改。但如果这个形参对象重新指向别的对象，则外边的对象便不会修改了,就是这个指针已经指向别处了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function setName(obj)&#123;</span><br><span class="line">  obj.name= &quot;li&quot;</span><br><span class="line">  obj = new Object();</span><br><span class="line">  obj.name = &quot;wang&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Object()</span><br><span class="line">setName(person);   // person.name = &quot;li&quot;</span><br></pre></td></tr></table></figure></li><li><p>检测类型<br>对应基本类型用typeOf()进行对象的检测<br>对于引用类型，使用instanceof来判断：这个与C++类似</p></li></ul><h2 id="执行环境及作用域"><a href="#执行环境及作用域" class="headerlink" title="执行环境及作用域"></a>执行环境及作用域</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p><img src="函数执行过程.png" alt=""></p><ul><li><p>所谓的执行环境，其实就是函数的环境一层一层的压栈，然后出栈的过程，对于作用域的查询也与C语言类似：先找局部、然后上一层的栈..直到全局变量。</p></li><li><p>但与之不同的是，每一个执行环境都有一个与其关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。 </p></li><li><p>当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的作用，是保证对执行环境有权访问的所有变量合函数的有序访问。这个作用域链用来保存各个执行环境的变量对象。</p></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><p>需要注意一点：JavaScript中没有块级作用域：即不能像C/C++通过{}来设置一个作用域.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (var i=0; i&lt;10; i++)&#123;</span><br><span class="line">    doSomething(i);</span><br><span class="line">&#125;</span><br><span class="line">alert(i);  // i=10</span><br></pre></td></tr></table></figure></li><li><p>还有一个比较坑<br>在非严格模式下如果在函数内定义一个变量没有var标志,那么这个定义的变量是全局变量.</p></li></ul><h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><ul><li><p>标记清除<br>标记清除用于局部变量的清除</p></li><li><p>引用计数<br>与python类似.也存在严重的循环引用问题。<br>但python中有隔代清理机制，没见JavaScript有介绍。</p></li><li><p>注意：<br>对于不同的对象，将变量直接赋null。这个在有垃圾收集机制的语言中通用。如Java\Pthon。即使在C++/C中，也建议将delete后的指针赋null，防止野指针。</p></li></ul><h1 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1><h2 id="Object类型-1"><a href="#Object类型-1" class="headerlink" title="Object类型"></a>Object类型</h2><ul><li><p>两种构造构造方法：</p><ul><li><p>new Object方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var person = new Object();</span><br><span class="line">person.name = &quot;sun&quot;</span><br><span class="line">person.age = 31</span><br></pre></td></tr></table></figure></li><li><p>对象字面量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">  name : &quot;sun&quot;,</span><br><span class="line">  age: 29</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>第一种形式就是C++的struct，第二种形式就是python的字典</p></li><li><p>访问<br>访问上也是沿用struct或者字典类型：<br>person.name<br>person[“name”]</p></li><li><p>注意：<br>起始对象字面量种的变量如name，age都是string。</p></li></ul><h2 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a>Array类型</h2><ul><li><p>定义<br>同Object，Array也有2种定义方法：即对象定义方法与对象字面量，前一种类似与c++的vector，后一种类似与python的列表[]</p><ol><li>对象定义方法<br>var colors = new Array();</li><li>对象字面量方法<br>var colors = []</li></ol></li><li><p>操作<br>Javasript为它的Array定义了好多的函数</p><ul><li>检测数组</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (value instanceof Array)&#123;&#125;</span><br><span class="line">if (Array.isArray(value))&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>转换</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]</span><br><span class="line">colors.toString()</span><br></pre></td></tr></table></figure><ul><li><p>栈方法<br>push与pop 方法</p></li><li><p>队列方法<br>shift与unshift<br>shift是取并移除队列头部的元素<br>unshift是往头部塞数据</p></li><li><p>顺序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var values = [1, 2, 4, 5]</span><br><span class="line">values.reverse() //values的顺序是倒序了，这个并没用python的好用</span><br><span class="line">    </span><br><span class="line">values.sort() // 这个是个坑，竟然是按照字符串来测序。</span><br><span class="line"></span><br><span class="line">// 好在这个坑，可以通过传入函数的方式来填</span><br><span class="line">function compare(v1, v2)&#123;</span><br><span class="line">   return v1-v2;</span><br><span class="line">&#125;</span><br><span class="line">values.sort(compare)</span><br></pre></td></tr></table></figure></li><li><p>切片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">slice()</span><br><span class="line">var values = [1, 2, 4, 5]</span><br><span class="line"> values.slice(1)    // 取的是1,-1</span><br><span class="line"> values.slice(1,3)  //也是左开右闭的区</span><br><span class="line"></span><br><span class="line">splice()  // 这个太强悍了，是一个基于切片的删除、插入方法</span><br><span class="line">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]</span><br></pre></td></tr></table></figure><p>完全体下： removed = colors.splice(1,1,”red”,”yellow”)<br>意思是，从1个位置上，删除1个，并插入”red”与”yellow”</p></li><li><p>查找<br>indedOf（）/lastIndexOf()<br>竟然不叫find()与rfind（），真另类。</p></li><li><p>迭代方法<br>这个挺牛逼，包含map</p></li></ul></li></ul><table><thead><tr><th>函数</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>every()</td><td style="text-align:right">对每一项运行函数，每一项皆true，结果才true</td></tr><tr><td>some()</td><td style="text-align:right">对每一项运行函数，有一项true，则结果true</td></tr><tr><td>forEach()</td><td style="text-align:right">遍历每个对象，运行函数</td></tr><tr><td>filter()</td><td style="text-align:right">通python</td></tr><tr><td>map()</td><td style="text-align:right">通python</td></tr></tbody></table><ul><li><p>reduce方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var values = [1, 2, 3, 4]</span><br><span class="line">var sum = values.reduce(function(pre, cur, index, array)&#123;</span><br><span class="line">   return prev + cur;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul><li><p>当前时间：<br>var now = new Date()</p><p>这样返回的是当前时间的毫秒数， 可以用来计算运算的时间<br>var start = Date.now()  </p></li><li><p>构建时间<br>需要在Date（）中传入一个表示该日期的毫秒数（自1970-1-1），类型位是int<br>但我们要想自己算毫秒数，人会疯掉，于是有了两个函数，用来将其他类型的转换成毫秒数</p><p>Date.parse():将本地的string类型转换成毫秒数。<br>Date.UTC():将以年月日、时分秒等数值转换成毫秒数。</p><p>于是有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var date1 = new Date(Date.parse(&quot;2018-7-30&quot;))</span><br><span class="line">var date2 = new Date(Date.UTC(2018, 7, 30))</span><br></pre></td></tr></table></figure><p>注意这里有个小坑： Date中的月，都是从0开始算的，所以1月是0, 8月是7.</p></li></ul><h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3><h4 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h4><ul><li>toString（）       // 可能是伦敦时间，格式也也是CST的</li><li><p>toLocalString()  // 北京时间： 年月日+时分秒 “2017-7-30 00:00:00”</p></li><li><p>toDateString()  // 星期、月、日、年</p></li><li><p>toLocalDateString() // “2017-7-30”</p></li><li><p>toTimeString()  // 时分秒 CST等等</p></li><li>toLocalTimeString() // “00:00:00”</li></ul><p>总之，用Locale的更好看一些</p><h4 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h4><ul><li>getTime()  // 返回表示日期的毫秒数</li></ul><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ul><li>getFullYear() //年</li><li>getMonth()    // 月，并以0为起始</li><li>getDate()     // 日:竟然是Date而不是Day 1-31</li><li>getDay()      // 星期几： 也以0位开始，Day竟然是周几，吐槽一下</li><li>getHours()    // 时：0-23</li><li>getMinutes()  // 分：0-59</li><li>getSeconds()  // 秒：0-59</li></ul><p>上述操作，有get也有set，还有个毫秒。</p><h2 id="ReqExp类型"><a href="#ReqExp类型" class="headerlink" title="ReqExp类型"></a>ReqExp类型</h2><p>JS的正则表达式与别的语言的大约类似<br>var expression = / pattern / flags<br>flags有： g 全局模式， i 不区分大小写， m 多行</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li><p>字面量形式<br>匹配第一个bat或者cat，且不区分大小写<br>var pattern1 = /[bc]at/i</p><p>匹配所有以at结尾的3个字符的组合，不区分大小写<br>var pattern2 = /.at/gi</p><p>同样模式中使用元字符需要转义： 如{[( \ ^ $ ? * . +)]}</p></li><li><p>还有一种构造函数的形式(起始就是类的形式)<br>var pattern1 = new RegExp(“[bc]at”, “i”)<br>在这里边，所有的元字符都需要双重转义</p></li><li><p>示例</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var text = &quot;mom and dad and baby&quot;;</span><br><span class="line">var pattern = /mom (and dad (and baby)?)?/gi</span><br><span class="line"></span><br><span class="line">var matches = pattern.exec(text)</span><br><span class="line">alert(matches.input)  // &quot;mom and dad and baby&quot;</span><br><span class="line">alert(matches[0]);    // &quot;mom and dad and baby&quot;</span><br><span class="line">alert(matches[1]);    // &quot;and dad and baby&quot;</span><br><span class="line">alert(matches[2]);    // &quot;and baby&quot;</span><br></pre></td></tr></table></figure><h3 id="实例属性或方法"><a href="#实例属性或方法" class="headerlink" title="实例属性或方法"></a>实例属性或方法</h3><p>var pattern3 = /[bc]]at/i</p><p>pattern3.lastIndex  // 0 表示开始搜索下一个匹配项的字符位置。<br>pattern3.source      // “[bc]at” 正则表达式的字符串表示</p><p>pattern3.exec()<br>pattern3.test(字符串) // 与模式匹配的情况下返回true，否则返回false</p><p>pattern3.toString()   // 返回增则表达式的字面量<br>pattern3.toLoacaleString() </p><h3 id="构造函数属性（类的属性）"><a href="#构造函数属性（类的属性）" class="headerlink" title="构造函数属性（类的属性）"></a>构造函数属性（类的属性）</h3><table><thead><tr><th>长属性名</th><th style="text-align:center">短属性名</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>input</td><td style="text-align:center">$_</td><td style="text-align:right">最近一次要匹配的字符串</td></tr><tr><td>lastMatch</td><td style="text-align:center">$&amp;</td><td style="text-align:right">最近一次的匹配项</td></tr><tr><td>lastParen</td><td style="text-align:center">$+</td><td style="text-align:right">最近一次的匹配捕获组</td></tr><tr><td>leftContext</td><td style="text-align:center">$`</td><td style="text-align:right">匹配项之前的文本</td></tr><tr><td>rightContext</td><td style="text-align:center">$’</td><td style="text-align:right">匹配项之后的文本`</td></tr><tr><td>multiline</td><td style="text-align:center">$*</td><td style="text-align:right">是否是多行</td></tr></tbody></table><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var text = &quot;this has been a short summer&quot;</span><br><span class="line">var pattern = /(.)hort/g</span><br><span class="line"></span><br><span class="line">if (pattern.test(text))&#123;</span><br><span class="line">  alert(RegExp.input)       // this has been a short summer</span><br><span class="line"></span><br><span class="line">  alert(RegExp.leftContext  // this has been a</span><br><span class="line">  alert(RegExp.lastMatch)   // short</span><br><span class="line">  alert(RegExp.rightContext // summer</span><br><span class="line"></span><br><span class="line">  alert(RegExp.lastParen)   // s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a>Function类型</h2><p>特意将函数拉到最后，因为后边的2章：面向对象、函数表达式其实都是对函数的深入理解。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>函数起始也是对象（这与python一样），每个函数都是Function类型的实例。而且Function与其他引用类型一样，具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。</p><h3 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h3><p>// 函数表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var fun1 = function(num)&#123;</span><br><span class="line">    return num+10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// 函数声明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function fun2(num)&#123;</span><br><span class="line">    retrun num+10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析器在向执行环境中加载数据时，对函数表达式与函数声明并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用（有点类似于静态语言的编译），至于函数表达式，则必须等到解析器之行到它所在的代码行，才会真正被解释执行。</p><h3 id="函数的内部属性"><a href="#函数的内部属性" class="headerlink" title="函数的内部属性"></a>函数的内部属性</h3><p>函数内部，有2个特殊的对象：arguments和this。</p><ul><li><p>arguments<br>前边介绍过，它是一个类数组对象，包含着传入函数的所有参数。但它还有一个callee属性，该属性是一个指针，指向拥有这个对象的函数名。</p><p>看阶乘函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function factorial(num)&#123;</span><br><span class="line">   if (num &lt;= 1)&#123;</span><br><span class="line">     return 1;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     return num * factoril(num-1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题，但这样这个函数的执行与函数名factorial紧耦合在一起了，如果将：</p><p>let factorial2 = factorial<br>let factorial = null<br>再运行factorial2，会报错。python也存在这样的问题。<br>如此可以这样改写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function factorial(num)&#123;</span><br><span class="line">   if (num &lt;= 1)&#123;</span><br><span class="line">     return 1;</span><br><span class="line">   &#125; else&#123;</span><br><span class="line">     return num * arguments.callee(num-1)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就不会有问题了。</p></li><li><p>this<br>this与Java/C++类似，this引用的是函数据以之行的环境对象。按之前的写法叫运行环境的变量对象，也就是作用域对象。</p></li></ul><h3 id="函数属性和方法"><a href="#函数属性和方法" class="headerlink" title="函数属性和方法"></a>函数属性和方法</h3><p>每个函数都包含2个属性：length与prototype，最好戏是这个prototype.</p><ul><li><p>length<br>length属性表示函数接收的命名参数的个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function sum(n1, n2)&#123;</span><br><span class="line">  return n1+n2;</span><br><span class="line">&#125;</span><br><span class="line">alert(sum.length)</span><br></pre></td></tr></table></figure></li><li><p>prototype<br>prototype放在下一章来写，在下一章会对 构造函数（类）， 实例， prototype进行详述。</p></li><li><p>apply()/call（）<br>这两个方法都是在特定的作用域中调用函数。他们的第一个参数都是作用域对象，差异是apply()的第二个参数是数组，call第二个对象是元素</p><p>// 作用域没变的情况下，就是传参或者调用函数，还不如直接调用省事</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function sum(a,b)&#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line">fuction callSum(a, b)&#123;</span><br><span class="line">   return sum.call(this, a, b)</span><br><span class="line">&#125;</span><br><span class="line">let color = &quot;red&quot;</span><br><span class="line">var o = &#123;color:&quot;blue&quot;&#125;</span><br><span class="line">function sayColor()&#123;</span><br><span class="line">  alert(this.color)</span><br><span class="line">&#125;</span><br><span class="line">sayColor();   // red</span><br><span class="line">sayColor(this);  // red</span><br><span class="line">sayColor(o);   // blue</span><br></pre></td></tr></table></figure></li><li><p>bind()<br>与apply类似，也是一种用来扩展作用域的方式，只是调用上不一样</p><p>var sayColor2 = sayColor.bind(o)<br>sayColor2()  // blue</p></li></ul><h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><p>包括有：Object、Array等都是内置对象，下边还有2个：Global与Math</p><h3 id="Global"><a href="#Global" class="headerlink" title="Global"></a>Global</h3><p>实际上没有全局变量与全局函数，所有在全局作用域中定义的属性和函数都是Global对象的属性，如isNaN（），isFinite（），parseInt（），parseFloat（）等</p><ul><li><p>encodeURI与encodeURIComponent()<br>主要用于对URI进行编码，区别在于encodeURI不会对本身属于URI的特殊字符进行编码例如: # ? /,而encodeURIComponent()会对任何非标准字符进行编码。<br>在实践中常见的是对查询字符串参数，而不是对基础URI编码，故使用后者会多一些</p></li><li><p>decodeURI与decodeURIComponent()解码<br>只能对应自己的编码</p></li></ul><p>在浏览器中，将Global对象作为window对象的一部分加以实现。</p><h3 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h3><table><thead><tr><th>属性</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>Math.E</td><td style="text-align:right">e</td></tr><tr><td>Math.LN10</td><td style="text-align:right">ln10</td></tr><tr><td>Math.LN2</td><td style="text-align:right">ln2</td></tr><tr><td>Math.LOG2E</td><td style="text-align:right">log 2底e</td></tr><tr><td>Math.LOG10E</td><td style="text-align:right">log 10底e</td></tr><tr><td>Math.PI</td><td style="text-align:right">pi</td></tr><tr><td>Math.SQRT2</td><td style="text-align:right">根2</td></tr></tbody></table><table><thead><tr><th>方法</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>Math.min()</td><td style="text-align:right">最小值</td></tr><tr><td>max（）</td><td style="text-align:right">最大值</td></tr><tr><td>ceil()</td><td style="text-align:right">向上舍入</td></tr><tr><td>floor()</td><td style="text-align:right">向下舍入</td></tr><tr><td>round()</td><td style="text-align:right">标志舍入</td></tr><tr><td>random()</td><td style="text-align:right">0-1间的随机数</td></tr><tr><td>abs(num)</td><td style="text-align:right">绝对值</td></tr><tr><td>exp(num)</td><td style="text-align:right">e的num次幂</td></tr><tr><td>log(num)</td><td style="text-align:right">num的自然对数</td></tr><tr><td>pow(num,power)</td><td style="text-align:right">num的power次幂</td></tr><tr><td>sqrt(num)</td><td style="text-align:right">平方根</td></tr><tr><td>三角函数..</td></tr></tbody></table><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>在这一里，主要对几个重要的技术进行说明，并不想对这一章进行整体的展开。这几个重要概念是：对象、构造函数（类）、原型、基于原型及构造函数的继承。</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>定义：无序属性的集合，其属性可以包含基本值、对象或者函数。</li><li>可以把es对象想象成散列表：无非就是一组名值对，其中值可以是数据与函数。<br>对与这个，首先我们在C++/Java里的对象，就是将他们的函数名当作的键。<br>其次也符合对python中的字典类型的认识，即可以当作struct来使用。<h3 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h3>es5中有两种属性：数据属性和访问器属性.这些属性是只在内部才可用的特性。<h4 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h4></li></ul><table><thead><tr><th>属性</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>Configurable</td><td style="text-align:right">表示能否通过delete删除属性从而重新定义属性</td></tr><tr><td>Enumerable</td><td style="text-align:right">表示能否通过for-in循环返回属性</td></tr><tr><td>Writable</td><td style="text-align:right">表示能否修改属性的值</td></tr><tr><td>value</td><td style="text-align:right">包含这个属性的数据值</td></tr></tbody></table><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;&#125;</span><br><span class="line">Object.defineProperty(person, &quot;name&quot;, &#123;</span><br><span class="line">   wriable: false,</span><br><span class="line">   configurable: fales,  //一旦设置为不可配置，就无法再配置回来</span><br><span class="line">   value: &quot;sun&quot;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">alert(person.name)  // &quot;sun&quot;</span><br><span class="line">delete person.name  </span><br><span class="line">alert(person.name)  // &quot;sun&quot;</span><br><span class="line">person.name = &quot;yan&quot;</span><br><span class="line">alert(person.name)  // &quot;sun&quot;</span><br></pre></td></tr></table></figure><p>这种类似于const</p><h4 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h4><table><thead><tr><th>属性</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>Configurable</td><td style="text-align:right">同上</td></tr><tr><td>Enumerable</td><td style="text-align:right">同上</td></tr><tr><td>Get</td><td style="text-align:right">在读取属性时调用的函数</td></tr><tr><td>Set</td><td style="text-align:right">在写入属性时调用的函数</td></tr></tbody></table><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var book = &#123;</span><br><span class="line">   _year: 2004   // _year表示只能通过对象方法访问的属性，私用，同python，可能也是改了下名字</span><br><span class="line">   edition:1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(book &quot;year&quot;, &#123;</span><br><span class="line">   get:function()&#123;</span><br><span class="line">     return this.__year;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   set:function(newValue)&#123;</span><br><span class="line">      </span><br><span class="line">      if(newValue &gt; 2004)&#123;</span><br><span class="line">         this.__year = newValue;</span><br><span class="line">         this.edition += newValue-2004</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">book.year = 2005</span><br><span class="line">alert(book.edition)</span><br></pre></td></tr></table></figure><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fuction createPerson(name, age, job)&#123;</span><br><span class="line">   var o = new Object();</span><br><span class="line">   o.name = name;</span><br><span class="line">   o.age = age;</span><br><span class="line">   o.job =job;</span><br><span class="line">   o.sayName = function()&#123;</span><br><span class="line">      alert(this.name)</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 = createPerson(&quot;sun&quot;, 19, &quot;Teacher&quot;);</span><br><span class="line">var person2 = createPerson(&quot;yan&quot;, 29, &quot;Doctor&quot;);</span><br></pre></td></tr></table></figure><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>工厂模式解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即知道一个对象的类型）</p><h3 id="构造函数（类）"><a href="#构造函数（类）" class="headerlink" title="构造函数（类）"></a>构造函数（类）</h3><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line"></span><br><span class="line">    this.sayName = function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 = new Person(&quot;sun&quot;, 19, &quot;software engieer&quot;)</span><br><span class="line">var person2 = new Person(&quot;yan&quot;, 29, &quot;doctor&quot;)</span><br></pre></td></tr></table></figure><h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h4><ul><li>这种构造函数的方法跟类是一致的</li><li>person1和person2分别保存着Person的一个不同的实例，这两个对象都有一个constructor（构造函数）属性，该属性指向Person</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(person1.constructor == Person) //true</span><br><span class="line">alert(person2.constructor == Person) //true</span><br></pre></td></tr></table></figure><ul><li>对象的constructor属性最初是用来标识对象类型的。但是，检测对象类型，还是用instanceof操作符更可靠一些。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(person1 instance of Person)  // true</span><br></pre></td></tr></table></figure><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul><li>构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。如person1和person2都有一个sayName()的方法，但那个方法不是同一个Function实例。</li></ul><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = &quot;Sun&quot;;</span><br><span class="line">Person.prototype.age = 29;</span><br><span class="line">Person.prototype.job = &quot;doctor&quot;</span><br><span class="line">Person.prototype.sayName = function()&#123;</span><br><span class="line">     alert(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 = new Person()</span><br><span class="line">person1.sayName(); //&quot;sun&quot;</span><br><span class="line"></span><br><span class="line">var person2 = new Person()</span><br><span class="line">person2.sayName(); // &quot;sun&quot;</span><br><span class="line"></span><br><span class="line">alert(person1.sayName == person2.sayName); // true</span><br></pre></td></tr></table></figure><h4 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h4><h5 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h5><p>原型对象类似于静态变量，类唯一。<br><img src="实例、构造函数、原型之间的关系.png" alt=""><br>上图很好的说明了实例、构造函数、原型之间的关系。<br>函数与原型之间的关系：每个新函数都有一个prototype属性，这个属性指向原型对象。默认情况下，所有原型对象会也有一个constructor属性，这个属性指向所原型所在的函数。</p><h5 id="实例与原型"><a href="#实例与原型" class="headerlink" title="实例与原型"></a>实例与原型</h5><p>新实例的内部包含一个指针，指向构造函数的原型对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(Object.getPrototypeOf(person1) == Person.prototype);  // true</span><br></pre></td></tr></table></figure><p>hasOwnProperty()可以检测一个属性是存在于实例，还是存在于原型中。只在属性存在于对象实例中，才会返回true</p><p>in:in操作符可以单独使用，在操作符会在通过对象能够访问给定属性时，返回true，无论是在实例还是在原型中。</p><p>若实例中添加一个属性，与原型中的属性同名，则该属性屏蔽原型中的属性.[这里就有一种类似于作用域东西，先搜索实例，没有找到就搜索原型]<br>这个新属性只会阻止访问原型中的属性，并不会修改那个属性，即使设置位null，也只会在实例中设置这个属性，而不会恢复其指向原型的连接。但delete操作符，则可以完全删除实例属性，从而恢复原型属性.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">person1.name = &quot;feng&quot;</span><br><span class="line">alert(person1.name); //&quot;feng&quot;</span><br><span class="line">person1.hasOwnProperty(&quot;name&quot;);  // true</span><br><span class="line">alert(&quot;name&quot; in person1);  // true</span><br><span class="line"></span><br><span class="line">delete person1.name;</span><br><span class="line">alert(person1.name)  // &quot;sun&quot;</span><br><span class="line">person1.hasOwnProperty(&quot;name&quot;)  // false</span><br><span class="line">alert(&quot;name&quot; in person1)   // true</span><br></pre></td></tr></table></figure><h5 id="更简单的原型语法"><a href="#更简单的原型语法" class="headerlink" title="更简单的原型语法"></a>更简单的原型语法</h5><p>前面每添加一个属性，都要敲一遍Person.prototype，更常见的做法是用一个对象字面量来重写整个原型对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  name:&quot;sun&quot;,</span><br><span class="line">  age:29,</span><br><span class="line">  job:teacher,</span><br><span class="line">  sayName: function()&#123;</span><br><span class="line">      alert(this.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样存在一个问题，原来prototype中的constructor指向Person构造函数，但重新赋值后,constructor属性不再指向Person了。可以通过制定constructor: Person来指定。但这样指定的，也可通过in来访问到，最好的方式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(Person.prototype, &quot;constructor&quot;, &#123;</span><br><span class="line">  enumrable: false,</span><br><span class="line">  value: Person</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="原型动态修改"><a href="#原型动态修改" class="headerlink" title="原型动态修改"></a>原型动态修改</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var friend = new Person();</span><br><span class="line"></span><br><span class="line">Pserson.prototype = &#123;</span><br><span class="line">  constructor: Person,</span><br><span class="line">  name: &quot;sun&quot;,</span><br><span class="line">  age: 29,</span><br><span class="line">  sayName: function()&#123;</span><br><span class="line">     alert(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">friend.sayName(); // error</span><br></pre></td></tr></table></figure><p>这是因为friend所中的原型指针指向的是赋值之前的原型，而不是之后的。<br><img src="原型动态修改.png" alt=""></p><h4 id="原型对象的问题"><a href="#原型对象的问题" class="headerlink" title="原型对象的问题"></a>原型对象的问题</h4><p>原型中所有的属性是被所有实例共享的，是静态的，所以修改一个，全部都会修改。故适合函数的复用。</p><h3 id="原型与构造函数的组合使用"><a href="#原型与构造函数的组合使用" class="headerlink" title="原型与构造函数的组合使用"></a>原型与构造函数的组合使用</h3><h4 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h4><p>即普通属性放到构造函数中，将函数放到原型中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job)&#123;</span><br><span class="line">   this.name = name;</span><br><span class="line">   this.age = age;</span><br><span class="line">   this.job = job;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  constructor: Person,</span><br><span class="line">  sayName: function()&#123;</span><br><span class="line">    alert(this.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job)&#123;</span><br><span class="line">   this.name = name;</span><br><span class="line">   this.age = age;</span><br><span class="line">   this.job = job;</span><br><span class="line"></span><br><span class="line">   if(typeof this.sayName != &quot;function&quot;)&#123;</span><br><span class="line">         Person.prototype.sayName = funciton()&#123;</span><br><span class="line">             alert(this.name)</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">   this.property = true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = function()&#123;</span><br><span class="line">    return this.property;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubType()&#123;</span><br><span class="line">    this.subProperty = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = new SuperType()  </span><br><span class="line">SubType.prototype.getSubValue = funtion()&#123;</span><br><span class="line">      return this.subProperty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var istance = new SubType();</span><br><span class="line">alert(instance.getSuperValue)</span><br></pre></td></tr></table></figure><h4 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h4><p>这种方法起始就是在设置子类的原型时指向父类的一个实例，这与用字面量来定义原型类似。他们之间的关系如下：<br><img src="原型链继承.png" alt=""></p><h4 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h4><ol><li>在为子类的原型添加其他属性的时候不能再用字面量了</li><li>依然存在对引用类型属性共享带来的问题。</li><li>故一般直接用的原型链继承的。<h3 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h3><h4 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h4></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">funtion SuperType()&#123;</span><br><span class="line">  this.colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubType()&#123;</span><br><span class="line">   superType.call(this)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var instance1 = new SubType();</span><br><span class="line">instance1.colors.push(&quot;black&quot;)</span><br><span class="line">alert(instance1.colors)   // &quot;red,green,blue,black&quot;</span><br><span class="line"></span><br><span class="line">var instance2 = new SubType();</span><br><span class="line">alert(instance2.colors)  //&quot;red,green blue&quot;</span><br></pre></td></tr></table></figure><h4 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a>说明</h4><p>通过使用call（）方法，就是在新创建SubType实例时，调用了SuperType构造函数，这样就会在SubType对象上初始化了所有SuperType（）函数的属性。</p><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><p>问题依旧明确，函数没有办法复用。</p><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><h4 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name)&#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.colors = [&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = function()&#123;</span><br><span class="line">   alert(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function SubType(name, age)&#123;</span><br><span class="line">   SuperType.call(this, name);</span><br><span class="line">   this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = new SuperType()</span><br><span class="line">subType.prototype.sayAge = function()&#123;</span><br><span class="line">   alert(this.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="说明-5"><a href="#说明-5" class="headerlink" title="说明"></a>说明</h4><p>属性通过构造函数来继承，避免了由于原型链继承带来的静态问题。<br>函数通过原型链继承，避免了构造函数继承带来的函数复用问题。<br>而且通过instanceof合isPrototypeOf()也能识别基于组合继承的对象。</p><h1 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="普通递归"><a href="#普通递归" class="headerlink" title="普通递归"></a>普通递归</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function factorial(num)&#123;</span><br><span class="line">   if (num &lt;= 1)&#123;</span><br><span class="line">      return 1;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      return num*facorial(num-1)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var another = factorial;</span><br><span class="line">factorial = null;</span><br><span class="line">alert(another(4));  // 出错</span><br></pre></td></tr></table></figure><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>函数内的arguments有一个 callee属性，指向正在之行函数的指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function factorial(num)&#123;</span><br><span class="line">   if (num &lt;= 1)&#123;</span><br><span class="line">      return 1;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      return num *  arguments.callee(num-1)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>当某个函数第一次调用时，会创建一个执行环境（execution context）及相应的作用域链，并把作用域链赋值给execution context一个内部特殊属性（[Scope]）。然后，使用this, arguments和其它命名参数的值来初始化函数的活动对象(activity object)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">funtion compare(v1, v2)&#123;</span><br><span class="line">   if(v1 &lt; v2)&#123;</span><br><span class="line">     return -1;</span><br><span class="line">   &#125; else if (v1 &gt; v2)&#123;</span><br><span class="line">     return 1;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     return 0;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="函数执行过程.png" alt=""></p><p>闭包是一个函数内部创建另一个函数，内部函数引用外部函数的变量。<br>这样内部函数的作用域链中，就含有外部函数的作用域（活动对象）</p><h3 id="闭包与变量"><a href="#闭包与变量" class="headerlink" title="闭包与变量"></a>闭包与变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createFuntions()&#123;</span><br><span class="line">   var result = new Array();</span><br><span class="line">   </span><br><span class="line">   for(var i=0; i&lt;10; i++)&#123;</span><br><span class="line">      result[i] = function()&#123;</span><br><span class="line">        return i;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内层函数直接访问外层函数的变量，而这个变量最后都变成了10,故所有的函数都返回10</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function createFuntions()&#123;</span><br><span class="line">   var result = new Array();</span><br><span class="line"></span><br><span class="line">   for(var i=0; i&lt;10; i++)&#123;</span><br><span class="line">     result[i] = function(num)&#123;</span><br><span class="line">        return function()&#123;</span><br><span class="line">            return num;</span><br><span class="line">        &#125;;</span><br><span class="line">     &#125;(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关于this"><a href="#关于this" class="headerlink" title="关于this"></a>关于this</h3><p>this对象是在运行时，基于函数的执行环境绑定的.当函数作为某个对象的方法调用时，this等于那个对象。不过匿名函数的执行环境具有全局性。</p><h2 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h2><p>私有变量起始跟类的私有成员类似。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function MyObject()&#123;</span><br><span class="line">   var privateVar = 10;</span><br><span class="line">   function privateFunction()&#123;</span><br><span class="line">    return false;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   this.publicMethod = function()&#123;</span><br><span class="line">     privateVar++;</span><br><span class="line">     return privateFunction();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数内部定义的的私有变量和函数不能在外部访问，但可以通过公有的函数进行访问。<br>可以认为有this的为公有，没有的就是私有。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍JavaScript的发展、组成，在Http中的使用，基础语法，变量、执行环境、内存等内容&lt;/p&gt;
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
</feed>
