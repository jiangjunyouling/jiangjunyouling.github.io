<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>思 见</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-21T11:59:34.002Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>sun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>v8引擎学习记录</title>
    <link href="http://yoursite.com/2019/10/21/v8%E5%BC%95%E6%93%8E%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/10/21/v8引擎记录/</id>
    <published>2019-10-21T13:41:28.000Z</published>
    <updated>2019-11-21T11:59:34.002Z</updated>
    
    <content type="html"><![CDATA[<p>使用node.js也有一段时间了，一直没有深入的研究一下node，这次就对node.js相关的技术，进行从上层到底层的学习，内容包括：</p><ul><li>v8引擎     &lt;=</li><li>node.js  </li><li>libuv  </li></ul><p>libuv的避免不了unix环境编程的api，这一块与node.js有点距离，不放在这个系列中了。  </p><a id="more"></a><p>本文主要引用：<br><a href="https://zhuanlan.zhihu.com/p/27628685" target="_blank" rel="noopener">认识v8引擎</a><br><a href="https://v8.dev/docs" target="_blank" rel="noopener">v8 doc文档</a>  </p><h1 id="V8简介"><a href="#V8简介" class="headerlink" title="V8简介"></a>V8简介</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>v8的背景是webkit内核的浏览器，webkit的架构如下：<br><img src="webkit内核.png" alt="webkit内核.png">  </p><p>这里：  </p><ul><li>WebCore 是各个浏览器使用的共享部分，包括HTML解析器、CSS解析器、DOM和SVG等</li><li>JSCore是WebKit的默认引擎，在谷歌系列产品中被替换为V8引擎。Javascript的引擎，或者类比Java的虚拟机  </li><li>WebKit Eembedding API是平台差异的,不同的浏览器实现不同</li></ul><p>这样就很容易看出V8的定位，解析执行JavaScript语言，JavaScript是一种解释性语言，与C、c++编译型语言不同，以及Java的半编译半解释性语言不同，它需要一遍执行一遍解析。</p><p>编译型语言的一般过程： 源代码 –&gt; 抽象语法树 –&gt;  中间表示 –&gt; 机器码<br>V8的过程: 源代码 –&gt; 抽象语法树 –&gt; 字节码 –&gt; JIT –&gt; 机器码</p><p>源代码：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象语法树：<br><img src="js抽象语法树.png" alt="js抽象语法树.png">  </p><p>字节码:<br><img src="字节码.png" alt="字节码"></p><p>v8 在5.9版本之前，不生成字节码，直接由抽象语法树经JIT运行，在5.9版本增加了Ignition字节码编译器。这一部分内容参考<a href="https://zhuanlan.zhihu.com/p/28590489" target="_blank" rel="noopener">v8字节码</a>  </p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>JavaScript代码编译的过程大致为：  </p><ul><li>Script类调用Compiler类的Compile函数为其生成本地代码。 </li><li>Compile函数先使用Parser类生成AST(抽象语法树)    </li><li>FullCodeGenerator类来生成本地代码。本地代码与具体的硬件平台密切相关，FullCodeGenerator使用多个后端来生成与平台相匹配的本地汇编代码。  </li><li>AstVisitor用于遍历AST（访问者模式） </li></ul><p><img src="js代码编译过程.jpg" alt="js代码编译过程.jpg">  </p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><ul><li>Script表示JavaScript代码，即包含源代码，又包含编译之后生成的本地代码，即是编译入口，又是运行入口；</li><li>Execution：运行代码的辅组类，包含一些重要函数，如Call函数，它辅组进入和执行Script代码；</li><li>JSFunction：需要执行的JavaScript函数表示类；</li><li>Runtime：运行这些本地代码的辅组类，主要提供运行时所需的辅组函数，如：属性访问、类型转换、编译、算术、位操作、比较、正则表达式等；</li><li>Heap：运行本地代码需要使用的内存堆类；</li><li>MarkCompactCollector：垃圾回收机制的主要实现类，用来标记、清除和整理等基本的垃圾回收过程；</li><li>SweeperThread：负责垃圾回收的线程。</li></ul><p><img src="js代码执行过程.jpg" alt="js代码执行过程.jpg">  </p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p><a href="https://zhuanlan.zhihu.com/p/33816534" target="_blank" rel="noopener">v8内存</a>  </p><ul><li>构成  </li></ul><p>一个 V8 进程的内存通常由以下几个块构成：</p><ol><li>新生代内存区（new space）<br>大多数的对象都会被分配在这里，这个区域很小但是垃圾回收比较频繁；</li><li>老生代内存区（old space）<br>属于老生代，这里只保存原始数据对象，这些对象没有指向其他对象的指针；</li><li>大对象区（large object space）<br>这里存放体积超越其他区大小的对象，每个对象有自己的内存，垃圾回收其不会移动大对象区；</li><li>代码区（code space）<br>代码对象，会被分配在这里。唯一拥有执行权限的内存；</li><li>map 区（map space）<br>存放 Cell 和 Map，每个区域都是存放相同大小的元素，结构简单。</li></ol><ul><li>生命周期</li></ul><p>假设代码中有一个对象 jerry ，这个对象从创建到被销毁，刚好走完了整个生命周期，通常会是这样一个过程：</p><ol><li>这个对象被分配到了 new space；</li><li>随着程序的运行，new space 塞满了，gc 开始清理 new space 里的死对象，jerry 因为还处于活跃状态，所以没被清理出去；</li><li>gc 清理了两遍 new space，发现 jerry 依然还活跃着，就把 jerry 移动到了 old space；</li><li>随着程序的运行，old space 也塞满了，gc 开始清理 old space，这时候发现 jerry 已经没有被引用了，就把 jerry 给清理出去了。</li></ol><h1 id="嵌入v8"><a href="#嵌入v8" class="headerlink" title="嵌入v8"></a>嵌入v8</h1><p>为什么介绍嵌入v8呢，因为node.js就是嵌入v8的。  </p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>isolate： 有自己堆的VM实例  </li><li>handle: 指向一个对象的指针，所有的V8对象都可以通过handle来访问</li><li>handle scope: 存放handle的容器，当删除handle scoppe，会自动删除其中的handle,从而也会触发删除v8对象  </li><li>context: 可以独立运行JavaScript脚本的可执行环境，要想运行一个JavaScript脚本，必须明确指明其context</li></ul><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><ul><li><p>Handles </p><p>handle是一个指针，指向在heap中JavaScript对象的地址。当这些对象没有被handle指向时，垃圾收集器GC就会回收这些存储。前边提到过，对象在heap中的位置会被GC移动，移动后，GC会更新所有指向这个对象的handle。  </p><p>最常见的有2种handle：local handle与Persistent handle<br>local handle存储在一个stack上，这个stack可以认为是前边的handle scope。用Local<sometype>来定义<br>Persistent handle也是指向一个在heap上分配的JavaScript对象，但它不在stack上。用UniquePersistent<sometype>与 Persistent<sometype>来定义。</sometype></sometype></sometype></p><p><img src="handle图解.png" alt="handle图解.png"> </p></li></ul><ul><li><p>context  </p><p>context是一个独立的可执行环境，它其中就包括了JavaScript内置的函数与对象。既然每个context都包含这些内置的函数与对象，加载的过程就比较耗时，v8做了一些优化，第一次创建context时候，会解析创建内置对象的JS代码，并创建对象，以后再创建context就只创建对象，而不再解析JS代码了。并且为第一创建也提供了快照功能，也会加快解析。  </p><p>你也可以多次进入、退出一个context，也可进入多个context，但只有一个当前的context。<br><img src="context图解.png" alt="context图解.png">  </p></li><li><p>template  </p><p>模板可以将C++的函数或者数据结构封装进一个JavaScript对象，这样可以再JavaScript中去操作这些对象。 在一个context下，一个template只能有一个实例。  </p><p>JavaScript有强烈的函数、对象二元性。这也反应在template上。有2种类型的template：</p><ul><li><p>Function template<br>通过调用template的GetFunction方法，在context中创建一个template的实例。可以将一个C++的回调函数与function template连接，这样当Js实例调用时，触发相应的C++函数。</p></li><li><p>Object template<br>每一个function template都与一个object template相连。用作配置被function示例化的对象（这里function当做类使用）。可以讲2种c++回调与object template关联。<br>accessor: 当一个Js对象的指定属性被访问使，触发<br>interceptor: 当一个Js对象的任意属性被访问时，触发</p></li></ul></li><li><p>Security model  </p><p>同源策略禁止一个origin的script访问另外一个origin的script的属性（数据）。origin在此指的是域名(<a href="http://www.example.com)、协议(https)、端口的结合。这3个相同，才可以认为是同源。" target="_blank" rel="noopener">www.example.com)、协议(https)、端口的结合。这3个相同，才可以认为是同源。</a><br>在V8中，“origin”被定义为context。默认禁止从任何一个context中访问另外一个context。既然默认禁止，那就有不默认的方式来访问。如果要从一个context访问另外一个context，就需要使用security token。可以在创建context时通过setSecurityToken手动创建，或者v8自动生成一个。当然时，v8的安全系统会检查调用者的token与被调用者的token，如果匹配，就允许访问，反之，就进一个回调来判断是否允许。</p></li><li><p>Exception  </p><p>当一个脚本执行不成功，V8返回空句柄。所以在继续执行之前，必须检查返回值是否是空句柄。<br>想要捕获异常，使用TryCatch，例如：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TryCatch <span class="title">trycatch</span><span class="params">(isolate)</span></span>;</span><br><span class="line">Local&lt;Value&gt; v = script-&gt;Run();</span><br><span class="line"><span class="keyword">if</span> (v.IsEmpty()) &#123;</span><br><span class="line">  Local&lt;Value&gt; exception = trycatch.Exception();</span><br><span class="line">  String::<span class="function">Utf8Value <span class="title">exception_str</span><span class="params">(exception)</span></span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Exception: %s\n"</span>, *exception_str);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式有点像unix，通过返回值标识是否错误，通过主动get错误信息来打印。</p></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>  官方给出3个示例，这里给出process这里示例的地址:<br>  <a href="https://github.com/v8/v8/blob/master/samples/process.cc" target="_blank" rel="noopener">process.cc</a><br>  <a href="https://github.com/v8/v8/blob/master/samples/count-hosts.js" target="_blank" rel="noopener">js脚本</a>  </p><p>  这个示例实现的是，统计访问host的个数，progess函数通过js来实现，保存在全局对象中，通过以下代码讲Js的函数引用到C++ process_对象中</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Local&lt;String&gt; process_name =</span><br><span class="line">  String::NewFromUtf8(GetIsolate(), <span class="string">"Process"</span>, NewStringType::kNormal)</span><br><span class="line">      .ToLocalChecked();</span><br><span class="line">Local&lt;Value&gt; process_val;</span><br><span class="line"><span class="comment">// If there is no Process function, or if it is not a function,</span></span><br><span class="line"><span class="comment">// bail out</span></span><br><span class="line"><span class="keyword">if</span> (!context-&gt;Global()-&gt;Get(context, process_name).ToLocal(&amp;process_val) ||</span><br><span class="line">    !process_val-&gt;IsFunction()) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// It is a function; cast it to a Function</span></span><br><span class="line">Local&lt;Function&gt; process_fun = Local&lt;Function&gt;::Cast(process_val);</span><br><span class="line">  </span><br><span class="line"><span class="comment">// Store the function in a Global handle, since we also want</span></span><br><span class="line"><span class="comment">// that to remain after this call returns</span></span><br><span class="line">process_.Reset(GetIsolate(), process_fun);</span><br></pre></td></tr></table></figure><p>  然后，写了一个Process函数，来调用，这个Process函数有些像代理一样  </p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> argc = <span class="number">1</span>;</span><br><span class="line">Local&lt;Value&gt; argv[argc] = &#123;request_obj&#125;;</span><br><span class="line">v8::Local&lt;v8::Function&gt; process =</span><br><span class="line">    v8::Local&lt;v8::Function&gt;::New(GetIsolate(), process_);</span><br><span class="line">Local&lt;Value&gt; result;</span><br><span class="line"><span class="keyword">if</span> (!process-&gt;Call(context, context-&gt;Global(), argc, argv).ToLocal(&amp;result)) &#123;</span><br><span class="line">  String::Utf8Value error(GetIsolate(), try_catch.Exception());</span><br><span class="line">  Log(*error);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  以上可以认为是C++调用JavaScript的函数，另外还有JavaScript使用C++的数据对象。<br>  既然是计数，最好的方式就是map，这里C++的实现就是用的Map来实现。然后将Map封装到全局的template下，就可以在脚本中直接使用该对象了。(原代码封装了2个对象,opts与output) </p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">bool</span> JsHttpRequestProcessor::InstallMaps(<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;* opts,</span><br><span class="line">                                         <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;* output) &#123;</span><br><span class="line">  HandleScope handle_scope(GetIsolate());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Wrap the map object in a JavaScript wrapper</span></span><br><span class="line">  Local&lt;Object&gt; opts_obj = WrapMap(opts);</span><br><span class="line"></span><br><span class="line">  v8::Local&lt;v8::Context&gt; context =</span><br><span class="line">      v8::Local&lt;v8::Context&gt;::New(GetIsolate(), context_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set the options object as a property on the global object.</span></span><br><span class="line">  context-&gt;Global()</span><br><span class="line">      -&gt;Set(context,</span><br><span class="line">            String::NewFromUtf8(GetIsolate(), <span class="string">"options"</span>, NewStringType::kNormal)</span><br><span class="line">                .ToLocalChecked(),</span><br><span class="line">            opts_obj)</span><br><span class="line">      .FromJust();</span><br><span class="line"></span><br><span class="line">  Local&lt;Object&gt; output_obj = WrapMap(output);</span><br><span class="line">  context-&gt;Global()</span><br><span class="line">      -&gt;Set(context,</span><br><span class="line">            String::NewFromUtf8(GetIsolate(), <span class="string">"output"</span>, NewStringType::kNormal)</span><br><span class="line">                .ToLocalChecked(),</span><br><span class="line">            output_obj)</span><br><span class="line">      .FromJust();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Js中使用output<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Process</span>(<span class="params">request</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (options.verbose) &#123;</span><br><span class="line">    log(<span class="string">"Processing "</span> + request.host + request.path +</span><br><span class="line">        <span class="string">" from "</span> + request.referrer + <span class="string">"@"</span> + request.userAgent);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!output[request.host]) &#123;</span><br><span class="line">    output[request.host] = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    output[request.host]++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用node.js也有一段时间了，一直没有深入的研究一下node，这次就对node.js相关的技术，进行从上层到底层的学习，内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;v8引擎     &amp;lt;=&lt;/li&gt;
&lt;li&gt;node.js  &lt;/li&gt;
&lt;li&gt;libuv  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;libuv的避免不了unix环境编程的api，这一块与node.js有点距离，不放在这个系列中了。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="v8" scheme="http://yoursite.com/tags/v8/"/>
    
  </entry>
  
  <entry>
    <title>微积分-其他</title>
    <link href="http://yoursite.com/2019/10/13/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%85%B6%E4%BB%96/"/>
    <id>http://yoursite.com/2019/10/13/微积分-其他/</id>
    <published>2019-10-13T13:40:25.000Z</published>
    <updated>2019-11-07T09:35:48.374Z</updated>
    
    <content type="html"><![CDATA[<p>本文是微积分复习的最后一篇，教材使用《普林斯顿微积分读本》，涵盖第27章-第30章的内容。  </p><ul><li>函数与微分  </li><li>积分  </li><li>级数  </li><li>其他      &lt;=</li></ul><p>本文的内容覆盖4章，包括：参数方程和极坐标、复数、体积弧长和表面积、微分方程。在函数中引入中间变量，过度到了参数方程，极坐标可以看作特殊的参数方程; 复数即可以用笛卡尔坐标系来表示，也可以用极坐标系来表示（欧拉公式），这两章的内容较近。体积、弧长与表面积一章是用微积分代入空间几何，可以看作一种应用，在3D中有很好的应用场景; 微分方程应用场景更宽广一些，这里介绍了3种微分方程的解法。  </p><a id="more"></a><h1 id="参数方程和极坐标"><a href="#参数方程和极坐标" class="headerlink" title="参数方程和极坐标"></a>参数方程和极坐标</h1><h2 id="参数方程"><a href="#参数方程" class="headerlink" title="参数方程"></a>参数方程</h2><ul><li><p>示例<br>x和y都是另外一个变量t的函数，例如：<br>x = 3cos(t) 和 y = 3sin(t)<br>图像为: <img src="参数方程示例.png" alt="参数方程示例.png">  </p></li><li><p>参数方程的导数<br><img src="参数方程的导数.png" alt="参数方程的导数.png">  </p></li></ul><h2 id="极坐标"><a href="#极坐标" class="headerlink" title="极坐标"></a>极坐标</h2><ul><li><p>极坐标与笛卡尔坐标互换<br>极坐标到笛卡尔坐标：x = rcos(θ) 和 y = rsin(θ)<br><img src="坐标变化1.png" alt="坐标变化1.png">  </p><p>笛卡尔坐标到极坐标：r<sup>2</sup> = x<sup>2</sup> + y<sup>2</sup> 和 tan(θ) = y/x, x不等于0， 需要检查象限<br><img src="极坐标的示例.png" alt="极坐标的示例.png">  </p></li><li><p>极坐标中的曲线<br>极坐标中的函数 r=f(θ), θ在给定的范围内取值。一般先画出r=f(θ)在笛卡尔坐标系下的图像，然后再画在极坐标中的图像<br>如 r=3sin(θ)</p><p><img src="极坐标画图.png" alt="极坐标画图.png"><br><img src="极坐标画图2.png" alt="极坐标画图2.png">  </p><p><img src="一些漂亮的极坐标曲线.png" alt="一些漂亮的极坐标曲线.png">  </p></li><li><p>极坐标曲线的切线<br>我们有r = f(θ)， 并且有 x = rcos(θ)一级 y = rsin(θ)<br>于是 x = f(θ)cos(θ) 和 y = f(θ)sin(θ)  </p><p>这样依据参数方式的切线方法 dy/dx = dy/dθ  /  dx/dθ</p><p>示例： r = 1+2cos(θ)，求穿过极坐标为（2, π/3）点的切线方程。</p><p>x = rcos(θ) = (1+2cos(θ))cos(θ)<br>y = rsin(θ) = (1+2cos(θ))sin(θ)<br>求导:<br>dy/dθ = -2sin<sup>2</sup>(θ) + (1+2cos(θ))cos(θ)<br>dx/dθ = -sin(θ)(1+4cos(θ))</p></li></ul><p>所以 dy/dx = dy/dθ / dx/dθ  将 θ = π/3代入得：<img src="极坐标切线.png" alt="极坐标切线.png">  代入点x = 2cos(π/3)=1 和 y = 2 sin(π/3) = √3</p><ul><li><p>极坐标曲线的围成的面积<br><img src="极坐标的面积.png" alt="极坐标的面积.png"><br><img src="极坐标的面积2.png" alt="极坐标的面积2.png">  </p><p>这里有个很有趣的例子：r = 1+2cos(θ)围成的图形的面积。<br><img src="极坐标面积示例.png" alt="极坐标面积示例.png"><br>直接从[0,2π]进行积分求处的面积是<img src="极坐标面积示例2.png" alt="极坐标面积示例2.png">图形的，问题在于θ 位于 2π/3 和 4π/3 之间时 , r 为负。由于面积公式包含r<sup>2</sup>无法辨别正负面积。（这与笛卡儿坐标下的情况大不相同,在笛卡儿坐标系中,y轴以下都为负）。<br>正解是通过通过完全的面积减去2倍小圈中的面积.<br>小圈中的面积为：<img src="极坐标面积示例3.png" alt="极坐标面积示例3.png"></p></li></ul><h1 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>复数的加、减、乘、除法则比较简单，不进行介绍了，主要介绍复数的指数化e<sup>z</sup><br>复指数也满足指数的法则 e<sup>z</sup>e<sup>w</sup> = e<sup>z+w</sup><br>证明的过程可以借鉴指数的泰勒级数：<br><img src="复指数函数-1.png" alt="复指数函数-1.png"><br><img src="复指数函数-2.png" alt="复指数函数-2.png"></p><h2 id="欧拉公式"><a href="#欧拉公式" class="headerlink" title="欧拉公式"></a>欧拉公式</h2><p><img src="欧拉公式.png" alt="欧拉公式.png"><br>欧拉公式的证明可以通过泰勒级数展开的方式进行证明。<br>不管怎么看，它都太简单，太美丽了，完美的定义了复数的极坐标形式<br><img src="复平面.png" alt="复平面.png"><br><img src="复平面示例1.png" alt="复平面示例1.png">  </p><p><img src="欧拉公式证明1.png" alt="欧拉公式证明1.png"><br><img src="欧拉公式证明2.png" alt="欧拉公式证明2.png">  </p><h2 id="复数的高次幂"><a href="#复数的高次幂" class="headerlink" title="复数的高次幂"></a>复数的高次幂</h2><p>为什么要使用极坐标形式呢？一个原因是，极坐标形式比较容易进行乘法跟取幂运算。<br>如：<br><img src="复数的高次幂.png" alt="复数的高次幂.png">  </p><h2 id="解Zn-w"><a href="#解Zn-w" class="headerlink" title="解Zn = w"></a>解Z<sup>n</sup> = w</h2><p><img src="解复数的幂-1.png" alt="解复数的幂-1.png"><br><img src="解复数的幂-2.png" alt="解复数的幂-2.png"><br><img src="解复数的幂-3.png" alt="解复数的幂-3.png"></p><p>这里的 5θ = 5π/6 + 2πk</p><p>因为极坐标方式很容易求指数方式，所以，复数的次幂，都是转换成极坐标方式进行求解。</p><h2 id="解-ez-w"><a href="#解-ez-w" class="headerlink" title="解 ez = w"></a>解 e<sup>z</sup> = w</h2><p><img src="e的复数次幂-1.png" alt="e的复数次幂-1.png"><br>z = x + iy<br><img src="e的复数次幂-2.png" alt="e的复数次幂-2.png">  </p><p>与复数的次幂类似，也转换成极坐标的方式来进行求解。  </p><h1 id="体积、弧长和表面积"><a href="#体积、弧长和表面积" class="headerlink" title="体积、弧长和表面积"></a>体积、弧长和表面积</h1><p>本章是微积分在空间几何中的应用，主要是求体积与求表面积2大目标，弧长的求解是表面积求解的引子</p><h2 id="旋转体的体积"><a href="#旋转体的体积" class="headerlink" title="旋转体的体积"></a>旋转体的体积</h2><p><img src="圆盘法-1.png" alt="圆盘法-1.png">  </p><ul><li><p>圆盘法<br>圆盘法是黎曼和积分的扩展。<br>求此图形绕x轴旋转得到图形的体积  </p><p><img src="圆盘法-2.png" alt="圆盘法-2.png"><br><img src="圆盘法-3.png" alt="圆盘法-3.png"><br>将体积看作面积的积分。  </p></li><li><p>壳法<br>求此图形绕y轴旋转得到图形的体积</p><p><img src="壳法-1.png" alt="壳法-1.png"><br>壳法比圆盘法理解更新奇一点,这里想想此图形y轴方向截开，形成长方体的体积。<br><img src="壳法-2.png" alt="壳法-2.png"><br><img src="壳法-3.png" alt="壳法-3.png">  </p></li><li><p>总结  </p><ul><li>若每个小条的dx边平行于旋转轴，运用圆盘法  </li><li>若咩个小条的dx边垂直于旋转轴，运用壳法</li></ul></li></ul><h2 id="一般立方体体积"><a href="#一般立方体体积" class="headerlink" title="一般立方体体积"></a>一般立方体体积</h2><p>一般立方体的体积求法也是考虑体积是面积的积分。需要注意是面积的选择与积分区间的选择。<br>基本上,你的选择是:选择一个轴,所有的切片将垂直于这个轴.一旦选定了轴,后续的思路就清晰了:求得每个垂直于该轴的切片的横截面面积.不同的切片有不同的面积。</p><ul><li>选定一个轴  </li><li>求轴上点x处的横截面面积，称该面积为A(x)  </li><li><img src="一般体积求法.png" alt="一般体积求法.png">  </li></ul><p><img src="一般体积求法示意图.png" alt="一般体积求法示意图.png">  </p><p>这些面积的求解都依赖于原始的曲线方程，那如果生活中一个物体，要求其体积如何来做呢。大概可以考虑拟合出曲线来，然后用公式求解，更一般的也许就类似与草冲称象了。  </p><h2 id="弧长"><a href="#弧长" class="headerlink" title="弧长"></a>弧长</h2><p><img src="弧长公式图像.png" alt="弧长公式图像.png"><br><img src="弧长公式-1.png" alt="弧长公式-1.png"><br><img src="弧长公式-2.png" alt="弧长公式-2.png"><br>这里有一点很有趣的变化，就是将(dx)<sup>2</sup>提到的根号外边。原文称这个变化需要进行证明但证明超越原书范围。<br>弧长公式也有参数形式: <img src="弧长公式-3.png" alt="弧长公式-3.png">  </p><ul><li>示例：<br><img src="弧长公式示例1.png" alt="弧长公式示例1.png"><br>t在[3,5]之间</li></ul><p><img src="弧长公式示例2.png" alt="弧长公式示例2.png"><br>根号内化简得到：36(t + 2)<sup>2</sup>  </p><ul><li>物理中的应用<br>定义在时间 t 秒处的蚂蚁位置是(x(t), y(t)). 那么,蚂蚁在时间 t 的速率是多少?<br><img src="速率.png" alt="速率.png">  </li></ul><p>把速率进行积分，就是蚂蚁走过曲线的弧长  </p><h2 id="旋转体的表面积"><a href="#旋转体的表面积" class="headerlink" title="旋转体的表面积"></a>旋转体的表面积</h2><p><img src="表面积示意图.png" alt="表面积示意图.png"><br>表面积看作周长的积分</p><p><img src="表面积公式1.png" alt="表面积公式1.png"><br><img src="表面积公式2.png" alt="表面积公式2.png">  </p><h1 id="微分方程"><a href="#微分方程" class="headerlink" title="微分方程"></a>微分方程</h1><p>微分方程就是包含导数的方程，它对于描述现实世界中量的变化非常有用，比如了解种群增长快慢，或者还清贷款等，都可以有微分方程来建模。  </p><h2 id="可分离变量的一阶微分方程"><a href="#可分离变量的一阶微分方程" class="headerlink" title="可分离变量的一阶微分方程"></a>可分离变量的一阶微分方程</h2><p>可分离变量的一阶微分方程指的是所有关于y的部分(包括dy)放到一边，所有关于x的部分(包括dx)放到另外一边。<br>这种方程比较好求解，只需要两边求积分即可，这里只介绍一个简单的示例：  </p><p><img src="可分离变量-1.png" alt="可分离变量-1.png"><br><img src="可分离变量-2.png" alt="可分离变量-2.png"><br><img src="可分离变量-3.png" alt="可分离变量-3.png">  </p><h2 id="一阶线性微分方程"><a href="#一阶线性微分方程" class="headerlink" title="一阶线性微分方程"></a>一阶线性微分方程</h2><ul><li><p>定义：<br>一阶线性微分方程：<img src="一阶线性方程形式.png" alt="一阶线性方程形式.png">。dy/dx 与 y的幂次都是1  </p></li><li><p>解法：<br>这种方程的解法是使用配方法，将左侧进行变换，转换成可分离变量的形式。进行的变化可以借鉴乘法的导数法则。<br><img src="一阶线性微分方程.png" alt="一阶线性微分方程.png">  </p><p><img src="配方法解释-1.png" alt="配方法解释-1.png"><br><img src="配方法解释-2.png" alt="配方法解释-2.png">  </p><p>这是一种解法，也可以参考下一节的常系数微分方程的解法</p></li><li><p>示例：<br><img src="一阶线性微分方程1.png" alt="一阶线性微分方程1.png"><br>两边乘e<sup>2x<sup>3</sup></sup>得：<br><img src="一阶线性微分方程2.png" alt="一阶线性微分方程2.png"><br><img src="一阶线性微分方程3.png" alt="一阶线性微分方程3.png">  </p></li></ul><h2 id="常系数微分方程"><a href="#常系数微分方程" class="headerlink" title="常系数微分方程"></a>常系数微分方程</h2><ul><li><p>定义：<br><img src="常系数微分方程.png" alt="常系数微分方程.png"><br>a<sub>n</sub> 只是一些普通的常实数。  </p></li><li><p>解法：<br>解法一般显示解齐次(右侧为0)，然后再解非齐次的特解，然后再合并。有些像线代中的解法，这里只介绍1次与2次。  </p></li><li><p>一阶齐次解法：<br><img src="一阶齐次.png" alt="一阶齐次.png"><br>y = Ae<sup>-ax</sup>  </p></li><li><p>二阶齐次解法：<br><img src="二阶齐次方程.png" alt="二阶齐次方程.png"><br><img src="二阶齐次方程解法.png" alt="二阶齐次方程解法.png">  </p><p>那为什么这种解法适用？<img src="二阶齐次解法解释.png" alt="二阶齐次解法解释.png">  </p></li><li><p>二阶非齐次<br>求一个特解，非齐次的解= 一般解 + 特解<br>特解归纳如下：<br><img src="特解的求法归纳.png" alt="特解的求法归纳.png">  </p></li><li><p>示例<br><img src="常系数示例1.png" alt="常系数示例1.png"><br>先求齐次部分：<br>t<sup>2</sup> -4t + 4 = 0，只有一个解，t=2<br><img src="常系数示例2.png" alt="常系数示例2.png"><br>特解形式为： <img src="常系数示例3.png" alt="常系数示例3.png"><br>代入方程求解的：C=-4 D=-3.<br><img src="常系数示例4.png" alt="常系数示例4.png">  </p></li></ul><h2 id="微分方程建模"><a href="#微分方程建模" class="headerlink" title="微分方程建模"></a>微分方程建模</h2><p>微分方程以上都是工具，建模部分是核心，它告诉我们，微分方程能如何使用。可惜的是，这部分原书中示例很少，只有一个细菌培养的例子。  </p><p><img src="微分方程建模1.png" alt="微分方程建模1.png"><br><img src="微分方程建模2.png" alt="微分方程建模2.png"><br>这是一个一阶线性微分方程，套用上边解法即可  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是微积分复习的最后一篇，教材使用《普林斯顿微积分读本》，涵盖第27章-第30章的内容。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数与微分  &lt;/li&gt;
&lt;li&gt;积分  &lt;/li&gt;
&lt;li&gt;级数  &lt;/li&gt;
&lt;li&gt;其他      &amp;lt;=&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文的内容覆盖4章，包括：参数方程和极坐标、复数、体积弧长和表面积、微分方程。在函数中引入中间变量，过度到了参数方程，极坐标可以看作特殊的参数方程; 复数即可以用笛卡尔坐标系来表示，也可以用极坐标系来表示（欧拉公式），这两章的内容较近。体积、弧长与表面积一章是用微积分代入空间几何，可以看作一种应用，在3D中有很好的应用场景; 微分方程应用场景更宽广一些，这里介绍了3种微分方程的解法。  &lt;/p&gt;
    
    </summary>
    
      <category term="理论" scheme="http://yoursite.com/categories/%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="微积分" scheme="http://yoursite.com/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>微积分-级数</title>
    <link href="http://yoursite.com/2019/09/28/%E5%BE%AE%E7%A7%AF%E5%88%86-%E7%BA%A7%E6%95%B0/"/>
    <id>http://yoursite.com/2019/09/28/微积分-级数/</id>
    <published>2019-09-28T06:41:25.000Z</published>
    <updated>2019-11-07T09:35:48.374Z</updated>
    
    <content type="html"><![CDATA[<p>本文是微积分复习的第三篇，教材使用《普林斯顿微积分读本》，涵盖第22章-第26章的内容。  </p><ul><li>函数与微分  </li><li>积分      </li><li>级数      &lt;=</li><li>其他</li></ul><p>级数的进入是从数列开始的，首先是数列的收敛性，然后是级数的收敛性，然后过度到泰勒级数，最后是对泰勒级数的应用（估值问题）。<br>级数是积分概念在离散数列的延伸，正向理解，是对离散数据的求和，反向理解，是对函数的分解。就分解而言，在工程领域得到了充分的应用。</p><a id="more"></a><h1 id="级数的收敛性"><a href="#级数的收敛性" class="headerlink" title="级数的收敛性"></a>级数的收敛性</h1><h2 id="数列收敛性"><a href="#数列收敛性" class="headerlink" title="数列收敛性"></a>数列收敛性</h2><p>谈到收敛性，就离不开极限，而数列从函数那里继承了很多极限的性质：  </p><ul><li>数列继承了函数的极限性质  </li><li>三明治定理  </li><li>连续函数保持极限，lim g(x) -&gt; L 则lim f(g(x)) -&gt; f(L)</li></ul><h2 id="级数收敛性简介"><a href="#级数收敛性简介" class="headerlink" title="级数收敛性简介"></a>级数收敛性简介</h2><p>级数就是和，就是将数列a<sub>n</sub>的所有项都加起来;<br>级数对等的是积分，无穷级数的收敛性对等反常积分对无限的积分，这样对反常积分收敛性的4种判别方法，就可以应用到级数上，另外级数也有几种独有的级数。  </p><h2 id="反常积分的方法"><a href="#反常积分的方法" class="headerlink" title="反常积分的方法"></a>反常积分的方法</h2><ul><li><p>第n项判别法<br><img src="第n项判别法.png" alt="第n项判别法"><br>注意：第n项判别法不能用于级数收敛性的判别，即lim a<sub>n</sub> = 0未必收敛。 </p></li><li><p>极限比较判别法<br><img src="极限比较判别法.png" alt="极限比较判别法.png">   </p></li><li><p>p判别法<br><img src="p值判断法.png" alt="p值判断法.png">  </p></li><li><p>绝对收敛判别法<br><img src="绝对收敛判别法.png" alt="绝对收敛判别法.png">  </p></li></ul><h2 id="特有的方法"><a href="#特有的方法" class="headerlink" title="特有的方法"></a>特有的方法</h2><p>以上是从反常积分继承来的判别法，以下是级数特有的判别法，包括：比式判别法、根式判别法、积分判别法和交错级数判别法<br>比式判别法与根式判别法不之间判断源数列，而是构建一个新的数列，通过判断新数列的收敛性来判断级数的收敛性  </p><ul><li><p>比式判别法</p><p>构建一个新的数列b<sub>n</sub>，定义其为数列相邻两项之的绝对值, 若b<sub>n</sub>收敛于一个小于1的数，则原级数收敛;大于1的数，则原级数发散;等于1，则不应该用比式判别法。  </p><p><img src="比式判别法.png" alt="比式判别法.png"></p></li><li><p>根式判别法  </p><p>根式判别式构建的新数列为第n项绝对值的n次方根，若b<sub>n</sub>收敛于一个小于1的数，则原级数收敛;大于1的数，则原级数发散;等于1，则不应该用根式判别法。  </p><p><img src="根式判别法.png" alt="根式判别法.png"></p></li><li><p>积分判别法  </p><p><img src="积分判别法.png" alt="积分判别法.png">  </p><p>若函数的f(x)的积分<img src="积分判别法-2.png" alt="积分判别法-2.png">收敛，则对应级数也收敛  </p></li><li><p>交错级数判别法  </p><p>若级数是交错的，且各项的绝对值递减趋于0,则级数收敛<br>这里引出一个条件收敛的概念，若一个级数收敛二其绝对值发散，就称为条件收敛<br>示例：  <img src="交错级数.png" alt="交错级数.png">  </p></li></ul><h2 id="使用总结"><a href="#使用总结" class="headerlink" title="使用总结"></a>使用总结</h2><p><img src="判断法使用总结.png" alt="判断法使用总结.png">  </p><p>特有方法的使用优先级高于继承方法的优先级  </p><h1 id="泰勒级数与幂级数"><a href="#泰勒级数与幂级数" class="headerlink" title="泰勒级数与幂级数"></a>泰勒级数与幂级数</h1><h2 id="泰勒定理"><a href="#泰勒定理" class="headerlink" title="泰勒定理"></a>泰勒定理</h2><p><img src="泰勒近似定理.png" alt="泰勒近似定理.png">  </p><p><img src="泰勒定理.png" alt="泰勒定理.png">  </p><p>若想证明一个函数在某些x处等于它的泰勒级数，需要证明当N → ∞ 时 R<sub>N</sub>(x) → 0.<br><img src="一个极限.png" alt="一个极限.png"> 对所有x都成立。  </p><h2 id="幂级数与泰勒级数"><a href="#幂级数与泰勒级数" class="headerlink" title="幂级数与泰勒级数"></a>幂级数与泰勒级数</h2><p>幂级数是以a<sub>0</sub>+a<sub>1</sub>x + a<sub>2</sub>x<sup>2</sup> + a<sub>3</sub>x<sup>3</sup> + a<sub>4</sub>x<sup>4</sup> + …<br>也可以写成![幂级数一般形式.png])<br>在x=a处的幂级数：<img src="幂级数形式.png" alt="幂级数形式.png">  </p><p>从这个形式处，可以看出泰勒级数是一种特殊的幂级数: <img src="幂级数与泰勒级数.png" alt="幂级数与泰勒级数.png">  </p><p>这里有一个麦克劳林级数，它是泰勒级数的在x=0处的特例：<img src="麦克劳林级数.png" alt="麦克劳林级数.png">  </p><h1 id="求解估值问题"><a href="#求解估值问题" class="headerlink" title="求解估值问题"></a>求解估值问题</h1><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>用二阶泰勒多项式估算e<sup>1/3</sup>，并估算误差  </p><table><thead><tr><th>n</th><th>f<sup>(n)</sup>(x)</th><th>f<sup>(n)</sup>(0)</th></tr></thead><tbody><tr><td>0</td><td>e<sup>x</sup></td><td>1</td></tr><tr><td>1</td><td>e<sup>x</sup></td><td>1</td></tr><tr><td>2</td><td>e<sup>x</sup></td><td>1</td></tr><tr><td>3</td><td>e<sup>x</sup></td><td>1</td></tr></tbody></table><p><img src="估值示例1-1.png" alt="估值示例1-1.png"><br><img src="估值示例1-2.png" alt="估值示例1-2.png"><br><img src="估值示例1-3.png" alt="估值示例1-3.png">  </p><p><img src="估值示例1-4.png" alt="估值示例1-4.png"><br><img src="估值示例1-5.png" alt="估值示例1-5.png"></p><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>估算sqart(27)，误差不大于1/250    </p><p><img src="估值示例2-1.png" alt="估值示例2-1.png"><br><img src="估值示例2-2.png" alt="估值示例2-2.png"><br>求得N = 1即可。P<sub>1</sub>(27) = 5 + 1/10 *(27-25) = 26/5</p><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><p>用三阶泰勒级数估算 cos(π/3 − 0.01) 的值 ,<br><img src="估值示例3-1.png" alt="估值示例3-1.png"><br><img src="估值示例3-2.png" alt="估值示例3-2.png"><br>求得N=3<br><img src="估值示例3-3.png" alt="估值示例3-3.png">  </p><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><h2 id="幂级数收敛半径与收敛区间"><a href="#幂级数收敛半径与收敛区间" class="headerlink" title="幂级数收敛半径与收敛区间"></a>幂级数收敛半径与收敛区间</h2><p>幂级数的收敛性判断，大多数时间使用比值判别法，有时可以使用根式判别法。<br><img src="幂级数收敛半径.png" alt="幂级数收敛半径.png"><br><img src="幂级数收敛半径-1.png" alt="幂级数收敛半径-1.png"><br><img src="幂级数收敛半径-2.png" alt="幂级数收敛半径-2.png"><br>当|x|&lt; 1 时绝对收敛，当|x| &gt; 1时绝对发散。<br>再考虑 x = 1 与 x = -1情况：<br>当x = 1 时<img src="幂级数收敛半径-3.png" alt="幂级数收敛半径-3.png">它发散<br>当x = -1时 <img src="幂级数收敛半径-4.png" alt="幂级数收敛半径-4.png">条件收敛  </p><h2 id="利用现有泰勒级数求其他泰勒级数"><a href="#利用现有泰勒级数求其他泰勒级数" class="headerlink" title="利用现有泰勒级数求其他泰勒级数"></a>利用现有泰勒级数求其他泰勒级数</h2><p><img src="麦克劳林级数1.png" alt="麦克劳林级数1.png"><br><img src="麦克劳林级数2.png" alt="麦克劳林级数2.png">  </p><p>可以通过换元、求导、求积分的方式求其他级数  </p><ul><li><p>换元<br><img src="麦克劳林级数-换元.png" alt="麦克劳林级数-换元.png">  </p><p><img src="麦克劳林级数-换元2.png" alt="麦克劳林级数-换元2.png"><br><img src="麦克劳林级数-换元2-2.png" alt="麦克劳林级数-换元2-2.png">  </p></li><li><p>求导<br><img src="麦克劳林级数-求导.png" alt="麦克劳林级数-求导.png">  </p></li><li><p>求积分<br><img src="麦克劳林级数-求积分.png" alt="麦克劳林级数-求积分.png">  </p></li></ul><h2 id="利用麦克劳林求极限"><a href="#利用麦克劳林求极限" class="headerlink" title="利用麦克劳林求极限"></a>利用麦克劳林求极限</h2><p>利用麦克劳林级数求极限时，将所有的函数，换算成多项式，然后进行合并求解即可<br><img src="泰勒级数求极限.png" alt="泰勒级数求极限.png"><br><img src="泰勒级数求极限-2.png" alt="泰勒级数求极限-2.png"><br><img src="泰勒级数求极限-3.png" alt="泰勒级数求极限-3.png"><br><img src="泰勒级数求极限-4.png" alt="泰勒级数求极限-4.png"><br><img src="泰勒级数求极限-5.png" alt="泰勒级数求极限-5.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是微积分复习的第三篇，教材使用《普林斯顿微积分读本》，涵盖第22章-第26章的内容。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数与微分  &lt;/li&gt;
&lt;li&gt;积分      &lt;/li&gt;
&lt;li&gt;级数      &amp;lt;=&lt;/li&gt;
&lt;li&gt;其他&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;级数的进入是从数列开始的，首先是数列的收敛性，然后是级数的收敛性，然后过度到泰勒级数，最后是对泰勒级数的应用（估值问题）。&lt;br&gt;级数是积分概念在离散数列的延伸，正向理解，是对离散数据的求和，反向理解，是对函数的分解。就分解而言，在工程领域得到了充分的应用。&lt;/p&gt;
    
    </summary>
    
      <category term="理论" scheme="http://yoursite.com/categories/%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="微积分" scheme="http://yoursite.com/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>微积分-积分</title>
    <link href="http://yoursite.com/2019/09/06/%E5%BE%AE%E7%A7%AF%E5%88%86-%E7%A7%AF%E5%88%86/"/>
    <id>http://yoursite.com/2019/09/06/微积分-积分/</id>
    <published>2019-09-06T13:36:30.000Z</published>
    <updated>2019-10-18T00:59:24.112Z</updated>
    
    <content type="html"><![CDATA[<p>本文是微积分复习的第二篇，教材使用《普林斯顿微积分读本》，涵盖第15章-第21章的内容。  </p><ul><li>函数与微分  </li><li>积分       &lt;=</li><li>级数</li><li>其他</li></ul><a id="more"></a><h1 id="积分定义"><a href="#积分定义" class="headerlink" title="积分定义"></a>积分定义</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>积分是从级数求和引入的，比如第一例子：<br><img src="级数求和.png" alt="级数求和.png"><br>这种引入方式即暗示积分的求（有向）面积，求位移做铺垫，也为后边级数做准备。</p><h2 id="伸缩级数"><a href="#伸缩级数" class="headerlink" title="伸缩级数"></a>伸缩级数</h2><p>比较有趣的一个例子:<br><img src="伸缩级数.png" alt="伸缩级数.png"><br>书中用伸缩级数的方法，推导出了平方和级数的和公式：<br><img src="伸缩级数推动-1.png" alt="伸缩级数推动-1.png"><br>将等式左侧整理后得到<br><img src="伸缩级数推动-2.png" alt="伸缩级数推动-2.png"><br><img src="伸缩级数推动-3.png" alt="伸缩级数推动-3.png">  </p><h2 id="有向面积"><a href="#有向面积" class="headerlink" title="有向面积"></a>有向面积</h2><p>这一段主要从直观上看级数到积分的一个过度<br><img src="有向面积.png" alt="有向面积.png"><br><img src="有向面积-2.png" alt="有向面积-2.png">  </p><h1 id="定积分"><a href="#定积分" class="headerlink" title="定积分"></a>定积分</h1><h2 id="定积分定义（黎曼和）"><a href="#定积分定义（黎曼和）" class="headerlink" title="定积分定义（黎曼和）"></a>定积分定义（黎曼和）</h2><p>定积分是一种定义，是一种求某段[a,b]曲线y=f(x)，与X轴形成闭合图形的面积。可以看出，定积分面向的是一个具体的问题，然后再次抽象之后才出现了不定积分。  </p><p>这个图形面积的求法，就需要借鉴上一节有向面积。将上一节的公式区间长度趋向于0,就是这个图像的面积，也就是积分。<br><img src="黎曼和.png" alt="黎曼和.png"><br>上一节的求和部分，也别称作黎曼和。<br>积分的定义也离不开极限。这里发散一下，这个叫黎曼和，也就与黎曼有关，而黎曼是19世纪人物，微积分是17世纪创立的，也就是这个定义，是很久之后才确定的。</p><h2 id="定积分性质"><a href="#定积分性质" class="headerlink" title="定积分性质"></a>定积分性质</h2><p>有了定义，就有了几个简单的性质：  </p><ol><li><img src="定积分性质-1.png" alt="定积分性质-1.png">  </li><li><img src="定积分性质-2.png" alt="定积分性质-2.png"></li><li><img src="定积分性质-3.png" alt="定积分性质-3.png"></li><li><img src="定积分性质-4.png" alt="定积分性质-4.png"></li><li><img src="定积分性质-5.png" alt="定积分性质-5.png"></li></ol><p>对这几个性质只说一点：在矩阵中，我们说线性变换符合两个公式：<br>T(v+w) = T(v) + T(w); T(cv) = cT(v)。如果把f(x)看作v，g(x)看作w，那积分就可以看作成一种线性变换了。  </p><h2 id="估算积分"><a href="#估算积分" class="headerlink" title="估算积分"></a>估算积分</h2><p>积分既然可以看作成一种面积，面积就有大小之分<br><img src="积分的简单估算.png" alt="积分的简单估算.png"><br>这样就看出，积分是在[m(b-a), M(b-a)]之间</p><h2 id="积分中值定理"><a href="#积分中值定理" class="headerlink" title="积分中值定理"></a>积分中值定理</h2><p>有了最大值与最小值，也就想到平均值。<br><img src="积分中值定理.png" alt="积分中值定理.png"><br><img src="积分中值定理2.png" alt="积分中值定理2.png"><br>f(c)就可以看作是f(x)在区间[a,b]上的平均值。  </p><h1 id="微积分基本定理"><a href="#微积分基本定理" class="headerlink" title="微积分基本定理"></a>微积分基本定理</h1><p>注意，这里说的是微积分基本定理，将积分与微分联合到一起的定理。主要有2个基本定理，一个阐述积分与微分之间的关系，从这里引出了不定积分，另一是积分函数与被积函数的关系，从而引出了不定积分的计算方法。</p><h2 id="第一基本定理"><a href="#第一基本定理" class="headerlink" title="第一基本定理"></a>第一基本定理</h2><p><img src="微积分第一基本定理.png" alt="微积分第一基本定理.png"><br>这里看出，微积分基本定理是与定积分相关的定理，也就是包含积分的上下限，以后的很多文章都是在上下限中做的。  </p><p>其证明源自:<br><img src="微积分第一定理的证明.png" alt="微积分第一定理的证明.png"><br><img src="微积分第一定理的证明2.png" alt="微积分第一定理的证明2.png">  </p><p>对比不定积分与导数：<br><img src="不定积分.png" alt="不定积分.png">  </p><h2 id="第二基本定理"><a href="#第二基本定理" class="headerlink" title="第二基本定理"></a>第二基本定理</h2><p><img src="微积分第二基本定理.png" alt="微积分第二基本定理.png"><br>微积分第二基本定理的证明书中没有画图，画图的话会很简单，就是阴影部分面积的减法运算。  </p><p>证明:<br><img src="微积分第二定理证明.png" alt="微积分第二定理证明.png"><br>函数到a部分的面积是F(a)，函数到b部分的面积是F(b)，那[a,b]之间的面积自然就是F(b)-F(a)了。</p><h2 id="积分上下限是函数"><a href="#积分上下限是函数" class="headerlink" title="积分上下限是函数"></a>积分上下限是函数</h2><p>积分上限是函数：  </p><p>这句话说全了是这样：求积分式的导数，如果积分上限是函数。解题时，其实是将上限设成另外一个变量，然后再隐函数求导。如：</p><p><img src="积分上限是函数.png" alt="积分上限是函数.png"><br><img src="积分上限是函数2.png" alt="积分上限是函数2.png"><br>这里需要注意，dy/du中积出的函数变量是u，后边要用x替换掉。  </p><p>积分下限是函数与上限是函数相同，做一个相反数即可转换成，这里不做介绍</p><ul><li>积分与导数公式  </li></ul><p><img src="积分公式.png" alt="积分公式.png"></p><h1 id="微积分基本方法1"><a href="#微积分基本方法1" class="headerlink" title="微积分基本方法1"></a>微积分基本方法1</h1><h2 id="换元法"><a href="#换元法" class="headerlink" title="换元法"></a>换元法</h2><ul><li><p>示例1</p><p><img src="换元法示例1-1.png" alt="换元法示例1-1.png"><br>这里设t = x<sup>3</sup>，将t导入得<br> (1/3)sin(x<sup>3</sup>) + C</p></li><li><p>示例2<br><img src="换元法示例2.png" alt="换元法示例2.png"><br>这里设t = x<sup>3</sup> + 7x - 9<br>从示例2看出的公式是这样：<br><img src="换元法公式1.png" alt="换元法公式1.png">  </p></li><li><p>示例3<br><img src="换元法示例3.png" alt="换元法示例3.png">  </p></li><li><p>示例4<br><img src="换元法示例4.png" alt="换元法示例4.png"><br> 这里的t = e<sup>x</sup>  </p></li><li><p>示例5<br> <img src="换元法示例5-1.png" alt="换元法示例5-1.png"><br> 这个与上边的例子有很大不同，这个需要一次函数的根式形式，需要将t设置成这个根式。<br> <img src="换元法示例5-2.png" alt="换元法示例5-2.png">  </p></li><li><p>理论解释<br><img src="换元法理论解释.png" alt="换元法理论解释.png"><br>这个解释其实只解释了前4个示例，第5个示例并不在此之列</p></li></ul><h2 id="分部积分法"><a href="#分部积分法" class="headerlink" title="分部积分法"></a>分部积分法</h2><ul><li><p>公式<br><img src="分部积分法公式.png" alt="分部积分法公式.png">  </p><p>分部积分法跟贝叶斯公式有点相似</p></li><li><p>示例1<br><img src="分部积分法示例1.png" alt="分部积分法示例1.png">  </p><p>多项式与指数函数</p></li><li><p>示例2<br><img src="分部积分法示例2.png" alt="分部积分法示例2.png"><br> 然后以相同德办法处理等式右边第二项</p><p>多项式与三角函数</p></li><li><p>示例3<br><img src="分部积分法示例3.png" alt="分部积分法示例3.png"><br> 利用三角函数两次求解后便会原值的特点</p><p>三角函数与指数函数  </p></li><li><p>示例4<br>以上三种都是两种基本初等函数的组合方式，e<sup>x</sup> &gt; sin(x) &gt; x 这种顺序<br>以下这些则反之，可以认为它们比 x 还小  </p><p><img src="分部积分法示例4-1.png" alt="分部积分法示例4-1.png"><br><img src="分部积分法示例4-2.png" alt="分部积分法示例4-2.png">  </p></li></ul><h2 id="部分积分法"><a href="#部分积分法" class="headerlink" title="部分积分法"></a>部分积分法</h2><p>部分积分法是处理，有理函数(两个多项式函数的比值)的方法. 通过一些代数运算把它分解成几个更简单的有理函数和的形式, 然后再对真写简单的有理函数求积分.  </p><ul><li><p>步骤  </p><ol><li>要确保分母的次幂大于分子的次幂,否则,通过除法方式,转换成此形式</li><li>对分母做因式分解<br>对于二次函数,查看判别式,若大于0,则可以因式分解</li><li><p>分部<br>分部是将因式分解之后的乘积形式,变成和形式的过程<br><img src="分部积分法1.png" alt="分部积分法1.png"><br><img src="分部积分法2.png" alt="分部积分法2.png"><br>这有些像基向量的样子,在每个基向量的常数倍.</p></li><li><p>计算常量的值</p></li><li>求解分母为线性项次幂的积分</li><li>对分母是二次函数的被积函数求积分</li></ol></li><li><p>示例1:<br><img src="分部积分法3.png" alt="分部积分法3.png">  </p></li><li><p>示例2:<br><img src="部分积分法示例2.png" alt="部分积分法示例2.png"></p></li><li><p>示例3:<br><img src="部分积分法示例3.png" alt="部分积分法示例3.png"><br>再次将进行分部,第一部分用换元法, 第二部分借用<img src="部分积分公式.png" alt="部分积分公式.png">来计算<br><img src="部分积分法示例3-2.png" alt="部分积分法示例3-2.png">  </p></li></ul><h1 id="微积分基本方法2"><a href="#微积分基本方法2" class="headerlink" title="微积分基本方法2"></a>微积分基本方法2</h1><h2 id="三角恒等式的积分"><a href="#三角恒等式的积分" class="headerlink" title="三角恒等式的积分"></a>三角恒等式的积分</h2><p>通过几个三角恒等式进行变化,将不易求的积分转变成易求的积分.恒等式包括:</p><ol><li>倍角公式: <img src="倍角公式.png" alt="倍角公式.png">  </li><li>毕达哥拉斯恒等式: <img src="毕达哥拉斯恒等式.png" alt="毕达哥拉斯恒等式.png">  </li><li>和差公式: <img src="和差公式.png" alt="和差公式.png">  </li></ol><p>这一部分的示例太多了,而且没有统一的解法,只做几个示例:  </p><ul><li><p>示例1<br><img src="三角恒等式示例1-1.png" alt="三角恒等式示例1-1.png"><br>给sec(x)上次幂,转换成2次进行<br><img src="三角恒等式示例1-2.png" alt="三角恒等式示例1-2.png"><br><img src="三角恒等式示例1-3.png" alt="三角恒等式示例1-3.png">  </p></li><li><p>示例2<br><img src="三角恒等式示例2.png" alt="三角恒等式示例2.png">  </p></li></ul><h2 id="三角函数的幂积分"><a href="#三角函数的幂积分" class="headerlink" title="三角函数的幂积分"></a>三角函数的幂积分</h2><p>三角函数的幂积分,很繁琐.不同的三角函数,技巧不相同.</p><ul><li><p>sinx或者cosx<br>如果是奇数次幂,则可以将一个奇数取出,转变积分<br>如果是偶数次幂,则使用倍角公式,将次幂转变成倍角</p></li><li><p>tan(x)<br>1次幂的tan(x),转换成sinx / cosx 的形式来计算<br>偶次幂的tan(x)求导很有趣,使用tan(x)与secx之间的关系,能不断的降幂,每次将2幂来完成</p></li><li><p>sec(x)<br>1次幂的secx求导很有技巧,(sec(x) + tan(x))/(sex(x) + tan(x))相乘之后,一下便可求出<br>偶次幂的sec(x),与偶次幂的tan(x)求法类似,但更复杂一些,不管的降幂,直到求出.</p></li><li><p>其他<br>cot(x) 同 tan(x), csc(x) 同 sec(x)</p></li><li><p>示例1<br><img src="三角函数幂积分示例1.png" alt="三角函数幂积分示例1.png"><br>将cos(x),转变成sin(x),然后将单独的cosx 放进积分中即可.</p></li><li><p>示例2<br><img src="三角函数幂积分示例2.png" alt="三角函数幂积分示例2.png"><br>将等式右侧展看,多变成多项式形式,偶次幂继续升角,奇次幂利用换元法求解</p></li><li><p>示例3<br><img src="tanx的积分.png" alt="tanx的积分.png">  </p></li><li><p>示例4<br><img src="tanx的2次幂积分.png" alt="tanx的2次幂积分.png">  </p></li><li><p>示例5<br><img src="tanx的4次幂积分.png" alt="tanx的4次幂积分.png">  </p></li><li><p>示例6<br><img src="secx的积分.png" alt="secx的积分.png"><br>sec(x)的二次幂积分为tan(x)+c  </p></li><li><p>示例7<br><img src="secx的6次幂积分1.png" alt="secx的6次幂积分1.png"><br><img src="secx的6次幂积分2.png" alt="secx的6次幂积分2.png"><br><img src="secx的6次幂积分3.png" alt="secx的6次幂积分3.png"><br>这里采用了分部积分法,并且只用来降成4次幂. 4次幂的过程仍然要继续采用此方法.  </p></li><li><p>总结  </p></li></ul><p>tan(x)与sex(x)的偶次幂,都是采用了类似数学归纳法的方式,不断降维来求解</p><h2 id="三角换元法"><a href="#三角换元法" class="headerlink" title="三角换元法"></a>三角换元法</h2><p>三角换元法不再求解的是三角函数,而是利用三角函数的特点来求解根式的积分.  </p><p><img src="三角换元法.png" alt="三角换元法.png"><br>进行换元之后,脱离根式,然后进行求解.  </p><ul><li><p>示例1<br><img src="三角换元法示例1.png" alt="三角换元法示例1.png"><br>用x = 3sin(θ)来进行换元<br><img src="三角换元法示例2.png" alt="三角换元法示例2.png">  </p></li><li><p>示例2<br><img src="三角换元法示例3.png" alt="三角换元法示例3.png"><br><img src="三角换元法示例3-1.png" alt="三角换元法示例3-1.png">  </p></li></ul><h1 id="反常积分"><a href="#反常积分" class="headerlink" title="反常积分"></a>反常积分</h1><p>反常积分要么在函数定义域内存在垂直渐进线,要么区间趋向无穷的定积分.这两种积分都涉及用极限来求积分的基本方法.在这种基本方法之上,演化出了常用的3中通用判别方法:比较判别法,极限比较判别法,p判别法,一种不太通用的判别法:绝对值判别法.这些判别法用于判断反常积分是否存在,或者称收敛.<br>原文中以2章的在讲述反常积分,其中,一章讲理论,一章讲示例.这里仅用一章将理论,不在积分花费更多的时间了.  </p><h2 id="2个定义"><a href="#2个定义" class="headerlink" title="2个定义"></a>2个定义</h2><p><img src="反常积分定义1.png" alt="反常积分定义1.png"><br>这是在下界的定义,在上界的定义同理  </p><p><img src="反常积分定义2.png" alt="反常积分定义2.png"><br>区间无穷的定义</p><h2 id="比较判别法"><a href="#比较判别法" class="headerlink" title="比较判别法"></a>比较判别法</h2><p>比较判别法可以从积分的面积定义上找到源头.  </p><p><img src="比较判别法表达式.png" alt="比较判别法表达式.png"><br><img src="比较判别法图像.png" alt="比较判别法图像.png"><br>如图,如果g(x)在区间[a,b]上收敛,则f(x)也一定收敛. 反命题不成立<br>逆反命题是如果f(x)在区间[a,b]上发散,则g(x)也一定发散.  </p><h2 id="极限比较判别法"><a href="#极限比较判别法" class="headerlink" title="极限比较判别法"></a>极限比较判别法</h2><p><img src="极限比较判别法.png" alt="极限比较判别法.png"><br>这个有同样的意义应该理解为:有相同的收敛性. 同收敛,共发散.</p><p>如: 在x -&gt; 0时, tan(x) ~ x, sin(x) ~ x, e<sup>x</sup>-1 ~x</p><h2 id="p判别法"><a href="#p判别法" class="headerlink" title="p判别法"></a>p判别法</h2><p>p判别法,应该是最接近运用的判别法<br><img src="p判别法.png" alt="p判别法.png"><br><img src="p判别法图像.png" alt="p判别法图像.png">  </p><p>记忆的方法是,与y=x相比, 更接近x轴霍y轴的收敛,反之发散</p><h2 id="绝对值判别法"><a href="#绝对值判别法" class="headerlink" title="绝对值判别法"></a>绝对值判别法</h2><p><img src="绝对收敛判别法.png" alt="绝对收敛判别法.png"><br>其他的判别法即可判别发散,也可以判别收敛.绝对值判别法,只能用来判别收敛.<br>在应用上,比较适合使用在sin(x)的判别上,即sin(x) &lt;= |sin(x)| &lt;= 1</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是微积分复习的第二篇，教材使用《普林斯顿微积分读本》，涵盖第15章-第21章的内容。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数与微分  &lt;/li&gt;
&lt;li&gt;积分       &amp;lt;=&lt;/li&gt;
&lt;li&gt;级数&lt;/li&gt;
&lt;li&gt;其他&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="理论" scheme="http://yoursite.com/categories/%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="微积分" scheme="http://yoursite.com/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>微积分-函数与微分</title>
    <link href="http://yoursite.com/2019/08/08/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%87%BD%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/"/>
    <id>http://yoursite.com/2019/08/08/微积分-函数与微分/</id>
    <published>2019-08-08T13:11:43.000Z</published>
    <updated>2019-08-20T06:44:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是微积分复习的第一篇，教材使用《普林斯顿微积分读本》，涵盖第1章-第14章的内容。 </p><ul><li>函数与微分  &lt;=</li><li>积分</li><li>级数</li><li>其他</li></ul><a id="more"></a><h1 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>函数是将一个对象转化成另外一个对象的规则。起始的对象称为输入，来自称为定义域的集合。返回的对象称为输出，来自称为值域的集合。<br>一个函数必须给每一有效的输入制定唯一的输出。</p><h2 id="定义域"><a href="#定义域" class="headerlink" title="定义域"></a>定义域</h2><p>定义据包括实数集尽可能多的部分，几种常见的情况：</p><ol><li>分母不能为0</li><li>不能取一个负数的平方根</li><li>不能取一个负数或0的对数</li></ol><h2 id="反函数"><a href="#反函数" class="headerlink" title="反函数"></a>反函数</h2><p>数据中有很多对称，例如有了函数就有反函数。<br>给定一个实数 y, 那么在 f 定义域中的哪个x满足 f(x) = y ？<br>变换 f<sup>-1</sup> 就像是 f 的撤销按钮: 如果你从 x 出发,并通过函数 f 将它变换为 y, 那么你可以通过在 y 上的反函数 f<sup>-1</sup> 来撤销这个变换的效果,取回 x<br><img src="反函数图像.png" alt="反函数图像"><br>图像关于y=x对称</p><h2 id="奇偶性"><a href="#奇偶性" class="headerlink" title="奇偶性"></a>奇偶性</h2><p>偶函数：f(x) = f(-x)，图像关于y轴具有镜面对称性。<br>奇函数：f(x) = -f(-x)， 图像关于原点有对称性。</p><h2 id="常见函数的图像"><a href="#常见函数的图像" class="headerlink" title="常见函数的图像"></a>常见函数的图像</h2><ul><li><p>多项式  p(x) = a<sub>n</sub>x<sup>n</sup> + a<sub>n-1</sub>x<sup>n-1</sup> + a<sub>1</sub>x<sup>1</sup> + a<sub>0</sub></p><p><img src="多项式函数图像.png" alt="多项式函数图像"><br>一般多项式函数图像很难画，但其左右两段的走势倒是很容易判断。主要是由首项系数决定的。  </p><p><img src="多项式函数走向.png" alt="多项式函数走向"></p></li><li><p>有理函数  p(x) / q(x)<br><img src="有理函数图像.png" alt="有理函数图像"></p></li><li><p>指数函数图像<br><img src="指数函数图像.png" alt="指数函数图像">  </p></li><li><p>对数函数图像<br><img src="对数函数图像.png" alt="对数函数图像">  </p></li><li><p>其他<br>绝对值函数，正值不变，负值关于x周对称<br>开方函数，将多项式关于镜像对称  </p></li></ul><h1 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h1><h2 id="x-a处的极限"><a href="#x-a处的极限" class="headerlink" title="x=a处的极限"></a>x=a处的极限</h2><p>从函数图像上，从左侧往右接近a时，就得到左极限; 反之从右往左接近是，就得到右极限。<br>当左极限等于右极限时，就称为双侧极限; 极限一般是指的双侧极限  </p><p>f(x)在x = a处有一条垂直渐进线，则在a处的左极限和右极限，至少有一个是∞或−∞。</p><p>左右极限不存在的例子：f(x) = sin(1/x)，在x=0,不存在左右极限。</p><p><img src="左右极限不存在.png" alt="左右极限不存在"></p><h2 id="在∞与-∞处的极限"><a href="#在∞与-∞处的极限" class="headerlink" title="在∞与-∞处的极限"></a>在∞与-∞处的极限</h2><p>当x-&gt;∞ f(x)有固定值，则函数有水平渐进线。</p><p><img src="导数与sin的结合.png" alt="导数与sin的结合"></p><p>函数与其渐进线可能会相交。</p><h2 id="三明治定理"><a href="#三明治定理" class="headerlink" title="三明治定理"></a>三明治定理</h2><p><img src="三明治定理.png" alt="三明治定理"><br><img src="三明治定理示例.png" alt="三明治定理示例"></p><h2 id="求解多项式的极限问题"><a href="#求解多项式的极限问题" class="headerlink" title="求解多项式的极限问题"></a>求解多项式的极限问题</h2><ul><li>x-&gt; a 有理函数,有理函数求解注意通分</li><li>x-&gt; a 平方根函数，注意乘共轭表达式</li><li>x-&gt; ∞ 有理函数，取决于首项及其系数</li><li>x-&gt; -∞ 时，若有函数需要开方时，注意取负数</li></ul><h1 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h1><p>连续性, 直观上,连续函数的图像必须能一笔画成;<br>可导性, 直观上,在可导函数的图像中不会出现尖角。</p><h2 id="连续性"><a href="#连续性" class="headerlink" title="连续性"></a>连续性</h2><ul><li><p>定义<br>如果在x=a处的极限 = f(x), 则在x=a处连续。<br>这个定义中包括：在x=a处有双侧极限，并且在x=a处有定义，或者f(a)存在，他们相等。</p></li><li><p>区间连续定义<br>f(x)在[a,b]区间上连续，在区间每一点都连续，且两个端点的单侧极限存在。</p></li><li><p>介值定理<br>如果f(x) 在[a,b]上连续，并且f(a)f(b)&lt;0，则在区间(a,b)上至少有一点c，使得f(c) = 0存在。</p></li><li><p>最值定理<br>如果f(x) 在[a,b]上连续，则在[a,b]上至少有一个最大值和一个最小值。</p></li></ul><h2 id="可导性"><a href="#可导性" class="headerlink" title="可导性"></a>可导性</h2><ul><li><p>定义<br><img src="可导性-切线斜率.png" alt="可导性-切线斜率.png">  </p><p><img src="可导性-表达式.png" alt="可导性-表达式.png"></p><p><img src="导数微分.png" alt="导数微分.png">.<br>后来有dx表示x中十分微笑的彪悍，dy表示y中十分微笑的变化。dy就是微分。</p></li><li><p>不存在导数的情况<br>双侧的导数不相同，直观上，就是有尖角。</p></li><li><p>如果一个函数f在x上可导，则它在x上连续。</p></li></ul><h2 id="求导法则"><a href="#求导法则" class="headerlink" title="求导法则"></a>求导法则</h2><ul><li><p>乘法法则<br><img src="求导-乘法法则.png" alt="求导-乘法法则.png"></p><p><img src="乘法法则的直观展示.png" alt="乘法法则的直观展示.png"><br>两个变量相乘直观的展示是图中矩形的面积，长与宽都是x的函数，当x有一个小变化∆x,时，面积S如何变化。<br>∆S = ∆(uv) = v∆u + u∆v + (∆u)(∆v)。 其中(∆u)(∆v)是更高阶的无穷小，可以忽略。</p></li><li><p>除法法则<br><img src="求导-商法则.png" alt="求导-商法则.png"></p></li><li><p>链式法则<br><img src="链式求导法则.png" alt="链式求导法则.png"><br>以 y=f(u) u=g(x) 为例：<br>∆y = f’(u)∆u<br>∆u = g’(x)∆x</p><p>代入 ∆y = f’(u)g’(x)∆x<br>由此  ∆y/∆x = f’(u)g’(x)</p></li><li><p>常见应用<br>几何：切线<br>物理：加速度<br>代数：导数伪装的极限  </p><p><img src="通过导数求极限-1.png" alt="通过导数求极限-1.png"></p></li></ul><h1 id="函数的导数"><a href="#函数的导数" class="headerlink" title="函数的导数"></a>函数的导数</h1><h2 id="多项式函数"><a href="#多项式函数" class="headerlink" title="多项式函数"></a>多项式函数</h2><p><img src="多项式求导.png" alt="多项式求导.png"></p><h2 id="三角函数的极限与导数"><a href="#三角函数的极限与导数" class="headerlink" title="三角函数的极限与导数"></a>三角函数的极限与导数</h2><ul><li><p>极限<br><img src="sinx与x.png" alt="sinx与x.png">  </p><p><img src="sinx与x的极限.png" alt="sinx与x的极限.png"><br><img src="tanx的0极限.png" alt="tanx的0极限.png"></p><p>x可以换成其他函数代入与x<sup>2</sup> 、5x等</p><p><img src="x、sinx、tanx极限的直观解释.png" alt="x、sinx、tanx极限的直观解释.png"><br>扇形面积= x/2，内三角形面积= sin(x)/2, 外三角形面积= tan(x)/2， 当x趋近0时，它们相等。<br>变换：1 &gt; sin(x)/x &gt; cos(x)，利用三明治定理，可以得到结论。</p><p><img src="sinx除以x图像.png" alt="sinx除以x图像.png"><br><strong>小波函数</strong></p></li><li><p>导数  </p><p> sin’(x) = cos(x)<br> cos’(x) = -sin(x)  </p><p> tan’(x) = sec<sup>2</sup>(x)<br> cot’(x) = -csc<sup>2</sup>(x)  </p><p> sec’(x) = sec(x)tan(x)<br> csc’(x) = -csc(x)cot(x)</p><p> 记忆：正的导数都是正好，余的导数都是负数</p></li><li><p>一个有趣的函数</p><p>f(x) = x<sup>2</sup>sin(1/x)</p><p>根据求导公式，其在0处导数不存在</p><p><img src="导函数不连续.png" alt="导函数不连续.png"><br>这样改之后，用导数定义，发现其在0处f’(0) = 0，但它同样不连续。</p><p><img src="导函数不连续图像.png" alt="导函数不连续图像.png">  </p></li><li><p>小结<br>本节的sin(x)/x函数，是一个很漂亮的函数。貌似在小波中见过。<br>关于最后这个f(x) = x<sup>2</sup>sin(1/x)。导函数在0处存在，但却不连续。这种情况基本都出在sin(1/x)这种情况内，倒数使趋向无穷大变成了趋向无穷小。</p></li></ul><h2 id="指数函数与对数函数"><a href="#指数函数与对数函数" class="headerlink" title="指数函数与对数函数"></a>指数函数与对数函数</h2><ul><li><p>对数基础<br>log<sub>b</sub>(1) = 0  </p><p>log<sub>b</sub>(xy) = log<sub>b</sub>(x) + log<sub>b</sub>(y)<br>log是可以将乘法变成加法的运算。  </p><p>log<sub>b</sub>(x/y) = log<sub>b</sub>(x) - log<sub>b</sub>(y)  </p><p>log<sub>b</sub>(x<sup>y</sup>) = ylog<sub>b</sub>(x)<br>对数可以处理指数与对数都是函数的情况。  </p><p>log<sub>b</sub>(x) =   log<sub>c</sub>(x) /  log<sub>c</sub>(b)<br>这意味着，所有不同底数的对数，其实都互为常数倍。 log<sub>b</sub>(x) =  Klog<sub>c</sub>(x) K=1/log<sub>c</sub>(b)</p></li><li><p>e的定义<br>e一种由来，可以从计算复利而得来：当年利率一定，每年结算的的次数越多，最终的金额也就越多。当次数取向无穷时，其最终金额不会趋向无穷，而是一个常数。  </p><p><img src="e.png" alt="e.png"><br><img src="e2.png" alt="e2.png">  </p></li><li><p>导数<br>介绍e的定义，主要用于计算对数的导数。<br><img src="对数导数.png" alt="对数导数.png"><br><img src="自然对数导数.png" alt="自然对数导数.png">  </p><p>根据反函数求导<br><img src="指数函数导数.png" alt="指数函数导数.png"><br><img src="指数函数导数2.png" alt="指数函数导数2.png">  </p></li><li><p>极限<br><img src="指数与多项式极限.png" alt="指数与多项式极限.png"><br><img src="对数与多项式.png" alt="对数与多项式.png">  </p></li><li><p>取对数求导法<br>y = x<sup>sin(x)</sup><br>=&gt; ln(y) = sin(x)ln(x)<br>=&gt; <img src="取对求导-1.png" alt="取对求导-1.png"><br>=&gt; <img src="取对求导-2.png" alt="取对求导-2.png"><br>=&gt; <img src="取对求导-3.png" alt="取对求导-3.png">  </p></li><li><p>指数增长与指数衰减  </p><p><img src="微分方程.png" alt="微分方程.png"><br>y变化率取决于这个量的大小。当k是正数就是指数增长，负数就是指数衰减。  </p><p>指数增长就是指的： P(t) = P<sub>0</sub>e<sup>kt</sup><br>这时候, dP/dt = kP<br>常见例子是无限条件下，兔子的增长。  </p><p>指数衰减：P(t) = P<sub>0</sub>e<sup>-kt</sup><br>dP/dt = -kP<br>常见例子是放射性原子的衰减。</p></li><li><p>双曲函数<br>![双曲函数.png])(双曲函数.png)<br><img src="双曲函数图像.png" alt="双曲函数图像.png">  </p><p>双曲函数有些像三角函数：</p><ol><li>cosh<sup>2</sup> - sinh<sup>2</sup> = 1</li><li>d(sinh(x))/dx = cosh(x) 及 d(cosh(x))/dx = sinh(x)  </li></ol><p><a href="https://www.zhihu.com/question/21239693" target="_blank" rel="noopener">双曲函数产生</a>  </p></li><li><p>小结：<br>从对称性上，我们可以看到初等函数可以分成很多空间，多项式函数、三角函数、指对函数。他们在很多时候，都在自己空间内玩。比如求导运算，多项式求导之后还是多项式，三角函数求导也还是三角函数。但对数函数却打破了这种规律，它的求导变成了有理函数，这真有趣。  </p><p>另一个是e，从定义上，就可以看到e是多么神奇的一个数字。</p></li></ul><h2 id="隐函数导数"><a href="#隐函数导数" class="headerlink" title="隐函数导数"></a>隐函数导数</h2><p>隐函数求导，比较适合于求等式的导数。</p><ul><li><p>示例<br>x<sup>2</sup> + y<sup>2</sup> = 4  </p><p>2x + 2y dy/dx = 0<br>dy/dx = -x/y  </p></li></ul><p>等式求导，一般关注于特定点，在特定点时，可以将等式求导之后，立即代入点，然后整理。对于二阶导，要等到求导2次之后再代入。</p><p>应用场景：求某个时刻的变化率问题，思路：<br>1、列出等式<br>2、等式求导  </p><h2 id="反函数导数"><a href="#反函数导数" class="headerlink" title="反函数导数"></a>反函数导数</h2><ul><li><p>导数与反函数存在<br>在区间内单调则反函数存在，单调意味着: f’(x)&gt;=0,或者f’(x)&lt;=0,且等于0的点有限。</p></li><li><p>公式<br><img src="反函数求导.png" alt="反函数求导.png"><br><img src="反函数求导-2.png" alt="反函数求导-2.png"><br> 把反函数表示出来，然后再代入原函数的导数，并求其倒数</p></li><li><p>示例<br>h(x) = x<sup>3</sup><br>h’(x) = 3x<sup>2</sup><br>反函数： y=x <sup>1/3</sup>  </p><p>代入可得反函数的导数 1/(3x<sup>2/3</sup>) </p></li></ul><h1 id="导数与图像"><a href="#导数与图像" class="headerlink" title="导数与图像"></a>导数与图像</h1><ul><li><p>函数的极值<br>假设函数 f 定义在开区间 (a, b) 内,并且点 c 在 (a, b) 区间内.如果点 c 为函数的局部最大值或最小值,那么点 c 一定为该函数的临界点.也就是说,f’(c) = 0 或 f’(c) 不存在  </p><p>闭区间[a,b]的最值，求f’(x) = 0的点，再加两个端点进行比较。</p></li><li><p>罗尔定理<br>假设函数 f 在闭区间[a, b]内连续,在开区间(a, b)内可导.如果 f(a) = f(b），那么在开区间 (a, b) 内至少存在一点 c, 使得 f‘(c) = 0.</p><p>也就是一定有极值点。</p></li><li><p>中值定理<br>假设函数 f 在闭区间[a, b]内连续,在开区间(a, b)内可导,那么在开区间(a, b)内至少有一点 c 使得：<br><img src="中值定理.png" alt="中值定理.png"><br><img src="中值定理图像.png" alt="中值定理图像.png"><br>可以看出，罗尔定理是中值定理的特例。  </p></li><li><p>二阶导数  </p><p>二级导数&gt;0时，图像像是一个凹向上的，像是碗的一部分;二阶导书&lt;0时，图像是凹向下的，像是倒着的碗。<br>拐点：在c点两侧，二阶导符号相异，则为拐点。<br><img src="拐点图像.png" alt="拐点图像.png"><br>这个感激挺有趣，经常听房价拐点、经济拐点，感觉像是在说极值点。这里的拐点却不是。<br>拐点处f’’(c) = 0，但反过来并不成立，比如f(x) = x<sup>4</sup>  </p></li></ul><h1 id="导数的应用"><a href="#导数的应用" class="headerlink" title="导数的应用"></a>导数的应用</h1><p>最优化涉及找出各种可能情况中最好的一种；<br>线性化是一种对难以计算的量找出其估算值的有用技术</p><h2 id="最优化"><a href="#最优化" class="headerlink" title="最优化"></a>最优化</h2><ol><li>找到变量  </li><li>找出等式  </li><li>消元  </li><li>求最值，可能用到隐函数求导  </li></ol><p>书上给出3个实例，这里不多介绍了  </p><h2 id="线性化"><a href="#线性化" class="headerlink" title="线性化"></a>线性化</h2><p>线性化其实是用直线（一阶函数）来拟合原函数（曲线），以求解问题。<br>f(a+∆x) ≈ f(a) + f’(a)∆x.<br><img src="线性化图像.png" alt="线性化图像.png">  </p><p>微分： 其中量df = f’(a)∆x，称为f在 x=a 处的微分。<br>误差： r(x) = f(x) - L(x)<br>      r(x) = f‘’(c)(x − a)<sup>2</sup> , 其中 c 为在 x 和 a 之间的某个数  </p><p>示例：  </p><ol><li>估算 (6.01)<sup>2</sup><br>f’(x) = 2x<br>df = f’(a)∆x = f’(6)(0.01) = 12 × (0.01) = 0.12<br>(6.01)<sup>2</sup> ≈ 36.12</li></ol><h2 id="估算零点的牛顿法"><a href="#估算零点的牛顿法" class="headerlink" title="估算零点的牛顿法"></a>估算零点的牛顿法</h2><p>牛顿法求0值，是线性化的一个应用  </p><p>假设现在要解一个形为 f (x) = 0 的方程,但你死活都解不出来.所以你退而求其次,试着猜测该方程有一个解,并把它记为 a. </p><p><img src="牛顿法图像.png" alt="牛顿法图像.png"><br><img src="牛顿法.png" alt="牛顿法.png">  </p><p>失效的情况：  </p><ul><li><p>f‘(a) 的值接近于 0.<br> <img src="牛顿法失效-1.png" alt="牛顿法失效-1.png">  </p></li><li><p>近似可能越来越糟<br> f (x) = x<sup>1/3</sup>，唯一解是 0 ，<br> 代入公式：b = -2a，除非从0开始，否则越来越糟糕  </p></li><li><p>可能限于左右循环<br> <img src="牛顿法失效-3.png" alt="牛顿法失效-3.png">  </p></li></ul><h2 id="洛必答法则"><a href="#洛必答法则" class="headerlink" title="洛必答法则"></a>洛必答法则</h2><p>洛必答法则本身容易记住，重点是使用时的变形，要点是是对不定式使用<br>除法情况：<br><img src="洛必达法则-1.png" alt="洛必达法则-1.png">  </p><p>除法=乘法，只须将一种一个变成倒数即可  </p><p>减法情况，需要将减法进行通分，变成除法  </p><p>指数情况，需要进行取对数，将指数编程乘法</p><p>示例：<br><img src="洛必答法则示例-1.png" alt="洛必答法则示例-1.png"><br><img src="洛必答法则示例-2.png" alt="洛必答法则示例-2.png"><br><img src="洛必答法则示例-3.png" alt="洛必答法则示例-3.png"><br><img src="洛必答法则示例-4.png" alt="洛必答法则示例-4.png">  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是微积分复习的第一篇，教材使用《普林斯顿微积分读本》，涵盖第1章-第14章的内容。 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数与微分  &amp;lt;=&lt;/li&gt;
&lt;li&gt;积分&lt;/li&gt;
&lt;li&gt;级数&lt;/li&gt;
&lt;li&gt;其他&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="理论" scheme="http://yoursite.com/categories/%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="微积分" scheme="http://yoursite.com/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>typeorm使用总结</title>
    <link href="http://yoursite.com/2019/07/11/typeorm%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/07/11/typeorm使用总结/</id>
    <published>2019-07-11T14:23:08.000Z</published>
    <updated>2019-07-15T00:17:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>总结一下typeorm常用的使用方法  </p><a id="more"></a><h1 id="entity"><a href="#entity" class="headerlink" title="entity"></a>entity</h1><h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><p>typeorm中，每个entity必须有主键</p><ul><li><p>普通主键</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Entity()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">TunnelPart</span></span>&#123;</span><br><span class="line">  @PrimaryGeneratedColumn()</span><br><span class="line">  id: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>uuid主键  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Entity()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseFileEntity</span> </span>&#123;</span><br><span class="line">  @PrimaryGeneratedColumn(<span class="string">"uuid"</span>)</span><br><span class="line">  id: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的主键，就是uuid  </p></li><li><p>多列主键  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Entity()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">StructureTeam</span> </span>&#123;</span><br><span class="line">    @PrimaryColumn(&#123; <span class="attr">type</span>: <span class="string">'int'</span> &#125;)</span><br><span class="line">    teamId: number;</span><br><span class="line"></span><br><span class="line">    @PrimaryColumn(&#123; <span class="attr">type</span>: <span class="string">'int'</span> &#125;)</span><br><span class="line">    structureId: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，就形成了一个有多列形成的主键  </p></li></ul><h2 id="ManyToOne与oneToMany"><a href="#ManyToOne与oneToMany" class="headerlink" title="ManyToOne与oneToMany"></a>ManyToOne与oneToMany</h2><p>ManyToOne 与 oneToMany是最常用的关系，两者可同时使用，ManyToOne可以单独使用，基本操作，如：保存、查询、级联删除等，放到后边下边来写，这里只写关系的建立  </p><h2 id="只建立ManyToOne"><a href="#只建立ManyToOne" class="headerlink" title="只建立ManyToOne"></a>只建立ManyToOne</h2>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Entity()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">TunnelSection</span></span>&#123;</span><br><span class="line">    @PrimaryGeneratedColumn()</span><br><span class="line">    id: number;</span><br><span class="line"></span><br><span class="line">    @Column(<span class="string">'int'</span>)</span><br><span class="line">    length: number;</span><br><span class="line"></span><br><span class="line">    @ManyToOne(<span class="function"><span class="params">type</span>=&gt;</span>TunnelMethod)</span><br><span class="line">    method: TunnelMethod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在ManyToOne的创建中，只提用一个参数即可，这个参数是一个箭头函数，指向One所对应的表<br>  关系在建立的时候，可以指明一些参数，比如OnDetete,当用<code>CASCADE</code>时，可以用作级联删除。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@ManyToOne(<span class="function"><span class="params">type</span>=&gt;</span>TunnelMethod, &#123; <span class="attr">onDelete</span>: <span class="string">'CASCADE'</span> &#125;)</span><br><span class="line">    method: TunnelMethod;</span><br></pre></td></tr></table></figure><h2 id="同时建立ManyToOne-与-OneToMany"><a href="#同时建立ManyToOne-与-OneToMany" class="headerlink" title="同时建立ManyToOne 与 OneToMany"></a>同时建立ManyToOne 与 OneToMany</h2>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Entity()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">TunnelFixture</span></span>&#123;</span><br><span class="line">    @PrimaryGeneratedColumn()</span><br><span class="line">    id: number;</span><br><span class="line"></span><br><span class="line">    @Column(<span class="string">'varchar'</span>, &#123;<span class="attr">length</span>: <span class="number">128</span>&#125;)</span><br><span class="line">    name: string;</span><br><span class="line"></span><br><span class="line">    @OneToMany(<span class="function"><span class="params">type</span> =&gt;</span> TunnelProcedure, procedure =&gt; procedure.fixture)</span><br><span class="line">    procedures: TunnelProcedure[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Entity()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">TunnelProcedure</span></span>&#123;</span><br><span class="line">    @PrimaryGeneratedColumn()</span><br><span class="line">    id: number;</span><br><span class="line"></span><br><span class="line">    @Column(<span class="string">"varchar"</span>, &#123;<span class="attr">length</span>: <span class="number">128</span>&#125;)</span><br><span class="line">    name: string;</span><br><span class="line"></span><br><span class="line">    @ManyToOne(<span class="function"><span class="params">type</span> =&gt;</span> TunnelFixture, fixture =&gt; fixture.procedures)</span><br><span class="line">    fixture: TunnelFixture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在建立双向关系时，除了指明所在的entity，还要指明对方entity的属性</p><h1 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h1><h2 id="relation查询"><a href="#relation查询" class="headerlink" title="relation查询"></a>relation查询</h2><p>  创建ManyToOne与OneToMany的关系以后，可以通过repository来查询</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Entity()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Photo</span> </span>&#123;</span><br><span class="line">    @PrimaryGeneratedColumn()</span><br><span class="line">    id: number;</span><br><span class="line"></span><br><span class="line">    @Column()</span><br><span class="line">    url: string;</span><br><span class="line"></span><br><span class="line">    @ManyToOne(<span class="function"><span class="params">type</span> =&gt;</span> User, user =&gt; user.photos)</span><br><span class="line">    user: User;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Entity()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    @PrimaryGeneratedColumn()</span><br><span class="line">    id: number;</span><br><span class="line"></span><br><span class="line">    @Column()</span><br><span class="line">    name: string;</span><br><span class="line"></span><br><span class="line">    @OneToMany(<span class="function"><span class="params">type</span> =&gt;</span> Photo, photo =&gt; photo.user)</span><br><span class="line">    photos: Photo[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userRepository = connection.getRepository(User);</span><br><span class="line"><span class="keyword">const</span> users = <span class="keyword">await</span> userRepository.find(&#123; <span class="attr">relations</span>: [<span class="string">"photos"</span>] &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> photoRepository = connection.getRepository(Photo);</span><br><span class="line"><span class="keyword">const</span> photos = <span class="keyword">await</span> photoRepository.find(&#123; <span class="attr">relations</span>: [<span class="string">"user"</span>] &#125;);</span><br></pre></td></tr></table></figure><h2 id="也可以用createQueryBuilder形式"><a href="#也可以用createQueryBuilder形式" class="headerlink" title="也可以用createQueryBuilder形式"></a>也可以用createQueryBuilder形式</h2>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> users = <span class="keyword">await</span> connection</span><br><span class="line">  .getRepository(User)</span><br><span class="line">  .createQueryBuilder(<span class="string">"user"</span>)</span><br><span class="line">  .leftJoinAndSelect(<span class="string">"user.photos"</span>, <span class="string">"photo"</span>)</span><br><span class="line">  .getMany();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> photos = <span class="keyword">await</span> connection</span><br><span class="line">  .getRepository(Photo)</span><br><span class="line">  .createQueryBuilder(<span class="string">"photo"</span>)</span><br><span class="line">  .leftJoinAndSelect(<span class="string">"photo.user"</span>, <span class="string">"user"</span>)</span><br><span class="line">  .getMany();</span><br></pre></td></tr></table></figure><p>  一直觉得relations只在findOne中，可用，看了官网，发现都可以。<br>  有些情况下，都是自己创建id字段来连接另外一个表使用，这种情况下，只能使用createQueryBuilder，查询出来的是地卡尔乘积的结果，有些情况下，需要经过去重处理。<br>  这里要注意<code>leftJoinAndSelect</code>与<code>leftJoin</code>的区别。leftJoin不会查询出join表的字段</p><h2 id="Raw查询"><a href="#Raw查询" class="headerlink" title="Raw查询"></a>Raw查询</h2><p>  getRawMany()时，注意给列起别名，否则列名包括了表名。查询的数据不是entity时，采用raw方式查询。包括联表的自定义字段、SUM、COUNT等函数</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">async</span> getMaterialList(subprojId:number, type?:string):<span class="built_in">Promise</span>&lt;Material[]&gt;&#123;</span><br><span class="line">      <span class="keyword">let</span> param = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">      param.subprojId = subprojId;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> condition = <span class="string">"material.subprojId=:subprojId "</span></span><br><span class="line">      <span class="keyword">if</span>(!isNullOrUndefined(type))&#123;</span><br><span class="line">          param.type = type</span><br><span class="line">          condition += <span class="string">" and material.type=:type"</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.materialRepos.createQueryBuilder(<span class="string">"material"</span>)</span><br><span class="line">              .select(<span class="string">"material.id"</span>, <span class="string">"id"</span>)</span><br><span class="line">              .addSelect(<span class="string">"material.type"</span>, <span class="string">"type"</span>)</span><br><span class="line">              .addSelect(<span class="string">"material.name"</span>, <span class="string">"name"</span>)</span><br><span class="line">              .addSelect(<span class="string">"material.unit"</span>, <span class="string">"unit"</span>)</span><br><span class="line">              .addSelect(<span class="string">"material.metaQuantityId"</span>, <span class="string">"metaQuantityId"</span>)</span><br><span class="line">              .addSelect(<span class="string">"material.subprojId"</span>, <span class="string">"subprojId"</span>)</span><br><span class="line">              .addSelect(<span class="string">"material.createAt"</span>, <span class="string">"createAt"</span>)</span><br><span class="line">              .addSelect(<span class="string">'materialPrice.price'</span>, <span class="string">"price"</span>)</span><br><span class="line">              .leftJoin(<span class="string">"material.price"</span>, <span class="string">"materialPrice"</span>)</span><br><span class="line">              .where(condition, param)</span><br><span class="line">              .getRawMany();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  注意join都是迪卡尔积，会有重复。<br>  OneToOne关系比较适合，不会用重复</p><h1 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h1><h2 id="LessThan、MoreThan、Between"><a href="#LessThan、MoreThan、Between" class="headerlink" title="LessThan、MoreThan、Between"></a>LessThan、MoreThan、Between</h2><p>  这里在repository中查询时，使用了以上区间函数;<br>  同样可以使用createQueryBuilder的当时完成相同的操作。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">async</span> getMaterialPriceList(materialId:number, startDate?:string, endDate?:string)&#123;</span><br><span class="line">  <span class="keyword">let</span> condition = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  condition.materialId = materialId;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(startDate!=<span class="literal">null</span> &amp;&amp; endDate==<span class="literal">null</span>)&#123;</span><br><span class="line">      condition.createAt =  MoreThan(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.parse(startDate)));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(startDate==<span class="literal">null</span> &amp;&amp; endDate!=<span class="literal">null</span>)&#123;</span><br><span class="line">      condition.createAt =  LessThan(<span class="keyword">new</span> <span class="built_in">Date</span>(endDate));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(startDate!=<span class="literal">null</span> &amp;&amp; endDate!=<span class="literal">null</span>)&#123;</span><br><span class="line">      condition.createAt = Between(<span class="keyword">new</span> <span class="built_in">Date</span>(startDate), <span class="keyword">new</span> <span class="built_in">Date</span>(endDate));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.priceRepos.find(&#123;...condition&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用createQueryBuilder完成区间查询："><a href="#用createQueryBuilder完成区间查询：" class="headerlink" title="用createQueryBuilder完成区间查询："></a>用createQueryBuilder完成区间查询：</h2>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">async</span> getMaterialPriceList(materialId:number, startDate?:string, endDate?:string)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.priceRepos.createQueryBuilder(<span class="string">"materialPice"</span>)</span><br><span class="line">          .where(<span class="string">'materialPice.materialId = :materialId'</span>)</span><br><span class="line">          .andWhere(<span class="string">'materialPice.createAt &gt;= :startDate'</span>)</span><br><span class="line">          .andWhere(<span class="string">'materialPice.createAt &lt;= :endDate'</span>)</span><br><span class="line">          .setParameters(&#123;<span class="attr">materialId</span>:materialId, <span class="attr">startDate</span>:<span class="keyword">new</span> <span class="built_in">Date</span>(startDate),<span class="attr">endDate</span>:<span class="keyword">new</span> <span class="built_in">Date</span>(endDate)&#125;)</span><br><span class="line">          .getMany();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h1><p>同样是使用skip与take来完成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> users = <span class="keyword">await</span> getRepository(User)</span><br><span class="line">    .createQueryBuilder(<span class="string">"user"</span>)</span><br><span class="line">    .leftJoinAndSelect(<span class="string">"user.photos"</span>, <span class="string">"photo"</span>)</span><br><span class="line">    .skip(<span class="number">5</span>)</span><br><span class="line">    .take(<span class="number">10</span>)</span><br><span class="line">    .getMany();</span><br></pre></td></tr></table></figure><h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><p>子查询是两个查询的嵌套，通常发生在where与from中</p><h2 id="where中"><a href="#where中" class="headerlink" title="where中"></a>where中</h2>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> posts = <span class="keyword">await</span> connection.getRepository(Post)</span><br><span class="line">  .createQueryBuilder(<span class="string">"post"</span>)</span><br><span class="line">  .where(<span class="function"><span class="params">qb</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> subQuery = qb.subQuery()</span><br><span class="line">          .select(<span class="string">"user.name"</span>)</span><br><span class="line">          .from(User, <span class="string">"user"</span>)</span><br><span class="line">          .where(<span class="string">"user.registered = :registered"</span>)</span><br><span class="line">          .getQuery();</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"post.title IN "</span> + subQuery;</span><br><span class="line">  &#125;)</span><br><span class="line">  .setParameter(<span class="string">"registered"</span>, <span class="literal">true</span>)</span><br><span class="line">  .getMany();</span><br></pre></td></tr></table></figure><p>  或者写成</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userQb = <span class="keyword">await</span> connection.getRepository(User)</span><br><span class="line">  .createQueryBuilder(<span class="string">"user"</span>)</span><br><span class="line">  .select(<span class="string">"user.name"</span>)</span><br><span class="line">  .where(<span class="string">"user.registered = :registered"</span>, &#123; <span class="attr">registered</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> posts = <span class="keyword">await</span> connection.getRepository(Post)</span><br><span class="line">  .createQueryBuilder(<span class="string">"post"</span>)</span><br><span class="line">  .where(<span class="string">"post.title IN ("</span> + userQb.getQuery() + <span class="string">")"</span>)</span><br><span class="line">  .setParameters(userQb.getParameters())</span><br><span class="line">  .getMany();</span><br></pre></td></tr></table></figure><h2 id="from中"><a href="#from中" class="headerlink" title="from中"></a>from中</h2>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> posts = <span class="keyword">await</span> connection</span><br><span class="line">  .createQueryBuilder()</span><br><span class="line">  .select(<span class="string">"user.name"</span>, <span class="string">"name"</span>)</span><br><span class="line">  .from(<span class="function"><span class="params">subQuery</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> subQuery</span><br><span class="line">          .select(<span class="string">"user.name"</span>, <span class="string">"name"</span>)</span><br><span class="line">          .from(User, <span class="string">"user"</span>)</span><br><span class="line">          .where(<span class="string">"user.registered = :registered"</span>, &#123; <span class="attr">registered</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">  &#125;, <span class="string">"user"</span>)</span><br><span class="line">  .getRawMany();</span><br></pre></td></tr></table></figure><p>  from中的“user“是别名，或者写成</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userQb = <span class="keyword">await</span> connection.getRepository(User)</span><br><span class="line">  .createQueryBuilder(<span class="string">"user"</span>)</span><br><span class="line">  .select(<span class="string">"user.name"</span>, <span class="string">"name"</span>)</span><br><span class="line">  .where(<span class="string">"user.registered = :registered"</span>, &#123; <span class="attr">registered</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> posts = <span class="keyword">await</span> connection</span><br><span class="line">  .createQueryBuilder()</span><br><span class="line">  .select(<span class="string">"user.name"</span>, <span class="string">"name"</span>)</span><br><span class="line">  .from(<span class="string">"("</span> + userQb.getQuery() + <span class="string">")"</span>, <span class="string">"user"</span>)</span><br><span class="line">  .setParameters(userQb.getParameters())</span><br><span class="line">  .getRawMany();</span><br></pre></td></tr></table></figure><h1 id="全列查询"><a href="#全列查询" class="headerlink" title="全列查询"></a>全列查询</h1><p>全表查询指的是对全部字段进行模糊查询，网上找资料看到一些方式，通过引入插件，再用函数的方式来实现，这样的实现在typeorm中很难实现。  </p><ul><li><p>列少时，可以考虑多列的模糊</p><p><code>select * from t where phonenum=&#39;digoal&#39; or info ~ &#39;digoal&#39; or c1=&#39;digoal&#39;</code>  </p></li><li><p>将所有字段记录在1列中，从一列中查询</p></li><li><p>pgsql中使用::text<br><code>select * from structure where structure::text like %大河%</code></p></li></ul><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;getManager&#125; <span class="keyword">from</span> <span class="string">"typeorm"</span>;</span><br><span class="line"><span class="keyword">await</span> getManager().transaction(<span class="keyword">async</span> transactionalEntityManager =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> transactionalEntityManager.save(users);</span><br><span class="line">    <span class="keyword">await</span> transactionalEntityManager.save(photos);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>事物可以使用装饰器方式来书写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Transaction()</span><br><span class="line">save(@TransactionManager() manager: EntityManager, <span class="attr">user</span>: User) &#123;</span><br><span class="line">    <span class="keyword">return</span> manager.save(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Transaction()</span><br><span class="line">save(user: User, @TransactionRepository(User) userRepository: Repository&lt;User&gt;) &#123;</span><br><span class="line">    <span class="keyword">return</span> userRepository.save(user);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在事务中指明隔离级别</p><h1 id="migration"><a href="#migration" class="headerlink" title="migration"></a>migration</h1><ul><li>需要注意其ormconfig.json配置文件的书写</li><li>其原理是通过检测migration中的文件，来执行文件，并且在数据库中创建一个migrations的数据表，用来存储执行过的文件。在执行的时候，会对比文件夹中的文件与数据库执行过的文件，并选择new的进行执行。</li><li>这种方式需要看一个revert如果执行。</li><li>migration其实是一种命令模式。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结一下typeorm常用的使用方法  &lt;/p&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
      <category term="nest.js" scheme="http://yoursite.com/tags/nest-js/"/>
    
  </entry>
  
  <entry>
    <title>hexo迁移记录</title>
    <link href="http://yoursite.com/2019/06/22/hexo%E8%BF%81%E7%A7%BB%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/06/22/hexo迁移记录/</id>
    <published>2019-06-22T14:44:25.000Z</published>
    <updated>2019-09-28T04:00:44.770Z</updated>
    
    <content type="html"><![CDATA[<p>本次在家里机器上迁移hexo成功，对这次迁移做一点记录。</p><a id="more"></a><p>hexo需要2个库，一个github page用来做网页，另一个库用来存md。网上一般的方式是建立一个github page库，用2个分支来存放，我自己的做法是将网站放在github page下，然后创建了一个gitlab库放md。</p><ul><li><p>配置ssh<br>详见ssh与git配置两篇博客<br>这里由于2个帐号，注意.ssh/config的配置</p></li><li><p>clone库<br>从gitlab下将库clone下来</p></li><li><p>安装hexo[3.9.0]<br>装机部分已经安装了git、node.js，这里只安装hexo即可。<br>参照：<a href="https://www.zhihu.com/question/21193762" target="_blank" rel="noopener">hexo换电脑更新</a><br>需要在blog下执行：  </p><ul><li>npm install hexo  </li><li>npm install  </li><li>npm install hexo-deployer-git  </li></ul><p>这样并不能直接使用hexo，我又在global范围内安装了一边hexo  </p><ul><li>npm install hexo -g  </li><li>npm install hexo-cli -g  </li><li>npm install hexo-deployer-git -g</li></ul><p>这样感觉多安装了一边，但确实可以了，只安装global范围内时，在blog下不能执行hexo g</p></li><li><p>_config.yml配置修改  </p><pre><code class="yml"><span class="attr">deploy:</span><span class="attr">  type:</span> <span class="string">git</span><span class="attr">  repo:</span> <span class="string">git@github.com:xxx/xxx.github.io.git</span><span class="attr">  branch:</span> <span class="string">master</span><span class="attr">  name:</span> <span class="string">xxxx</span><span class="attr">  email:</span> <span class="string">xxxx@xxx.xx</span></code></pre><p>这次修改其中的user =&gt; name</p></li><li><p>遗留<br>hexo d时，曾出现过HEAD不对应，但重新安装了global的hexo问题解决，github page的git同步并没有研究，但最终完成了同步，像是hexo内部自己做了封装。  </p></li><li><p>推荐<br>搜索过程中发现一篇比价全的hexo搭建博客<a href="https://thief.one/2017/03/03/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">Hexo搭建博客教程</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本次在家里机器上迁移hexo成功，对这次迁移做一点记录。&lt;/p&gt;
    
    </summary>
    
      <category term="工具与运维" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E4%B8%8E%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu装机后</title>
    <link href="http://yoursite.com/2019/06/16/%E8%A3%85%E6%9C%BA%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/06/16/装机记录/</id>
    <published>2019-06-16T13:18:04.000Z</published>
    <updated>2019-07-01T02:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>本次装机，话费了大半天的时间，ubuntu装机出现几次启动问题，后边的软件安装也颇费功夫。写一下本次的装机记录，以后可以考虑写成脚本来自动完成装机。</p><a id="more"></a><h1 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h1><ul><li><p><a href="https://zhuanlan.zhihu.com/p/59393289" target="_blank" rel="noopener">UEFI+GPT 与 BIOS+MBR</a><br>启动方式是指如何主板上的固件在开机自检后如何找到引导程序，有Legacy模式（BIOS + MBR）和UEFI模式（UEFI _+ GPT）。大家注意这里的对应即可。 UEFI是15年之后才比较火的一种启动方式，电脑启动速度快是它的一大特点。所以15年后很多电脑都是采用这种方式。而之前的主板都是采用Lagacy的模式。需要硬件支持。</p></li><li><p><a href="https://blog.csdn.net/u014292358/article/details/70195932" target="_blank" rel="noopener">分区</a><br>由于本次重装，并没有手动分区，这个当选项了。</p></li></ul><h1 id="基础软件"><a href="#基础软件" class="headerlink" title="基础软件"></a>基础软件</h1><ul><li><p><a href="https://blog.csdn.net/happywho250/article/details/52506321" target="_blank" rel="noopener">换源</a>  </p></li><li><p><a href="https://jingyan.baidu.com/article/f79b7cb31a990d9144023ea2.html" target="_blank" rel="noopener">安装chrome</a><br>sudo apt-get install chromium-browser  </p></li><li><p><a href="https://blog.csdn.net/duxu24/article/details/52955785" target="_blank" rel="noopener">安装wps</a><br>sudo dpkg -i  </p></li><li><p><a href="https://zhuanlan.zhihu.com/p/37914770" target="_blank" rel="noopener">安装node</a><br><a href="https://nodejs.org/en/" target="_blank" rel="noopener">node下载</a><br>tar 之后 ln -s  </p></li><li><p><a href="https://code.visualstudio.com/Download" target="_blank" rel="noopener">安装vscode</a><br>sudo dpkg -i  </p></li><li><p>安装git<br>sudo apt-get install git  </p></li></ul><h1 id="gitlab"><a href="#gitlab" class="headerlink" title="gitlab"></a>gitlab</h1><ul><li><p><a href="https://sunyanfeng.cn/2019/01/09/ssh%E5%85%8D%E5%AF%86%E9%85%8D%E7%BD%AE/" target="_blank" rel="noopener">git免密</a>  </p></li><li><p>翻墙<br>从ubuntu软件中心中下载shadowsocks，下载snap的</p><p><a href="https://ea.36fy.com/clientarea.php" target="_blank" rel="noopener">加速度</a>  </p><p>chromium –proxy-server=”socks5://127.0.0.1:1080”</p></li></ul><h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt update</span><br><span class="line">$ sudo apt install -y \</span><br><span class="line">           apt-transport-https \</span><br><span class="line">           ca-certificates \</span><br><span class="line">           curl \</span><br><span class="line">           software-properties-common</span><br><span class="line">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line">$ sudo add-apt-repository \</span><br><span class="line">           <span class="string">"deb [arch=amd64] https://download.docker.com/linux/ubuntu <span class="variable">$(lsb_release -cs)</span> stable"</span></span><br><span class="line">$ sudo apt update</span><br><span class="line">$ sudo apt install -y docker-ce</span><br><span class="line">$ sudo usermod -a -G docker $(whoami)</span><br><span class="line">$ newgrp docker</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本次装机，话费了大半天的时间，ubuntu装机出现几次启动问题，后边的软件安装也颇费功夫。写一下本次的装机记录，以后可以考虑写成脚本来自动完成装机。&lt;/p&gt;
    
    </summary>
    
      <category term="工具与运维" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E4%B8%8E%E8%BF%90%E7%BB%B4/"/>
    
    
  </entry>
  
  <entry>
    <title>next.js弃坑总结</title>
    <link href="http://yoursite.com/2019/05/23/next%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/05/23/next实践总结/</id>
    <published>2019-05-23T02:30:00.000Z</published>
    <updated>2019-07-01T02:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>关键字：next.js</p><a id="more"></a><h1 id="next-js接触"><a href="#next-js接触" class="headerlink" title="next.js接触"></a>next.js接触</h1><p>接触next.js的过程在<a href>next.js记录</a>中已经说过了，主要是在自己搭建后台渲染过程中，使用了web-isomorphic-tools，而它官网中，推荐使用其进化版本universal-tools或者使用集成了universal-tools的next.js。而自己搭建的渲染，跳过了无数坑之后，渲染Materila-Ui组件时失败，况且不知道越过这坑后边是否还有坑，索性研究一下next.js.</p><p>next.js是一个后台渲染的MPA（多页面应用）</p><h1 id="next-js优点"><a href="#next-js优点" class="headerlink" title="next.js优点"></a>next.js优点</h1><ul><li><p>后台渲染做的不错<br>对Material-Ui支持不错</p></li><li><p>代码切割做的不错<br>本身是不过加载页面中不用的component，也可以手动进行动态加载，并支持prefetch(预取)的功能，提高加载的速度。</p></li><li><p>动态数据加载做的可以<br>由前端服务器向api server获取数据使用getInitPrepoty的方式不错</p></li></ul><h1 id="next-js缺点"><a href="#next-js缺点" class="headerlink" title="next.js缺点"></a>next.js缺点</h1><p>这里的缺点是针对我们应用的场景而言</p><ul><li><p>文件系统路由的方式不太适合<br>虽然它支持定制路由，但也仅是做了as，类似于一个别名，还需要服务侧做转换。<br>并且由于文件系统路由，使它内部仅支持用query方式(url?key=value)传参，若需要param方式(/:userId)，需要使用定制url。</p></li><li><p>对componet不太友好<br>在面临选择page还是componet时，next.js偏向与page。比如通过link导向一个page，然后在page进行一些操作之后，通过component切换的形式来做一些view的切换，这时候如果想再逆操作时，没法通过点击link的方式进行切换，只能自己控制。link发现地址没变，点击不会响应。  </p></li><li><p>传参问题<br>由于更多的页面，在传值问题上存在更多的挑战。使用react的component，可以愉快的使用向下流的传值，而页面只能在地址中增加一些id，然后在页面内部再次去获取数据，这样效率比较低一些。</p></li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>与同事讨论之后，我们觉得，next.js更适合向博客、新闻等使用场景，不太适合写数据交互多的场景，这样就准备弃用了。<br>如果非要用next.js来写的话，感觉可以将next.js做一个后端渲染的活，然后在next.js之上移植react-router，由MPA转换成SPA，这方面的资料在next.js github的issue中可以找到一点，有兴趣的朋友可以考虑一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关键字：next.js&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="next.js" scheme="http://yoursite.com/tags/next-js/"/>
    
  </entry>
  
  <entry>
    <title>同构SPA应用jwt实践</title>
    <link href="http://yoursite.com/2019/05/23/%E5%90%8C%E6%9E%84SPA%E5%BA%94%E7%94%A8jwt%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2019/05/23/同构SPA应用jwt实践/</id>
    <published>2019-05-23T01:30:00.000Z</published>
    <updated>2019-07-01T02:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>关键字：Isomorphic、SPA、Jwt</p><a id="more"></a><h1 id="Jwt简介"><a href="#Jwt简介" class="headerlink" title="Jwt简介"></a>Jwt简介</h1><p>先介绍一下Jwt:<a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener">Jwt简介</a></p><h1 id="3层过程"><a href="#3层过程" class="headerlink" title="3层过程"></a>3层过程</h1><ul><li>浏览器获取页面，前端服务器发现未登录，重定向到登录页面&lt;这个重定向由后端控制&gt;</li><li>录入用户、密码，发送给accout后端服务，验证信息，返回jwt给浏览器</li><li><p>登录成功，浏览器重定向到主页面，此时携带token&lt;这个重定向由浏览器控制&gt;</p></li><li><p>前端服务器接收到主页的请求，再次进行验证，发现已经登录，返回主页面</p></li><li>浏览器做前端渲染，向后台请求数据时，携带token。进行验证。</li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li><p>查资料说，token可以通过cookie来设置，也可以通过localStorage来设置<br>token通过Set-Cookie的方式发送给浏览器但一直没有设置成功，设置了domain、path、max-age<br><a href="http://bubkoo.com/2014/04/21/http-cookies-explained/" target="_blank" rel="noopener">cookie详解</a><br>后来通过浏览器调用document.cookie来进行设置</p></li><li><p>使用cookie设置的问题<br>token时间与cookie时间问题，token与cookie各有自己的过期时间，两个时间不一致会存在问题，不太喜欢2个源的东西。</p></li><li><p>使用localStorage的问题<br>存储在LocalStorag里的问题是，无法在向前端服务器请求页面的时候，自动携带这个token。</p></li><li><p>后端缓存token的问题<br>jwt本身设计就是stateless，如果加上缓存，就是一有状态的东西，与sessionId的使用一致。<br>需要用一些规则来包成token的安全</p></li></ul><h1 id="token安全规则"><a href="#token安全规则" class="headerlink" title="token安全规则"></a>token安全规则</h1><p>  <a href="https://stackoverflow.com/questions/30523238/best-practices-for-server-side-handling-of-jwt-tokens" target="_blank" rel="noopener">token最佳实践</a></p><h1 id="2层过程"><a href="#2层过程" class="headerlink" title="2层过程"></a>2层过程</h1><p>思维过程如下：<br>用cookie来传输jwt由于2个过期时间，所以弃用<br>=&gt; 选择localStorage来存储<br>=&gt; 无法给前端服务器携带<br>=&gt; 放弃前端服务器重定向<br>=&gt; 使用浏览器端的重定向</p><p>浏览器端的重定向通过判断localStorage中是否存在jwt来判断是否登录，判断时机是整个页面重渲染时，由于是Isomorphic的SPA，这个时机可以认为是在页面第一次从后端取之后，前端第一次渲染时做的判断。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关键字：Isomorphic、SPA、Jwt&lt;/p&gt;
    
    </summary>
    
    
      <category term="jwt" scheme="http://yoursite.com/tags/jwt/"/>
    
  </entry>
  
  <entry>
    <title>Matrix-图像压缩与伪逆</title>
    <link href="http://yoursite.com/2019/05/22/Matrix-%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9%E4%B8%8E%E4%BC%AA%E9%80%86/"/>
    <id>http://yoursite.com/2019/05/22/Matrix-图像压缩与伪逆/</id>
    <published>2019-05-21T22:32:16.000Z</published>
    <updated>2019-07-01T02:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>原课程Lessson31～Lesson32课，图像压缩是基于基变换，伪逆</p><a id="more"></a><h1 id="图像压缩"><a href="#图像压缩" class="headerlink" title="图像压缩"></a>图像压缩</h1><ul><li>图像的向量表示<br>对于一副512×512的的黑白图像，它有512<sup>2</sup>个像素，每个像素用8bit的信息来表达，<img src="图片的矩阵表示.png" alt="图片的矩阵表示"></li><li>压缩的必要性<br>如果采用标准基(I)，来表示每一张图片，每一张图片都需要512<sup>2</sup>bit的数据，那所用的带宽太高。如果根据JPEG的标准，换一种基来表达，那么可以更高效的表达、传输数据。<br>以黑板为例，如果是标准基，那每个图片，都需要那么多的数据，但如果用一种基，其中一个基向量代表亮度，那黑板图片，就可以压缩到很小。<br>下边整理一下常见的基.  </li></ul><h2 id="傅里叶基"><a href="#傅里叶基" class="headerlink" title="傅里叶基"></a>傅里叶基</h2><p><img src="傅里叶基.png" alt="傅里叶基"><br>在JPEG中，使用的是w<sup>jk</sup>的实部，也就是cos分量。<br>它将512<sup>2</sup>的向量，分裂成8×8的小块，然后进行压缩，然后剔除掉系数低于某阈值。<br><img src="傅里叶基的使用.png" alt="傅里叶基的使用"></p><h2 id="小波基"><a href="#小波基" class="headerlink" title="小波基"></a>小波基</h2><p><img src="小波基.png" alt="小波基"><br>JPEG2000中采用小波基从上图中可以看出，示例小波基中，每个向量的非零元素在折半递减。</p><h2 id="压缩与矩阵"><a href="#压缩与矩阵" class="headerlink" title="压缩与矩阵"></a>压缩与矩阵</h2><p>  线性代数用来计算从标准基到傅里叶基或者小波基的系数。<br>  <img src="图像基变换公式1.png" alt="图像基变换公式1"><br>  <img src="图像基变换公式2.png" alt="图像基变换公式2"><br>  故，可得c = W<sup>-1</sup>x.<br>  上式中，如果选择合适的基向量使W<sup>-1</sup> = W<sup>T</sup>，这样计算效率就会大大提高。</p><h1 id="基变换"><a href="#基变换" class="headerlink" title="基变换"></a>基变换</h1><p>对于一个在旧基的向量A，可以通过x=Wc关系，转换到新基体系中，转换后的向量是B。<br>A和B是相似的: B=M<sup>-1</sup>AM  </p><p>对于旧基，用v<sub>1</sub>,v<sub>2</sub>…v<sub>8</sub>来表示<br>A暂时用v来表示： <img src="v表示.png" alt="v表示"><br>转换之后表示为： T(v) = c<sub>1</sub>T(v<sub>1</sub>) + c<sub>2</sub>T(v<sub>2</sub>) + … +c<sub>8</sub>T(v<sub>8</sub>)</p><p>如果T(v<sub>i</sub>) = λ<sub>i</sub>x<sub>i</sub>，这样的变化效率是最高的，但计算一个图像的特征向量，是一件计算量很大的操作，所以不如用佛里叶变换或小波变换。  </p><h1 id="左逆"><a href="#左逆" class="headerlink" title="左逆"></a>左逆</h1><p>左逆是矩阵A：m×n rank(A) = n而言的，川型矩阵</p><p>(A<sup>T</sup>A)<sup>-1</sup>A<sup>T</sup>A = I 我们说：<br><img src="A的左逆.png" alt="A的左逆"> 是A 的左逆。</p><h1 id="右逆"><a href="#右逆" class="headerlink" title="右逆"></a>右逆</h1><p>同样的道理，来类比右逆，右逆是对A: m×n rank(A) = m而言，三型矩阵<br><img src="A的右逆.png" alt="A的右逆"> 是A的右逆。</p><h1 id="伪逆"><a href="#伪逆" class="headerlink" title="伪逆"></a>伪逆</h1><p>左右逆解决了长方形矩阵的逆的问题，但对于奇异矩阵，如何来找到最佳的逆呢？伪逆。<br>因为是奇异矩阵，Ax=0存在非0解，存在着null space，也就不可能有逆的存在。伪逆其实建立的是A的row space与column space之间对应关系。A中row space 中的向量与column space中的向量一一对应。证明略。<br>向量x在row space中 Ax转换到column space上，称之为Ax， 然后再通过A<sup>+</sup>，再转换回来。<img src="伪逆.png" alt="伪逆">  </p><p>A = UΣV<sup>T</sup>  =&gt;  A<sup>+</sup> = UΣ<sup>+</sup>V<sup>T</sup>.</p><p>Σ<sup>+</sup>:1/σ1, 1/σ2, …, 1/σ</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原课程Lessson31～Lesson32课，图像压缩是基于基变换，伪逆&lt;/p&gt;
    
    </summary>
    
      <category term="理论" scheme="http://yoursite.com/categories/%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="Matrix" scheme="http://yoursite.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>问题汇总</title>
    <link href="http://yoursite.com/2019/05/15/%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2019/05/15/问题汇总/</id>
    <published>2019-05-14T16:00:00.000Z</published>
    <updated>2019-07-01T02:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录踩的坑</p><a id="more"></a><h1 id="nest框架的坑"><a href="#nest框架的坑" class="headerlink" title="nest框架的坑"></a>nest框架的坑</h1><ul><li><p>搭建pms-account后，连接报502 bad gateway的错<br>描述：<br>pms-account运行后，报502的错  </p><p>解决：<br>报502的错问题很多，这一次是docker运行时候，暴露的端口是10001,而服务启动时候的端口是3000，修改后问题解决  </p></li><li><p>bcrypt的坑<br>描述1：<br>bcrypt在阿华电脑上启动是，报的是node module version的一个错</p><p>解决1：<br>怀疑是node版本造成的问题，对比后发现在build在主机上执行，node版本是10.0+的版本，而运行是在docker中，node版本是8.+版本。<br>删除node_module，在容器中重新编译，然后运行，问题解决。  </p><p>描述2：<br>在阿里云上install事，一直安装不了bcrypt  </p><p>解决2：<br>怀疑也是版本问题，但同样的解决方式虽然install成功了，但却不可运行，还在继续</p></li></ul><h1 id="node"><a href="#node" class="headerlink" title="node"></a>node</h1><ul><li><p>找不到package的坑<br>描述：<br>Couldn’t find package “package-name” on the “npm” registry  </p><p>解决：<br>npm源是官方源，换了一个淘宝源后，问题解决，这个有点真坑<br>查看：<code>npm get registry</code><br>修改：<code>npm config set registry https://registry.npm.taobao.org</code></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录踩的坑&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>next.js基础</title>
    <link href="http://yoursite.com/2019/05/12/next%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/05/12/next基础/</id>
    <published>2019-05-12T07:35:49.000Z</published>
    <updated>2019-07-01T02:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文为学习next.js而做的笔记，主要参照<a href="https://nextjs.org/docs" target="_blank" rel="noopener">官网</a> ，也会借鉴<a href="https://juejin.im/post/5b868b45e51d4538ae4db7ca" target="_blank" rel="noopener">Next.js踩坑</a>  </p><a id="more"></a><h1 id="起因与目的"><a href="#起因与目的" class="headerlink" title="起因与目的"></a>起因与目的</h1><p>最早接触next.js是在看webpack-isomorphic-tools的官网时候，其推荐新项目使用universal-tools，或者直接用next.js这样的框架。那时候基于create-react-app而搭建的同构已经走了大半，没有继续研究next.js。而搭建的系统遇到了stylus问题，一时间没有找到解决方案，就试着接触一下next.js，一方面想看一下next.js是如何解决这个问题的，另一方也看一下是否可以直接使用next.js。<br>看过之后，觉得next.js是不错的框架，值得去整理一下。</p><p>next.js是一个基于react的SSR框架，它有很多特性值得去应用，下边对这些特性进行整理  </p><p>对于SSR，首先它需要根据浏览器的路径，选择合适的页面、组件进行渲染；<br>其次，<code>&lt;head&gt;</code>中对静态文件的引用，页面中也会包含一些静态的文件，包括react、material的js，还有一些图片等；<br>接着，页面、组件加载时为了提升性能，就需要一些技术：代码切割、预取页面、动态导入等<br>然后，对于有些请求，需要从api sever中加载数据，然后再渲染到页面上；<br>再然后，对于登录，需要判断是否登录（头部判断），再进行路由的跳转；<br>最后，在同构的时候react-router有对history的使用，对于这一点有点疑问，浏览器显然是有自己的一块存储区域来存储历史，为什么在服务器也会看到history？<br>这期间还夹杂一些基础，如对css的支持、路由的参数等</p><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><h2 id="文件系统路由"><a href="#文件系统路由" class="headerlink" title="文件系统路由"></a>文件系统路由</h2><p>  next.js是一个文件系统路由，意思是，需要一个pages目录，这个目录对应’/‘路由；若存在’/home’路由，则需要page目录下有一个home目录。路由与目录结构对应。  </p><p>  这种方式跟最早接触的tomcat有些类似，也与http的静态文件形态时候形同。<br>  webship中维护一个路由与文件的映射；<br>  react-router常见的用法是SPA，只有一个页面，也就不太需要这种映射。</p><h2 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h2><p>  Next.js没有一个记录所有路由的清单，当前页面对其他页面一无所知。这样，浏览器中页面的组织、跳转是通过<code>Link</code>来完成的.与html的<code>&lt;a&gt;</code>标签很相似。  </p><p>  它有2个主要属性：<br>  <code>href</code>：a标签的href，包括路由+请求参数。<br>  <code>as</code>：在浏览器中展示的URL。这个听起来有点怪，需要多做一个说明。<code>next.js</code>本身只支持文件系统路由 与 query形式的参数传递，但为了支持制定方式，可以讲文件系统路由命名成其他的路由，展示在浏览器上。这个就是定制路由</p><p>  url参数：<br>  <code>/about?name=Zeit</code>，从根上，next只支持query形式的传参，对于param形式的传参，需要用<code>as</code></p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link href=&#123;&#123; pathname: '/about', query: &#123; name: 'Zeit' &#125; &#125;&#125;&gt;</span><br><span class="line">  &lt;a&gt;here&lt;/a&gt;</span><br><span class="line">&lt;/Link&gt;</span><br></pre></td></tr></table></figure><h2 id="定制路由"><a href="#定制路由" class="headerlink" title="定制路由"></a>定制路由</h2><ul><li>对于<code>/post/:slug</code>路由  </li><li><p>需要在<code>pages/post.js</code>  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Post</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">async</span> getInitialProps(&#123; query &#125;) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'SLUG'</span>, query.slug);</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>My blog post<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Post;</span><br></pre></td></tr></table></figure></li><li><p>在服务增加一个对<code>/post/:slug</code>路由的响应  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.get(<span class="string">'/post/:slug'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> app.render(req, res, <span class="string">'/post'</span>, &#123; <span class="attr">slug</span>: req.params.slug &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里需要将这个<code>/post/:slug</code>路由转换成内部的<code>/post</code>路由，参数通过query的方式传递。</p></li><li><p>在前端使用<code>next/link</code>  </p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link href=<span class="string">"/post?slug=something"</span> <span class="keyword">as</span>=<span class="string">"/post/something"</span>&gt;</span><br></pre></td></tr></table></figure></li></ul><h1 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h1><ul><li><p>static<br>next.js除了pages目录用于放页面，还有一个static目录用于存放静态文件，这个目录是设定死的，不能改变。路由上使用<code>/  static/</code>与之对应。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyImage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/static/my-image.png"</span> <span class="attr">alt</span>=<span class="string">"my image"</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">export default MyImage;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="加载性能"><a href="#加载性能" class="headerlink" title="加载性能"></a>加载性能</h1><h2 id="代码切割"><a href="#代码切割" class="headerlink" title="代码切割"></a>代码切割</h2><p>  代码切割不应该属于静态文件，指的是对于页面，仅会加载<code>import</code>到的组件，并不会加载其他组件。  </p><h2 id="预取页面"><a href="#预取页面" class="headerlink" title="预取页面"></a>预取页面</h2><p><code>prefetch</code>预取页面是<code>Link</code>的第三个属性，加上它，next.js会在后台自动加载这些页面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">'next/link'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;nav&gt;</span><br><span class="line">            &lt;Link prefetch href=<span class="string">"/"</span>&gt;</span><br><span class="line">                &lt;a&gt;Home&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>Link&gt;</span><br><span class="line">            &lt;Link prefetch href=<span class="string">"/about"</span>&gt;</span><br><span class="line">                &lt;a&gt;About&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>Link&gt;</span><br><span class="line">            &lt;Link prefetch href=<span class="string">"/contact"</span>&gt;</span><br><span class="line">                &lt;a&gt;Contact&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>Link&gt;</span><br><span class="line">        &lt;<span class="regexp">/nav&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default Header;</span></span><br></pre></td></tr></table></figure><h2 id="动态引用组件"><a href="#动态引用组件" class="headerlink" title="动态引用组件"></a>动态引用组件</h2><p>动态引用可以认为是另一种控制代码切割的方式。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// components/hello.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dynamic <span class="keyword">from</span> <span class="string">'next/dynamic'</span>;</span><br><span class="line"><span class="keyword">const</span> DynamicComponent = dynamic(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../components/hello'</span>));</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Header /&gt;</span><br><span class="line">      &lt;DynamicComponent /&gt;</span><br><span class="line">      &lt;p&gt;HOME PAGE is here!<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default Home;</span></span><br></pre></td></tr></table></figure><p>动态引入还支持对组件的引入不使用SSR。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dynamic <span class="keyword">from</span> <span class="string">'next/dynamic'</span>;</span><br><span class="line"><span class="keyword">const</span> DynamicComponentWithNoSSR = dynamic(</span><br><span class="line">  () =&gt; <span class="keyword">import</span>(<span class="string">'../components/hello3'</span>),</span><br><span class="line">  &#123;</span><br><span class="line">    ssr: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Header /&gt;</span><br><span class="line">      &lt;DynamicComponentWithNoSSR /&gt;</span><br><span class="line">      &lt;p&gt;HOME PAGE is here!<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Home;</span></span><br></pre></td></tr></table></figure><h1 id="动态数据加载"><a href="#动态数据加载" class="headerlink" title="动态数据加载"></a>动态数据加载</h1><p>当页面启动需要加载数据时，使用<code>getInitialProps</code>函数来完成，它可以异步获取数据，并解析成对象，并发送给<code>props</code>。注意，<code>getInitialProps</code> 仅可以在pages中使用，不能在components中使用。其仅用于渲染在页面路由中有参数，需要根据这些参数来获取数据并进行渲染的情况。对于动态的交互，还是需要ajax。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloUA</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">async</span> getInitialProps(&#123; req &#125;) &#123;</span><br><span class="line">    <span class="keyword">const</span> userAgent = req ? req.headers[<span class="string">'user-agent'</span>] : navigator.userAgent;</span><br><span class="line">    <span class="keyword">return</span> &#123; userAgent &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello World &#123;this.props.userAgent&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> HelloUA;</span><br></pre></td></tr></table></figure><h1 id="定制路由-1"><a href="#定制路由-1" class="headerlink" title="定制路由"></a>定制路由</h1><p>定制路由，next.js的文档写的有点没跟上，大体记录一下：</p><h2 id="路由修改"><a href="#路由修改" class="headerlink" title="路由修改"></a>路由修改</h2><p>  其实与link的as类似，在express中，对外展示一层，对内依然用文件系统路由。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">app.prepare().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"> createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">// Be sure to pass `true` as the second argument to `url.parse`.</span></span><br><span class="line">   <span class="comment">// This tells it to parse the query portion of the URL.</span></span><br><span class="line">   <span class="keyword">const</span> parsedUrl = parse(req.url, <span class="literal">true</span>);</span><br><span class="line">   <span class="keyword">const</span> &#123; pathname, query &#125; = parsedUrl;</span><br><span class="line">   <span class="keyword">if</span> (pathname === <span class="string">'/a'</span>) &#123;</span><br><span class="line">     app.render(req, res, <span class="string">'/b'</span>, query);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pathname === <span class="string">'/b'</span>) &#123;</span><br><span class="line">     app.render(req, res, <span class="string">'/a'</span>, query);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     handle(req, res, parsedUrl);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;).listen(<span class="number">3000</span>, err =&gt; &#123;</span><br><span class="line">   <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'&gt; Ready on http://localhost:3000'</span>);</span><br><span class="line"> &#125;);</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="后端禁用文件系统路由"><a href="#后端禁用文件系统路由" class="headerlink" title="后端禁用文件系统路由"></a>后端禁用文件系统路由</h2><p>  如果使用定制路由，文件系统路由的方式可能会导致从多个路由里边访问的内容是一样的情况，可以禁用掉文件系统路由。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// next.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  useFileSystemPublicRoutes: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  useFileSystemPublicRoutes属性会禁用掉SSR侧的文件名路由，CSR侧可能继续提供。对于CSR侧的需要<code>popstate</code></p><p>  以上是官方提供的文档，但并没有提供SSR侧禁用文件系统路由之后，服务端的渲染该如何处理的方案。</p><h2 id="前端拦截popstate"><a href="#前端拦截popstate" class="headerlink" title="前端拦截popstate"></a>前端拦截<code>popstate</code></h2><p>监听<code>popstate</code>，在router响应之前进行拦截，这样可以操作request，或者强制SSR刷新。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'next/router'</span>;</span><br><span class="line">Router.beforePopState(<span class="function">(<span class="params">&#123; url, <span class="keyword">as</span>, options &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// I only want to allow these two routes!</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">as</span> !== <span class="string">'/'</span> || <span class="keyword">as</span> !== <span class="string">'/other'</span>) &#123;</span><br><span class="line">    <span class="comment">// Have SSR render bad routes as a 404.</span></span><br><span class="line">    <span class="built_in">window</span>.location.href = <span class="keyword">as</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>返回false时，router不再处理<code>popstate</code></p><h2 id="router对象的使用"><a href="#router对象的使用" class="headerlink" title="router对象的使用"></a>router对象的使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'next/router'</span>;</span><br><span class="line"><span class="keyword">const</span> handler = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  Router.push(&#123;</span><br><span class="line">    pathname: <span class="string">'/about'</span>,</span><br><span class="line">    query: &#123; <span class="attr">name</span>: <span class="string">'Zeit'</span> &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReadMore</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      Click &lt;span onClick=&#123;handler&#125;&gt;here&lt;<span class="regexp">/span&gt; to read more</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ReadMore;</span><br></pre></td></tr></table></figure><p>这里的功能与<code>&lt;link&gt;</code>相同，但在router上可以监听很多时间，包括<code>routeChangeStart(url)</code>、<code>routeChangeComplete(url)</code>。<br>通过:  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Router.events.on(<span class="string">'routeChangeStart'</span>, handleRouteChange);</span><br></pre></td></tr></table></figure><h1 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h1><p>页面跳转其实是express的功能，只需要将res.redirect(301, ‘/new/link’)即可。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> next = <span class="built_in">require</span>(<span class="string">'next'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; join &#125; = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> dev = process.env.NODE_ENV !== <span class="string">'production'</span></span><br><span class="line"><span class="keyword">const</span> app = next(&#123; dev &#125;)</span><br><span class="line"><span class="keyword">const</span> handle = app.getRequestHandler()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> redirects = [</span><br><span class="line">  &#123; <span class="attr">from</span>: <span class="string">'/old-link-1'</span>, <span class="attr">to</span>: <span class="string">'/new-link-1'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">from</span>: <span class="string">'/old-link-2'</span>, <span class="attr">to</span>: <span class="string">'https://externalsite.com/new-link-2'</span> &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">app.prepare().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> server = express()</span><br><span class="line"></span><br><span class="line">  redirects.forEach(<span class="function">(<span class="params">&#123; <span class="keyword">from</span>, to, type = <span class="number">301</span>, method = <span class="string">'get'</span> &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    server[method](<span class="keyword">from</span>, (req, res) =&gt; &#123;</span><br><span class="line">      res.redirect(type, to)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  server.get(<span class="string">'*'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> handle(req, res)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  server.listen(<span class="number">3000</span>, err =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'&gt; Ready on http://localhost:3000'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>package.json:  </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"dev"</span>: <span class="string">"node server.js"</span>,</span><br><span class="line">  <span class="attr">"start"</span>: <span class="string">"NODE_ENV=production node server.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于登录，可以在’*’中，检查req来进行重定向</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="lt-App-gt"><a href="#lt-App-gt" class="headerlink" title="&lt;App&gt;"></a><code>&lt;App&gt;</code></h2><p>next利用App组件来初始化页面，我们可以重写它来控制页面的初始化，可以处理：</p><ul><li>在页面变换时，持久化布局  </li><li>在页面导航时，保存状态  </li><li>注入额外的数据</li><li>使用<code>componentDidCatch</code>来做定制的错误处理</li></ul><p>创建一个pages/_app.js，然后继承App来实现即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> App, &#123; Container &#125; <span class="keyword">from</span> <span class="string">'next/app'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">async</span> getInitialProps(&#123; Component, ctx &#125;) &#123;</span><br><span class="line">    <span class="keyword">let</span> pageProps = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (Component.getInitialProps) &#123;</span><br><span class="line">      pageProps = <span class="keyword">await</span> Component.getInitialProps(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; pageProps &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; Component, pageProps &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Container&gt;</span><br><span class="line">        &lt;Component &#123;...pageProps&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Container&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default MyApp;</span></span><br></pre></td></tr></table></figure><h2 id="lt-Document-gt"><a href="#lt-Document-gt" class="headerlink" title="&lt;Document&gt;"></a><code>&lt;Document&gt;</code></h2><p>用于改变初始化时候服务端渲染的document标记。处理与App类似<br>修改pages/_document.js，继承自Document</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为学习next.js而做的笔记，主要参照&lt;a href=&quot;https://nextjs.org/docs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网&lt;/a&gt; ，也会借鉴&lt;a href=&quot;https://juejin.im/post/5b868b45e51d4538ae4db7ca&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Next.js踩坑&lt;/a&gt;  &lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="next.js" scheme="http://yoursite.com/tags/next-js/"/>
    
  </entry>
  
  <entry>
    <title>阿里云使用</title>
    <link href="http://yoursite.com/2019/05/12/%E9%98%BF%E9%87%8C%E4%BA%91%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/05/12/阿里云使用/</id>
    <published>2019-05-11T16:00:00.000Z</published>
    <updated>2019-07-01T02:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>总结阿里云使用需要注意的问题</p><a id="more"></a><h1 id="阿里云新实例的坑"><a href="#阿里云新实例的坑" class="headerlink" title="阿里云新实例的坑"></a>阿里云新实例的坑</h1><ul><li><p>80端口不可用的坑<br>描述：<br>搭建起来之后运行core-nginx失败，log日志中什么都没用，80端口也没有被占用</p><p>解决：<br>每个esc都有自己的安全组，需要在阿里云控制台，需要开相应的端口<br>然后，连接后，ubunt预装了防火墙，需要放行80端口，与行<code>ufw allow http</code>即可<br><a href="https://help.aliyun.com/knowledge_detail/59367.html#ubuntu" target="_blank" rel="noopener">ubuntu</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结阿里云使用需要注意的问题&lt;/p&gt;
    
    </summary>
    
      <category term="工具与运维" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E4%B8%8E%E8%BF%90%E7%BB%B4/"/>
    
    
  </entry>
  
  <entry>
    <title>Matrix-SVD与线性变换</title>
    <link href="http://yoursite.com/2019/05/11/Matrix-SVD%E4%B8%8E%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/"/>
    <id>http://yoursite.com/2019/05/11/Matrix-SVD与线性变换/</id>
    <published>2019-05-11T14:44:48.000Z</published>
    <updated>2019-07-01T02:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>原课程Lessson29～Lesson30课，svd其实是正定的延伸，正定是一种特殊的svd；线性变换是矩阵的基础与来源</p><a id="more"></a><h1 id="SVD奇异变换"><a href="#SVD奇异变换" class="headerlink" title="SVD奇异变换"></a>SVD奇异变换</h1><ul><li><p>SVD定义<br>SVD是找到A的一组行向量空间的正交基，通过线性变换，变成列空间的一组正交基的运算。用公式表达为：<br><img src="SVD分析.png" alt="SVD分析"><br>由于是行向量的变换，所有A是左乘V，得到的结果不一定是单位正交的，通过对角阵来表示。<br>这里还可以回忆一下4个基本向量空间：V<sub>1</sub>…V<sub>r</sub> 是在行向量空间，那么V<sub>r+1</sub>…V<sub>n</sub>就是在就会在Nullspace。<br><img src="SVD公式1.png" alt="SVD公式1"><br><img src="SVD公式2.png" alt="SVD公式2">  </p></li><li><p>计算<br>计算是利用的正定，通过A<sub>T</sub>A，来计算V；通过AA<sub>T</sub>来计算U。<br><img src="SVD的计算.png" alt="SVD的计算">  </p></li><li><p>示例1<br><img src="SVD示例1-1.png" alt="SVD示例1-1"><br><img src="SVD示例1-2.png" alt="SVD示例1-2"><br>求得A<sub>T</sub>A的特征值是32 与 18， 特征向量是v<sup>1</sup>=[1 1]<sup>T</sup> 与 v<sup>2</sup>=[1 -1]<sup>T</sup><br>将特征向量标准化:<br><img src="SVD示例1-3.png" alt="SVD示例1-3"><br>同样的道理来求AA<sub>T</sub><br><img src="SVD示例1-4.png" alt="SVD示例1-4"><br>这里由于正好是对角化，于是原课中，直接使用了u1=[1 0]<sup>T</sup> 与 u2=[0 1]<sup>T</sup><br>这样做造成了结果的不一致，而需要通过最原始的进行验证符号， Av<sub>2</sub> = σ<sub>2</sub>u<sub>2</sub><br>于是u2=[0 -1] 最后结果为：<br><img src="SVD示例1-5.png" alt="SVD示例1-5">  </p></li><li><p>示例2<br>原文中给出了奇异状态下的分解：<br><img src="SVD示例2-1.png" alt="SVD示例2-1"><br>由于奇异，也就只有一个行向量，只有一个特征值(另一个为0)<br>v<sup>1</sup>=[0.8 0.6]<sup>T</sup>  </p><p>同样的求法：先求A<sub>T</sub>A，再求AA<sub>T</sub>，最后得结果<br><img src="SVD示例2-2.png" alt="SVD示例2-2"><br><img src="SVD示例2-3.png" alt="SVD示例2-3">  </p><p>这里给出了结果，由于只有一个行向量，而又是2*2的矩阵，另一个V其实是nullspace的基<br><img src="SVD结尾.png" alt="SVD结尾"></p></li></ul><h1 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h1><ul><li><p>定义<br>一个公式：T(cv + dw) = cT(v) + dT(w)，其中c、d是常数，v、w是向量。<br>等同于2个公式：T(v+w) = T(v) + T(w); T(cv) = cT(v)<br>如此T(0) = 0  </p></li><li><p>线性变换与矩阵<br>理解一个线性变换最好的方式，是找到变换后面的矩阵。为此，要引入基向量与坐标。  </p><p>T(v) = Av，因为：<br>A(v+w) = A(v)+A(w)<br>A(cv) = cA(v)  </p><p>给定一个变换T，如何得到一个矩阵A能够代表它呢？<br>首先要选定2组基，如v: v: v<sub>1</sub>,v<sub>2</sub>…v<sub>n</sub>，是R<sup>n</sup>中的基，w: w<sub>1</sub>,w<sub>2</sub>…w<sub>m</sub>。是R<sup>m</sup>中的基。v是input，w是output。<br>T(v<sub>i</sub>) = a<sub>1i</sub>w<sub>1</sub> + a<sub>2i</sub>w<sub>2</sub>…+a<sub>mi</sub>w<sub>m</sub></p></li><li><p>示例1<br><img src="线性变换1-1.png" alt="线性变换1-1"><br>T(v) = Av<br>在R<sup>2</sup>空间中，对于每一个input v=[x, y]<sup>T</sup>，A会将其x值保持不变，而y值取反。结合图像，针对x轴做了对称  </p></li><li><p>示例2<br>求导也是一种线性变换<br><img src="线性变换2-1.png" alt="线性变换2-1"><br>这是一个3维空间向2维空间变换的例子，取输入的基为3维：v<sub>1</sub> = 1, v<sub>2</sub> = x, v<sub>2</sub> = x<sup>2</sup>，输出的的基为2维：w<sub>1</sub> = 1, w<sub>2</sub> = x<br>由此得到<img src="线性变换2-2.png" alt="线性变换2-2"><br>由此得到<img src="线性变换2-3.png" alt="线性变换2-3"></p></li><li><p>结论<br>对于每一个线性变换，都有一个A与之对应，使得T(v) = Av。<br>如果A是可逆的，则线性变换的逆变换 对应的矩阵就是A<sup>-1</sup><br>两个变换的乘积变换： T<sub>1</sub> : v <--> A<sub>1</sub>v ; T<sub>2</sub> : w <--> A<sub>2</sub>w。则这个变换对应的矩阵是A<sub>2</sub>A<sub>1</sub>。这是矩阵乘积的来源。</--></--></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原课程Lessson29～Lesson30课，svd其实是正定的延伸，正定是一种特殊的svd；线性变换是矩阵的基础与来源&lt;/p&gt;
    
    </summary>
    
      <category term="理论" scheme="http://yoursite.com/categories/%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="Matrix" scheme="http://yoursite.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>js构建工具</title>
    <link href="http://yoursite.com/2019/05/05/js%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2019/05/05/js构建工具/</id>
    <published>2019-05-05T14:45:39.000Z</published>
    <updated>2019-07-01T02:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>前一段时间搭建Isomorphic过程中，对js的构建工具接触比较多，也做了一些记录但都不够系统，这里对接触的构建工具做一些较系统的整理，包括：webpack、gulp、babel</p><a id="more"></a>  <h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><ul><li><p>webpack的用途<br>webpack是一个打包工具，打包又是为什么呢？对于前端，用react写了很多组件，如果直接编译成js会有很多的文件，也就需要很多的script来做引用，这样会极为不方便，webpack就是自动的寻找依赖关系，将这些文件打包到一起的工具。<br>起初它只做这个，这样对于非js的文件就不太好处理，这样它通过自己的插件（loader）来对这些非js文件进行支持。这样对于css、ts、stylus等文件，都可以通过webpack来进行处理了。</p></li><li><p>webpack基本概念</p><p>  <a href="https://webpack.js.org/concepts#loaders" target="_blank" rel="noopener">原文</a><br>  4大概念：Entry、Output、Loaders、Plugins</p><ul><li><p>Entry:<br>An entry point indicates which module webpack should use to begin building out its internal dependency graph. webpack will figure out which other modules and libraries that entry point depends on</p></li><li><p>Output:<br>The output property tells webpack where to emit the bundles it creates and how to name these files  </p></li><li><p>Loaders:<br>Out of the box, webpack only understands JavaScript and JSON files. Loaders allow webpack to process other types of files and convert them into valid modules that can be consumed by your application and added to the dependency graph.  </p></li><li><p>Plugins:<br>While loaders are used to transform certain types of modules, plugins can be leveraged to perform a wider range of tasks like bundle optimization, asset management and injection of environment variables.</p></li></ul></li><li><p>使用<br>对于Ts与stylus的loader配置如下:</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123; </span><br><span class="line">            test: /\.tsx$/, </span><br><span class="line">            use: ['awesome-typescript-loader'],</span><br><span class="line">            exclude: /node_modules/</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            test: /\.styl$/,</span><br><span class="line">            use: [ </span><br><span class="line">                &#123;</span><br><span class="line">                    loader: 'style-loader'</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    loader: 'css-loader',</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        modules: true</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    loader: 'stylus-loader'</span><br><span class="line">                &#125; </span><br><span class="line">            ],</span><br><span class="line">            exclude: /node_modules/</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>其他<br>webpack像是一个家族，对于同构它们提供webpack-isomorphic-tools，但在gitlab库的说明上： It allowed many projects to set up basic isomorphic (universal) rendering in the early days but is now considered deprecated and new projects shouldn’t use it. This library can still be found in legacy projects. For new projects use either universal-webpack or all-in-one frameworks like Next.js.</p></li></ul><h1 id="gulp"><a href="#gulp" class="headerlink" title="gulp"></a>gulp</h1><ul><li><p>gulp的用途<br>gulp是一个流式任务运行器，换句话说，我们通过命令行执行的操作，可以通过gulp定义成任务，然后对任务进行编排（指定运行顺序）、运行。<br>gulp的任务执行，从触发方式上看可以是手动执行，也可以通过watch检测文件变化自动执行。</p></li><li><p>gulp基本概念<br><a href="https://www.gulpjs.com.cn/docs/api/" target="_blank" rel="noopener">原文</a><br>输出（Emits）符合所提供的匹配模式（glob）或者匹配模式的数组（array of globs）的文件。 将返回一个 Vinyl files 的   stream 它可以被 piped 到别的插件中。</p><ul><li><p>pipe<br>管道，任务流</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gulp.src(<span class="string">'client/templates/*.jade'</span>)</span><br><span class="line">.pipe(jade())</span><br><span class="line">.pipe(minify())</span><br><span class="line">.pipe(gulp.dest(<span class="string">'build/minified_templates'</span>));</span><br></pre></td></tr></table></figure></li><li><p>task<br>这里采用的是函数编程范式  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">'somename'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> stream = gulp.src(<span class="string">'client/**/*.js'</span>)</span><br><span class="line">    .pipe(minify())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'build'</span>));</span><br><span class="line"><span class="keyword">return</span> stream;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>任务编排：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个 callback，因此系统可以知道它什么时候完成</span></span><br><span class="line">gulp.task(<span class="string">'one'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 做一些事 -- 异步的或者其他的</span></span><br><span class="line">    cb(err); <span class="comment">// 如果 err 不是 null 或 undefined，则会停止执行，且注意，这样代表执行失败了</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个所依赖的 task 必须在这个 task 执行之前完成</span></span><br><span class="line">gulp.task(<span class="string">'two'</span>, [<span class="string">'one'</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 'one' 完成后</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'one'</span>, <span class="string">'two'</span>]);</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>watch<br>监视文件变化  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> watcher = gulp.watch(<span class="string">'js/**/*.js'</span>, [<span class="string">'uglify'</span>,<span class="string">'reload'</span>]);</span><br><span class="line">watcher.on(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'File '</span> + event.path + <span class="string">' was '</span> + event.type + <span class="string">', running tasks...'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>其他<br>gulp其实也提供了一些插件，比如<code>gulp-typescript</code>，可以Ts直接编译成js，它与webpack中的ts-loader应该有类似的作用，只不过webpack中将所有的文件都打包到一起了。</p></li></ul><h1 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h1><ul><li><p>babel的用途<br>babel是转码器，这个转码器是将不同版本的js进行转换。目前有的浏览器并不支持 ES6，而我们又用ES6来编码，那就用babel进行处理，自动转换成相应的版本。<br>而且babel支持React的JSX语法转换，对于Ts，babel也有所支持，比如退去所有的annotation，以及类型  </p></li><li><p>使用<br><a href="https://babeljs.io/docs/en/" target="_blank" rel="noopener">官方文档</a><br>babel部分摘自：<a href="http://www.ruanyifeng.com/blog/2016/01/babel.html" target="_blank" rel="noopener">阮一峰：Babel 入门教程</a>  </p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 转码结果输出到标准输出</span></span><br><span class="line">$ babel example.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转码一个文件：--out-file 或 -o 参数指定输出文件</span></span><br><span class="line">$ babel example.js --out-file compiled.js</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">$ babel example.js -o compiled.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转码整个目录： --out-dir 或 -d 参数指定输出目录</span></span><br><span class="line">$ babel src --out-dir lib</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">$ babel src -d lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># -s 参数生成source map文件</span></span><br><span class="line">$ babel src -d lib -s</span><br></pre></td></tr></table></figure></li><li><p>babel全家桶  </p><ul><li><p>babel-cli<br>上文使用cli运行，需要安装babel-cli：<code>npm install --global babel-cli</code></p></li><li><p>babel-core<br>我们在用的使用更多的是通过gulp来调用，就需要babel-core，<code>npm install babel-core --save</code>  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> babel = <span class="built_in">require</span>(<span class="string">'babel-core'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串转码</span></span><br><span class="line">babel.transform(<span class="string">'code();'</span>, options);</span><br><span class="line"><span class="comment">// =&gt; &#123; code, map, ast &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件转码（异步）</span></span><br><span class="line">babel.transformFile(<span class="string">'filename.js'</span>, options, <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">result; <span class="comment">// =&gt; &#123; code, map, ast &#125;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件转码（同步）</span></span><br><span class="line">babel.transformFileSync(<span class="string">'filename.js'</span>, options);</span><br><span class="line"><span class="comment">// =&gt; &#123; code, map, ast &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>babel-polyfill<br>Babel默认只转换新的JavaScript句法（syntax），而不转换新的API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。 在使用上，就需要babel-ployfill来完成对这些内容的支持。</p><p>安装：<br><code>npm install --save babel-polyfill</code></p><p>在脚本的头部，加入：<br><code>import &#39;babel-polyfill&#39;</code>;</p></li></ul></li></ul><h1 id="webpack-isomorphic-tools"><a href="#webpack-isomorphic-tools" class="headerlink" title="webpack-isomorphic-tools"></a>webpack-isomorphic-tools</h1><ul><li><p>前言<br>在搭建同构应用中，几次都遇到这个工具，在这里对这个工具进行一个整理  </p></li><li><p>webpack-isomorphic-tools的用途<br>webpack做的事情，是将文件进行打包，方便浏览器去获取原本这些分散的js，但对于isomorphic，事情变的不同。node.js的后端并不需要webpack打包，而不经过打包，对于有些类型的文件(图片类、CSS类)，后端没法直接支持。这也正是在前面<a href="https://sunyanfeng.cn/2019/04/14/SSR%E3%80%81CSR%E4%B8%8E%E5%90%8C%E6%9E%84/#more" target="_blank" rel="noopener">SSR、CSR与同构</a>中对stylus文件处理时遇到的问题。</p><p><a href="https://github.com/catamphetamine/webpack-isomorphic-tools#api" target="_blank" rel="noopener">官网</a>  </p></li><li><p>使用  </p><ul><li><p>安装<br>npm install webpack-isomorphic-tools –save</p></li><li><p>将<code>webpack-isomorphic-tools</code>嵌入webpack的配置中  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> WebpackIsomorphicToolsPlugin = <span class="built_in">require</span>(<span class="string">'webpack-isomorphic-tools/plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> webpackIsomorphicToolsPlugin = </span><br><span class="line"><span class="comment">// webpack-isomorphic-tools settings reside in a separate .js file </span></span><br><span class="line"><span class="comment">// (because they will be used in the web server code too).</span></span><br><span class="line"><span class="keyword">new</span> WebpackIsomorphicToolsPlugin(<span class="built_in">require</span>(<span class="string">'./webpack-isomorphic-tools-configuration'</span>))</span><br><span class="line"><span class="comment">// also enter development mode since it's a development webpack configuration</span></span><br><span class="line"><span class="comment">// (see below for explanation)</span></span><br><span class="line">.development()</span><br><span class="line"></span><br><span class="line"><span class="comment">// usual Webpack configuration</span></span><br><span class="line"><span class="built_in">module</span>.exports =</span><br><span class="line">&#123;</span><br><span class="line">context: <span class="string">'(required) your project path here'</span>,</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>:</span><br><span class="line">&#123;</span><br><span class="line">    loaders:</span><br><span class="line">    [</span><br><span class="line">    ...,</span><br><span class="line">    &#123;</span><br><span class="line">        test: webpackIsomorphicToolsPlugin.regularExpression(<span class="string">'images'</span>),</span><br><span class="line">        loader: <span class="string">'url-loader?limit=10240'</span>, <span class="comment">// any image below or equal to 10K will be converted to inline base64 instead</span></span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">plugins:</span><br><span class="line">[</span><br><span class="line">    ...,</span><br><span class="line"></span><br><span class="line">    webpackIsomorphicToolsPlugin</span><br><span class="line">]</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官网在这里也说明了一下为什么要.development()。对于开发模式，它让asset缓存失效，而让asset hot reload使能。</p></li><li><p>isomorphic自己的配置文件：webpack-isomorphic-tools-configuration.js  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> WebpackIsomorphicToolsPlugin <span class="keyword">from</span> <span class="string">'webpack-isomorphic-tools/plugin'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span></span><br><span class="line">&#123;</span><br><span class="line">  assets:</span><br><span class="line">  &#123;</span><br><span class="line">    images:</span><br><span class="line">    &#123;</span><br><span class="line">      extensions: [<span class="string">'png'</span>, <span class="string">'jpg'</span>, <span class="string">'gif'</span>, <span class="string">'ico'</span>, <span class="string">'svg'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>服务端运行入口 main.js配置  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> WebpackIsomorphicTools = <span class="built_in">require</span>(<span class="string">'webpack-isomorphic-tools'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// this must be equal to your Webpack configuration "context" parameter</span></span><br><span class="line"><span class="keyword">var</span> projectBasePath = <span class="built_in">require</span>(<span class="string">'path'</span>).resolve(__dirname, <span class="string">'..'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// this global variable will be used later in express middleware</span></span><br><span class="line">global.webpackIsomorphicTools = <span class="keyword">new</span> WebpackIsomorphicTools(<span class="built_in">require</span>(<span class="string">'./webpack-isomorphic-tools-configuration'</span>)  )</span><br><span class="line">.server(projectBasePath, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// webpack-isomorphic-tools is all set now.</span></span><br><span class="line">  <span class="comment">// here goes all your web application code:</span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./server'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>后端渲染页面  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// clear require() cache if in development mode</span></span><br><span class="line"><span class="comment">// (makes asset hot reloading work)</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>)</span><br><span class="line">&#123;</span><br><span class="line">    webpackIsomorphicTools.refresh()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for react-router example of determining current page by URL take a look at this:</span></span><br><span class="line"><span class="keyword">const</span> pageComponent = [determine your page component here using request.path]</span><br><span class="line"></span><br><span class="line"><span class="comment">// render the page to string and send it to the browser as text/html</span></span><br><span class="line">response.send(<span class="string">'&lt;!doctype html&gt;\n'</span> +</span><br><span class="line">        React.renderToString(<span class="xml"><span class="tag">&lt;<span class="name">Html</span> <span class="attr">assets</span>=<span class="string">&#123;webpackIsomorphicTools.assets()&#125;</span> <span class="attr">component</span>=<span class="string">&#123;pageComponent&#125;</span> /&gt;</span>))</span></span><br></pre></td></tr></table></figure><p>这里它传了fluxstore，在我们那并没有引入，故这个可以不用</p></li><li><p>Html中的使用<br>Html中接收传入的assets const { assets, component, store } = this.props<br>然后从asset中去获取资源，即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> picture = <span class="built_in">require</span>(<span class="string">'../assets/images/cat.jpg'</span>)</span><br><span class="line"><span class="keyword">const</span> icon = <span class="built_in">require</span>(<span class="string">'../assets/images/icon/32x32.png'</span>)</span><br></pre></td></tr></table></figure><p>在header中，也可有直接去引入styles  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="comment">/* styles (will be present only in production with webpack extract text plugin) */</span>&#125;</span><br><span class="line">&#123;<span class="built_in">Object</span>.keys(assets.styles).map(<span class="function">(<span class="params">style, i</span>) =&gt;</span></span><br><span class="line">&lt;link href=&#123;assets.styles[style]&#125; key=&#123;i&#125; media=<span class="string">"screen, projection"</span></span><br><span class="line">        rel=<span class="string">"stylesheet"</span> type=<span class="string">"text/css"</span>/&gt;)&#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="comment">/* resolves the initial style flash (flicker) on page load in development mode */</span>&#125;</span><br><span class="line">&#123; <span class="built_in">Object</span>.keys(assets.styles).length === <span class="number">0</span> ? <span class="xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">dangerouslySetInnerHTML</span>=<span class="string">&#123;&#123;__html:</span> <span class="attr">require</span>('<span class="attr">..</span>/<span class="attr">assets</span>/<span class="attr">styles</span>/<span class="attr">main_style.css</span>')&#125;&#125;/&gt;</span><span class="undefined"> : null &#125;</span></span></span><br></pre></td></tr></table></figure><p>asserts是由webpack-isomorphic-tools创建的webpack-asset.json中的内容 </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"javascript"</span>:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"main"</span>: <span class="string">"/assets/main-d8c29e9b2a4623f696e8.js"</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="attr">"styles"</span>:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"main"</span>: <span class="string">"/assets/main-d8c29e9b2a4623f696e8.css"</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="attr">"assets"</span>:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"./assets/images/cat.jpg"</span>: <span class="string">"http://localhost:3001/assets/9059f094ddb49c2b0fa6a254a6ebf2ad.jpg"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="yarn-vs-npm"><a href="#yarn-vs-npm" class="headerlink" title="yarn vs npm"></a>yarn vs npm</h1><p><a href="https://zhuanlan.zhihu.com/p/27449990" target="_blank" rel="noopener">原文</a></p><p>源头是一致的，yarn会比npm快一些，并且安装版本统计</p><p>npm install === yarn<br>npm install taco –save === yarn add taco<br>npm uninstall taco –save === yarn remove taco<br>npm install taco –save-dev === yarn add taco –dev<br>npm update –save === yarn upgrade  </p><h1 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h1><p>推荐阅读：<a href="http://www.siguoya.name/pc/home/article/271" target="_blank" rel="noopener">思过崖</a>  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一段时间搭建Isomorphic过程中，对js的构建工具接触比较多，也做了一些记录但都不够系统，这里对接触的构建工具做一些较系统的整理，包括：webpack、gulp、babel&lt;/p&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>产品反思</title>
    <link href="http://yoursite.com/2019/05/04/%E4%BA%A7%E5%93%81%E5%8F%8D%E6%80%9D/"/>
    <id>http://yoursite.com/2019/05/04/产品反思/</id>
    <published>2019-05-04T02:10:39.000Z</published>
    <updated>2019-07-01T02:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>整个4月大部分时间都处在产品重构的思考与设计中，牺牲了一些正在坚持的习惯，一方面是时间紧张，另一方面自己很大的精力都投入在这些思考与设计中，没有分心的心思。作为一个由设计到开发的转折点，我觉得有必要对这个过程进行一些反思。</p><a id="more"></a><h1 id="开场白"><a href="#开场白" class="headerlink" title="开场白"></a>开场白</h1><p>回顾4月，先是产品的定位的思考，包括其提供给用户的核心价值。后又用了不太到2个周的时间，对前端的框架进行了探索，包括SPA与MPA、SSR与CSR与同构。后来产品设计、架构设计尤其后端服务的拆分通信、最后对界面进行了讨论与设计。下面反思一下整个过程，一方面为了总结经验，另一方面通过回顾也找一下不足与提升空间。</p><h1 id="产品设计"><a href="#产品设计" class="headerlink" title="产品设计"></a>产品设计</h1><p>产品本身是一个重构，并不是完全从无到有去设计一个产品。从旧的产品中，发现了一些不足。这些不足表现为：  </p><ul><li>原产品中，最初的想法是将项目管理整个从线下搬到线上，这个出发点没有具体表达出产品的核心价值;  </li><li>项目管理是一个整体，同时整体搬迁到线上的难度很高，可行性差;  </li><li>原产品中，虽然有很多角色，但对这些角色如何使用产品，并没有进行设计;  </li><li>原系统中，功能开发出来，但这个功能本身能为用户提供什么帮助，或者设想用户怎么使用并没有思考清楚;  </li></ul><p>所以这次的重构，超越了代码层面、服务架构，是一个从旧产品中重新构思新产品的过程。这个过程：  </p><ul><li><p>首先是归纳了旧产品的价值，提出了3个核心价值：控制、协同、知识。<br>控制指的是项目管理者，对项目进度、产值、成本的控制<br>协同指的是项目成员为完成项目所进行的沟通、交互、审核、汇报等协同<br>知识指的是由数据涌现的对工程的计划、施工、设计等的辅助功能、预警功能  </p></li><li><p>接着制定了3个使用场景<br>第一个场景是控制场景，其包括4种角色，这4种角色以什么样的工作流程、什么样的操作来使用系统，使用后为各角色以及整体产生怎样的价值<br>第二个场景是协同场景，业务上是一个用料申请的场景，这个场景本身其实可以分成4个子场景，每个子场景都是一种用料申请，每个子场景中，都是一种1v1的交互<br>第三个场景也是协同场景，是一个巡查的场景，涉及2个人物也是1v1的交互  </p></li><li><p>从场景中抽象功能<br>从第一场景开始，想象每个角色需要如何使用产品，为了满足其需要，系统要提供什么的功能<br>借鉴旧系统，将这些功能分解、聚合这也就就自然过度到了服务设计  </p></li></ul><h1 id="服务设计"><a href="#服务设计" class="headerlink" title="服务设计"></a>服务设计</h1><p>这里的服务指的是业务层微服务的设计，不能算是整个系统架构的设计。<br>服务的设计过程中，是根据功能分解、聚合之后的结构，尽量达到高内聚，低耦合。另外，一些公共的业务低相关度的功能抽离到独立的微服务中完成<br>后来发现，业务服务竟然大约可以与角色相对应，很大程度上达到的多租户的隔离方式。<br>服务间的通信，大部分采用消息队列来做事件驱动，一部分采用通过redis来共享数据，最小的一部分采用Restful的方式来调用。<br>这种业务服务设计，由于用户的使用频率不同，对应的服务的流量要求就不同，部署的使用也就要有所差异，当然后边可以通过整个架构的监控、devops等设施来完成</p><h1 id="交互设计与界面"><a href="#交互设计与界面" class="headerlink" title="交互设计与界面"></a>交互设计与界面</h1><p>交互的设计上也对比着旧系统，旧系统的组织方式是以部分来划分，原本是可以的，但存在的问题是，现有情况多个部门对于主要的个功能的要求相同，造成前端好几处写了多遍。<br>在这次设计中，并不是从上而下的设计方式，是根据功能使用，自下而上的设计，即先想这个小场景中的功能，应该如何表达，然后画出草图，全部场景设计完全后，将他们聚合在一起的方式。<br>整个设计过程也与队友进行过多次讨论，吸取了他们的意见。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>由产品核心价值定义产品使用场景  </li><li>由产品使用场景定义需求  </li><li>由需求来定义功能，由功能定义业务服务  </li><li>同样由产品使用场景定义交互  </li><li>产品的使用场景亦可以验证交互与需求  </li></ul><p>除此之外，本次的产品，很大程度上是借鉴了旧产品，这方面的空间还有很多，比如现场管理分析、各用户分析，比如竞品分析等</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整个4月大部分时间都处在产品重构的思考与设计中，牺牲了一些正在坚持的习惯，一方面是时间紧张，另一方面自己很大的精力都投入在这些思考与设计中，没有分心的心思。作为一个由设计到开发的转折点，我觉得有必要对这个过程进行一些反思。&lt;/p&gt;
    
    </summary>
    
      <category term="思考" scheme="http://yoursite.com/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>Matrix PositivDefinite</title>
    <link href="http://yoursite.com/2019/05/03/Matrix-PositiveDefinite/"/>
    <id>http://yoursite.com/2019/05/03/Matrix-PositiveDefinite/</id>
    <published>2019-05-03T14:02:34.000Z</published>
    <updated>2019-07-01T02:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>本部分主要研究的是正定，课程包括Lesson25~Lesson28<br>包括：Symmetric matrices and positive definite­ness、Complex matrices and fast Fourier transform、Positive definite matrices and minima、Similar matrices and Jordan form</p><a id="more"></a><h1 id="对称矩阵与正定"><a href="#对称矩阵与正定" class="headerlink" title="对称矩阵与正定"></a>对称矩阵与正定</h1><h2 id="对称矩阵的性质"><a href="#对称矩阵的性质" class="headerlink" title="对称矩阵的性质"></a>对称矩阵的性质</h2><p>A = A<sup>T</sup></p><p>性质：  </p><ul><li>the eigenvalues are real</li><li>the eigenvector are perpendicular even orthonormal</li></ul><p>由此，若A对称，则 A =Q Λ Q<sup>−1</sup> = Q Λ Q<sup>T</sup></p><p>why real eigenvalues?<br>证明思路是从：AX = λX开始，一方面都取共轭，另一方面将原式乘以X的共轭，通过变换，得到λ = λ共轭，得证</p><p>Symmetric matrices with real entries have A =A<sup>T</sup>,  real eigenvalues, and perpendicular eigenvectors.<br>If A has complex entries, then it  will have real eigenvalues and perpendicular eigenvectors if and only if <img src="共轭转置.png" alt="共轭转置"></p><h2 id="对阵矩阵的解释"><a href="#对阵矩阵的解释" class="headerlink" title="对阵矩阵的解释"></a>对阵矩阵的解释</h2><p>A = Q Λ Q<sup>T</sup><br>Q = [q<sub>1</sub>, q<sub>2</sub>… q<sub>n</sub>]<br>展开后得到A = λ<sub>1</sub>q<sub>1</sub>q<sub>1</sub><sup>T</sup> + λ<sub>2</sub>q<sub>2</sub>q<sub>2</sub><sup>T</sup> +…+ λ<sub>n</sub>q<sub>n</sub>q<sub>n</sub><sup>T</sup></p><p>由于q正交，所以q<sub>1</sub>q<sub>1</sub><sup>T</sup>其实是投影矩阵，如此得到，每一个对称阵，其实都是投影的组合。</p><h2 id="关于特征值的符号"><a href="#关于特征值的符号" class="headerlink" title="关于特征值的符号"></a>关于特征值的符号</h2><p>number of positive pivots = number of positive eigenvalues.<br>主元的符号与特征值的符号相同</p><h2 id="正定的定义"><a href="#正定的定义" class="headerlink" title="正定的定义"></a>正定的定义</h2><p>A positive definite matrix is a symmetric matrix A for which all eigenvalues are positive.正定矩阵是所有特征值都是正数的对称矩阵。</p><p>=&gt;  </p><ul><li>所有特征值都是正数  </li><li>所有主元都是正数  </li><li>所有的子行列式(1<em>1,2</em>2..n*n形成的行列式)都是正数</li></ul><h1 id="复数矩阵与FFT"><a href="#复数矩阵与FFT" class="headerlink" title="复数矩阵与FFT"></a>复数矩阵与FFT</h1><h2 id="复数矩阵的特性"><a href="#复数矩阵的特性" class="headerlink" title="复数矩阵的特性"></a>复数矩阵的特性</h2><p>  对于复数向量，取转置运算要变成取共轭转置，或者交Hermite，简写H</p><ul><li><p>复向量的长度<br><img src="复向量长度.png" alt="复向量长度"><br><img src="Hermite.png" alt="Hermite"></p></li><li><p>内积<br>y<sup>T</sup>x =&gt; y<sup>H</sup>x</p></li><li><p>正交<br>Q<sup>H</sup>Q = I，这时候正交Orthogonal 要用 unitary来表达，单位化。</p></li></ul><h2 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h2><ul><li><p>基础形式<br><img src="傅里叶变换1.png" alt="傅里叶变换1"></p></li><li><p>复数矩阵形式<br><img src="傅里叶变换2.png" alt="傅里叶变换2"><br><img src="w定义.png" alt="w定义"></p></li><li><p>n=4例子<br><img src="F4.png" alt="F4"><br><img src="F4结论.png" alt="F4结论">  </p></li></ul><h2 id="FFT"><a href="#FFT" class="headerlink" title="FFT"></a>FFT</h2><p>FFT将傅里叶计算从n<sup>2 =&gt; nlogn  </sup></p><p><img src="FFT.png" alt="FFT"><br>其中<img src="P.png" alt="P">,其作用是将奇数行拿到偶数行的前面<br><img src="D.png" alt="D">  </p><h1 id="正定矩阵性质"><a href="#正定矩阵性质" class="headerlink" title="正定矩阵性质"></a>正定矩阵性质</h1><ul><li><p>最小值<br>对于正定，除了，特征值&gt;0，主元&gt;0，子行列式&gt;0，还有一个X<sup>T</sup>AX &gt; 0<br><img src="正定分析.png" alt="正定分析"><br>如果二次方程一定 &gt; 0，则A正定</p><p><img src="非正定.png" alt="非正定"><br><img src="正定.png" alt="正定">  </p><p>由此得出，正定 =&gt; 有最小值</p><p><img src="Hessian矩阵.png" alt="Hessian矩阵"><br>首先它是对阵的，Its determinant is positive when the matrix is positive definite</p><p><img src="正定多维推广.png" alt="正定多维推广"><br>一个多维的向上的碗，而且全是正的</p></li><li><p>加法<br>if A,B 正定  =&gt; A+B正定</p></li><li><p>推论<br>A<sup>T</sup>A 一定正定， 这里A是m×n 且 rank(A) = n 的矩阵<br>应为其多项式：<img src="正定的一个推理.png" alt="正定的一个推理"></p></li></ul><h1 id="相似矩阵与Jordan式"><a href="#相似矩阵与Jordan式" class="headerlink" title="相似矩阵与Jordan式"></a>相似矩阵与Jordan式</h1><ul><li><p>定义<br>对于A，B两个矩阵，若A = M<sup>-1</sup>BM，则A、B相似</p></li><li><p>性质<br>相似矩阵，拥有相同的特征值，相同数量的独立特征向量（一般不同）</p></li><li><p>重特征值问题<br>以λ<sub>1</sub> = λ<sub>2</sub> = 4 为例<br>可以分成两个famliy:  </p><ol><li><img src="重特征值-1.png" alt="重特征值-1">,这一族比较大  </li><li><img src="重特征值-2.png" alt="重特征值-2">，这一族只有这一个矩阵，因为它与任何M相乘都会返回自身  </li></ol></li><li><p>Jordan matrix<br>简单的说，对于重特征值问题，它们需要有相同的Jordan blocks的形式.<br><img src="Jordan-blocks.png" alt="Jordan-blocks"><br><img src="Jordan-blocks一般形式.png" alt="Jordan-blocks一般形式"><br>其中<img src="Jordan-blocks一般形式2.png" alt="Jordan-blocks一般形式2">，这里，对角线上都是特征值，下方都是0，上方跟随一层1.</p><p><img src="概括Jordan.png" alt="概括Jordan"><br>这样，不同的特征值情况可以认为是一种特殊的Jordan Matrix，它们的Jordan Block都是为1*1的特征值本身</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本部分主要研究的是正定，课程包括Lesson25~Lesson28&lt;br&gt;包括：Symmetric matrices and positive definite­ness、Complex matrices and fast Fourier transform、Positive definite matrices and minima、Similar matrices and Jordan form&lt;/p&gt;
    
    </summary>
    
      <category term="理论" scheme="http://yoursite.com/categories/%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="Matrix" scheme="http://yoursite.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>nest.js记录</title>
    <link href="http://yoursite.com/2019/05/03/nest%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/05/03/nest记录/</id>
    <published>2019-05-03T06:45:39.000Z</published>
    <updated>2019-07-01T02:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文为理解nest.js而做记录，内容为官网中的基础部分，目的是为了理解、记忆，所以不会抄原文的例子。<br><a href="https://docs.nestjs.com/" target="_blank" rel="noopener">官网</a>  </p><a id="more"></a><h1 id="骨架"><a href="#骨架" class="headerlink" title="骨架"></a>骨架</h1><p>骨架部分主要介绍：Controllers、Providers、Modules，他们组成了nest应用的最基础部分，可以认为Route Handler部分</p><h2 id="Controllers"><a href="#Controllers" class="headerlink" title="Controllers"></a>Controllers</h2><ul><li><p>定义<br>Controllers are responsible for handling incoming requests and returning responses to the client.</p></li><li><p>路由<br>分层的定义方法，在类上定义的，被其下的方法所继承，如在类上定义<code>@Controller(&#39;customers&#39;)</code>，在类方法中定义<code>@Get(&#39;profile&#39;)</code>，则其路由为<code>GET /customers/profile</code></p></li><li><p>两种模式<br>一种是标准模式，也是推荐模式，通过nest的装饰器来使用各种参数;<br>另一种原生模式（Library-specific），通过@Res(),@Req()获取库原生的request与response对象，来直接进行操作。<br>这两种方式不能同时使用，当然nest推荐前者。</p></li><li><p>装饰器  </p></li></ul><table><thead><tr><th style="text-align:left">装饰器</th><th style="text-align:center">介绍</th></tr></thead><tbody><tr><td style="text-align:left">@Req()</td><td style="text-align:center">获取Request对象(express)</td></tr><tr><td style="text-align:left">@Res()</td><td style="text-align:center">获取Response对象(express)</td></tr><tr><td style="text-align:left">@Session()</td><td style="text-align:center">获取req.session</td></tr><tr><td style="text-align:left">@Param(key?: string)</td><td style="text-align:center">req.params / req.params[key],param是路由中的参数</td></tr><tr><td style="text-align:left">@Body(key?: string)</td><td style="text-align:center">req.body / req.body[key]</td></tr><tr><td style="text-align:left">@Query(key?: string)</td><td style="text-align:center">req.query / req.query[key],query是?后的参数</td></tr><tr><td style="text-align:left">@Headers(name?: string)</td><td style="text-align:center">req.headers / req.headers[name]</td></tr><tr><td style="text-align:left">@HttpCode(201)</td><td style="text-align:center">指定response中的返回值</td></tr></tbody></table><h2 id="Providers"><a href="#Providers" class="headerlink" title="Providers"></a>Providers</h2><ul><li><p>定义<br>Many of the basic Nest classes may be treated as a provider – services, repositories, factories, helpers, and so on. A provider is simply a class annotated with an @Injectable() decorator  </p></li><li><p>理解<br>这里说的很明白的，provider可以理解成功能的提供者了,任何可以注入的类都可以认为是provider。原文中也说，provider不仅仅是@Injectable(),它可以是数值、类、同步或异步工厂(plain values, classes, and either asynchronous or synchronous factories)，这个在后边的Custom Provider中会做更多介绍  </p></li></ul><h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h2><ul><li><p>定义<br>A module is a class annotated with a @Module() decorator. The @Module() decorator provides metadata that Nest makes use of to organize the application structure.  </p></li><li><p>理解<br>Module要做一点解释，Nest是Module来组织的，不论是Controller还是Provider都需要注册到Module中才能被Nest托管。还有一点比较有趣的，在Module中可以imports其他Module，而imports的内容，其实是被引用Module中exports出的内容</p></li><li><p>属性<br>@Module装饰器接收一个对象，其属性包括</p></li></ul><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:center">介绍</th></tr></thead><tbody><tr><td style="text-align:left">providers</td><td style="text-align:center">被Nest injector实例化的providers</td></tr><tr><td style="text-align:left">controllers</td><td style="text-align:center">被Nest injector实例化的controllers</td></tr><tr><td style="text-align:left">imports</td><td style="text-align:center">引入这些moludes export 的providers</td></tr><tr><td style="text-align:left">exports</td><td style="text-align:center">providers的子集，被其他模块可以import</td></tr></tbody></table><h1 id="经脉"><a href="#经脉" class="headerlink" title="经脉"></a>经脉</h1><p>经脉介绍中间件(Middleware)、异常过滤器(Exception filters)、管道(Pipes)、哨兵(Guards)、拦截器(Interceptors)。我觉得广义上看，他们都可以被称为拦截器，他们要么在拦截request（Middleware,Pipe，Guard），要么在拦截response(Exception filter)，要么双方都拦截（Interceptors）。<br>它们有着类似的scope，包括：全局(global)、控制器（controller）、路由函数(router)，其实隐藏着模块（module）等范围</p><h2 id="Middleware"><a href="#Middleware" class="headerlink" title="Middleware"></a>Middleware</h2><ul><li><p>定义<br>Middleware is a function which is called before the route handler. Middleware functions have access to the request and response objects, and the next() middleware function in the application’s request-response cycle.<br><img src="middleware.png" alt="middleware"></p></li><li><p>理解<br>中间件常见的场景包括，Log，cors，helmet等，中间件的使用上，主要在routers,controllers,module范围内，原文中没有在全局使用中间件。</p></li></ul><h2 id="Exception-filters"><a href="#Exception-filters" class="headerlink" title="Exception filters"></a>Exception filters</h2><ul><li><p>定义<br>Nest comes with a built-in exceptions layer which is responsible for processing all unhandled exceptions across an application. When an exception is not handled by your application code, it is caught by this layer, which then automatically sends an appropriate user-friendly response.</p><p><img src="pipe与filter.png" alt="filter"></p></li><li><p>理解<br>从定义中可以看出，它是在request上，进行filter，当服务端有异常抛出，对异常进行捕获、处理，并返回给客户端。<br>异常过滤器4种使用方式都支持，这部分可以写一些异常处理的代码，定义好Exception 与 exception 与 filter，然后在代码中可以方便的抛异常了。</p><p><a href="https://docs.nestjs.com/exception-filters#exception-filters-1" target="_blank" rel="noopener">Exception filters</a></p></li></ul><h2 id="Pipes"><a href="#Pipes" class="headerlink" title="Pipes"></a>Pipes</h2><ul><li><p>定义<br>A pipe is a class annotated with the @Injectable() decorator. Pipes should implement the PipeTransform interface.<br>原文可能觉得pipe真不用定义了，所以也没有定义，就是函数编程范式pipe，其实跟中间件、拦截器都一样.<br><img src="pipe与filter.png" alt="pipe"></p></li><li><p>使用场景  </p><ul><li>transformation: transform input data to the desired output  </li><li>validation: evaluate input data and if valid, simply pass it through unchanged; otherwise, throw an exception when the data is incorrect</li></ul><p>就是数据转换与有效性检验。这一部分集成化比较高，通过class-validator and class-transformer可以直接使用ValidationPipe，ParseIntPipe了，支持4种使用方式</p></li></ul><h2 id="Guards"><a href="#Guards" class="headerlink" title="Guards"></a>Guards</h2><ul><li><p>定义<br>A guard is a class annotated with the @Injectable() decorator. Guards should implement the CanActivate interface.<br><a href="guard.png">guard</a><br>Guards have a single responsibility. They determine whether a given request will be handled by the route handler or not, depending on certain conditions (like permissions, roles, ACLs, etc.) present at run-time. This is often referred to as authorization。<br>在express中，认证由中间件来做，原文中有对为什么用guard而不用middleware的解释，大约就是middleware你需要控制next，并且不知道next的下一步是什么，而guard由于有执行环境（ExecutionContext），可以清楚的知道下一步执行什么。</p></li><li><p>理解<br>4种使用方式都支持。<br>这里使用了reflect，因为对于guard，它需要知道定义在每个router的角色<br><a href="https://docs.nestjs.com/guards#putting-it-all-together" target="_blank" rel="noopener">实例</a><br>这个部分要好好写一下，与原文中的例子略有不同，原文中认证的角色，我们要认证权限  </p></li></ul><h2 id="Interceptors"><a href="#Interceptors" class="headerlink" title="Interceptors"></a>Interceptors</h2><ul><li><p>定义<br>An interceptor is a class annotated with the @Injectable() decorator. Interceptors should implement the NestInterceptor interface.<br><img src="Interceptors.png" alt="Interceptors">  </p></li><li><p>理解<br>支持4种使用方式。通过next.handle()来调用主体，然后在pipe中对返回进行处理。在piple中可以对response进行处理，可以对异常进行处理等。<br>应用场景比如通过记录每个调用的入口、出口时间来计算响应时间，对response中数据的处理，对异常的处理等。<br>Interceptor可以对前后两端的处理，由于入口侧的验证、转换、认证都有特殊的解决方案了，所以我觉得它更注重出口侧一些，以及更注重业务逻辑一些。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 中间件的实现可能与其他略有不同，Exception filter，pipe,guard简直就是interception在各应用场景的细化。<br> 在使用上，需要对异常处理(Exception Filter)、参数验证(Pipe)、权限认证(Guard)、日志(Middleware/Interceptor)、监控(Interceptor)等，都可以用到.</p><h1 id="套路"><a href="#套路" class="headerlink" title="套路"></a>套路</h1><h2 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h2><p>这里的认证，并不是权限认证，而是主要是对客户端的认证，这里只记录jwt方式，认证主要使用Passport模块</p><ul><li><p>过程<br>客户端进行登录，后端核对完用户名、密码之后，创一个token给浏览器，浏览器之后在header(cookie与Authorization其实都行)中一直带着，来做http状态的认证。</p></li><li><p>理解<br>因为后端要验证用户名、密码，以及生成token，就需要一个Service来做这件事情，而passport本身支持‘bearer’,‘jwt’等不同策略，也就需要一个Strategy来解耦不同策略，而这个策略本身要依赖那个验证的Service。Strategy完成的是对token的解析，调用Service去验证，其统一的接口应该validate()函数。<br>在Strategy的使用上，即Strategy如何被nest使用，这里只能做一个推测，其通过Module的providers属性注入到nest中，nest在注册PassportModule时，自动将注册的Strategy注册到Passport当中，并完成jwt认证过程。<br>在使用上，通过Passport提供的AuthGuard来使用，这样就与Guard联系到了一起。</p><p>本质上讲，Passport也是一种Guard，更本质，就是一前置拦截器。</p></li></ul><h2 id="Database-ORM"><a href="#Database-ORM" class="headerlink" title="Database/ORM"></a>Database/ORM</h2><p>这里的ORM使用的TypeORM<br><a href="https://typeorm.io/" target="_blank" rel="noopener">ypeORM</a></p><ul><li><p>概念<br>这里需要注意的概念包括：  </p><ul><li><p>连接(Connection)<br>在这里连接的建立，使用过在ApplicationModule中，import TypeOrmModule.forRoot()来建立的，forRoot的参数就是一个数据库连接必备的字段。连接本身有name属性，缺省为’default’，这在多连接建立时会需要。</p></li><li><p>实体(Entity)<br>实体就是Model层，需要指定类属性对应的表结构，并指定one2Many/Many2One等与其他实体的关系</p></li><li><p>实体管理器(EntityManager)<br>Using EntityManager you can manage (insert, update, delete, load, etc.) any entity. EntityManager is just like a collection of all entity repositories in a single place  </p><p>实体管理器是对所有实体进行管理，它是Repository的一个集合</p></li><li><p>库(Repository)<br>Repository is just like EntityManager but its operations are limited to a concrete entity</p><p>Repository是对单个实体进行管理</p></li></ul></li><li><p>使用<br>需要在Module中imports TypeOrmModule.forFeature([Photo])，这个forFeature应该是获取Photo实体所对应的Repository，进而在Service中就可以使用Repository来操作实体了。<br>在TypeORM官网中，可以通过Connection来直接获取Repository，在nest中介绍的并不详细。<br>应该是在forRoot时，指明连接的名字，然后在Service中通过InjectConnection(‘连接名’)，来注入连接，通过@InjectEntityManager(‘连接名’)来注入实体管理器entityManager。</p></li></ul><h1 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h1><h2 id="Custom-providers"><a href="#Custom-providers" class="headerlink" title="Custom providers"></a>Custom providers</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为理解nest.js而做记录，内容为官网中的基础部分，目的是为了理解、记忆，所以不会抄原文的例子。&lt;br&gt;&lt;a href=&quot;https://docs.nestjs.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网&lt;/a&gt;  &lt;/p&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
      <category term="nest.js" scheme="http://yoursite.com/tags/nest-js/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统设计模式</title>
    <link href="http://yoursite.com/2019/04/19/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/04/19/分布式系统设计模式/</id>
    <published>2019-04-18T23:25:35.000Z</published>
    <updated>2019-07-01T02:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章来整理《左耳听风》栏目的分布式设计模式弹力设计、管理设计、性能设计篇，并根据当下情况，借鉴一二</p><a id="more"></a><h1 id="弹力设计"><a href="#弹力设计" class="headerlink" title="弹力设计"></a>弹力设计</h1><h2 id="隔离设计-Bulkheads"><a href="#隔离设计-Bulkheads" class="headerlink" title="隔离设计 Bulkheads"></a>隔离设计 Bulkheads</h2><ul><li><p>背景<br>这个设计借鉴了船舱通过隔板来把船隔成几个独立空间，防止一点进水蔓延到整个船只。</p></li><li><p>2种隔离方法  </p><ul><li><p>按服务的种类来做隔离<br>如用户注册、商品中心、社交服务，将他们独立成各自的服务，并独占各自自己的DB<br>总会面对获取多个板块数据的情况，这样会调用多个服务，对于这样的问题，一般来说，我们需要小心地设计用户交互，最好不要让用户在一个页面上获得所有的数据。对。<br>业务跨板块时，控制就有点复杂。对此我们需要一个类似于 Pub/Sub 的高可用的并可以持久化的消息订阅通知的中间件来打通各个版块的数据和信息交换。最后还会有在多个版块中分布式事务的问题。对此，我们需要“二阶段提交”这样的方案。在亚马逊中，使用的是 Plan – Reserve – Commit/Cancel 模式。  </p></li><li><p>多租户：按用户的请求来分离<br>将用户分成不同的组，并把后端的同一个服务根据这些不同的组分成不同的实例。让同一个服务对于不同的用户进行冗余和隔离，这样一来，当服务实例挂掉时，只会影响其中一部分用户，而不会导致所有的用户无法访问。<br>做法有：<br>完全独立的设计。每个租户有自己完全独立的服务和数据。<br>独立的数据分区，共享的服务。多租户的服务是共享的，但数据是分开隔离的。<br>共享的服务，共享的数据分区。每个租户的数据和服务都是共享的。<br>一般会选择折中方案，服务是共享的，数据通过分区来隔离。</p></li></ul></li><li><p>重点<br>隔离模式需要配置一些高可用、重试、异步、消息中间件，流控、熔断等设计模式的方式配套使用。</p></li><li><p>课外<br>在虚拟化技术非常成熟的今天，我们完全可以使用“完全独立”（完全隔离）的方案，通过底层的虚拟化技术（Hypervisor 的技术，如 KVM，或是 Linux Container 的技术，如 Docker）来实现物理资源的共享和成本的节约。</p></li></ul><h2 id="异步通讯设计-Asynchronous"><a href="#异步通讯设计-Asynchronous" class="headerlink" title="异步通讯设计 Asynchronous"></a>异步通讯设计 Asynchronous</h2><ul><li><p>异步通讯的3种方式  </p><ul><li><p>请求响应式<br>直接REST调用  </p></li><li><p>通过订阅的方式<br>订阅者模式，接收方（receiver）会来订阅发送方（sender）的消息，发送方会把相关的消息或数据放到接收方所订阅的队列中，而接收方会从队列中获取数据。<br>这种情况下接收方需要想发送方订阅事件</p></li><li><p>通过中间人的方式<br>这是完整版的订阅者模式，发送方（sender）和接收方（receiver）都互相看不到对方，它们看得到的是一个 Broker，发送方向 Broker 发送消息，接收方向 Broker 订阅消息。如下图所示。<br><img src="broker方式.png" alt="broker方式"></p></li></ul></li><li><p>事件驱动  </p><p><img src="时间驱动.png" alt="时间驱动"><br>每个服务都是“自包含”的。所谓“自包含”也就是没有和别人产生依赖。而要把整个流程给串联起来，我们需要一系列的“消息通道（Channel）”。各个服务做完自己的事后，发出相应的事件，而又有一些服务在订阅着某些事件来联动。<br>这好处与遇到问题，与隔离设计其实是相同的。</p><p>需要消息跟踪：异步通讯会导致业务处理流程不那么直观，因为像接力一样，所以在 Broker 上需要有相关的服务消息跟踪机制，否则出现问题后不容易调试。<br>需要工作流引擎：因为服务间只通过消息交互，所以业务状态最好由一个总控方来管理，这个总控方维护一个业务流程的状态变迁逻辑，以便系统发生故障后知道业务处理到了哪一步，从而可以在故障清除后继续处理。  </p></li></ul><h2 id="幂等设计-Idempotency"><a href="#幂等设计-Idempotency" class="headerlink" title="幂等设计 Idempotency"></a>幂等设计 Idempotency</h2><ul><li><p>定义<br>所谓幂等性设计，就是说，一次和多次请求某一个资源应该具有同样的副作用。用数学的语言来表达就是：f(x)  = f(f(x))。<br>为什么我们需要这样的操作？说白了，就是在我们把系统解耦隔离后，服务间的调用可能会有三个状态，一个是成功（Success），一个是失败（Failed），一个是超时（Timeout）。前两者都是明确的状态，而超时则是完全不知道是什么状态。因为系统超时，而调用户方重试一下，会给我们的系统带来不一致的副作用。</p></li><li><p>全局ID<br>要做到幂等性的交易接口，需要有一个唯一的标识，来标志交易是同一笔交易。而这个交易 ID 由谁来分配是一件比较头疼的事。因为这个标识要能做到全局唯一。<br>算法详见： Twitter 的开源项目 Snowflake</p></li><li><p>处理流程<br>对于幂等性的处理流程来说，说白了就是要过滤一下已经收到的交易。要做到这个事，我们需要一个存储来记录收到的交易。于是，当收到交易请求的时候，我们就会到这个存储中去查询。如果查找到了，那么就不再做查询了，并把上次做的结果返回。如果没有查到，那么我们就记录下来。<br>所以，最好是当这个存储出现冲突的时候会报错。也就是说，我们收到交易请求后，直接去存储里记录这个 ID（相对于数据的 Insert 操作），如果出现 ID 冲突了的异常，那么我们就知道这个之前已经有人发过来了，所以就不用再做了。比如，数据库中你可以使用。<br>对于更新的场景来说，如果只是状态更新，可以使用如下的方式。如果出错，要么是非法操作，要么是已被更新，要么是状态不对，总之多次调用是不会有副作用的。</p></li><li><p>HTTP幂等性<br>Post不具备幂等性，处理如下：<br>首先，在表单中需要隐藏一个 token，这个 token 可以是前端生成的一个唯一的 ID。用于防止用户多次点击了表单提交按钮，而导致后端收到了多次请求，却不能分辨是否是重复的提交。这个 token 是表单的唯一标识。（这种情况其实是通过前端生成 ID 把 POST 变成了 PUT。）<br>然后，当用户点击提交后，后端会把用户提示的数据和这个 token 保存在数据库中。如果有重复提交，那么数据库中的 token 会做排它限制，从而做到幂等性。<br>当然，更为稳妥的做法是，后端成功后向前端返回 302 跳转，把用户的前端页跳转到 GET 请求，把刚刚 POST 的数据给展示出来。如果是 Web 上的最好还把之前的表单设置成过期，这样用户不能通过浏览器后退按钮来重新提交。这个模式又叫做。[对于前端渲染的方式，需要前端来控制]</p></li></ul><h2 id="重试设计-Retry"><a href="#重试设计-Retry" class="headerlink" title="重试设计 Retry"></a>重试设计 Retry</h2><ul><li><p>场景<br>“重试”的语义是我们认为这个故障是暂时的，而不是永久的，所以，我们会去重试<br>我认为，设计重试时，我们需要定义出什么情况下需要重试，例如，调用超时、被调用端返回了某种可以重试的错误（如繁忙中、流控中、维护中、资源不足等）。<br>而对于一些别的错误，则最好不要重试，比如：业务级的错误（如没有权限、或是非法数据等错误），技术上的错误（如：HTTP 的 503 等，这种原因可能是触发了代码的 bug，重试下去没有意义）。</p></li><li><p>策略<br>关于重试的设计，一般来说，都需要有个重试的最大值，经过一段时间不断的重试后，就没有必要再重试了，应该报故障了。在重试过程中，每一次重试失败时都应该休息一会儿再重试，这样可以避免因为重试过快而导致网络上的负担加重。<br>在重试的设计中，我们一般都会引入，Exponential Backoff 的策略，也就是所谓的 “ 指数级退避 “。在这种情况下，每一次重试所需要的休息时间都会成倍增加。这种机制主要是用来让被调用方能够有更多的时间来从容处理我们的请求。这其实和 TCP 的拥塞控制有点像。  </p><p>例如，我们定义一个调用返回的枚举类型，其中包括了 5 种返回错误——成功 SUCCESS、维护中 NOT_READY、流控中 TOO_BUSY、没有资源 NO_RESOURCE、系统错误 SERVER_ERROR。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Results &#123;</span><br><span class="line">  SUCCESS,</span><br><span class="line">  NOT_READY,</span><br><span class="line">  TOO_BUSY,</span><br><span class="line">  NO_RESOURCE,</span><br><span class="line">  SERVER_ERROR</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>spring的重试方法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Retryable</span>(</span><br><span class="line">    value = &#123; SQLException.class &#125;,</span><br><span class="line">    maxAttempts = <span class="number">2</span>,</span><br><span class="line">    backoff = <span class="meta">@Backoff</span>(delay = <span class="number">5000</span>))</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">retryService</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设计重点<br>重试的代码比较简单也比较通用，完全可以不用侵入到业务代码中。这里有两个模式。一个是代码级的，像 Java 那样可以使用 Annotation 的方式（在 Spring 中你可以用到这样的注解），如果没有注解也可以包装在底层库或是 SDK 库中不需要让上层业务感知到。另外一种是走 Service Mesh 的方式（关于 Service Mesh 的方式，我会在后面的文章中介绍）。<br>对于有事务相关的操作。我们可能会希望能重试成功，而不至于走业务补偿那样的复杂的回退流程。对此，我们可能需要一个比较长的时间来做重试，但是我们需要保存请求的上下文，这可能对程序的运行有比较大的开销，因此，有一些设计会先把这样的上下文暂存在本机或是数据库中，然后腾出资源来做别的事，过一会再回来把之前的请求从存储中捞出来重试。</p></li></ul><h2 id="补偿设计-Compensating-Transaction"><a href="#补偿设计-Compensating-Transaction" class="headerlink" title="补偿设计 Compensating Transaction"></a>补偿设计 Compensating Transaction</h2><ul><li>前沿<br>既然要分布式，必须要分离，隔离的服务之间通信要用异步的来解耦开，然后可能会存在通信异常，就需要重试，重试时不想被重试操作多次，也就需要幂等，更重要的一个问题是如果业务走不下去怎么办？那就是本节的补偿，如果前边几种是正流程，那么补偿就是逆流程。  </li><li><p>ACID 和 BASE<br>这里先做一点解释，这两个概念其实是tradeoff，严格必然不会繁荣，繁荣必然存在瑕疵。<br>有必要先说一下 ACID 和 BASE 的差别。传统关系型数据库系统的事务都有 ACID 属性，即原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。<br>为了提高性能，出现了 ACID 的一个变种 BASE。可以看到，BASE 系统是允许或是容忍系统出现暂时性问题的，这样一来，我们的系统就能更有弹力。因为我们知道，在分布式系统的世界里，故障是不可避免的，我们能做的就是把故障处理当成功能写入代码中，这就是 Design for Failure。</p></li><li><p>业务补偿<br>一般来说，业务的事务补偿都是需要一个工作流引擎的。亚马逊是一个超级喜欢工作流引擎的公司，这个工作流引擎把各式各样的服务给串联在一起，并在工作流上做相应的业务补偿，整个过程设计成为最终一致性的。<br>对于业务补偿来说，首先需要将服务做成幂等性的，如果一个事务失败了或是超时了，我们需要不断地重试，努力地达到最终我们想要的状态。然后，如果我们不能达到这个我们想要的状态，我们需要把整个状态恢复到之前的状态。另外，如果有变化的请求，我们需要启动整个事务的业务更新机制。</p><p>一个好的业务补偿机制需要做到下面这几点：<br>要能清楚地描述出要达到什么样的状态（比如：请假、机票、酒店这三个都必须成功，租车是可选的），以及如果其中的条件不满足，那么，我们要回退到哪一个状态。这就是所谓的整个业务的起始状态定义。<br>当整条业务跑起来的时候，我们可以串行或并行地做这些事。对于旅游订票是可以并行的，但是对于网购流程（下单、支付、送货）是不能并行的。总之，我们的系统需要努力地通过一系列的操作达到一个我们想要的状态。如果达不到，就需要通过补偿机制回滚到之前的状态。这就是所谓的状态拟合。<br>对于已经完成的事务进行整体修改，可以考虑成一个修改事务。  </p><p>我们需要小心维护和监控整个过程的状态，所以，千万不要把这些状态放到不同的组件中，最好是一个业务流程的控制方来做这个事，也就是一个工作流引擎。所以，这个工作流引擎是需要高可用和稳定的。这就好像旅行代理机构一样，我们把需求告诉它，它会帮我们搞定所有的事。如果有问题，也会帮我们回滚和补偿的。<br>下层的业务方最好提供短期的资源预留机制。就像电商中的把货品的库存预先占住等待用户在 15 分钟内支付。如果没有收到用户的支付，则释放库存。然后回滚到之前的下单操作，等待用户重新下单。</p></li></ul><h2 id="熔断设计-Circuit-Breaker"><a href="#熔断设计-Circuit-Breaker" class="headerlink" title="熔断设计 Circuit Breaker"></a>熔断设计 Circuit Breaker</h2><p>先简单描述  </p><ul><li><p>定义<br>熔断器模式可以防止应用程序不断地尝试执行可能会失败的操作，使得应用程序继续执行而不用等待修正错误，或者浪费 CPU 时间去等待长时间的超时产生。熔断器模式也可以使应用程序能够诊断错误是否已经修正。如果已经修正，应用程序会再次尝试调用操作。</p><p>由此可见，重试的次数显示实在前端的一种控制，这里的熔断实在后端，更确切说是网关的控制</p></li><li><p>示意图<br><img src="熔断示意图.png" alt="熔断示意图"></p></li><li><p>状态<br><img src="熔断状态转换.png" alt="熔断状态转换"></p><ul><li><p>closed，通畅状态<br>我们需要一个调用失败的计数器，如果调用失败，则使失败次数加 1。如果最近失败次数超过了在给定时间内允许失败的阈值，则切换到断开 (Open) 状态。此时开启了一个超时时钟，当该时钟超过了该时间，则切换到半断开（Half-Open）状态。该超时时间的设定是给了系统一次机会来修正导致调用失败的错误，以回到正常工作的状态。在 Closed 状态下，错误计数器是基于时间的。在特定的时间间隔内会自动重置。这能够防止由于某次的偶然错误导致熔断器进入断开状态。也可以基于连续失败的次数。  </p></li><li><p>open，断开状态<br>在该状态下，对应用程序的请求会立即返回错误响应，而不调用后端的服务。这样也许比较粗暴，有些时候，我们可以 cache 住上次成功请求，直接返回缓存（当然，这个缓存放在本地内存就好了），如果没有缓存再返回错误（缓存的机制最好用在全站一样的数据，而不是用在不同的用户间不同的数据，因为后者需要缓存的数据有可能会很多）。</p></li><li><p>Half-open，半开状态<br>允许应用程序一定数量的请求去调用服务。如果这些请求对服务的调用成功，那么可以认为之前导致调用失败的错误已经修正，此时熔断器切换到闭合状态，同时将错误计数器重置。</p></li></ul></li><li><p>课外<br> Netflix 的Hystrix开源项目</p></li></ul><h2 id="限流设计-Throttle"><a href="#限流设计-Throttle" class="headerlink" title="限流设计 Throttle"></a>限流设计 Throttle</h2><ul><li><p>定义<br>保护系统不会在过载的情况下出现问题，需要通过对并发访问进行限速，相关的策略一般是，一旦达到限制的速率，那么就会触发相应的限流行为。包括：拒绝服务、服务降级、特权请求、延时请求等</p></li><li><p>3种实现方式  </p><ul><li><p>计数器方式<br>最简单的限流算法就是维护一个计数器 Counter，当一个请求来时，就做加一操作，当一个请求处理完后就做减一操作。如果这个 Counter 大于某个数了（我们设定的限流阈值），那么就开始拒绝请求以保护系统的负载了。可以增加对特权用户增加新的队列，来完成对不同用户的控制。<br><img src="计数限流.png" alt="计数限流"><br><img src="队列限流.png" alt="队列限流"></p></li><li><p>漏斗方式<br>我们可以看到，就像一个漏斗一样，进来的水量就好像访问流量一样，而出去的水量就像是我们的系统处理请求一样。当访问流量过大时这个漏斗中就会积水，如果水太多了就会溢出。<br>一般来说，这个“漏斗”是用一个队列来实现的，当请求过多时，队列就会开始积压请求，如果队列满了，就会开拒绝请求。很多系统都有这样的设计，比如 TCP。当请求的数量过多时，就会有一个 sync backlog 的队列来缓冲请求，或是 TCP 的滑动窗口也是用于流控的队列。<br><img src="漏斗限流方式.png" alt="漏斗限流方式">  </p></li><li><p>令牌桶方式<br>关于令牌桶算法，主要是有一个中间人。在一个桶内按照一定的速率放入一些 token，然后，处理程序要处理请求时，需要拿到 token，才能处理；如果拿不到，则不处理。<br><img src="令牌桶限流方式.png" alt="令牌桶限流方式"></p></li><li><p>基于响应时间的动态限流<br>这其实是将限流加了负反馈回路<br>上面的算法有个不好的地方，就是需要设置一个确定的限流值。这就要求我们每次发布服务时都做相应的性能测试，找到系统最大的性能值。<br>我们想使用一种动态限流的方式。这种方式，不再设定一个特定的流控值，而是能够动态地感知系统的压力来自动化地限流。这方面设计的典范是 TCP 协议的拥塞控制的算法。TCP 使用 RTT - Round Trip Time 来探测网络的延时和性能，从而设定相应的“滑动窗口”的大小，以让发送的速率和网络的性能相匹配。这个算法是非常精妙的，我们完全可以借鉴在我们的流控技术中。</p></li></ul></li><li><p>课外<br>tcp的限流方式</p></li></ul><h2 id="降级设计-Degradation"><a href="#降级设计-Degradation" class="headerlink" title="降级设计 Degradation"></a>降级设计 Degradation</h2><ul><li><p>定义<br>所谓的降级设计（Degradation），本质是为了解决资源不足和访问量过大的问题。当资源和访问量出现矛盾的时候，在有限的资源下，为了能够扛住大量的请求，我们就需要对系统进行降级操作。也就是说，暂时牺牲掉一些东西，以保障整个系统的平稳运行。  </p></li><li><p>方法</p><ul><li><p>停止次要功能<br>停止次要的功能也是一种非常有用的策略。把一些不重要的功能给暂时停止掉，让系统释放出更多的资源来。比如，电商中的搜索功能，用户的评论功能，等等。等待访问的峰值过去后，我们再把这些功能给恢复回来。  </p></li><li><p>简化功能<br>关于功能的简化上，上面的下单流程中已经提到过相应的例子了。而且，从缓存中返回数据也是其中一个。这里再提一个，就是一般来说，一个 API 会有两个版本，一个版本返回全量数据，另一个版本只返回部分或最小的可用的数据。  </p></li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>分布式核心就是分，就是隔离服务<br>联系起来整理，才发现这一系列的脉络，整个分布式系统有两条流程，一条是正向流程、一条是反向流程。<br>正向流程中包括，分解服务、异步通讯、重试、幂等<br>反向流程指的是补偿设计<br>为了保护正反向流程不被流量压跨，又有了3个保护设计：熔断、限流、降级</p><h1 id="管理设计"><a href="#管理设计" class="headerlink" title="管理设计"></a>管理设计</h1><h2 id="分布式锁-Distributed-Lock"><a href="#分布式锁-Distributed-Lock" class="headerlink" title="分布式锁 Distributed Lock"></a>分布式锁 Distributed Lock</h2><p>先简化写了</p><ul><li><p>定义<br>我们知道，在多线程情况下访问一些共享资源需要加锁，不然就会出现数据被写乱的问题。在分布式系统下，这样的问题也是一样的。只不过，我们需要一个分布式的锁服务。对于分布式的锁服务，一般可以用数据库 DB、Redis 和 ZooKeeper 等实现。不管怎么样，分布式的锁服务需要有以下几个特点。  </p></li><li><p>redis分布式锁<br><code>SET resource_name my_random_value NX PX 30000</code></p></li><li><p>redis分布式锁的问题</p></li><li><p>解决方案</p><ul><li>版本号</li><li>fence token</li></ul></li><li><p>课外<br>细心的你一定发现了，这不就是计算机汇编指令中的原子操作 CAS（Compare And Swap）嘛，大量无锁的数据结构都需要用到这个。（关于 CAS 的话题，你可以看一下我在 CoolShell 上写的</p></li></ul><h2 id="配置中心-Configuration-Management"><a href="#配置中心-Configuration-Management" class="headerlink" title="配置中心 Configuration Management"></a>配置中心 Configuration Management</h2><p>先简写了，这个跟杨波老师的配置中心一个概念，不过引出了下边3节的内容</p><ul><li><p>配置区分<br>有一种方式是把软件的配置分成静态配置和动态配置。<br>静态配置：所谓静态配置其实就是在软件启动时的一些配置，运行时基本不会进行修改，也可以理解为是环境或软件初始化时需要用到的配置。如，操作系统的网络配置，软件运行时 Docker 进程的配置，这些配置在软件环境初始化时就确定了，未来基本不会修改了<br>动态配置：就是软件运行时的一些配置，在运行时会被修改。比如，日志级别、降级开关、活动开关。</p></li><li><p>架构<br><img src="配置中心.png" alt="配置中心"></p></li></ul><h2 id="边车模式-SideCar"><a href="#边车模式-SideCar" class="headerlink" title="边车模式 SideCar"></a>边车模式 SideCar</h2><ul><li><p>定义<br>边车就有点像一个服务的 Agent，这个服务所有对外的进出通讯都通过这个 Agent 来完成。这样，我们就可以在这个 Agent 上做很多文章了。但是，我们需要保证的是，这个 Agent 要和应用程序一起创建，一起停用。</p><p>编程的本质就是将控制和逻辑分离和解耦，而边车模式也是异曲同工，同样是让我们在分布式架构中做到逻辑和控制分离。</p></li><li><p>讨论<br>对于监视、日志、限流、熔断、服务注册、协议转换等等这些功能，其实都是大同小异，甚至是完全可以做成标准化的组件和模块的。一般来说，我们有两种方式：<br>一种是通过 SDK、Lib 或 Framework 软件包方式，在开发时与真实的应用服务集成起来。性能高，但对应用有侵入<br>另一种是通过像 Sidecar 这样的方式，在运维时与真实的应用服务集成起来。性能低，无需改应用，增加了依赖，也做到了逻辑与控制的分离。  </p><p>其实一种是在代码层面解决，一种是在服务层面解决</p></li><li><p>结构<br><img src="边车模式.png" alt="边车模式"></p></li><li><p>特点<br>我们知道，熔断、路由、服务发现、计量、流控、监视、重试、幂等、鉴权等控制面上的功能，以及其相关的配置更新，本质来上来说，和服务的关系并不大。但是传统的工程做法是在开发层面完成这些功能，这就会导致各种维护上的问题，而且还会受到特定语言和编程框架的约束和限制。<br>而随着系统架构的复杂化和扩张，我们需要更统一地管理和控制这些控制面上的功能，所以传统的在开发层面上完成控制面的管理会变得非常难以管理和维护。这使得我们需要通过 Sidecar 模式来架构我们的系统。  </p></li></ul><h2 id="服务网格-Service-Mesh"><a href="#服务网格-Service-Mesh" class="headerlink" title="服务网格 Service Mesh"></a>服务网格 Service Mesh</h2><ul><li><p>背景<br>将边车模式发扬广大，是 CNCF（Cloud Native Computing Foundation，云原生计算基金会）目前主力推动的新一代的微服务架构——Service Mesh 服务网格。<br>Service Mesh 这个服务网络专注于处理服务和服务间的通讯。其主要负责构造一个稳定可靠的服务通讯的基础设施，并让整个架构更为的先进和 Cloud Native。在工程中，Service Mesh 基本来说是一组轻量级的服务代理和应用逻辑的服务在一起，并且对于应用服务是透明的。  </p></li><li><p>示意图<br><img src="service_mesh.png" alt="service_mesh"><br><img src="server_mesh_2.png" alt="server_mesh_2">  </p></li><li><p>课外<br>Rust/Go 语言实现的 lstio 和 Conduit，后者比前者要轻很多。</p></li></ul><h2 id="网关模式-Gateway"><a href="#网关模式-Gateway" class="headerlink" title="网关模式 Gateway"></a>网关模式 Gateway</h2><ul><li><p>背景<br>这其实与service mesh是两个方向的发展了<br>它不需要为每个服务的实例都配置上一个 Sidecar。其实，一个服务集群配上一个 Gateway 就可以了，或是一组类似的服务配置上一个 Gateway。  </p></li><li><p>示意图<br><img src="网关示意图.png" alt="网关示意图"></p></li><li><p>网关的功能</p><ul><li>请求路由</li><li>服务注册</li><li>负载均衡</li><li>弹力设计：重试、幂等、流控、熔断、监视等都可以实现进去</li><li>安全方面：SSL 加密及证书管理、Session 验证、授权、数据校验等</li></ul></li></ul><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>首先，Sidecar 的方式主要是用来改造已有服务。我们知道，要在一个架构中实施一些架构变更时，需要业务方一起过来进行一些改造。然而业务方的事情比较多，像架构上的变更会低优先级处理，这就导致架构变更的“政治复杂度”太高。而通过 Sidecar 的方式，我们可以适配应用服务，成为应用服务进出请求的代理。这样，我们就可以干很多对于业务方完全透明的事情了。<br>当 Sidecar 在架构中越来越多时，需要我们对 Sidecar 进行统一的管理。于是，我们为 Sidecar 增加了一个全局的中心控制器，就出现了我们的 Service Mesh。在中心控制器出现以后，我们发现，可以把非业务功能的东西全部实现在 Sidecar 和 Controller 中，于是就成了一个网格。业务方只需要把服务往这个网格中一放就好了，与其它服务的通讯、服务的弹力等都不用管了，像一个服务的 PaaS 平台。<br>然而，Service Mesh 的架构和部署太过于复杂，会让我们运维层面上的复杂度变大。为了简化这个架构的复杂度，我认为 Sidecar 的粒度应该是可粗可细的，这样更为方便。但我认为，Gateway 更为适合，而且 Gateway 只负责进入的请求，不像 Sidecar 还需要负责对外的请求。因为 Gateway 可以把一组服务给聚合起来，所以服务对外的请求可以交给对方服务的 Gateway。于是，我们只需要用一个负责进入请求的 Gateway 来简化需要同时负责进出请求的 Sidecar 的复杂度。</p><h1 id="性能设计"><a href="#性能设计" class="headerlink" title="性能设计"></a>性能设计</h1><h2 id="缓存-Cache"><a href="#缓存-Cache" class="headerlink" title="缓存 Cache"></a>缓存 Cache</h2><h2 id="异步处理-Asynchronous"><a href="#异步处理-Asynchronous" class="headerlink" title="异步处理 Asynchronous"></a>异步处理 Asynchronous</h2><h2 id="数据库扩展"><a href="#数据库扩展" class="headerlink" title="数据库扩展"></a>数据库扩展</h2><h2 id="秒杀-Flash-Sales"><a href="#秒杀-Flash-Sales" class="headerlink" title="秒杀 Flash Sales"></a>秒杀 Flash Sales</h2><h2 id="边缘计算-Edge-Computing"><a href="#边缘计算-Edge-Computing" class="headerlink" title="边缘计算 Edge Computing"></a>边缘计算 Edge Computing</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章来整理《左耳听风》栏目的分布式设计模式弹力设计、管理设计、性能设计篇，并根据当下情况，借鉴一二&lt;/p&gt;
    
    </summary>
    
      <category term="系统" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="分布式系统" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
