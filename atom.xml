<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>思 见</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-04T03:12:26.585Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>sun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vscode下md导pdf</title>
    <link href="http://yoursite.com/2019/04/04/vscode%E4%B8%8Bmd%E5%AF%BCpdf/"/>
    <id>http://yoursite.com/2019/04/04/vscode下md导pdf/</id>
    <published>2019-04-04T02:47:46.000Z</published>
    <updated>2019-04-04T03:12:26.585Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下通过vscode转md导成pdf的方法</p><a id="more"></a><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>用md写文档已经渐渐成为习惯，尤其可以通过hexo，直接发布成博客。<br>造成的问题呢，很多文档并不是博客，比如会议纪要、工作的一些记录，写成md分享给非技术人员看，并不太合适，尤其有图片的时候，于是就想用md转成pdf。</p><h1 id="Markdown-Pdf插件安装"><a href="#Markdown-Pdf插件安装" class="headerlink" title="Markdown Pdf插件安装"></a>Markdown Pdf插件安装</h1><p>从扩展中安装Markdown Pdf</p><p><img src="插件.png" alt="插件"></p><p>安装成功后，可以在md文件中右键看到如下菜单</p><p><img src="右键.png" alt="右键"></p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>看到很多介绍，说到这里就可以直接点击导出就能成功，但在我机器上并没有成功。</p><p>点击后，发现没有任何反应，最初以为是导出的目录可能不对，搜索了一下，发现可以通过<code>markdown-pdf.outputDirectory</code>的方式来配置导出的目录，于是进行了设置，发现还是没反应</p><p>我注意到每次启动时，vscode坐下脚的提示中，总在install chromium，于是就有数了，这个Markdown Pdf其实是调用了chromium的接口来完成转换的。也是就看一下这个插件的配置。如下</p><p><img src="ExecutablePath.png" alt="ExecutablePath"></p><p>由于本机上有chromium浏览器，就<code>whereis chromium-browser</code>，然后在进行了配置，在settings.json中增加：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"markdown-pdf.executablePath": "/usr/bin/chromium-browser"</span><br></pre></td></tr></table></figure><p>重试，导出成功。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下通过vscode转md导成pdf的方法&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>编程范式</title>
    <link href="http://yoursite.com/2019/04/01/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/04/01/编程范式/</id>
    <published>2019-04-01T09:26:14.000Z</published>
    <updated>2019-04-02T02:40:22.685Z</updated>
    
    <content type="html"><![CDATA[<p>本篇作为笔记形式存在，对左耳听风中的编程范式做笔记，便于以后去查看。<br>原文中主要用到了语言有C、C++、Python、Java、Javascript、Go、Prolog。由于我对Go语言了解不深，委托范式像是一种组合方式的应用，这里就不对这种范式进行记录了，以后有机会，再回来补充;另外Prolog的方式我觉得很有趣，以后想去研究一下再写，这里也不包括在内。</p><p>我需要找到一种合适的记录顺序：原文以一种语言发展的顺序展开，是一种不错的方式; 根据我学习语言的前后顺序，也是一种不错的方式; 再有一种是总分式展开方式。这里选用第二种吧，以我接触这些范式的先后关系来展开。</p><a id="more"></a><h1 id="过程式编程"><a href="#过程式编程" class="headerlink" title="过程式编程"></a>过程式编程</h1><p>作为学习的起点，我也是从C语言起步的，但作为使用的起点却不能算是。真正使用的起点应该是汇编语言了，那时候在学校里做课程设计，用汇编控制循环。后来第二次做的时候就用上了C语言，感觉轻松了好多，循环用for就可以了，不用来回的jump。</p><p>对C语言的特性，这里直接引用了</p><ul><li>C 语言是一个静态弱类型语言，在使用变量时需要声明变量类型，但是类型间可以有隐式转换；</li><li>不同的变量类型可以用结构体（struct）组合在一起，以此来声明新的数据类型；</li><li>C 语言可以用 typedef 关键字来定义类型的别名，以此来达到变量类型的抽象；</li><li>C 语言是一个有结构化程序设计、具有变量作用域以及递归功能的过程式语言；</li><li>C 语言传递参数一般是以值传递，也可以传递指针；</li><li>通过指针，C 语言可以容易地对内存进行低级控制，然而这引入了非常大的编程复杂度；</li><li>编译预处理让 C 语言的编译更具有弹性，比如跨平台。</li></ul><p>我这里尝试来回忆一下：</p><ul><li>从数据上看，数据本身都是二进制，类型是对这段二进制的解释，类型本身并不是数据。</li><li>从内存山看，可以分成静态区、堆区、栈区、常量区，分别用来存储存储全局、new、局部、常量字符串等数据</li><li>数据对齐方式要注意大小端的差异，尤其在传输过程中，一般都需要大小端的转换，实现方式就是按中轴进行互换。</li><li>还有一些比较有趣的结构：比如union，还记得老师写的那段代码，用union来包含两个struct，它们的长度相同，但在传输与解析时做不同的使用。</li><li>还有很多宏定义，像是去年看的，内核中使用链表时候那段宏定义就很有意义。</li><li>中断的处理，单片机上的中断口有限，需要对中断手动进行配置，包括端口以及回调函数。中断其实一种异步方式，中断方式比起轮询方式节省很多资源。</li></ul><p>C语言回忆就到这里了，说是过程式的，不如说是指令式的，你像机器发送着一些指令，这其实比汇编语言好多了，起码不需要记住每一个寄存器。另外，以前只听老师说过C语言其实可以写OO，一直无缘得见，后来看vfs时候才明白，原来面向对象是一种思想，并不一定被语言限制，在C中一样可以用这种思想。</p><h1 id="面向对象式编程"><a href="#面向对象式编程" class="headerlink" title="面向对象式编程"></a>面向对象式编程</h1><p>最早接触C++其实是在实验室里，那时候用MFC做桌面端的应用程序，当然那时候我们称桌面为上位机。对C++的认识也比较模糊，因为MFC做了好多封装，也体会不出C++的特点。工作之后，写了5年的C++，目前为止，在所有语言里使用时间也是最长的。</p><p>面向对象的3大特性：封装、继承、多态。<br>对面向对象的评价继续引用：</p><ul><li><p>优点</p><ul><li>能和真实的世界交相辉映，符合人的直觉。</li><li>面向对象和数据库模型设计类型，更多地关注对象间的模型设计。</li><li>强调于“名词”而不是“动词”，更多地关注对象和对象间的接口。</li><li>根据业务的特征形成一个个高内聚的对象，有效地分离了抽象和具体实现，增强了可重用性和可扩展性。</li><li>拥有大量非常优秀的设计原则和设计模式。S.O.L.I.D（单一功能、开闭原则、里氏替换、接口隔离以及依赖反转，是面向对象设计的五个基本原则）、IoC/DIP……</li></ul></li><li><p>缺点</p><ul><li>代码都需要附着在一个类上，从一侧面上说，其鼓励了类型。</li><li>代码需要通过对象来达到抽象的效果，导致了相当厚重的“代码粘合层”。</li><li>因为太多的封装以及对状态的鼓励，导致了大量不透明并在并发下出现很多问题。</li></ul></li></ul><p>缺点上这两点原文中，原文中的举例都是针对Java，像Spring的那些注入，导致了大量的封装，这些封装还屏蔽了细节。</p><p>这里只对自己在使用C++的时候的一些回忆吧，主要针对面向对象的3大特性来展开</p><ul><li>封装，封装其实沿用着C语言模块化编程的思维，讲究低耦合高内聚的方式，只不过面向对象是将数据与操作封装成一个类，这里的数据也就是后边说的状态。</li><li>继承，继承是代码复用的一种方式，起先比较喜欢继承，后来发现继承也是有缺点的，会出现类爆炸的情况。于是就提倡使用组合的方式来复用代码。尤其加之与后边将的多态，使对组合元素的依赖于接口，而不是具体实现，耦合程度进一步降低。</li><li>多态，就是刚才说的，依赖于接口而不是具体实现。其实后来发现那些设计模式，其实就是对继承、组合、多态的一些常见用法，直接点就是套路。</li></ul><p>还有一部分是开发过程的控制</p><ul><li>多线程及线程池的使用，重构预处理服务的时候，将不同的处理策略抽象各自的实现中，然后将整个流程又封装成了各自的过程对象，最后获取线程池中的线程运行过程对象。后来发现这种方式在Java中与runable的方式类似，而且当时各个流程是硬编码的，如果是面AOP的方式，或者装饰器的方式会更好一些。</li><li>由于各个处理步骤的只完成对数据处理的一部分，可能会new出一段数据区来，在不同的步骤之间传递引用，但当时的的情况不同，最后的结果并不是线性依赖的，而是根据各个步骤处理结果的逻辑运算。在实现的过程中将数据放到了一块contex的数据区，并将每个步骤的结果也保存在集中，最后将取结果的逻辑与结果本身解耦出来。</li><li>在多线程中处理全局数据，对锁的要求很高。</li></ul><p>感慨一下，没想到3年过去了，还能顺利记起当时的做法。</p><p>其实这隐含着这种编码方式很大的问题，在分布式系统中，状态如此之多，处理起来会加倍的困难。虽然当时从内存监控上看，并没有出现泄露的情况，但也是战战兢兢，如履薄冰的。</p><p>Java其实在面向对象方面其实比C++做的好一些，从我的基础上看，MVC、IoC、动态代理这些是接触到Java之后才真正了解，而且Java的那本Head First设计模式比C++那本更容易理解。由于Java使用并没有C++使用的深，就此作罢吧。</p><h1 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h1><p>对于泛型编程，除去比用的STL，其实自己写的时候还真的比较少，记忆中，刚开始写Qt界面的时候，3个表格数据不同，表达基本相同，我用泛型做了一个实现。这里做个引用：</p><p>理想情况下，算法应是和数据结构以及类型无关的，各种特殊的数据类型理应做好自己分内的工作。算法只关心一个标准的实现。而对于泛型的抽象，我们需要回答的问题是，如果我们的数据类型符合通用算法，那么对数据类型的最小需求又是什么呢？<br>原文中给出的方式包括3重：</p><ol><li><p>它通过类的方式来解决<br>构造函数与析构函数<br>拷贝构造函数，表示对内存的复制<br>重载操作符</p></li><li><p>通过模板达到类型和算法的妥协。</p></li><li><p>通过虚函数和运行时类型识别。</p></li></ol><p>这里想说一下STL，没有接触STL之前，培训老师出了一题，题目现在已经忘记了，记得最主要的数据结构就是动态数据了，我们自己写链表来实现，人家直接用vector，效率高出许多。如果没用vector、set、map，那C++的路还会坎坷一些。</p><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>函数式编程最早也是从coolshell中看到的，而且缺少实践，需要引用的东西更多一些了。</p><ul><li><p>定义</p><p>定义输入数据和输出数据相关的关系，数学表达式里面其实是在做一种映射（mapping），输入的数据和输出的数据关系是什么样的，是用函数来定义的。</p><p>从通篇来看，函数式编程都是在借鉴函数，y = f(x) ,在这里只定义了一种关系，而且这种关系可以替换，如 z = g(y)，这时候可以将y带入变成z = g(f(x))，由此，函数与变量本身是等价的，自然也就是懒惰的，并且，是可以嵌套的。</p></li><li><p>特点</p><p>stateless: 无状态，就像是电路，本身不能存储电荷一样，有出有入，入多少出多少<br>immutable： 输入数据是不能动的，动了输入数据就有危险，所以要返回新的数据集。这条其实是从stateless中演化而来，对与函数f(x)，进了x就要出y，且x不能变</p></li><li><p>一些技术</p><ul><li>first class function（头等函数），函数像变量一样使用，参考 z = g(f(x))</li><li>recursing(递归)， z = f(f(x))，是对上一条的加深</li><li>pipeline(管道), 原文解释：将函数实例成一个一个的 action，然后将一组 action 放到一个数组或是列表中，再把数据传给这个 action list，数据就像一个 pipeline 一样顺序地被各个函数所操作，最终得到我们想要的结果。 pipleline最早也是shell的管道操作了。在代码方面有点。这些用法其实都是基于stateless的。</li><li>tail recursion optimization(尾递归)</li><li>map &amp; reduce &amp; filter，这个不论在python还是js中都有使用<br>…</li></ul></li><li><p>一些总结</p><ul><li>函数式编程的核心就stateless，仿照y = f(x)，仿照节点不存电荷</li><li>函数可以替换，也就是函数与变量等价，因为这种等价，在多线程调用时候，也就更安全</li><li>函数可以嵌套，也就可以currying、可以recursing、可以pipeline</li></ul></li><li><p>一些问题</p><ul><li><p>关于无状态<br>联想到了http协议，本来设计是一个无状态的协议，最后却不得不加上cookie、session等的加上状态。那函数式变成处理陈老师提到的频繁复制的问题，还会有什么问题。</p><p>另一个是体系架构，都是尽量在做到无状态，但一个请求需要在不同的服务中流转来完成，这种感觉有些像pipeline，需要流转的次序可配置，并且需要记录在每个流程中的一些信息，比如日志聚合，这种方式跟http协议上加cookie是何等的相似。</p><p>需要状态才是函数编程存在的问题，无状态是一种存在，优点也是缺点。</p></li><li><p>函数编程与面向对象编程<br>面向对象基础其实是封装了，封装是将数据与操作封装在一起的思想，这些数据也就是成员变量，就是状态。但完全可以封装一个类，没有成员变量，里边的函数全是函数式的无状态。这种范式即是面向对象，也是函数编程。那其实也就没有继承的必要性了，完全组合就可以，但多态还是需要的，面向接口编程会保存下来。</p></li></ul></li></ul><h1 id="基于原型的编程"><a href="#基于原型的编程" class="headerlink" title="基于原型的编程"></a>基于原型的编程</h1><p>基于原型的编程已经单独总结过了，这里只放个链接：<br><a href="https://sunyanfeng.cn/2019/03/31/js%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B/#more" target="_blank" rel="noopener">js中的原型</a>  </p><p>基于原型的编程，其实就是用组合的方式在完成着继承。继承跟组合的界限在这里有些模糊了。<br>node.js中的异步其实是一种软中断，这一部分可以整体梳理成一个博文了，包括单片机的中断处理、linux上下部的中断处理、以及node.js异步的处理，这里就不多写了。</p><h1 id="编程的本质"><a href="#编程的本质" class="headerlink" title="编程的本质"></a>编程的本质</h1><p>陈老师给出的编程本质也是函数式的：<br>Programs = Algorithms + Data Structures<br>Algorithm = Logic + Control<br>So:<br>Promgrams = Logic + Control + DataStructures<br>其中Logic是业务逻辑，逻辑过程的抽象，加上由术语表示的数据结构的定义<br>Control与业务逻辑无关，你控制它的执行，控制一个程序执行的方式，串行or并行，以及调度不同的执行模块，数据之间的存储关系，这些和业务逻辑无关。</p><p>尤其其中给出的注册验证的代码例子，看的我有些汗颜，重构那个模块时，没有想起来，然后这块代码其实在pg测试里见过，没有联想到可以这样玩。</p><p>这里对logic与control的分离做一点简单的思考：</p><p>在代码级别上，将logic以配置的方式（json、xml）来表达出来，然后将control针对格式来做，而不是针对内容。<br>在服务级别上，跟上边的无状态服务有些类似，每个无状态的服务可以看作是logic，通过编排来control执行的服务。</p><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>本文为了自己记忆方便，做一些记录与思考的东西，所有引用都是从陈皓老师，极客时间《左耳听风》处引来。若有不妥，请联系我，联系方式，详见站内“关于”部分。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇作为笔记形式存在，对左耳听风中的编程范式做笔记，便于以后去查看。&lt;br&gt;原文中主要用到了语言有C、C++、Python、Java、Javascript、Go、Prolog。由于我对Go语言了解不深，委托范式像是一种组合方式的应用，这里就不对这种范式进行记录了，以后有机会，再回来补充;另外Prolog的方式我觉得很有趣，以后想去研究一下再写，这里也不包括在内。&lt;/p&gt;
&lt;p&gt;我需要找到一种合适的记录顺序：原文以一种语言发展的顺序展开，是一种不错的方式; 根据我学习语言的前后顺序，也是一种不错的方式; 再有一种是总分式展开方式。这里选用第二种吧，以我接触这些范式的先后关系来展开。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ARTS第二周</title>
    <link href="http://yoursite.com/2019/03/31/%E7%AC%AC%E4%BA%8C%E5%91%A8ARTS/"/>
    <id>http://yoursite.com/2019/03/31/第二周ARTS/</id>
    <published>2019-03-31T14:00:37.000Z</published>
    <updated>2019-04-01T01:21:44.271Z</updated>
    
    <content type="html"><![CDATA[<p>第二周打卡<br><a id="more"></a></p><h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><p><a href="https://sunyanfeng.cn/2019/03/31/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98/#more" target="_blank" rel="noopener">最大子数组问题</a></p><h1 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h1><p><a href="https://codeburst.io/interfaces-in-javascript-with-es6-naive-implementation-91b703110a09" target="_blank" rel="noopener">Interfaces in JavaScript with ES6 Symbol. Naive implementation</a></p><p>在javascript中通过Symbol的方式来实现interface</p><p>这种打算通过重写一些代码，有一些东西需要依赖接口来编程，于是就探索了一下在javascript中如何使用接口。这其实与本周share中的原型继承有一定的联系了，于是找到了这篇文章。</p><p>在这篇文章中，通过es6提供的Symbol实现了接口的功能，而且使用了es6的getter与setter，主要依赖就是Symbol的唯一性,试想，如果不用Symbol而是使用string，那样如果一个类不具有这个接口实现中，而偏偏有了一个相同的属性名，这样在判断undefine时就是真，就会出现问题。</p><h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><p><a href="https://sunyanfeng.cn/2019/03/31/Matrix-Determinants/#more" target="_blank" rel="noopener">Matrix Determinants</a></p><h1 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h1><p><a href="https://sunyanfeng.cn/2019/03/31/js%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B/#more" target="_blank" rel="noopener">js中的原型</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二周打卡&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>js中的原型</title>
    <link href="http://yoursite.com/2019/03/31/js%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/03/31/js中的原型/</id>
    <published>2019-03-31T13:08:47.000Z</published>
    <updated>2019-04-02T01:59:42.229Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客主要是想总结一下js中的原型，其中包含《左耳听风》36节之后的一点思考。</p><a id="more"></a><h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><p>在去年刚看JS高程的时候，觉得javascipt这继承真麻烦，并没有去深入思考一下，在看到左耳听风这篇文章后，觉得有了一些新的认识。这里对原型再深入探索一下。</p><p><img src="原型链-1.png" alt="原型链.jpg"><br>从这个图里，可以很明白表达原型链的含义，在每个对象里都有一个<code>__proto__</code>的属性，用来指向其原型。</p><p><img src="原型链-2.png" alt="原型链.jpg"><br>这里是对<code>__proto__</code>与prototype差异的一个说明，Foo每个Function对象都会多一个prototype属性，指向一个对象，其他对象的通过<code>__proto__</code>指向Foo.prototype。</p><p><img src="原型链继承.png" alt="原型链继承"><br>这个是JS高程中原型链继承中的图片，很清楚的看出SubType的prototype对象通过<code>__proto__</code>指向SuperType的prototype来继承其中的方法，instance实例通过<code>__proto__</code>来使用subtype中的方法。</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>这引发了我对两个问题的思考：</p><ol><li><p>为什么要有prototype与<code>__proto__</code></p><p>首先原型链的本质就是通过<code>__proto__</code>来指向其他对象的方式来复用代码，典型的组合方式。那为什么会用prototype呢，我觉得是原因Function两个维度上的使用，其一直接new对象，其二被子类继承使用。因为需要直接new对象，也就需要<code>__proto__</code>；因为需要被其他子Function继承，所以将被继承、被共用的部分独立出来，放到prototype中，本质上是一种模块化思维，将可以被复用的与不能被复用的分离。</p></li><li><p>js为什么以这种方式来实现继承</p><p>js基本属于一切皆对象的语言，函数是对象、类是对象。这样的情况注定没有类型，也就注定只能是组合的方式来完成类。在静态语言中，我们生命一个Student类，然后实例化一个xiaoMing的实例，在这里Student是一个对象，它与xiaoMing本质上是一种东西。xiaoMing通过一个指定的属性依赖Student。</p><p>这其实引发另一个问题，这种组合方式是动态类型语言唯一的方式吗？python中好像并不是这样玩的，这个问题留给以后来思考。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇博客主要是想总结一下js中的原型，其中包含《左耳听风》36节之后的一点思考。&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="编程范式" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Matrix Determinants</title>
    <link href="http://yoursite.com/2019/03/31/Matrix-Determinants/"/>
    <id>http://yoursite.com/2019/03/31/Matrix-Determinants/</id>
    <published>2019-03-31T12:21:42.000Z</published>
    <updated>2019-04-01T01:08:56.076Z</updated>
    
    <content type="html"><![CDATA[<p>本周完成了Gilbert Strang线性代数的中行列式的学习，课程中的Lesson18~Lesson21.</p><p>笔记都是用课程中手记的，这里只做一个简单的记录。</p><a id="more"></a><h1 id="determinants"><a href="#determinants" class="headerlink" title="determinants"></a>determinants</h1><ol><li><p>det I = 1</p></li><li><p>交换2行的位置，符合改变。</p></li><li><p>在每一个行上，都是线性的。</p></li><li><p>A中存在2个相同的行，det A = 0</p></li><li><p>substract c*row(i) from row(j), and the det does not change</p></li><li><p>A: Row of zeros, det A = 0</p></li><li><p>U: 上三角矩阵，d1,d2…dn为主元素， det U = d1 <em> d2 ..</em> dn<br>这个说明可以通过消元法来求解行列式，而且Gilbert老师说，是matlib等求det的主要方法。</p></li><li><p>A: singular, det A = 0</p></li><li><p>det(AB) = detA <em> detB<br>det2A = 2^n </em> det A<br>其实看到这里的时候，Gilbert老师就提到过，这种样子像是求体积，自然而然就意识到det其实就是矩阵的体积，不过带有方向。</p></li><li><p>det A transpose = det A</p></li></ol><h1 id="Big-formula"><a href="#Big-formula" class="headerlink" title="Big formula"></a>Big formula</h1><p><img src="bigformular.png" alt="bigformular"></p><h1 id="cofactor"><a href="#cofactor" class="headerlink" title="cofactor"></a>cofactor</h1><p><img src="cofactor-1.png" alt="cofactor"><br><img src="cofactor-2.png" alt="cofactor"></p><h1 id="原矩阵与逆矩阵"><a href="#原矩阵与逆矩阵" class="headerlink" title="原矩阵与逆矩阵"></a>原矩阵与逆矩阵</h1><h2 id="formular-for-A-1"><a href="#formular-for-A-1" class="headerlink" title="formular for A^(-1)"></a>formular for A^(-1)</h2><p><img src="A-1.png" alt="逆矩阵"></p><h2 id="Cramer’s-Rule"><a href="#Cramer’s-Rule" class="headerlink" title="Cramer’s Rule"></a>Cramer’s Rule</h2><p><img src="cramer_rule_1.png" alt="cramer_rule"><br><img src="cramer_rule_2.png" alt="cramer_rule"><br><img src="cramer_rule_3.png" alt="cramer_rule"></p><p>这个Cramer法则好看不中用</p><h1 id="Volumn"><a href="#Volumn" class="headerlink" title="Volumn"></a>Volumn</h1><p>这个很有趣，是对行列式终极含义</p><p>|det A| is equal to the volumn of matrix</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周完成了Gilbert Strang线性代数的中行列式的学习，课程中的Lesson18~Lesson21.&lt;/p&gt;
&lt;p&gt;笔记都是用课程中手记的，这里只做一个简单的记录。&lt;/p&gt;
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Matrix" scheme="http://yoursite.com/tags/Matrix/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>最大子数组问题</title>
    <link href="http://yoursite.com/2019/03/31/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/03/31/最大子数组问题/</id>
    <published>2019-03-31T09:41:06.000Z</published>
    <updated>2019-04-01T00:58:16.181Z</updated>
    
    <content type="html"><![CDATA[<p>本题是Leecode的53. Maximum Subarray</p><a id="more"></a><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p><p>Example:</p><p>Input: [-2,1,-3,4,-1,2,1,-5,4],<br>Output: 6<br>Explanation: [4,-1,2,1] has the largest sum = 6.<br>Follow up:</p><p>If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>与上周的主题一样，本周训练的主题还是分治，题目是最大子数组，属于分治里的例题了。</p><p>这个题目思路用暴力来求解，可以设置一个窗口，长度是length(from 1 to length-1)，然后不断的在数组中滑动，比较得到最大的数组,这个的复杂度在o(n^2).</p><p>分治的思路大概是找递归的过程，或者找f(n)与f(n-1)之间关系的过程。子问题的划分其实也与数组的分裂相关，最快的分法就是每次都均分。这个问题就可以这样来解决了，最长子数组：</p><ul><li>完全位于子数组nums[low, middle]</li><li>完全位于子数组nums[middle+1, high]</li><li>子数组跨越中点，这种情况下，需要去求middle~low的最大值以及middle~high的最大值，然后求和即可。</li></ul><p>对于完全位于的，可以继续去递归。</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> constMinInt = <span class="number">-2147483648</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = findMaxSubArray(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (low == high) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[low];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> middle = (low+high)/<span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> leftMax = findMaxSubArray(nums, low, middle);</span><br><span class="line">            <span class="keyword">int</span> rightMax = findMaxSubArray(nums, middle+<span class="number">1</span>, high);</span><br><span class="line">            <span class="keyword">int</span> crossMax = findMaxCrossSubArray(nums, low, high, middle);</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span>  getMax(leftMax, rightMax, crossMax);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxCrossSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> middle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leftMax = constMinInt;</span><br><span class="line">        <span class="keyword">int</span> rightMax = constMinInt;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// left</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=middle; i&gt;=low; --i) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; leftMax) &#123;</span><br><span class="line">                leftMax = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// right</span></span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=middle+<span class="number">1</span>; i&lt;=high; ++i) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; rightMax) &#123;</span><br><span class="line">                rightMax = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> leftMax+rightMax;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span> leftMax, <span class="keyword">int</span> rightMax, <span class="keyword">int</span> crossMax)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (leftMax&gt;=rightMax &amp;&amp; leftMax&gt;=crossMax) &#123;</span><br><span class="line">            <span class="keyword">return</span> leftMax;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (rightMax&gt;=leftMax &amp;&amp; rightMax&gt;=crossMax) &#123;</span><br><span class="line">            <span class="keyword">return</span> rightMax;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> crossMax;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个算法在写的过程中，在getMax时候出现了一点问题，即&gt;=写成了&gt;，造成在获取最大值的时候出现了一点问题，提交后问题解决。</p><p>T(n) = 2T(n/2) + O(n)，根据主定理，复杂度是nlgn.</p><p>还有一个要思考的是对最大子数组的思考。将数组每个元素位置看成横坐标，值看成纵坐标，求和的过程其实是积分的过程，这样，最大子数组，其实是在求这个数组表达的函数的定积分。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本题是Leecode的53. Maximum Subarray&lt;/p&gt;
    
    </summary>
    
      <category term="练习" scheme="http://yoursite.com/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>ARTS第一周</title>
    <link href="http://yoursite.com/2019/03/24/%E7%AC%AC%E4%B8%80%E5%91%A8ARTS/"/>
    <id>http://yoursite.com/2019/03/24/第一周ARTS/</id>
    <published>2019-03-24T15:22:45.000Z</published>
    <updated>2019-04-01T01:17:34.848Z</updated>
    
    <content type="html"><![CDATA[<p>第一周打卡<br><a id="more"></a></p><h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><p><a href="https://sunyanfeng.cn/2019/03/24/%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/#more" target="_blank" rel="noopener">求两个排序数组的中位数</a></p><h1 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h1><p>Socket.io:优点、缺点、丑陋<br>原文地址：(Socket.io — The Good, the Bad, and the Ugly)[<a href="https://dzone.com/articles/socketio-the-good-the-bad-and-the-ugly]" target="_blank" rel="noopener">https://dzone.com/articles/socketio-the-good-the-bad-and-the-ugly]</a></p><p>本周在做一个消息服务过程中，使用了Socket.io这个模块，并对这个模块进行了简单的分析，这里不再记录，在搜索过程中，发现了这篇由James Roper发表DZone上的文章，觉得比较适合做Review。</p><p>这里抛开它对socket.io不谈，我觉得他说的价值观还不错：</p><ol><li>他强烈的支持反应式系统，这种系统相应，弹性，可扩展，并且是消息驱动的</li><li>他支持高生产率的软件开发的工具、lib以及框架</li><li>他认为好的定义标准以及接口能最大化两个解耦实现之间的兼容性</li></ol><p>这里他说的这几个特点，与陈皓老师在技术领导力以及分布式系统架构的一些观念类似，比如提高效率的事，分布式架构之间解耦的过程等</p><h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><p><a href="https://sunyanfeng.cn/2019/03/24/Matrix-Projection/#more" target="_blank" rel="noopener">Matrix Projection</a></p><h1 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h1><p><a href="https://sunyanfeng.cn/2019/03/21/%E7%94%B1%E4%B8%80%E4%B8%AASelect%E5%BC%95%E8%B5%B7%E7%9A%84%E6%8E%A2%E7%B4%A2/#more" target="_blank" rel="noopener">由一个Select引起的探索</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一周打卡&lt;br&gt;
    
    </summary>
    
      <category term="ARMS" scheme="http://yoursite.com/categories/ARMS/"/>
    
    
  </entry>
  
  <entry>
    <title>Matrix Projection</title>
    <link href="http://yoursite.com/2019/03/24/Matrix-Projection/"/>
    <id>http://yoursite.com/2019/03/24/Matrix-Projection/</id>
    <published>2019-03-24T15:08:56.000Z</published>
    <updated>2019-04-01T01:21:18.523Z</updated>
    
    <content type="html"><![CDATA[<p>本周完成了Gilbert Strang线性代数的正交、投影、正交矩阵的学习，课程中的Lesson14～Lesson17</p><p>笔记都是用课程中手记的，这里只做一个简单的记录。</p><a id="more"></a><h1 id="Orthogonal-正交"><a href="#Orthogonal-正交" class="headerlink" title="Orthogonal 正交"></a>Orthogonal 正交</h1><ol><li>两个向量正交的定义</li><li>子空间正交： row space is orthogonal to null space;<pre><code>column space is orthogonal to null space of A tranpose</code></pre></li><li><p>正交的意义：the best solution Ax=b when there is no solution</p><pre><code>which means seperate the nosize from the infomation.A^T&lt;/sup&gt;AX = A&lt;sup&gt;T&lt;/sup&gt;b</code></pre></li></ol><h1 id="Projection投影"><a href="#Projection投影" class="headerlink" title="Projection投影"></a>Projection投影</h1><ol><li>向量投影</li><li>矩阵投影</li><li>投影矩阵</li><li>最小二乘法</li></ol><p>这一部分已经充分说明了一个基本认知：矩阵就是向量。主要研究的是投影矩阵，因为任何向量与它想乘都会映射到相应的空间中。这里对最小二乘法的矩阵解释也很令人印象深刻。</p><h1 id="Orthonomal-Matrix-正交矩阵"><a href="#Orthonomal-Matrix-正交矩阵" class="headerlink" title="Orthonomal Matrix 正交矩阵"></a>Orthonomal Matrix 正交矩阵</h1><p>正交矩阵就是一个向量空间两两垂直的向量组成的一组基。<br>它的好处是简化了投影运算效率</p><ol><li>正交矩阵的定义与意义</li><li>求解正交矩阵的方法：Gramh-schmit方法，（其实就是不断减p然后归一化的过程）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周完成了Gilbert Strang线性代数的正交、投影、正交矩阵的学习，课程中的Lesson14～Lesson17&lt;/p&gt;
&lt;p&gt;笔记都是用课程中手记的，这里只做一个简单的记录。&lt;/p&gt;
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Matrix" scheme="http://yoursite.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>求两个排序数组的中位数</title>
    <link href="http://yoursite.com/2019/03/24/%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://yoursite.com/2019/03/24/求两个排序数组的中位数/</id>
    <published>2019-03-24T00:06:42.000Z</published>
    <updated>2019-04-01T00:58:16.177Z</updated>
    
    <content type="html"><![CDATA[<p>这道题，我并没有完全解答，但从中锻炼了对分治法的理解。</p><a id="more"></a><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p><p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p><p>You may assume nums1 and nums2 cannot be both empty.</p><p>Example 1:</p><p>nums1 = [1, 3]<br>nums2 = [2]</p><p>The median is 2.0<br>Example 2:</p><p>nums1 = [1, 2]<br>nums2 = [3, 4]</p><p>The median is (2 + 3)/2 = 2.5</p><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = nums1.size() + nums2.size();</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// this should throw an error</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums1.size()!=<span class="number">0</span> &amp;&amp; nums2.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>; c&lt;count;++c)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i] &lt; nums2[j])&#123;</span><br><span class="line">                    nums.push_back(nums1[i]);</span><br><span class="line">                    i++;</span><br><span class="line">                    <span class="keyword">if</span>(i==nums1.size())&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    nums.push_back(nums2[j]);</span><br><span class="line">                    j++;</span><br><span class="line">                    <span class="keyword">if</span>(j==nums2.size())&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(i==nums1.size() &amp;&amp; j&lt;nums2.size())&#123;</span><br><span class="line">                <span class="keyword">while</span>(j!=nums2.size())&#123;</span><br><span class="line">                    nums.push_back(nums2[j++]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(j==nums2.size() &amp;&amp; i&lt;nums1.size())&#123;</span><br><span class="line">                <span class="keyword">while</span>(i!=nums1.size())&#123;</span><br><span class="line">                    nums.push_back(nums1[i++]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums1.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;nums2.size(); ++k)&#123;</span><br><span class="line">                nums.push_back(nums2[k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums2.size() == <span class="number">0</span>)&#123;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;nums1.size(); ++k)&#123;</span><br><span class="line">                nums.push_back(nums1[k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> ret = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = count/<span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(count%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            ret = ((<span class="keyword">double</span>)(nums[m<span class="number">-1</span>]+nums[m]))/<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ret = nums[m];</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上答案是一种m+n的算法，虽然通过了，但并不符合复杂度的要求。</p><p>于是进行了第二次的思考，这里选的题目本身，是分治标签下的，上述算法是归并排序中一步的做法，然后就思考怎样用分治的想法来实现。<br>另一种思路是，分治应该是在什么维度上进行分治，本身应该类似于数学归纳法的方式。在维度上既然是数组，就采用数组元素的方式来分。首先思考的是如果两个表，慢慢增加元素会是什么样的，1-0,1-1,2-1,3-2，2-2，这样发现一种可以递归的方式，即每次拿一个数组的最大值与另一个数组的最大值对比去掉最大的，最小值与最小值对比去掉最小的，这样，如果总和为奇数剩余1个，为最后结果，为偶数剩余2个，其平均值为最后结果。<br>回头意向这个复杂度也不是ln(m+n)，而是(m+n)/2，比上一种算法略有提升。</p><p>那最后就看一下提供的解法吧<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = A.length;</span><br><span class="line">        <span class="keyword">int</span> n = B.length;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) &#123; <span class="comment">// to ensure m&lt;=n</span></span><br><span class="line">            <span class="keyword">int</span>[] temp = A; A = B; B = temp;</span><br><span class="line">            <span class="keyword">int</span> tmp = m; m = n; n = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> iMin = <span class="number">0</span>, iMax = m, halfLen = (m + n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (iMin &lt;= iMax) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = (iMin + iMax) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> j = halfLen - i;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; iMax &amp;&amp; B[j-<span class="number">1</span>] &gt; A[i])&#123;</span><br><span class="line">                iMin = i + <span class="number">1</span>; <span class="comment">// i is too small</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; iMin &amp;&amp; A[i-<span class="number">1</span>] &gt; B[j]) &#123;</span><br><span class="line">                iMax = i - <span class="number">1</span>; <span class="comment">// i is too big</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// i is perfect</span></span><br><span class="line">                <span class="keyword">int</span> maxLeft = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123; maxLeft = B[j-<span class="number">1</span>]; &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123; maxLeft = A[i-<span class="number">1</span>]; &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; maxLeft = Math.max(A[i-<span class="number">1</span>], B[j-<span class="number">1</span>]); &#125;</span><br><span class="line">                <span class="keyword">if</span> ( (m + n) % <span class="number">2</span> == <span class="number">1</span> ) &#123; <span class="keyword">return</span> maxLeft; &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> minRight = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (i == m) &#123; minRight = B[j]; &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j == n) &#123; minRight = A[i]; &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; minRight = Math.min(B[j], A[i]); &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> (maxLeft + minRight) / <span class="number">2.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题，我并没有完全解答，但从中锻炼了对分治法的理解。&lt;/p&gt;
    
    </summary>
    
      <category term="练习" scheme="http://yoursite.com/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>由一个Select引起的探索</title>
    <link href="http://yoursite.com/2019/03/21/%E7%94%B1%E4%B8%80%E4%B8%AASelect%E5%BC%95%E8%B5%B7%E7%9A%84%E6%8E%A2%E7%B4%A2/"/>
    <id>http://yoursite.com/2019/03/21/由一个Select引起的探索/</id>
    <published>2019-03-21T09:48:41.000Z</published>
    <updated>2019-04-01T00:58:16.177Z</updated>
    
    <content type="html"><![CDATA[<p>好久没有写问题处理类的博客了，正好今天解决了一个小问题，而且时间还有些，就写一下吧，作为本周的一share。</p><a id="more"></a><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>背景是这样的，今天帮人写了一个查询语句，用于查询一个1（表A）对多（表B）关系中，表B的一个字段的累加和。由于表A已经连接了多张表，而且我不太原因去动那段代码，就想着用表A的id从表B中去获取，而且她已经写好了一个接口来获取列表，我索性就直接在内存里计算了。代码就不贴了，这段代码效率比较低。<br>    问题出现了，我拿出来的数据莫名变成了字符串，数据相加以后成了字符串相加。”50”+”100” = “50100”.</p><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>出现问题咱就处理吧，首先去看一下表结构:<br><img src="表结构.png" alt="表结构"><br>字段是amount 类型是numeric,是数字没问题。</p><p>然后就怀疑是不是存储的时候是字符串，就去调试了一下，发现并没有问题。</p><p>那现在就是存的时候是数字，数据库里也是数字，而读取出来的是字符串。那问题肯定就是读取的时候出现问题了，读取时候调用的是node.js中’pg’这个模块，那就移步到这里去看一下。</p><p>pg模块中的目录如下：<br><img src="pg目录结构.png" alt="pg目录结构"><br>既然怀疑是读取时候出现了问题，从这个结构中，就直接去看结果的处理部分：result.js。在这其中，发现对每个Field都有一个对应的parser，那问题自然就归结到这个Parser上了。</p><p>这个Parser是从’pg-types’中引用而来，那就从pg-types中去看一下<br>在这里定义了3个Parse，arrayParser、binaryParsers、textParsers，在index.js中，通过<code>setTypeParser</code>来设置相应类型的parese，通过<code>getTypeParser</code>来获取。在这里并没有看出问题，然后看了一下这个库的test，这里看到</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bignum = <span class="string">'31415926535897932384626433832795028841971693993751058.16180339887498948482045868343656381177203091798057628'</span></span><br><span class="line">exports.numeric = &#123;</span><br><span class="line">format: <span class="string">'text'</span>,</span><br><span class="line">id: <span class="number">1700</span>,</span><br><span class="line">tests: [</span><br><span class="line">    [bignum, bignum]</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它其实是将numeric放到text这种format下，解析出来的自然就是text了。</p><p>既然是有意将numeric当成text来处理，那就numeric这种类型就要注意一下，在pgsql的官方文档中对其论述为：</p><p>numeric类型可以存储非常大的数字并且准确地进行计算。 我们特别建议将它用于货币金额和其它要求精确计算的场合。不过， numeric类型上的算术运算比整数类型或者我们下一节描述的浮点数类型要慢很多。</p><p> 一个numeric类型的标度 (scale)是小数部分的位数，精度(precision) 是全部数据位的数目，也就是小数点两边的位数总和。 因此数字 23.5141 的精度为 6 而标度为 4 。你可以认为整数的标度为零。</p><p>这样可以思考numeric本身用来处理很大的浮点数，这种数字转换成text也能理解了</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>由于我们的数字比较小，也就修改了一下表结构，将这numeric变成了real，这样问题就解决了。当然也可以通过ParseFloat来从表层处理一下。</p><h1 id="探索"><a href="#探索" class="headerlink" title="探索"></a>探索</h1><p>下边会探索一下pg的结构。这里时间限制，简单写一下依赖关系：<br>index.js中做聚合，聚合了client、Query、Connection、Pool等模块，<br>Client中依赖Connection,通过调用Connection来完成其业务<br>Connect中，依赖net.Socket来完成对postgresql的链接，以及在链接之上的接口；<br>在Client中还还依赖Query，并有一个queryQueue，来异步处理各个请求。<br>在Query中，依赖一个Result模块，来对返回的数据进行解析，其调用了以上的parse模块。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久没有写问题处理类的博客了，正好今天解决了一个小问题，而且时间还有些，就写一下吧，作为本周的一share。&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="node.js" scheme="http://yoursite.com/tags/node-js/"/>
    
      <category term="pgsql" scheme="http://yoursite.com/tags/pgsql/"/>
    
  </entry>
  
  <entry>
    <title>关于技术领导力的思考</title>
    <link href="http://yoursite.com/2019/03/19/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF%E9%A2%86%E5%AF%BC%E5%8A%9B/"/>
    <id>http://yoursite.com/2019/03/19/关于技术领导力/</id>
    <published>2019-03-19T06:14:00.000Z</published>
    <updated>2019-04-01T00:58:16.177Z</updated>
    
    <content type="html"><![CDATA[<p> 本文从极客时间《左耳听风》触发而来。</p><a id="more"></a><h1 id="何为技术领导力"><a href="#何为技术领导力" class="headerlink" title="何为技术领导力"></a>何为技术领导力</h1><p>陈老师的技术领导力定义：</p><ul><li>尊重技术，追求核心基础技术</li><li>追逐自动化的高效率的工具和技术，同时避免无效率的组织架构和管理</li><li>解放生产力，追逐人效的提高</li><li>开发抽象和高质量的可以重用的技术组件</li><li>坚持高于社会主流的技术标准和要求</li></ul><p>这些语言对我来说有些离散，我需要重新逻辑化一下</p><ul><li>追求核心基础技术</li><li>由核心基础技术派生的高质量、可重用的技术组件</li><li>由技术、技术组件而形成的工具，提高效率与人效</li><li>在这些工具之上，进行合理的组织架构与管理</li></ul><h1 id="拥有技术领导力需要的特质"><a href="#拥有技术领导力需要的特质" class="headerlink" title="拥有技术领导力需要的特质"></a>拥有技术领导力需要的特质</h1><p>陈老师的技术领导力特质</p><ul><li>能够发现问题</li><li>能够提供解决问题的思路和方案，并能比较这些方案的优缺点</li><li>能够作出正确的技术决定</li><li>能够用更优雅，更简单，更容易的方式来解决问题</li><li>能够提高代码或软件的扩展性、可重用性和可维护性</li><li>能够用正确的方式管理团队：正确的人干正确的事，提高团队的人效</li><li>创新能力</li></ul><p>同样，也需要逻辑化一下</p><ul><li>发现问题能力</li><li>寻找最佳解决方案的能力</li><li>优雅、高效实现方案的能力</li><li>发现、培养他人拥有以上能力的能力</li></ul><h1 id="如何才能拥有技术领导力"><a href="#如何才能拥有技术领导力" class="headerlink" title="如何才能拥有技术领导力"></a>如何才能拥有技术领导力</h1><p>陈老师在文章中举出了4点，这里只节选2点即可，其余两点价值观更重一些</p><ul><li><p>吃透基础技术</p><ul><li><p>编程部分</p><p>C语言，推荐《C程序设计语言（第二版）》</p><p>编程范式，面向对象变成，泛型编程，函数式编程</p><p>算法和数据结构</p></li><li><p>系统部分</p><p>计算机系统原理。推荐《深入理解计算机系统》</p><p>操作系统原理和基础。cpu，内存，硬盘，中断。推荐《UNIX环境高级编程》、《UNIX网络编程》《Windows核心编程》，可以让你更能从本质理解各种语言或者技术的底层原理（这一步似乎少了编译原理）。</p><p>网络基础。推荐《TCP/IP详解》</p><p>数据库原理。SQL与NoSQL，用于数据性能调优</p><p>分布式技术架构。包括负载均衡、DNS解析、多子域名、无状态应用层、缓存层、数据库分片、容错和恢复机制、Paxos、MR操作、分布式SQL数据库的一致性等。</p></li></ul><p>ps：这一部分比较硬核，也比较干，对于技术联系并没有叙述，我这里也不去说了。</p></li><li><p>提高学习能力</p><ul><li>学习的信息源，Quora、Stack Overflow,书，API、论文、博客</li><li>与高手交流</li></ul></li></ul><h1 id="我的思考"><a href="#我的思考" class="headerlink" title="我的思考"></a>我的思考</h1><h2 id="关于技术"><a href="#关于技术" class="headerlink" title="关于技术"></a>关于技术</h2><p>技术理念</p><ul><li>技术概念中包含实践性;切忌光学不练</li><li>技术概念中包含着理论性;所有光练不学，也是不对的</li><li>可以想像这个模型，技术底层是理论，技术上层是产品，底层的变动要比上层会慢，但来的更有变革性，产品。产品因人而异，因人而变，变化也就很多啦，但不论怎么变，也受技术的制约。</li><li>技术与艺术创作可以类比，若只固守，或者人云亦云，成就不了伟大，只有那些创新，那些拓展技术边界的创新，才能称得上伟大。（技术想象力）</li></ul><p>技术问题</p><ul><li>每一种技术，都是面向问题的，这个问题是什么？</li><li>对于这个问题，如果让你来实现，如何来做？</li><li>技术是如何解决面向的问题？</li><li><p>对比自己的做法与技术的做法，既可以丰富思维，也可以找到技术的不足</p></li><li><p>技术既然是发展的，那承前启后了哪些技术？（技术发展观）</p></li><li>这些技术面向的问题又有怎样的变化？</li><li>由此也就培养了技术鉴赏能力。（技术鉴赏力）</li></ul><h1 id="关于领导力"><a href="#关于领导力" class="headerlink" title="关于领导力"></a>关于领导力</h1><ul><li>领导力这个概念中包含着团队，所以是关于人的</li><li>领导，指引道路；领导力也就是指引的能力；技术领导力也就是在技术方面指引方向的能力啦</li><li>领导力与管理力有区别，有联系</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 本文从极客时间《左耳听风》触发而来。&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>中序遍历二叉树</title>
    <link href="http://yoursite.com/2019/03/16/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2019/03/16/中序遍历二叉树/</id>
    <published>2019-03-16T14:08:33.000Z</published>
    <updated>2019-04-01T00:58:16.177Z</updated>
    
    <content type="html"><![CDATA[<p> 本文是第一周ARMS挑战的Algorithm部分，也是为了熟悉一下Leetcode，选择了一个中序遍历二叉树。其中递归方式很快就完成、通过，但迭代方式花了一点时间，也终于通过啦，主要对迭代方式进行分析。</p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>Given a binary tree, return the inorder traversal of its nodes’ values.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [1,3,2]</span><br></pre></td></tr></table></figure></p><p>Follow up: Recursive solution is trivial, could you do it iteratively?</p><h1 id="递归方式"><a href="#递归方式" class="headerlink" title="递归方式"></a>递归方式</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vecVal;</span><br><span class="line">        recursiveTraversalNode(root, vecVal);        </span><br><span class="line">        <span class="keyword">return</span> vecVal;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recursiveTraversalNode</span><span class="params">(TreeNode * root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vecVal)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            recursiveTraversalNode(root-&gt;left, vecVal);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vecVal.push_back(root-&gt;val);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            recursiveTraversalNode(root-&gt;right, vecVal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="迭代方式"><a href="#迭代方式" class="headerlink" title="迭代方式"></a>迭代方式</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vecValue;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode *&gt; stackTreeNode;</span><br><span class="line">        </span><br><span class="line">        TreeNode *p = root;</span><br><span class="line">        <span class="keyword">while</span>(!stackTreeNode.empty() || p!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                stackTreeNode.push(p);</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                p = stackTreeNode.top();</span><br><span class="line">                stackTreeNode.pop();</span><br><span class="line">                </span><br><span class="line">                vecValue.push_back(p-&gt;val);</span><br><span class="line">                p = p-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> vecValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在迭代方式中，二叉树的指针一定会先遍历最深的left，然后返回遍历父节点，再遍历右节点，结构体中并没有指向父元素的指针，也就是要缓存一下父元素的指针，递归一下，所有的左侧线路上所有的父节点都需要缓存，而且每次完成指向父节点时，都是取最近的一个指针，那这种缓存的结构很自然就想到了stack。这步完成的比较顺利，只是没写C++了一开始想用vector来当stack用，但vector在获取最后一个节点时，处理的不太优雅，其实stack相对会好点，其实感觉pop直接返回数据，更方便一些。</p><p>出现了2个问题：一是入栈时候并没有入到叶子节点，造成出栈时处理的问题；二是在循环的判断上，对循环的结束只思考成stack的empty()。第二遍写的时候，很自然就解决了第一个问题，接着解决了第二个问题，也就顺利通过啦。</p><p>错误代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode&gt; stackNode;</span><br><span class="line">        TreeNode *p = root;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(p == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                p = stackNode.top();</span><br><span class="line">                stackNode.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;left != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                stackNode.push(p);</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                vecVal.push_back(p-&gt;val);</span><br><span class="line"></span><br><span class="line">                p = stackNode.top();</span><br><span class="line">                stackNode.pop();</span><br><span class="line">                </span><br><span class="line">                vecVal.push_back(p-&gt;val);</span><br><span class="line">                </span><br><span class="line">                p = p-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">while</span>(!stackNode.empty());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h1><p>树的遍历有3种，preorder、inorder、postorder,题目给的是inorder方式，后边需要对其余两种进行练习。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 本文是第一周ARMS挑战的Algorithm部分，也是为了熟悉一下Leetcode，选择了一个中序遍历二叉树。其中递归方式很快就完成、通过，但迭代方式花了一点时间，也终于通过啦，主要对迭代方式进行分析。&lt;/p&gt;
    
    </summary>
    
      <category term="练习" scheme="http://yoursite.com/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>旅途</title>
    <link href="http://yoursite.com/2019/03/16/%E6%97%85%E9%80%94/"/>
    <id>http://yoursite.com/2019/03/16/旅途/</id>
    <published>2019-03-16T02:27:59.000Z</published>
    <updated>2019-04-01T00:58:16.177Z</updated>
    
    <content type="html"><![CDATA[<p>  这周机缘巧合之下，参加了陈皓老师的ARTS的挑战，作为一段路途的起点，应该立个flag来表达一下决心，同时需要对这段旅途做一个规划，并论述一下旅途中潜在的问题。</p><a id="more"></a><h1 id="机缘"><a href="#机缘" class="headerlink" title="机缘"></a>机缘</h1><p>与陈老师的机缘应该从coolshell中的那篇《程序员练级攻略》开始，很多技术书籍的选择也是听从了这篇博文中的建议，这是其一；</p><p>回首毕业到现在，自己在技术的广度方面已经有了很多的积累，由C++，到了Java Web栈，到了Hadoop栈，到了我最爱的数据分析栈与机器学习栈，到近来node微服务架构的学习。但在广度之外，深感自己在技术深度方面的不足，于是想在深度方面下一番功夫，这是其二；</p><p>年初开始极客时间的体验，一个月的vip每日一课，可惜更新不足，很多课程看到1/3也就可以了，后有订阅了一个微服务架构栏目，认可了栏目这种方式。刚看完微服务架构，碰到陈老师的ARTS挑战三期，这是其三。</p><h1 id="由ARTS到ARMS"><a href="#由ARTS到ARMS" class="headerlink" title="由ARTS到ARMS"></a>由ARTS到ARMS</h1><p>ARTS挑战是 Algorithm、Review、Tip、Share，具体要求：<br>（1）每周至少做一个 leetcode 的算法题<br>（2）阅读并点评至少一篇英文技术文章<br>（3）学习至少一个技术技巧<br>（4）分享一篇有观点和思考的技术文章</p><p>ARTS挑战是一个习惯的养成，于我而言，已经有了的自己的学习的习惯或者生态，那就借鉴陈老师的ARTS概念，来夯实自己的学习生态。在这4条挑战中</p><p>Algorithm，虽然自己看过很多算法书、视频，但在训练上确实不够，这也是陈老师所说的没有训练看再多也没用的典型代表，而leetcode是一种方式，并没有规定路线，那我就选择按导论中的顺序挑选题目来进行训练，这样会更全面一些。</p><p>Review，应该是评论的意思，在英文方面，我已经迈过了这道坎，所以并不需要刻意去，以后的google过程中，我会更多使用英语来搜索，至于评论或者叫读后的思考，这个就从陈老师的栏目开始吧，结果刚结束的微服务架构，对提到的内容、技术做一个深入的探索。</p><p>Tip，我觉得指的是技术工具，分析、检测工具的使用，这个于当下，可以做一些变通，那就依据我的习惯，改成Math吧，课程依据原来的计划进行。</p><p>Share，我就用我的博客来做share，内容还是保持现有发布的技术性文章，主要是想将Review到的内容share在这里。数学方面的整理，md写数学公式以及矩阵，较为麻烦，写作成本有点高，可能会写一些的纲领性概念。对于我的哲学思考，就先不对外发布了。纠结了一下要不要开启评论，想想先作罢了,这源于我对信息爆炸时代的看法，让我去寻找，不要推送给我。</p><p>那这样就改成ARMS，跟学生时代用的芯片架构很像，挺美。</p><h1 id="矛盾"><a href="#矛盾" class="headerlink" title="矛盾"></a>矛盾</h1><p>在这里也要写一下现实的冲突与内心的冲突。</p><p>本阶段产品的开发效果来看，业务逻辑需要进一步的梳理与优化，产品如此复杂难以用起来，需要进一步简化;开发架构上，由总监开发的node后端框架已经影响到了后端的效率，并造成了代码可维护性的问题;团队成员水平有限，很多时候顶不上，一片败象之下我却想努力一把，不仅源于我对徐老师（老板）的认可，我不想善良、正直的人输的很惨，也源于我对旅途的看法，<strong>每一段旅途，都是生命最美好的馈赠（the best gift of life）</strong>，每一份工作都是一段旅途，如果不去努力，如何对得起这gift。</p><p>接下来的时间，势必耗费极大的精力，这又与ARTS产生了一些冲突，我并不处于当年陈老师简单完成任务而可以追求技术精深的处境上。好在是一周一个循环，需要我好好安排一下时间。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  这周机缘巧合之下，参加了陈皓老师的ARTS的挑战，作为一段路途的起点，应该立个flag来表达一下决心，同时需要对这段旅途做一个规划，并论述一下旅途中潜在的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="ARMS" scheme="http://yoursite.com/categories/ARMS/"/>
    
    
  </entry>
  
  <entry>
    <title>微服务架构</title>
    <link href="http://yoursite.com/2019/03/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    <id>http://yoursite.com/2019/03/12/微服务架构/</id>
    <published>2019-03-11T16:00:00.000Z</published>
    <updated>2019-03-16T04:27:23.300Z</updated>
    
    <content type="html"><![CDATA[<p>本文整理的极客时间中，杨波讲的微服务架构<br><a id="more"></a><br>本来打算把杨老师的图重新画完，一来做一个复习，二来也避免一些问题，但由于时间有限，就一起跟旅途发出来了，若有不妥，请联系我，联系方式见博客的关于。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><img src="overview.png" alt="概述"><br>整个分层体系如上图所示，底层是基础设施，主要是硬件iaas层。往上是平台服务paas层，包括发布系统，集群资源调度，镜像治理，资源治理等，在这层我们的镜像使用阿里的镜像仓库，集群资源调度使用的k8s。再网上是支撑服务，这一部分是课程的重点，包括服务发现，集中配置，容错限流，日志聚合，监控告警，这一层后变各节进行分述。再上一层是业务服务，在业务服务里，这里也分成了2层，聚合服务与基础服务，聚合服务对不同的接入进行相应，并调用基础服务，对web端、手机端、第三方接入提供不同的聚合服务。再一层是网关，网关就像是aop，对接入进行控制、检查等，对网关也会进行分述。</p><p>提出一个重要的思想：系统架构与组织结构相一致<br><img src="微服务团队组织.png" alt="微服务团队组织"></p><p>提出了中台战略</p><p><img src="阿里大中台战略.png" alt="阿里大中台战略"></p><h1 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h1><p><img src="网关整体.jpg" alt="网关整体"><br><img src="zuul网关1.jpg" alt="zuul网关"><br><img src="zuul网关2.jpg" alt="zuul网关"></p><h1 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h1><p><img src="服务发现.jpg" alt="服务发现"></p><h1 id="通讯-jpg"><a href="#通讯-jpg" class="headerlink" title="通讯.jpg"></a>通讯.jpg</h1><p><img src="通讯.jpg" alt="通讯"></p><h1 id="集中配置"><a href="#集中配置" class="headerlink" title="集中配置"></a>集中配置</h1><p><img src="配置中心1.jpg" alt="配置中心"><br><img src="配置中心2.jpg" alt="配置中心"></p><h1 id="熔断限流"><a href="#熔断限流" class="headerlink" title="熔断限流"></a>熔断限流</h1><p><img src="熔断限流1.jpg" alt="熔断限流1"><br><img src="熔断限流2.jpg" alt="熔断限流"></p><h1 id="日志聚合"><a href="#日志聚合" class="headerlink" title="日志聚合"></a>日志聚合</h1><p><img src="日志聚合1.jpg" alt="日志聚合"><br><img src="日志聚合2.jpg" alt="日志聚合"></p><h1 id="监控告警"><a href="#监控告警" class="headerlink" title="监控告警"></a>监控告警</h1><p><img src="监控告警1.jpg" alt="监控告警1"><br><img src="监控告警2.jpg" alt="监控告警2"></p><h1 id="资源调度"><a href="#资源调度" class="headerlink" title="资源调度"></a>资源调度</h1><p><img src="资源调度.jpg" alt="资源调度"></p><h1 id="镜像中心"><a href="#镜像中心" class="headerlink" title="镜像中心"></a>镜像中心</h1><p><img src="镜像中心.jpg" alt="镜像中心"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文整理的极客时间中，杨波讲的微服务架构&lt;br&gt;
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="架构" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="微服务" scheme="http://yoursite.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>《简约至上》</title>
    <link href="http://yoursite.com/2019/03/03/%E7%AE%80%E7%BA%A6%E8%87%B3%E4%B8%8A%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/03/03/简约至上总结/</id>
    <published>2019-03-03T11:36:00.000Z</published>
    <updated>2019-03-11T03:08:53.609Z</updated>
    
    <content type="html"><![CDATA[<p>书中分成8章来讲述，其中第一章介绍什么是简单，为什么要简单，第二章了产品设计的步骤，由人物、场景而到情节来设计产品的逻辑，第三章总的来介绍了4种策略：删除、组织、隐藏、转移，后四章对4种策略的分述，最后一章所示算是结语。<br><a id="more"></a></p><p>前几天写了一个读书方法论，是从读这本书体会到的一个认知方法，那现在，将通过这个方法中想到的3个层次来总结一下这本书。</p><h1 id="具体设计"><a href="#具体设计" class="headerlink" title="具体设计"></a>具体设计</h1><ul><li><p>错误提示的挫败感:对时间选择的设计<br><img src="错误提示.png" alt="错误提示的挫败感"></p></li><li><p>认知分层:地铁线路的颜色设计<br><img src="地铁.png" alt="认知分层"></p></li><li><p>突出重点：对万豪酒店页面的重新设计<br><img src="万豪网站.png" alt="突出重点"></p></li><li><p>网格优化<br><img src="网格.png" alt="网格优化"></p></li><li><p>渐进展示：保存<br><img src="保存.jpeg" alt="渐进展示"></p></li><li><p>期望路径与实际路径<br><img src="期望路径.png" alt="期望路径"> </p></li></ul><h1 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h1><ul><li><p>产品使用环境分析：</p><p>  办公室：容易受打扰</p><p>  家中：电视剧空隙</p><p>  户外：繁忙</p></li><li><p>用户分类</p><p>  专家用户：发烧友、高级用户</p><p>  随意用户：用过类似产品，对新功能要求简单，中级用户</p><p>  主流用户：有需要才会用的，问题导向型用户</p></li><li><p>产品与故事</p><p>  产品的概念包括了使用者、使用环境，以及在什么情节中使用，这就构成了一个故事情节。</p><p>  故事情节需要从观察使用者出发，然后从众多场景中，抽象出故事。故事中包含着需求与产品的特点</p><p>  故事的精进还需要与不同的人去讲述，看其对故事（产品）的反馈，反馈的过程可以借助于原型与竞品。</p></li><li><p>墨水率<br> 并通过提出了一个有趣的概率：数据墨水率，墨水（像素）不应该浪费在那些不是内容或者重要的内容上。</p></li></ul><h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><ul><li><p>整体原则</p><ul><li><p>办公室里假如用户来讨论需求是无效的</p></li><li><p>最好的观察用户的途径是从竞品与原型来观察用户的需要</p></li><li><p>用户并不知道自己提出需求所带来的负面作用</p></li></ul></li><li><p>删除原则</p><ul><li><p>紧跟核心，去掉不必要的功能，去掉不完善的功能，强化核心功能</p></li><li><p>突出重点可以用颜色与大小来提示<br>颜色只用在最关键的一两点上<br>大小而不是粗体提示重要的内容，非关键的尽量是小字体，原文是如果这个内容重要程度是1/2，那么使用1/4的字体。</p></li><li><p>颜色也常用来表达认知分层</p></li><li><p>尽量避免错误提示，这样会给用户带来挫败感</p></li><li><p>尽量避免结构化表单，这样会给人以约束</p></li><li><p>能用图片就用图片，能少用文字就少用文字，精简文字，去掉冗余的描述</p></li><li><p>尽量避免打扰用户的注意力，使其分心</p></li><li><p>避免给用户过多的选择，过多的选择让人无法选择<br>为用户提供更少的选择，并为选择提供默认选项</p></li><li><p>有选择尽量又默认选项</p></li></ul></li><li><p>组织原则</p><ul><li><p>使用组织时，最重要是只强调一两个最重要的主题<br>围绕这些主题进行分块，这些主题本身是根据用户行为来分类</p></li><li><p>最好先对内容有效的组织，然后再考虑如何设计搜素</p></li><li><p>按时间与空间来组织</p></li><li><p>控制信息的层次，不超过3层，标题、子标题、正文。<br>降低控制信息，如网格，加粗，用均匀的浅色代替</p></li><li><p>避免用户自定义界面，用户往往不知道如何最有效布置</p></li><li><p>渐进展示内容，普通用户使用默认的简单功能，而必要时候可以选择更细节的功能</p></li><li><p>避免使用“高级”等字眼，会给人以被鄙视的暗示</p></li></ul></li><li><p>转移原则</p><ul><li><p>手机端与电脑端的差异：手机端不适合录入文字，并且是及时使用</p></li><li><p>人与电脑的差异：人更是个与计划，电脑更适合与记录</p></li></ul></li><li><p>隐藏原则</p><ul><li>不得不存在，但有很少用的，最佳案例是设置部分</li></ul></li></ul><h1 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h1><ul><li><p>产品的设计产生与对用户的观察、思考与想象。</p><p>想象的过程就像是写故事，人物、场景、情节，也就是某些人，在什么样的情况下，使用这个产品，这个场景中有哪些故事会发生。这种情况下，人们对产品有着怎样的需要，尤其指的是特点。</p></li><li><p>产品的设计像是写文章，铭记核心，删减与核心无关的内容</p></li><li><p>针对大众设计产品，而不是专家</p></li><li><p>用户并不知道它们提出的需求所带来的负面影响</p></li><li><p>简单并不是初见的简单，它是在扬起复杂之后的简单</p></li><li><p>所以最好的设计是大众与专家都觉得很舒服</p></li><li><p>用户喜欢掌控产品，而不是被产品所掌握</p></li><li><p>产品需要留白，给用户留有再创造的空间</p></li><li><p>认知分层</p></li><li><p>很多时候简约设计是把这个复杂性放在哪里的问题</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;书中分成8章来讲述，其中第一章介绍什么是简单，为什么要简单，第二章了产品设计的步骤，由人物、场景而到情节来设计产品的逻辑，第三章总的来介绍了4种策略：删除、组织、隐藏、转移，后四章对4种策略的分述，最后一章所示算是结语。&lt;br&gt;
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="产品" scheme="http://yoursite.com/tags/%E4%BA%A7%E5%93%81/"/>
    
  </entry>
  
  <entry>
    <title>数系</title>
    <link href="http://yoursite.com/2019/02/18/%E6%95%B0%E7%B3%BB/"/>
    <id>http://yoursite.com/2019/02/18/数系/</id>
    <published>2019-02-17T16:00:00.000Z</published>
    <updated>2019-02-18T01:05:34.740Z</updated>
    
    <content type="html"><![CDATA[<h1 id="起因：由激活函数所引发的对数系的探索"><a href="#起因：由激活函数所引发的对数系的探索" class="headerlink" title="起因：由激活函数所引发的对数系的探索"></a>起因：由激活函数所引发的对数系的探索</h1><ul><li><p>激活函数</p><p>先是看到了激活函数：</p><p>$f(x) = \frac{1}{1+e^{-x}} = \frac{e^x}{1+e^x}$</p></li><li><p>值域在[-1,1]之间对称的函数</p><p>然后想去构造一个新的函数</p><p>特点：$+\infty$趋向1，$-\infty$趋向-1,0处为0，并且对称。</p><p>$f(x) = \frac{e^x-1}{e^x+1}$</p><p>试过用其他基础函数，都办法实现，首先定义域得相同，难处在于两个极限处要变号。</p></li><li><p>基本函数</p><p>通过实验，发现幂函数系没有发现满足要求的形式。因为在无穷处要想趋向与1，只有除法可以，这样在正负无穷都是一样的。<br>在上述函数的构造过程中，也思考过作为基础函数的三角函数。但三角函数是一种周期函数，此处更不能用。</p><p>理解三角函数与圆离不开关系，这样自然而然的想起了复指数函数。</p></li><li><p>复指数函数</p><p>欧拉公式：<br>$e^{ix} = cosx + isinx$</p><p>欧拉公式的证明很有趣，既可以通过微分的方法，又可以通过积分的方法来证明。<br>这又引起了对复数的兴趣，要说复数，我们先从数系入手。</p></li></ul><h1 id="数系"><a href="#数系" class="headerlink" title="数系"></a>数系</h1><p>  人类了解数的过程，真是很艰难的过程，远远不是数学课本上的，实数、虚数、有理数、无理数、整数、分数等几个概念那么简单。</p><p>  以下内容摘自：<a href="http://shc2000.sjtu.edu.cn/030802/congjishu.htm" target="_blank" rel="noopener">从计数法到复数域</a></p><p>  自然数：</p><p>  自然数系是一个离散的、而不是稠密的数系，因此，作为量的表征，它只能限于去表示一个单位量的整数倍，而无法表示它的部分。同时，作为运算的手段，在自然数系中只能施行加法和乘法，而不能自由地施行它们的逆运算。这些缺陷，由于分数和负数的出现而得以弥补。</p><p>  分数与负数：</p><p>  分数都是有理数，非整除的都是无限循环小数。分数系是一个稠密的数系，它对于加、乘、除三种运算是封闭的。为了使得减法运算在数系内也同行无阻，负数的出现就是必然的了。</p><p>  无理数：</p><p>  有理数系的缺陷：一条直线上的有理数尽管是“稠密”，但是它却漏出了许多“孔隙”，而且这种“孔隙”多的“不可胜数”。这样。人们对微积分基础的关注，使得实数域的连续性问题再次突显出来。因为，微积分是建立在极限运算基础上的变量数学，而极限运算，需要一个封闭的数域。无理数正是实数域连续性的关键。</p><p>  无理数是什么？变量数学独立建造完备数域的历史任务，终于在19世纪后半叶，由维尔斯特拉斯（Weierstrass,1815- 1897）、戴德金（R.Dedekind1831- 1916、康托（G.Cantor,1845- 1918）等人加以完成了。1872年，实数的三大派理论：戴德金“分割”理论；康托的“基本序列”理论，以及维尔斯特拉斯的“有界单调序列”理论，同时在德国出现了。由“戴德金分割”定义的实数，是完全不依赖于空间与时间直观的人类智慧的创造物。</p><p>  复数：</p><p>  1545年，此时的欧洲人尚未完全理解负数、无理数，然而他们智力又面临一个新的“怪物”的挑战。例如卡丹在所著《重要的艺术》（1545）中提出一个问题：把10分成两部分，使其乘积为40。这需要解方程x (10-x) = 40，他求得的根是$5+\sqrt{-15}$和$5-\sqrt{-15}$. 对复数的模糊认识，莱布尼兹（Leibniz,1646- 1716）的说法最有代表性：“圣灵在分析的奇观中找到了超凡的显示，这就是那个理想世界的端兆，那个介于存在与不存在之间的两栖物，那个我们称之为虚的—1的平方根。”。在使人们接受复数方面，高斯(1777－1855)的工作更为有效。他不仅将 a+ bi 表示为复平面上的一点 ( a, b)，而且阐述了复数的几何加法和乘法。</p><p>  在澄清复数概念的工作中，爱尔兰数学家哈米尔顿（Hamilton,1805 – 1865） 是非常重要的。哈米尔顿所关心的是算术的逻辑，并不满足于几何直观。他指出：<strong>复数a+ bi 不是 2 ＋ 3意义上的一个真正的和，加号的使用是历史的偶然，而 bi 不能加到a 上去。复数a+ bi 只不过是实数的有序数对（a，b），并给出了有序数对的四则运算，同时，这些运算满足结合律、交换率和分配率</strong>。在这样的观点下，不仅复数被逻辑地建立在实数的基础上，而且至今还有点神秘的 也完全消除了。</p><h1 id="数、运算、函数"><a href="#数、运算、函数" class="headerlink" title="数、运算、函数"></a>数、运算、函数</h1><p>  函数是一种自变与因变关系，是一种因果、变化思维<br>  基础运算（+-×/乘法与开方）都是一种增减逻辑<br>  微积分是一种基于函数（变量）的极限逻辑</p><ul><li><p>数系的扩展与运算：</p><p>如小数与分数的出现与四则运算的完备相关；<br>无理数的出现起初与乘方、开方相关，后又与微积分相关；<br>复数的出现也与开方相关。</p></li><li><p>运算都有与之对应的逆运算</p><p>乘法对除法<br>乘方对开方<br>积分对微分</p></li><li><p>运算的律</p><p>结合律、交换律、分配率。<br>乘法结合律:(a×b)×c=a×(b×c)<br>乘法交换律:a×b=b×a<br>乘法分配律:(a+b)×c=a×c+b×c</p></li></ul><ul><li><p>初等运算都有与之对应的函数</p><p>基础运算：<br>乘方对应的(负)幂函数与指数函数<br>开方对应的对数函数</p><p>微积分：<br>多数的基础函数都在自己的域内<br>如幂函数、指数函数、三角函数。<br>但对数函数与负幂函数是例外；<br>三角函数也通过欧拉公式与复指数函数相关了；</p></li><li><p>函数</p><p>初等函数：<br>幂、指、对、三角、反三角</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;起因：由激活函数所引发的对数系的探索&quot;&gt;&lt;a href=&quot;#起因：由激活函数所引发的对数系的探索&quot; class=&quot;headerlink&quot; title=&quot;起因：由激活函数所引发的对数系的探索&quot;&gt;&lt;/a&gt;起因：由激活函数所引发的对数系的探索&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="探索" scheme="http://yoursite.com/categories/%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="数学" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>docker中pgsql数据的导入导出</title>
    <link href="http://yoursite.com/2019/01/10/docker%E4%B8%ADpgsql%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"/>
    <id>http://yoursite.com/2019/01/10/docker中pgsql数据的导入导出/</id>
    <published>2019-01-10T02:28:42.000Z</published>
    <updated>2019-02-15T08:01:26.578Z</updated>
    
    <content type="html"><![CDATA[<p> 测试环境中录入了一些数据，这些数据不想重复再在运行环境中录入，就想着通过导入导出的方式来解决。<br><a id="more"></a></p><h1 id="pgsql数据库、数据表的导出导入"><a href="#pgsql数据库、数据表的导出导入" class="headerlink" title="pgsql数据库、数据表的导出导入"></a>pgsql数据库、数据表的导出导入</h1>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">导出表：pg_dump -U root -d builder -t 表名 &gt; ~/表名.sql</span><br><span class="line">导出库：pg_dump -U root -d builder &gt; ~/库名.sql</span><br><span class="line">导 入：psql -d  builder  -f  ~/*.sql</span><br><span class="line"></span><br><span class="line">ps: -U: User </span><br><span class="line">    -d: database </span><br><span class="line">    -t: table </span><br><span class="line">    -f: file</span><br></pre></td></tr></table></figure><h1 id="docker中传输文件到运行机器"><a href="#docker中传输文件到运行机器" class="headerlink" title="docker中传输文件到运行机器"></a>docker中传输文件到运行机器</h1><p>  docker中安装scp<br>  <code>apt-get update</code><br>  <code>apt-get install openssh-client</code></p><p>  传输文件<br>  <code>scp 源文件 用户名@主机：路径</code><br>  <code>scp ~/表名.sql root@baidu.com:/home/root/</code></p><h1 id="运行机器将文件copy到docker中"><a href="#运行机器将文件copy到docker中" class="headerlink" title="运行机器将文件copy到docker中"></a>运行机器将文件copy到docker中</h1><p>  从主机copy文件到容器，在主机中执行：<br>  <code>docker cp /opt/test/file.txt mycontainer：/opt/testnew/</code></p><p>  从容器copy文件到主机：<br>  <code>docker cp mycontainer：/opt/testnew/file.txt /opt/test/</code></p><h1 id="docker中导入表"><a href="#docker中导入表" class="headerlink" title="docker中导入表"></a>docker中导入表</h1><p>  <code>psql -d  builder  -f  ~/*.sql</code></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p> <a href="https://blog.csdn.net/allen_oscar/article/details/9061573" target="_blank" rel="noopener">postgresql的导入、导出</a><br> <a href="https://blog.csdn.net/dongdong9223/article/details/71425077" target="_blank" rel="noopener">docker与主机的copy</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 测试环境中录入了一些数据，这些数据不想重复再在运行环境中录入，就想着通过导入导出的方式来解决。&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>ssh免密配置</title>
    <link href="http://yoursite.com/2019/01/09/ssh%E5%85%8D%E5%AF%86%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/01/09/ssh免密配置/</id>
    <published>2019-01-09T06:07:01.000Z</published>
    <updated>2019-02-15T08:01:26.578Z</updated>
    
    <content type="html"><![CDATA[<p> 本文是第一篇转到md写的文档，作为对问题的总结，也作为使用md语法的开始。<br> <a id="more"></a></p><h1 id="ssh简介"><a href="#ssh简介" class="headerlink" title="ssh简介"></a>ssh简介</h1><p> ssh(Secure Shell)是一种加密的网络传输协议，在网络中创建安全隧道来实现ssh客户端与服务器之间的连接。<br> 虽然任何网络服务都可以通过ssh实现安全传输，ssh最常见的用途是远程登录系统。在设计上ssh是Telnet和非安全shell的替代品，telnet等协议采用明文传输，不使用不可靠的密码，容易遭到监听、嗅探和中间人攻击。ssh旨在保护非安全网络环境中信息加密完整可靠。<br> ssh以非对称加密实现身份验证，人工生成一对公钥和私钥，通过生成的密钥进行认证，这样就可以在不输入密码的情况下登录。公钥需要放在待访问的计算机之中，而对应的私钥需要由用户自行保管。认证过程基于生成出来的私钥，但整个认证过程中私钥本身不会传输到网络中。<br> 核实未知密钥来源都是重要的事情，因为SSH只验证提供用户是否拥有与公钥相匹配的私钥，只要接受公钥而且密钥匹配服务器就会授予许可。这样的话，一旦接受了恶意攻击者的公钥，那么系统也会把攻击者视为合法用户。</p><h1 id="ssh原理"><a href="#ssh原理" class="headerlink" title="ssh原理"></a>ssh原理</h1><p> <a href="https://www.jianshu.com/p/33461b619d53" target="_blank" rel="noopener">图解SSH原理</a><br>  简单概述一下：原来是通过ssh user@host申请，然后server应答后，输入password，但这样会造成中间人攻击，就是代理截获了client与server之间的通信，伪装server骗取client的密码，然后对server进行攻击。<br>  于是有了公钥认证的过程，就是俗称的免密，其过程就是客户端生成一段密钥对，然后把公钥设置到服务器的authorized_keys中，这样client与server都各有一对密钥，同时握有对方的公钥，只要进行配对认证，就可以不再输入密码了。</p><h1 id="ssh免密配置"><a href="#ssh免密配置" class="headerlink" title="ssh免密配置"></a>ssh免密配置</h1><ul><li><p>client端生成密钥对<br>cd ~/.ssh<br>ssh-keygen -t rsa -C “名字” -f “名字_rsa”</p></li><li><p>放到server的~/.ssh/authorized_keys中<br>上传到服务器有好几种方式，可以手动打开粘帖进去，也可以在客户端使用命令：<br><code>ssh-copy-id -i 公钥 用户名@服务器</code></p></li><li><p>client配置~/.ssh/config</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host xw</span><br><span class="line">    HostName 47.98.197.178</span><br><span class="line">    User root</span><br><span class="line">    Port 22</span><br><span class="line">    PubKeyAuthentication yes</span><br><span class="line">    IdentityFile ~/.ssh/chenjing_rsa</span><br></pre></td></tr></table></figure></li></ul><ul><li>问题：<br> signing failed: agent refused operation问题：<br> 一般情况下设置完如上操作，就可以访问了，若出现：sign_and_send_pubkey: signing failed: agent refused operation，则需要在client端将key增加到agent，操作如下：<br> <code>ssh-add ~/.ssh/your-key-name</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 本文是第一篇转到md写的文档，作为对问题的总结，也作为使用md语法的开始。&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="ssh" scheme="http://yoursite.com/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>谷歌软件测试之道</title>
    <link href="http://yoursite.com/2019/01/01/%E8%B0%B7%E6%AD%8C%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B9%8B%E9%81%93/"/>
    <id>http://yoursite.com/2019/01/01/谷歌软件测试之道/</id>
    <published>2019-01-01T07:23:57.000Z</published>
    <updated>2019-02-15T08:01:26.578Z</updated>
    
    <content type="html"><![CDATA[<p> 测试是开发过程中必不可少的一部分，当开发过程和测试一起不分彼此之时，即是得到质量<br> 本博文是摘自《谷歌软件测试之道》，尚未看完，陆续更新中</p><a id="more"></a><h1 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h1><ul><li><p>SWE： software engineer<br>创建设计文档，选择最优的数据结构和整体架构，代码实现与代码审核。<br>需要编写测试代码，包括测试驱动的设计、单元测试、参与构建各种大小规模的测试等。</p></li><li><p>SET： software engineer in test<br>工作重心：可测性和通用测试基础框架上<br>参与设计评审，增加可测性。<br>编写单元测试框架和自动化测试框架。</p></li><li><p>TE： test engineer<br>把用户放在第一位来思考，代表用户的利益。有时会花费大量时间在模拟用户的使用场景和自动化脚本或代码的编写上，分析、解释、测试运行结果，驱动测试执行，构建端到端的自动化测试。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 测试是开发过程中必不可少的一部分，当开发过程和测试一起不分彼此之时，即是得到质量&lt;br&gt; 本博文是摘自《谷歌软件测试之道》，尚未看完，陆续更新中&lt;/p&gt;
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="测试" scheme="http://yoursite.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>linux内核导读</title>
    <link href="http://yoursite.com/2018/12/17/linux%E5%86%85%E6%A0%B8%E5%AF%BC%E8%AF%BB/"/>
    <id>http://yoursite.com/2018/12/17/linux内核导读/</id>
    <published>2018-12-17T04:46:44.000Z</published>
    <updated>2019-02-15T08:01:26.530Z</updated>
    
    <content type="html"><![CDATA[<p>本博文从《linux内核设计与实现》第三版的笔记，主要是任务调度、终端、内存管理、虚拟文件系统等部分。作为导读来存在，为以后看源码做点准备。</p><a id="more"></a><h1 id="内核开发的特点"><a href="#内核开发的特点" class="headerlink" title="内核开发的特点"></a>内核开发的特点</h1><ul><li><p>内核编程既不能访问C库，也不能访问标准的C头文件<br>内核不能链接使用标准C函数库，因为C函数库依赖系统调用（操作系统），而且C库对于内核，太大太低效。但大部分常用的C库函数在内核中都已经得到实现。</p></li><li><p>内核编程必须使用GNU C<br>内核并不完全符合ANSI C标准。它总是用到gcc提供的许多语言的扩展部分。</p></li><li><p>内核编程时缺乏像用户空间那样的内存保护机制<br>用户进程访问非法内存时，内核就会发现错误，并发送SIGSEGV信号。但内核如果访问了非法内存，那就很难控制了。<br>内核中的内存不分页。也就是说，没掉一个字节，物理内存就减少一个字节。</p><p>CPU通过寻址来访问内存。32位CPU的寻址宽度是4G，就是可支持的物理内存最大是4G，但如果物理内存小于4G，程序不得不降低内存占用。为解决此类问题，现在CPU引入MMU（内存管理单元），思想就是利用虚拟地址来替代物理地址，即CPU寻址时使用虚拟地址替代物理地址，即CPU寻址时，使用虚拟地址，由MMU负责将虚拟地址映射为物理地址。<br>内存分页（Paging）是在使用MMU的基础上，提出的内存管理机制。它将虚拟地址和物理地址按固定大小（4K）分割成页（page）和页帧（page frame），并保证页与页帧的大小相同。</p></li><li><p>内核变成时难以执行浮点运算。<br>用户空间的进程进行浮点操作的时候，内核会完成从整数操作到浮点数操作的模式转换。而内核并不完美支持浮点操作，因为它本身不能陷入。在内核中使用浮点数时，除了人工保存和恢复浮点寄存器，还有一些琐碎的事情要做。</p></li><li><p>内核给每个进程只有一个很小的定长堆栈<br>内核空间的栈比较小，一般就2页，即32位的内核是8KB，64位是16KB。</p></li><li><p>由于内核支持异步中断、抢占和SMP<br>SMP：（Symmetric mutliprocessing）是一种多处理器的计算硬件构架，在对称多处理架构下，每个处理器的地位都是平等的，对资源的使用权相同。有两个或更多的相同的处理器共享同一主存，由一个操作系统控制。<br>SMP，里那个以上的cpu内核有可能访问共享的同一资源<br>中断是异步的，中断处理程序就可能访问同一资源<br>inux内核可以抢占，内核中一段正在执行的代码可能会被另一段代码抢占，从而还是访问相同的资源。<br>常用的解决办法是自旋锁和信号量。</p></li></ul><h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><p>虚拟机制<br>进程提供了2种虚拟机制：虚拟处理器和虚拟内存。虽然多个进程正在共享一个处理，但虚处理器给进程一种假象，让这些进程觉得自己在独享处理器。而虚拟内存让进程在分配和管理内存时觉得自己拥有整个系统的所有内存资源。</p></li><li><p>进程描述符pid与任务结构task_struct<br>内核中通常把进程叫做任务（task）<br><img src="进程任务队列.png" alt=""></p></li><li><p>任务结构task_struct<br><img src="内核栈与进程描述.png" alt=""><br>thread_info,指针指向task_struct，通过slab分配器分配task_struct，这样能达到对象复用和缓存的目的。放在内核站的尾端是为了通过栈指针就能找到它的位置。</p></li><li><p>进程的状态<br><img src="进程状态转化.png" alt=""></p></li><li><p>进程树<br>所有进城都是通过fork()来实现，所以就有了父子进程的关系，在task_struct中有父进程的指针，以及子进程的列表。</p></li><li><p>进程创建<br>资源： 地址空间（VM）、文件系统资源(FS)、文件描述符(FILES)、信号处理程序(SIGHAND)<br>fork()： 大体是从父进程拷贝相同的task_struct，然后将描述符、资源从父进程分离。对于线程，就可以有些资源就不分离而已。</p></li><li><p>进程终结<br>首先会回收task_struct中的资源，并给其子进程找到合适的父进程，然后返回到其父进程，然后删除进程描述符。</p></li></ul><h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>进程调度系统可以看作在运行态P35<br>抢占式与非抢占式的区别</p><p>进程调度历史<br>简单调动 =》 O（1）调度程序 =》 完全公平调度算法（CFS）</p><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><p>调度程序角度对进程的划分：I/O消耗型与cpu消耗型<br>调度策略的平衡：进程响应迅速（响应时间短）和最大系统利用率（高吞吐量）<br>进程优先级，2套优先级范围：<br>nice值（人越nice越礼让，进程nice越大优先级越低），范围-20 到 +19<br>rtprio实时优先级，其值可配置，范围是0-99。越高优先级越高。任何实时进程的优先级都高于普通的进程，实时优先级与nice优先级处于互补相交的两个范畴。<br>时间片<br>调度策略必须规定一个默认的时间片，时间过长会导致系统对交互的响应欠佳（I/O消耗型），时间片太短会明显增大进程切换带来的cpu耗时。但linux的CFS调度器并没有直接分配时间片到进程，它是将处理器的使用比划分给了进程，这样进程所获得的时间片其实是个系统负载密切相关的。CFS调度器，其抢占时机决定于新的可运行程序消耗了多少处理器使用比，如果消耗的使用比比当前进程小，则新进程立即投入运行，抢占当前进程。</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>假设有2个运行进程，在标准Unix调度模型中，我们先运行其中一个5ms，然后再运行另一个5ms。但它们任何一个运行时都将占有100%的处理器。而在理想情况下，完美的多任务处理器模型应该是：我们在10ms内同时运行两个进程，它们各自使用处理器一半的能力。</p><p>CFS的做法是允许每个进程运行一段时间、循环论转、选择运行最少的集成作为下一个运行进程，而不再采用分配给每个进程时间片的做饭，CFS在所有可运行进程总数基础上计算出一个进程应该运行多久，而不是依靠nice值来计算时间片。nice值在CFS中被作为进程获得的处理器运行比的权重。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li><p>时间记账<br>多数Unix系统中，分配一个时间片给每一个进程，当系统时钟节拍发生时，时间片都会减少每一个节拍周期，当一个进程的时间片减少至0,它就会被另一进程抢占。</p><p>CFS不再用时间片的概念，但它也必须维护每一个进程运行的时间到帐。vruntime变量存放进程的虚拟运行时间，该运行是经过所有可运行进程总数的标准化，跟定时器节拍不再相关。vruntime变量来记录一个程序到底运行了多长时间以及它还应该再运行多久。</p><p> update_curr()函数来实现记账功能，它是有系统定时器周期性调用，curr-&gt;vruntime每次都增加一个 delta_exec_weighted，而这个delta_exec_weighted是根据当前任务的本次间隔delta_exec来，以及所有其他进程的delta_exec来计算的。</p><p> 应该这个权重是考虑了nice值的，但没有看到vruntime对任务调度的影响的部分代码，应该是在update_min_vruntime(cfs_rq)中产生了影响。</p></li><li><p>进程选择<br>当CFS需要选择下一个运行进程时，它会挑选一个具有最小vruntime的进程。CFS使用红黑树来组织可运行进程队列，红黑树是一个自平衡二叉搜索树小于节点在其左节点，大于在右节点，且是一种平衡的二茶树。</p></li><li><p>调度器入口<br>入口为schedule()，在kernel/sched.c中，它会找到一个最高优先级的调度类，然后有最高优先级的调度类下一该运行的进程。<br>CFS是对普通进程的调度类，而系统运行的绝大多数进程都是普通进程。</p></li><li><p>休眠<br>休眠的进程处于不可执行状态，需要从红黑树里移出，放入等待队列。待唤醒后，再从等待队列移出，放入红黑树。</p></li><li><p>总结<br>CFS就是通过vruntime实现对所有进程运行时间归一化的处理，处理过程肯定有nice值、以及进程数的参与。然后每次选取最小vruntime的去调度。</p></li></ul><h3 id="抢占"><a href="#抢占" class="headerlink" title="抢占"></a>抢占</h3><ul><li><p>上下文切换<br>抢占就需要进行上下文的切换，上下文切换主要负责：</p><ol><li>把虚拟内存从上一个进程切换到新进程中</li><li>调用switch_to()，从上一个进程的处理器状态切换到新进程的处理器状态。这包括保存、恢复栈信息和寄存器信息，还有其他任何与体系结构相关的状态信息。</li></ol></li><li><p>用户抢占<br>内核将返回用户空间的时候，如果need_resched标志被设置，会导致schedule()被调用，此时就会发生用户抢占。用户抢占发生在：</p><ol><li>从系统调用返回用户空间时</li><li>从中断处理程序返回用户空间时</li></ol></li><li><p>内核抢占<br>Linux完整支持内核抢占，不支持抢占的内核中，内核代码可以一直执行，到它去完成为止，调度程序没法在一个内核级任务正在执行的时候重新调度。Linux内核就可以在任何时间抢占正在执行的任务。内核抢占发生在：</p><ol><li>中断处理程序正在执行，且返回内核空间之前。</li><li>内核代码再一次具有可抢占性的时候</li><li>内核中的任务显式调用schedule()</li><li>内核中的任务阻塞</li></ol></li></ul><h3 id="实时调度策略"><a href="#实时调度策略" class="headerlink" title="实时调度策略"></a>实时调度策略</h3><p>linux提供了两种实时调度策略： SCHED_FIFO 和 SCHED_RR。<br>SCHED_FIFO实现了一种简单那的,先入先出的调度算法: 一旦一个SCHED_FIFO进程处于可执行状态,就会一直执行,知道它自己受阻或显式释放处理器,它不基于时间片,可以一直执行下去.只有更高优先级的SCHED_FIFO或者SCHED_RR任务才能抢占SCHED_FIFO人任务,且高优先级的SCHED_FIFO可以立即抢占低有线的.<br>SCHED_RR与SCHED_FIFO大体相同,只是SCHED_RR带有时间片.当时间片耗尽,它在统一优先级的其他实时进程被轮流调度,时间片之用来重新调度同一优先级的进程.即使时间片耗尽,低优先级的也不能抢占SCHED_RR高优先级的任务.</p><p>一点疑问: SCHED_FIFO是一种先入先出的队列,如果一个高优先级的紧挨在一个低优先级的后面,那会发生什么? 低优先级先运行,接着被高优先级的抢占,并将低优先级任务处于TASK_INTERRUPTABLE状态,并指导高优先级的运行完,再去运行低优先级的.<br>反过来,低优先级在一个高优先级的后边,会发生什么? 高优先级的先运行,低优先级的会继续在队列里,还是在其他的等待对立里?</p><p>优先级范围<br>实时优先级从0 到 MAX_RT_PRIO-1(99),SCHED_NORMAL级进程的nice值共享了这个取值空间,它的取值从MAX_RT_PRIO 到 (MAX_RT_PRIO + 40),也就是说 nice从-20到+19对应着 100到139的实时优先级范围.</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>时间片理解<br>对传统unix的时间片还有有些疑问,首先时间片是按nice值来进行分配,当高优先级运行完再运行低优先级的,当都运行完呢? 应该由调度程序继续来划分时间片,再继续运行,那这样,高优先级的任务也会等较久的时间啦,如果有100个任务,轮过一遍还是挺费事的.<br>不对,传统unix的时间片是固定的,什么样的优先级对应的时间片是固定的,那就需要有一个队列,时间片运行完后,将任务放到队列的后面,继续运行.且队列不能按优先级排序,因为一排序,它就又到前面了.不排序就会造成低优先级的比高优先级的先运行的情况,又会造成问题.</li></ul><h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在os中，内核提供了用户进程与内核进程进行交互的一组接口，这些接口让应用程序受限地访问硬件设备，提供了创建新进程并与已有进程进行通信的机制，也提供了申请操作系统其他资源的能力。</p><p>在linux中，系统调用是用户空间访问内核的唯一手段。</p><h2 id="系统调用-与-应用程序接口（API）"><a href="#系统调用-与-应用程序接口（API）" class="headerlink" title="系统调用 与 应用程序接口（API）"></a>系统调用 与 应用程序接口（API）</h2><p>大约关系是，内核提供系统调用接口，供用户空间的应用程序使用，但一般都会将系统调用进行进一步的封装变成应用程序编程接口API，这些接口中最流行的标准是POSIX，最后应用程序直接使用的是这些编程接口。以C库为中printf()调用为例：<br><img src="系统调用与API.png" alt=""><br>C库提供了POSIX绝大部分API</p><h2 id="系统调用-1"><a href="#系统调用-1" class="headerlink" title="系统调用"></a>系统调用</h2><p>在Linux系统中，每个syscall被赋予一个系统调用号，通过这个独一无二的号就可以关联系统调用。当用户空间的进程执行一个系统调用的时候，这个系统调用号来指明到底是要执行哪个系统调用。如此可见，系统调用号是静态的，如果一个系统调用被删除，它占用的系统调用号不允许被回收。</p><p>如getpid()系统调用，它会返回当前进程的PID，内核中的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE0(getpid)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">return</span> task_tgid_vnr(current);   <span class="comment">//return current-&gt;tgid</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SYSCALL_DEFINE0是一个宏，它定义一个无参数的系统调用，展开后的代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_getpid</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br></pre></td></tr></table></figure></p><p>asmlinkage限定词，是一个编译指令，通知编译器仅从栈中提取该函数的参数。</p><h2 id="系统调用处理程序"><a href="#系统调用处理程序" class="headerlink" title="系统调用处理程序"></a>系统调用处理程序</h2><p>用户空间的程序无法直接执行内核代码，也不能直接调用内核空间的函数，因为内核驻留在受保护的地址空间上。<br>应用程序应该以某种方式通知系统，告诉内核自己需要执行一个系统调用，系统系统切换到内核态，这样内核就可以代表应用程序在内核空间执行系统调用。<br>通知内核的机制是靠软中断（中断号128）实现的。通过引发一个异常，促使系统切换到内核态去执行异常处理程序，这个异常处理程序就是系统调用的处理程序。</p><p>仅陷入内核空间是不够的。必须将系统调用号、函数的参数一并传给内核。这些传递，是通过寄存器来完成的，分别放在eax,ebx,ecx,edx,esi,edi（前5个参数）中。<br><img src="系统调用处理程序.png" alt=""></p><h2 id="系统调用上下文"><a href="#系统调用上下文" class="headerlink" title="系统调用上下文"></a>系统调用上下文</h2><p>内核在执行系统调用的时候，处于进程上下文中。current指针指向当前任务，即引发系统调用的那个进程。<br>在进程上线文中，内核可以休眠，可以被抢占。</p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><ul><li><p>参数验证<br>指针、权限等验证防止内核崩溃<br>内核提供了2个方法来完成内核空间与用户空间之间数据的来回拷贝。注意内核无论何时都不能轻率的接受来自用户空间的指针。（这就需要数据的拷贝了，但数据的拷贝本身就需要起止的指针）。copy_to_user（）与copy_from_user()</p></li><li><p>例子</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(silly_copy,</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span> * src,</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span> * dst,</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> buf;  <span class="comment">// 书中例子，直接一个long的buf就能使用？</span></span><br><span class="line">    <span class="keyword">if</span>(copy_from_user(&amp;buf, src, len))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    <span class="keyword">if</span>(copy_to_user(dst, &amp;buf, len))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  还有对权限的检验： capable(CAP_SYS_BOOT) 来进行用户权限的检验。</p><p>  还需要将这个系统掉哟个你注册：</p><ol><li>在系统调用表最后，增加新的一项，类似与枚举，用于获取新的系统调用号。</li><li>对于所有支持的体系结构，系统调用都必须定义于 &lt;asm/unistd.h&gt;中。</li><li><p>系统调用必须被编译进内核影像(不能被编译成模块)。这需要将实现放到kernel/下的一个相关文件中，比如sys.c（包含各种各样的系统调用）</p><p>这样虽然定义了系统调用，但在C库中肯定没有对它的支持，好在linux提供了一组宏，用户对系统掉哟个你进行直接访问</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NR_foo 283</span></span><br><span class="line">_syscall3(<span class="keyword">long</span>, silly_copy, src, dst, len)</span><br></pre></td></tr></table></figure></li></ol></li></ul><h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><ul><li><p>简介<br>中断也是老朋友了，就是硬件中，使能了某个引脚的中断，然后编写这个中断的响应函数来处理。只不过在操作系统中会稍微麻烦了一点，它将终端分为2部分，其中上半部用来响应硬件、恢复中断，下半部用来处理硬件的数据。</p></li><li><p>上、下半部的对比<br>中断处理程序是上半部，接收一个中断，它就立即开始执行，只做有限的工作，例如对接收的中断进行应答，或者复位硬件，这些工作都是在所有中断被禁止的情况下完成的。能够被允许稍后完成的工作会推迟到下半部去。</p></li><li><p>注册中断处理程序<br>中断处理程序是驱动程序的组成部分，驱动程序通过request_irq()函数&lt;linux/iterrupt.h&gt;中注册一个中断处理程序，并激活给定的中断线，以处理中断。<br>主要参数是中断号与中断处理程序。</p></li><li><p>中断上下文<br>当执行一个中断处理程序时，内核处于中断上下文中。回忆进程上下文，进程上下文是一种内核所处的操作模式，此时内核代表进程执行如系统调用，运行内核线程等任务，在进程上下文中，可以通过current宏关联当前进程，因为进程是以进程上下文的形式连接到内核中，因此，进程上下文可以睡眠，可以调用调度程序。<br>中断上下文则相反，它与进程无关，也就没有后备进程，所以不能睡眠，中断上下文具有严格的时间限制，因为它打断了其他代码。<br><img src="中断处理程序.png" alt=""></p><p>/proc/interrupts中存放与系统中中断的相关信息。</p></li><li><p>下半部<br>下半部就主要有三种选择：软中断、tasklet和工作队列，其中tasklet基于软中断，工作队列依靠内核线程实现。<br>对于后半部，如果有休眠的需要，工作队列是唯一选择，否则就用tasklet。软中断一般不会用，因为它就32个，且被整个系统严格格共享且规范使用。</p></li></ul><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><ul><li><p>页<br>内核以page(页)作为管理内存的基本单位，因为MMU(内存管理单元，把虚拟地址转换成物理地址的硬件)通常就是以页为单位进行处理。<br>32位体系结构支持4KB页，64位体系一般支持8KB页大小。<br>内核用struct page结构表示系统中的每个物理页，该结构位于&lt;linux/mm_types.h中&gt;<br>page结构与物理页相关，而并非虚拟页。保存着页是否脏页，引用计数，虚拟地址（高地址可能没有，null）。</p></li><li><p>区<br>由于硬件限制，内核并不能对所有的页一视同仁，只有特定物理地址上的page才能用于也写特定的任务，所以内核就把页划分为不同的区。<br>linux主要用于4个区：</p><ol><li>ZONE_DMA – 这个区包含的页用来执行DMA操作【好久不见DMA，印象中是内存不再cpu参与下，直接与I/O交互】</li><li>ZONE_DMA32 – 只能被32位设备访问的DMA</li><li>ZONE_NORMAL – 能正常映射的页</li><li>ZONE_HIGHM – 所谓的高端内存，其中的页并不能永久的映射到内核地址空间。<br>这些区不不是都会有，如在64位体系中，所有内存都被映射，ZONE_HIGHMEM就为空<br>在x86-32上</li></ol></li></ul><table><thead><tr><th>区</th><th style="text-align:right">物理内存</th></tr></thead><tbody><tr><td>ZONE_DMA</td><td style="text-align:right">&lt;16MB</td></tr><tr><td>ZONE_NORMAL</td><td style="text-align:right">16~896MB</td></tr><tr><td>ZONE_HIGHMEM</td><td style="text-align:right">&gt;896MB</td></tr></tbody></table><p>  这些区域一般在&lt;linux/mmzone.h&gt;中的struct zone中定义<br>  比较重要的有lock域，是一个自旋锁，它防止zone被并发访问，这个域只保护zone结构，而不是保护这个区中的所有页。watermark数组，持有该区的最小值、最低和最高水位值。内核使用水位为每个内存设置合适的内存消耗基准，该水位随空闲内存的多少而变化。</p><ul><li><p>每个cpu的内存分配<br>一般来说，每个CPU的数据存放在一个数组中，数组中的每一项对应系统上一个存在的处理器。按当前处理器确定这个元素的当前元素。这些数据对当前处理器来说是唯一的，且除了当前处理器，没有其他处理器可接触到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cpu;</span><br><span class="line">cpu = get_cpu();  <span class="comment">// 获取当前处理器，并禁止内核抢占</span></span><br><span class="line">...操作</span><br><span class="line">put_cpu();       <span class="comment">// 激活内核抢占</span></span><br></pre></td></tr></table></figure><p>2.6版本引入新接口，percup来创建和操作每个CPU的数据<br>编译时，定义每个CPU变量<br>DEFINE_PER_CPU(type, name) 它为系统中的每一个处理器都创建一个类型为type，名字为name的变量。<br>DECLARE_PER_CPU(type, name)这是声明一个变量<br>get_cpu_var(name) 和 put_cpu_var(name)返回当前处理器的中指定变量.</p><p>这里有个问题,什么样的数据适合放在为每个cpu分配的内存上呢?</p></li><li><p>内存分配的选择<br>如果需要连续的物理页，可以使用某个低级页分配器或者kmalloc()。这是内核中内存分配的常用方式，也就是大多数应该使用的内存分配方式。传递给这些函数通常的标志是GFP_ATOMIC和GFP_KERNEL。GFP_ATOMIC表示进行不睡眠的高优先级分配，这是终端处理程序和其他不能睡眠的代码段的需要。GFP_KERNEL表示可以睡眠的代码，比如进程上下文中。</p><p>如果想从高端内存进行分配，就是用alloc_pages()。alloc_pages()函数返回一个指向struct page结构体的指针，而不是指向某个逻辑地址的指针。因为高端内存很可能没有被映射，因此访问它的唯一方式就是通过相应的struct page结构。有时为了获得真正的指针，应该调用kmap()，把高端内存映射到内存的逻辑地址空间，kmap在高端内存用会永久映射高端内存，而在低端用就是获取内存地址。</p><p>如果不需要物理上连续的页，而仅仅需要虚拟地址上连续的页，那么就使用vmalloc()。vmallog()函数分配的内存虚地址是连续的，但它本身不保证物理上的连续。</p><p>如果要创建和撤销很大的内存结构，那么应该考虑slab高速缓存。slab层会给每个处理器维持一个对象高速缓存（空闲链表）。这种高速缓存会极大提高对象分配和回收的性能【就是提前new出好多空间，使用时直接使用，无需新建跟销毁】</p></li></ul><h1 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h1><ul><li><p>unix文件系统：文件、目录项、索引节点和安装点<br>从本质上讲文件系统是特殊的数据分层存储系统，它包含文件、目录和相关的控制信息。文件系统的通用操作包括创建、删除和安装。<br>文件可以做一个有序字符串，字符串的第一个字节是文件的头，最后一个字节是文件的尾。每一个文件为了便于系统和用户识别，都被分配了一个便于理解的名字。典型的文件系统有读、写、创建和删除。<br>在Unix中，目录属于普通文件，它列出包含在其中的所有文件，由于VFS把目录当作文件对待，所以可以对目录执行和文件相同的操作。<br>Unix系统将文件本身 和 文件的控制信息2个概念区分，例如访问控制权限、大小、拥有者、创建时间等信息。文件信息被存储在一个单独的数据结构中，该结构被称为索引节点（inode）。文件控制信息被存储磁盘的超级块中。</p></li><li><p>vfs对象及其数据结构<br>vfs采用面向对象的设计思路。VFS中四个主要的对象类型，它们分别是：<br>（super）超级块对象，它代表一个具体的已安装文件系统<br>（inode）索引节点对象，它代表一个具体文件<br>（dentry）目录项对象，它代表一个目录项，是路径的一个组成部分<br>（file）文件对象，它代表有进行打开的文件。<br>unix是用C实现了，也就不会有class等关键字，那如何来实现面向对象呢，4个主要的对象类型都是结构体，而对他们的操作都封装在一个操作对象里作为类型对象的属性，操作对象中包含指向操作其父对象的函数指针;这就是之前听说过的，用C来实现面向对象的技术。</p></li><li><p>超级块对象<br>super_block结构体，定义在&lt;linux/fs.h&gt;中，用于存储特定文件系统的信息<br>超级块对象的操作位于fs.super.c中，超级块对象通过alloc_super()函数创建并初始化。在文件系统安装时，文件系统会调用该函数从磁盘读取文件系统超级块，并且将其信息填充到内存中的超级块对象中。</p><ul><li>超级块操作<br>超级块对象中最重要的一个属性s_op，它指向超级块的操作函数表。该函数表由super_operations结构体表示，定义在linux/fs.h中。<br>所有的操作都在进程上下文中调用。除了dirty_inode()，其他函数都可以阻塞。</li></ul></li><li><p>索引节点对象<br>一个索引节点代表文件系统的一个文件，它也可以是设备或管道这样的特殊文件。索引节点对象必须在内存中创建，以便于文件系统使用。<br>索引节点对象包含了对象操作文件或目录时需要的全部信息。对于Unix风格的文件系统，这些信息可以从磁盘索引节点直接读入，但有些文件系统需要特殊的转换，不管哪种情况，索引节点对象必须在内存中创建，以便VFS使用。<br>inode 结构体在 &lt;linux/fs.h&gt;中</p></li><li><p>目录项对象<br>目录项对象是为了简化索引对象对目录的操作而来的，在磁盘上并没有一个目录项的文件与之对应，是在访问的过程中，在内存中创建的对象。<br>路径中的每一项都属于目录项对象：/mnt/cdrom/foo中，/、mnt、cdrom和foo都属于目录项对象。VFS在执行目录操作时，会现场创建目录项对象<br>dentry 结构体在&lt;linux/dcache.h&gt;中</p><p>目录项状态： 被使用、未被使用、负状态; 被使用与未被使用的状态都对应一个有效的索引节点，而负状态则没有对应的有效节点。</p><p>如果VFS层便利路径中所有的元所将他们逐个解析成目录项对象，还要到达最深层的目录，将是一个非常费力的工作，会浪费大量的时间。所以内核将目录项对象缓存在目录项缓存中。使用时，先在目录项缓存中去查找，如果知道则直接使用，反之就按路径逐层解析、搜索，找到后，将目录项加入dcache中。</p></li><li><p>文件对象<br>文件对象表示进程已打开的文件在内存中的表示。该对象由相应的open()系统调用创建，而由close()调用撤销。所有这些文件相关的调用实际上都是文件操作表中定义的方法。<br>多个进程可以同时打开和操作一个文件，所以同一个文件可能存在多个文件对象。<br>文件系统仅仅在进程观点上代表已打开文件，它反过来指向目录项对象，又指向索引节点。<br>file结构体在 &lt;linux/fs.h&gt;中</p><p>常见的ioctl()、read（）、write()等都是在文件操作对象中定义的</p></li><li><p>其他</p><ul><li><p>vfsmount 当文件系统被安装时，将有一个vfsmount结构体在安装时被创建，用来代表文件系统的实例–也就是代表一个安装点</p></li><li><p>进程相关的数据结构<br>file_struct:进程与文件对象的关联，像是中间表那样<br>fs_struct：进程当前的工作目录(pwd)和根目录<br>namespace: 它使得没一个进程在系统中都看到唯一的安装文件系统（不仅是唯一的根目录，而且是唯一的文件系统层次结构）。</p></li></ul></li></ul><h1 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h1><p>linux采用虚拟内存技术，系统中的所有进程以虚拟方式共享内存。对于一个进程而言，它好像可以访问整个系统的所有物理内存。更重要的是，即使单独一个进程，它拥有的地址空间也可以远远大于系统物理内存。</p><ul><li><p>地址空间<br>每个进程都有一个32或者64位独立、连续的平台地址空间。尽管一个进程可以寻址4GB虚拟内存（32位），但并不代表它就有权访问所有的虚拟地址，进程只能访问有效内存区域内的内存地址。如果进程访问了无效的内存区域，内核会终止进程，并返回段错误。可被访问的有效地址被称为内存区域(memory areas)</p><p>内存区域包含各种内存对象：<br> – 可执行文件代码的内存映射：代码段<br> – 可执行文件已初始化全局变量的内存映射：数据段<br> – 包含未初始化全局变量的内存映射：bss<br> – 用于进程用户空间栈的内存映射：栈，局部变量<br> – 匿名的内存映射，malloc()分配的内存： 堆，<br> – 任何共享内存段<br> – 任何内存映射文件<br> – 动态链接程序等共享库的代码段、数据段、bss</p></li><li><p>内存描述符mm_struct<br>mm_struct结构体，定义在&lt;linux/sched.h&gt;中，内核使用mm_struct表示进程的地址空间，该结构包含了和进程地址空间有关的全部信息。<br>内存描述符mm_struct与进程一一对应，描述的是进程各段使用的地址，而各段使用的地址用vm_area_struct结构体来表示，各段的起止地址在mm_struct中都有属性来记录，还保存虚拟页到实际物理地址的映射：pgd_t</p><p>fork() =&gt; copy_mm()函数来完成创建mm_struct</p><p>内核线程的使用不一样，因为内核线程没有进程地址空间，也就没有内存描述符，所以在进程描述符中，mm域为空。<br>当一个进程被调度时，该进程的mm域指向的地址空间被装载到内存，进程描述符中的active_mm域会被更新，指向新的地址空间。内核县城没有地址空间，mm域为NULL，当一个内核线程被调度的时候，内核发现mm域为NULL，会保留前一个进程的地址空间，随后内核更新内核县城对应的进程描述符中的active_mm域，使其只想前一进程的内存描述符。<br>内核线程如此使用，是因为内核线程是需要使用页表的（虚拟内存到物理内存的映射）。</p></li><li><p>虚拟内存区域vm_area_struct(VMA)<br>vm_area_struct结构体描述了制定地址空间内连续区间上的一个独立内存范围。内核将每个内存区域作为一个单独的内存对象管理，每个内存区域都拥有一致的属性，如访问权限等。<br>vm_area_struct在&lt;linux/mm_types.h&gt;中。<br>主要就是区间的首尾地址，VMA形成的链表，访问权限，mm_struct指针<br>使用中可以使用pmap <pid> 打印出进程的各个VMA。<br>比如C库中的物理内存1212KB空间，内存中只映射一份，将这些地址空间以只读的方式映射进每个引用的进程中即可.某个vm_area_struct就可以映射一份即可。</pid></p><p>mmap() 和 do_mmap（）创建地址空间。其实如果是地址空间跟一个已经存在的地址空间相邻，并且访问权限相同，两个空间就合并（类似与扩展）。反之就创建一新的VMA，并把地址加到进程的地址空间中。</p></li><li><p>页表<br>应用程序操作的是虚拟内存，但CPU直接操作确是物理内存，所以当程序访问虚拟内存时，必须将虚拟内存转换成物理内存，CPU才能解析地址访问请求。地址转换工作通过查询页表完成。<br>linux中使用三级页表完成地址转换：<br>顶层页表PGD（页全局目录），它包含了一个pgd_t类型数组<br>二级页表PMD(页中间目录)，是一个pmd_t类型数组<br>底层页表PTE，包含了pte_t类型的页表，指向物理页面<br>搜索页面的工作一部分是由硬件完成的，对应的结构提依赖具体的体系结构，定义在&lt;asm/page.h&gt;中<br><img src="页表.png" alt=""> </p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本博文从《linux内核设计与实现》第三版的笔记，主要是任务调度、终端、内存管理、虚拟文件系统等部分。作为导读来存在，为以后看源码做点准备。&lt;/p&gt;
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
</feed>
