<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>思 见</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-15T02:27:45.963Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>sun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第四周ARTS</title>
    <link href="http://yoursite.com/2019/04/14/%E7%AC%AC%E5%9B%9B%E5%91%A8ARTS/"/>
    <id>http://yoursite.com/2019/04/14/第四周ARTS/</id>
    <published>2019-04-14T00:52:35.000Z</published>
    <updated>2019-04-15T02:27:45.963Z</updated>
    
    <content type="html"><![CDATA[<p>第四周打卡<br><a id="more"></a></p><h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><p>本题是Leetcode的56题Merge Intervals，主要来训练排序的<br><a href="https://sunyanfeng.cn/2019/04/11/合并区间问题/#more" target="_blank" rel="noopener">合并区间问题</a></p><h1 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h1><p><a href="https://medium.com/@goldybenedict/single-page-applications-vs-multiple-page-applications-do-you-really-need-an-spa-cf60825232a3" target="_blank" rel="noopener">原文</a><br>本周来review一篇SPA(Single Page Application)与MPA(Multiple Page Application)对比的文章<br>在原文中它对比了SPA与MPA的优缺点，如下图：  </p><table><thead><tr><th style="text-align:left">优缺点对比</th><th style="text-align:center">SPA</th><th style="text-align:center">MPA</th></tr></thead><tbody><tr><td style="text-align:left">优点</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left"></td><td style="text-align:center">SPA更平滑更快</td><td style="text-align:center">搜索引擎方面表现良好</td></tr><tr><td style="text-align:left"></td><td style="text-align:center">更容易开发、部署</td><td style="text-align:center">为用户提供web应用的visual map</td></tr><tr><td style="text-align:left"></td><td style="text-align:center">更容易调试</td><td style="text-align:center"></td></tr><tr><td style="text-align:left"></td><td style="text-align:center">重用一套后端开发生成手机端</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">缺点</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left"></td><td style="text-align:center">对搜索引擎表现不足(已改)</td><td style="text-align:center">相比而言开发复杂</td></tr><tr><td style="text-align:left"></td><td style="text-align:center">只提供单一链接</td><td style="text-align:center">耦合前后端</td></tr><tr><td style="text-align:left"></td><td style="text-align:center">由于跨域问题,安全性稍差</td></tr></tbody></table><p>在选择时，给出建议：<br>If your business deals with a single product, nothing can be perfect than a single page application。<br>While, if your business caters a variety of services or products, you definitely need to give importance to each of them by bifurcating them in different pages with a multi-page application.</p><p>意思是如果产品单一，SPA更好；如果服务、产品众多，更适合MPA。<br>其实这个度其实不好把握，而且感觉SPA与MPA之间的度并不是那么分明。对于单一产品先开发SPA，然后随着业务变大，然后再开发一些SPA，在网关层上做一些调整，感觉也不错。</p><h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><p>由于内容上的连贯，本周的内容继续放在了上周的博客中。<br><a href="https://sunyanfeng.cn/2019/04/08/Matrix-Eigenvalue/#more" target="_blank" rel="noopener">Matrix Eigenvalue</a></p><h1 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h1><p>本周工作中主要是想搭建一个React的前端框架出来，在SSR、CSR与同构下了一点功夫，就这个问题做一个分享。<br><a href="https://sunyanfeng.cn/2019/04/14/SSR%E3%80%81CSR%E4%B8%8E%E5%90%8C%E6%9E%84/#more" target="_blank" rel="noopener">SSR、CSR与同构</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第四周打卡&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SSR、CSR与同构</title>
    <link href="http://yoursite.com/2019/04/14/SSR%E3%80%81CSR%E4%B8%8E%E5%90%8C%E6%9E%84/"/>
    <id>http://yoursite.com/2019/04/14/SSR、CSR与同构/</id>
    <published>2019-04-14T00:51:40.000Z</published>
    <updated>2019-04-15T02:38:18.966Z</updated>
    
    <content type="html"><![CDATA[<p>为本周的前端的框架选择做一个总结</p><a id="more"></a><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>团队的前端同学们想探索一些新的框架，于是就跟他们一起做一些技术选择。<br>现有的前端框架分成server部分与browser部分，server中是一个node.js服务器，负责页面与路由的映射，根据路由导向不同的页面，渲染的交给了前端来完成，是一个React MPA 前端渲染的框架，设计是用的Material-UI库</p><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><ul><li><p>create-react-app<br>选择的过程是从FaceBook官方提供的Create-React-App脚手架开始的。<br>由于团队比较喜欢ts，所以在创建时需要指明<br><code>npx create-react-app [app] --scripts-version=react-scripts-ts</code>。  </p></li><li><p>yarn vs npm<br>然后包管理器用的yarn，又对比了一下yarn与npm，这里放一个知乎的链接，<a href="https://zhuanlan.zhihu.com/p/27449990" target="_blank" rel="noopener">原文</a>。  </p></li><li><p>build<br>接着调用yarn build进行构建，这个构建过程与原框架的构建相差比较大，原框架中通过gulp与webpack的结合来完成从ts到js的编译构建过程，这里并没有看一下这个build如何完成的，最终是构建到了build文件夹下。  </p></li><li><p>deploy<br>与构建紧密相关的deploy，这里给出<a href="https://facebook.github.io/create-react-app/docs/deployment" target="_blank" rel="noopener">create-react-app的deployment</a>，无非就是自己用node.js服务器（它叫dynamic服务器方式）再就是用Serve、Tomcat等服务器（它称之为static服务器方式）来做路由的转换，其实这里本来我是想用nginx来当静态服务器来做，但随着认知的深入，放弃的这种想法，后边再谈。  </p></li><li><p>react-router<br>同学们最看重的模块是React-Router，于是对React-Router进行了探索,原文:<a href="https://reacttraining.com/react-router/web/guides/quick-start" target="_blank" rel="noopener">react-router</a>。队友们只看到了前端渲染的方式，也就是Quick Start部分，React-Router本质上是一个单页面应用的东西，在前端渲染，可以通过将与路由无关的route刷新成null来完成页面的切换，其实问题处在这份guides的Server Render部分，这让我的目光转向了SSR(server side render)与CSR(client side render)。</p></li><li><p>SSR与CSR<br>其实从名字上看差别很清楚，其实是render过程是在服务器上执行还是在浏览器上执行。看了很多区别的文章，尤其后边又增加了同构东西，一段时间内感觉乱糟糟的。这篇文章<a href="https://juejin.im/post/5c821dc45188257e1f2915b1" target="_blank" rel="noopener">前端同构渲染的思考与实践</a>写的比较清楚。</p></li></ul><h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><p>随着这篇文章来梳理一下</p><ul><li><p>html时代<br>http协议最早设计的是从服务器上获取静态的资源，其实也就是静态html  </p></li><li><p>模板渲染<br>后来Java时代，可以通过模板，将数据渲染进模板，从而生成html发送给前端，在后来的CSR出现之间，我觉得可能也没有SSR的概念。  </p><p>浏览器与服务端数据的交互通过表单来实现，浏览器将表达中的数据一次性通过表单提交，后代进行处理完成后可以再次渲染模板，然后将数据表达出来。</p></li><li><p>前端渲染<br>后来我觉得是ajax与virtual dom技术的出现，使浏览器渲染成为可能，一开始可能只是想做一点改变，感觉很平滑，后来干脆所有的dom都直接渲染，这就成成CSR  </p><p>这个CSR从过程上看，浏览器先去获取一个空模板，然后再获取js文件进行virtual dom的渲染，这个过程浏览器上会有一瞬的白屏。  </p><p>浏览器与服务端数据交互很多时候被ajax所替代，好处是比较灵活，不论是数据交互还是页面刷新，不好处容易被滥用，使通信的效率降低，后台服务压力上升。  </p></li><li><p>同构<br>于是出现了同构，同构其实就是服务器渲染一边，浏览器也渲染一边，服务器渲染完初识界面之后就算完成任务，其余的渲染就靠浏览器来完成。react-router中的server render其实就是同构渲染。  </p><p>这时候浏览器与服务端的数据交互与前端渲染并没有变化</p></li></ul><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>这样我们的技术选择就应该是这样的：是一个React SPA 同构渲染的框架，语言上依旧是ts的，设计依旧是用的Material-Ui库</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为本周的前端的框架选择做一个总结&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>合并区间问题</title>
    <link href="http://yoursite.com/2019/04/11/%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/04/11/合并区间问题/</id>
    <published>2019-04-11T15:18:06.000Z</published>
    <updated>2019-04-15T02:20:24.912Z</updated>
    
    <content type="html"><![CDATA[<p>本题是Leetcode的56题Merge Intervals，主要来训练排序的<br><a id="more"></a></p><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a collection of intervals, merge all overlapping intervals.</p><p>Example 1:</p><p>Input: [[1,3],[2,6],[8,10],[15,18]]<br>Output: [[1,6],[8,10],[15,18]]<br>Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].  </p><p>Example 2:  </p><p>Input: [[1,4],[4,5]]<br>Output: [[1,5]]<br>Explanation: Intervals [1,4] and [4,5] are considered overlapping.  </p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>本周想对排序进行练习，上周的Kth最大子数组就是用归并排序来完成的，是训练分治也是训练排序。本周从sort标签中选了第一题。<br>首先需要将各个区间按第一个起始位置排序，然后去合并这些区间即可。这里采用的是快速排序的方式，而且合并的过程也采用与快排查找中间位置类似的想法。<br>这书写上，想着用一下函数范式的一些规则，形参不改变，返回一个相同的参数，使函数无状态。  </p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * struct Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() : start(0), end(0) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;Interval&gt; merge(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;Interval&gt; sortedVals = sortInterval(intervals);</span><br><span class="line">        <span class="built_in">vector</span>&lt;Interval&gt; mergedVals = mergeInterval(sortedVals);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mergedVals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;Interval&gt; sortInterval(<span class="built_in">vector</span>&lt;Interval&gt; &amp;intervals)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Interval&gt; sortedVals = intervals;</span><br><span class="line">        quickSortInterval(sortedVals, <span class="number">0</span>, sortedVals.size()<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sortedVals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quickSortInterval</span><span class="params">(<span class="built_in">vector</span>&lt;Interval&gt; &amp;intervals, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(start &gt;= end)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = partition(intervals, start, end);</span><br><span class="line">        quickSortInterval(intervals, start, mid<span class="number">-1</span>);</span><br><span class="line">        quickSortInterval(intervals, mid+<span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;Interval&gt; &amp;intervals, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        Interval ref = intervals[end];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = start<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=start; j&lt;end; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[j].start &lt; ref.start)&#123;</span><br><span class="line">                i++;</span><br><span class="line"></span><br><span class="line">                exchange(intervals[i], intervals[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = i+<span class="number">1</span>;</span><br><span class="line">        exchange(intervals[mid], intervals[end]);</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">(Interval &amp;a, Interval &amp;b)</span></span>&#123;</span><br><span class="line">        Interval tmp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;Interval&gt; mergeInterval(<span class="built_in">vector</span>&lt;Interval&gt; &amp;intervals)&#123;</span><br><span class="line">        <span class="keyword">int</span> len = intervals.size();</span><br><span class="line">        <span class="keyword">if</span>(len &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> intervals;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;Interval&gt; mergedVals;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=j+<span class="number">1</span>; i&lt;len; ++i)&#123;</span><br><span class="line">          <span class="keyword">if</span>(intervals[j].end &lt; intervals[i].start)&#123;</span><br><span class="line">              mergedVals.push_back(intervals[j]);</span><br><span class="line">              j=i;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span>(intervals[j].end &lt; intervals[i].end)&#123;</span><br><span class="line">              intervals[j].end = intervals[i].end;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(i == len<span class="number">-1</span>)&#123;</span><br><span class="line">            mergedVals.push_back(intervals[j]);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mergedVals;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本题在合并区间的时候考虑过将合并掉的区间删除，考虑到vector删除size发生变化，就思考与快排用两个指示器来处理的方式。这种方式其实改变了传入值，其实可以做一层复制来规避，这里图简单，没有将无状态贯彻到底。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本题是Leetcode的56题Merge Intervals，主要来训练排序的&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>第三周ARTS</title>
    <link href="http://yoursite.com/2019/04/08/%E7%AC%AC%E4%B8%89%E5%91%A8ARTS/"/>
    <id>http://yoursite.com/2019/04/08/第三周ARTS/</id>
    <published>2019-04-08T02:22:36.000Z</published>
    <updated>2019-04-09T01:47:54.042Z</updated>
    
    <content type="html"><![CDATA[<p>第三周打卡<br><a id="more"></a></p><h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><p><a href="https://sunyanfeng.cn/2019/04/04/kth%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/#more" target="_blank" rel="noopener">kth最大元素</a></p><h1 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h1><p>本周主要Review了陈皓老师的编程范式</p><p><a href="https://sunyanfeng.cn/2019/04/01/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/#more" target="_blank" rel="noopener">编程范式</a></p><h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><p><a href="https://sunyanfeng.cn/2019/04/08/Matrix-Eigenvalue/#more" target="_blank" rel="noopener">Matrix Eigenvalue</a></p><h1 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h1><p>本周顺便做了一个工具的记录，就当share了，稍显薄了一点</p><p><a href="https://sunyanfeng.cn/2019/04/04/vscode%E4%B8%8Bmd%E5%AF%BCpdf/#more" target="_blank" rel="noopener">vscode下md导pdf</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第三周打卡&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Matrix Eigenvalue</title>
    <link href="http://yoursite.com/2019/04/08/Matrix-Eigenvalue/"/>
    <id>http://yoursite.com/2019/04/08/Matrix-Eigenvalue/</id>
    <published>2019-04-08T02:14:22.000Z</published>
    <updated>2019-04-15T02:20:24.908Z</updated>
    
    <content type="html"><![CDATA[<p>本周清明回家，只完成2节的Matrix学习，Lesson21～Lesson22<br>为保持博客的完整性，下周的Matrix依旧会放到本篇博客中  </p><p>第四周完成了Less23~Lesson24,继续在这里记录。<br><a id="more"></a></p><hr><h1 id="Eigenvalues-and-eigenvectors"><a href="#Eigenvalues-and-eigenvectors" class="headerlink" title="Eigenvalues and eigenvectors"></a>Eigenvalues and eigenvectors</h1><ul><li><p>定义</p><p>AX = λX</p><p>A matrix A acts on vectors x . Eigenvectors are vectors for which Axis parallel to x。</p></li><li><p>计算</p><p>det(A-λI) = 0</p></li><li><p>复数eigenvalues</p><p>对称阵的特征值为实数，反对称阵的特征值为纯虚数<br>Symmetric matrices have real eigenvalues<br>For antisymmetric matrices like Q, for which AT = −A, all eigenvalues are imaginary (λ=bi). </p></li><li><p>重复的eigenvalues</p><p>非重复的eigenvalues用于相互独立的eigenvector，重复的eigenvalues可能用于独立的，也可能不独立的eigenvector</p><p><img src="重复的eigenvalues示例.png" alt="重复的eigenvalues示例"></p></li></ul><h1 id="Diagonalization-and-powers-of-A"><a href="#Diagonalization-and-powers-of-A" class="headerlink" title="Diagonalization and powers of A"></a>Diagonalization and powers of A</h1><ul><li><p>对角化：Diagonalization</p><p><img src="对角化公式.png" alt="对角化公式"><br><img src="对角化证明.png" alt="对角化证明"></p></li><li><p>A的幂运算，Powers of A<br><img src="A的幂运算.png" alt="A的幂运算"></p><p>当A的K次幂 -&gt; 0时，说明A的特征向量绝对值&lt;1</p></li><li><p>差分方程<br><img src="差分方程.png" alt="差分方程"></p><p><img src="差分方程的解.png" alt="差分方程的解"><br>在这里，它将U0用A的特征向量来表示的，有点当成一组基在使用</p></li><li><p>菲比队列</p><p><img src="Fibonacci队列.png" alt="Fibonacci"><br><img src="构造矩阵.png" alt="构造矩阵"><br><img src="解.png" alt="解"></p></li></ul><hr><h1 id="微分方程与exp-At"><a href="#微分方程与exp-At" class="headerlink" title="微分方程与exp(At)"></a>微分方程与exp(At)</h1><p>本节可以分成3部分，解一个微分方程，稳态分析，exp(At)</p><ul><li><p>解微分方程<br><img src="微分方程实例.png" alt="微分方程实例"><br>初始状态u1=1 u2=0. </p><p><img src="微分方程.png" alt="微分方程">其中A为<img src="微分方程的A.png" alt="微分方程的A"><br>对A求解特征值与特征向量得<br>λ1=0，λ2=-3<br>对应的特征向量为<br><img src="特征向量1.png" alt="特征向量1"><br><img src="特征向量2.png" alt="特征向量2">  </p><p>微分方程对应的一般解为：<br><img src="一般解.png" alt="一般解"><br>可以看出这个一般解其实是一个线性组合，这里可以有一个证明，原因是在所有微分中，指数函数是唯一微分不变的。<br><img src="证明.png" alt="证明">  </p><p>将特征值、特征向量、初始值带入一般解，求解出c1、c2，以此得到u(t)<br><img src="u(t" alt="u(t)">.png)</p><p>以此解完了整个微分方程，同时也引出了稳态分析</p></li><li><p>稳态分析<br>可以对u(t)，尽心分析，当t趋于无穷.<br><img src="u无穷.png" alt="u无穷"></p><p>由此得到微分方程的稳态条件<br><img src="稳态.png" alt="稳态"></p></li><li><p>推广<br><img src="推广.png" alt="推广"><br>这里的推广，首先是将<img src="一般解.png" alt="一般解">写成了矩阵方式即u=Sv，这里S是A的特征向量组成的矩阵，v是变量；然后将次等式带入微分方程，求解v(t).然后将v(t)代入等式，得到u(t)，这里u(t)多了一个S逆<br>这样引出了本节最后一部分exp(At)</p></li><li><p>exp(At)<br><img src="指数的无穷级数.png" alt="指数的无穷级数"></p><p><img src="指数矩阵.png" alt="指数矩阵"></p><p><img src="指数矩阵的解释.png" alt="指数矩阵的解释"></p></li><li><p>二阶微分方程<br>这里对二阶微分方程做了引申<br><img src="二阶微分方程.png" alt="二阶微分方程"><br>与函数相同，将2阶换成2个一阶<br><img src="二阶引申.png" alt="二阶引申"></p></li></ul><h1 id="马尔科夫矩阵与傅里叶级数"><a href="#马尔科夫矩阵与傅里叶级数" class="headerlink" title="马尔科夫矩阵与傅里叶级数"></a>马尔科夫矩阵与傅里叶级数</h1><ul><li><p>马尔科夫矩阵<br>马尔科夫矩阵是这样一类矩阵：1. 矩阵每个元素都是正数；2. 矩阵每列的和为</p><p><img src="Markov矩阵.png" alt="Markov矩阵">  </p><p>它有两个属性</p><ol><li>λ=1是一个特征值，证明可以det(A-λI) = 0</li><li>其他的特征值都小于1</li></ol><p>上一节主要研究是是指数矩阵，这一节其实主要研究的是幂矩阵<br><img src="幂矩阵.png" alt="幂矩阵"><br><img src="级数矩阵.png" alt="级数矩阵"></p></li><li><p>例子<br><img src="以麻省与加州人口.png" alt="以麻省与加州人口"></p><p>λ1=1， λ2=0.7</p><p>对应特征向量<br><img src="Markov特征向量1.png" alt="Markov特征向量1"><br><img src="Markov特征向量2.png" alt="Markov特征向量2">  </p><p><img src="Markov的解.png" alt="Markov的解"></p></li><li><p>Projections with orthonormal basis<br>这个是之前章的一个复习，正交化的矩阵的一个好处是，做投影时只需与正交矩阵相乘即可。<br><img src="正交矩阵-1.png" alt="正交矩阵-1"><br><img src="正交矩阵-2.png" alt="正交矩阵-2"><br><img src="正交矩阵的解.png" alt="正交矩阵的解">  </p></li><li><p>傅里叶级数<br><img src="傅里叶级数.png" alt="傅里叶级数">  </p><p>对于向量：在R空间中<img src="向量空间.png" alt="向量空间"><br>对于函数：<img src="函数空间.png" alt="函数空间"><br>乘后加操作变成乘后积分操作，因为是周期函数，所以只积分周期即可。<br><img src="解过程.png" alt="解过程"><br><img src="傅里叶的解.png" alt="傅里叶的解"><br> 这样就解出了a1，以此可以解出an。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周清明回家，只完成2节的Matrix学习，Lesson21～Lesson22&lt;br&gt;为保持博客的完整性，下周的Matrix依旧会放到本篇博客中  &lt;/p&gt;
&lt;p&gt;第四周完成了Less23~Lesson24,继续在这里记录。&lt;br&gt;
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Matrix" scheme="http://yoursite.com/tags/Matrix/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>kth最大元素</title>
    <link href="http://yoursite.com/2019/04/04/kth%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2019/04/04/kth最大元素/</id>
    <published>2019-04-04T05:57:09.000Z</published>
    <updated>2019-04-09T01:43:59.866Z</updated>
    
    <content type="html"><![CDATA[<p>本题是 Leecode的 215.Kth Largest Element in an Array<br><a id="more"></a></p><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p><p>Example 1:</p><p>Input: [3,2,1,5,6,4] and k = 2<br>Output: 5<br>Example 2:</p><p>Input: [3,2,3,1,2,4,5,5,6] and k = 4<br>Output: 4<br>Note:<br>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>本题，想到了2种可行方式：</p><ol><li>用排序算法，对数组进行排序，然后返回地k-1个元素即可，既然是训练分治，这里可以使用归并排序的方式。</li><li>设计一个k大小的窗口，然后从数组上滑过，每个元素与这k个元素比较，根据大小做处理。类似于插入排序的方式。<br>本题准备实现一下1方式</li></ol><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sortedNums = sort(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> sortedNums[k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mergeNums;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(low == high)&#123;</span><br><span class="line">            mergeNums.push_back(nums[low]);</span><br><span class="line">            <span class="keyword">return</span> mergeNums;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> middle = (low + high)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lnums = sort(nums, low, middle);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hnums = sort(nums, middle+<span class="number">1</span>, high);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&lt;lnums.size() &amp;&amp; j&lt;hnums.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(lnums[i] &gt;= hnums[j])&#123;</span><br><span class="line">                mergeNums.push_back(lnums[i++]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mergeNums.push_back(hnums[j++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&lt;lnums.size())&#123;</span><br><span class="line">            mergeNums.push_back(lnums[i++]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(j&lt;hnums.size())&#123;</span><br><span class="line">            mergeNums.push_back(hnums[j++]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mergeNums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上边2种做法，1中对所有的数组进行了排序，2中对k个元素进行了排序，不是直接去找Kth，应该能直接找子数组与kth之间的关系来直接分治。想了一种k分的方式，取最大，然后再取这k个值的最小，但是错误的;还有2分各取k应该，排序然后取第K，也是一种做法，但受K的影响，如果K &gt; length/2，还需要作转换，衰减也并不明显。<br>暂时并未想到可行的直接分治的方法</p><p>google了一下结果，发现有用快排方式的，有用二分方式的，复杂度都是nlog(n)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本题是 Leecode的 215.Kth Largest Element in an Array&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vscode下md导pdf</title>
    <link href="http://yoursite.com/2019/04/04/vscode%E4%B8%8Bmd%E5%AF%BCpdf/"/>
    <id>http://yoursite.com/2019/04/04/vscode下md导pdf/</id>
    <published>2019-04-04T02:47:46.000Z</published>
    <updated>2019-04-04T03:17:19.548Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下通过vscode转md导成pdf的方法</p><a id="more"></a><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>用md写文档已经渐渐成为习惯，尤其可以通过hexo，直接发布成博客。<br>造成的问题呢，很多文档并不是博客，比如会议纪要、工作的一些记录，写成md分享给非技术人员看，并不太合适，尤其有图片的时候，于是就想用md转成pdf。</p><h1 id="Markdown-Pdf插件安装"><a href="#Markdown-Pdf插件安装" class="headerlink" title="Markdown Pdf插件安装"></a>Markdown Pdf插件安装</h1><p>从扩展中安装Markdown Pdf</p><p><img src="插件.png" alt="插件"></p><p>安装成功后，可以在md文件中右键看到如下菜单</p><p><img src="右键.png" alt="右键"></p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>看到很多介绍，说到这里就可以直接点击导出就能成功，但在我机器上并没有成功。</p><p>点击后，发现没有任何反应，最初以为是导出的目录可能不对，搜索了一下，发现可以通过<code>markdown-pdf.outputDirectory</code>的方式来配置导出的目录，于是进行了设置，发现还是没反应</p><p>我注意到每次启动时，vscode坐下脚的提示中，总在install chromium，于是就有数了，这个Markdown Pdf其实是调用了chromium的接口来完成转换的。也是就看一下这个插件的配置。如下</p><p><img src="ExecutablePath.png" alt="ExecutablePath"></p><p>由于本机上有chromium浏览器，就<code>whereis chromium-browser</code>，然后在进行了配置，在settings.json中增加：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"markdown-pdf.executablePath": "/usr/bin/chromium-browser"</span><br></pre></td></tr></table></figure><p>重试，导出成功。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下通过vscode转md导成pdf的方法&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>编程范式</title>
    <link href="http://yoursite.com/2019/04/01/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/04/01/编程范式/</id>
    <published>2019-04-01T09:26:14.000Z</published>
    <updated>2019-04-08T02:54:46.369Z</updated>
    
    <content type="html"><![CDATA[<p>本篇作为笔记形式存在，对左耳听风中的编程范式做笔记，便于以后去查看。<br>原文中主要用到了语言有C、C++、Python、Java、Javascript、Go、Prolog。由于我对Go语言了解不深，委托范式像是一种组合方式的应用，这里就不对这种范式进行记录了，以后有机会，再回来补充;另外Prolog的方式我觉得很有趣，以后想去研究一下再写，这里也不包括在内。</p><p>我需要找到一种合适的记录顺序：原文以一种语言发展的顺序展开，是一种不错的方式; 根据我学习语言的前后顺序，也是一种不错的方式; 再有一种是总分式展开方式。这里选用第二种吧，以我接触这些范式的先后关系来展开。</p><a id="more"></a><h1 id="过程式编程"><a href="#过程式编程" class="headerlink" title="过程式编程"></a>过程式编程</h1><p>作为学习的起点，我也是从C语言起步的，但作为使用的起点却不能算是。真正使用的起点应该是汇编语言了，那时候在学校里做课程设计，用汇编控制循环。后来第二次做的时候就用上了C语言，感觉轻松了好多，循环用for就可以了，不用来回的jump。</p><p>对C语言的特性，这里直接引用了</p><ul><li>C 语言是一个静态弱类型语言，在使用变量时需要声明变量类型，但是类型间可以有隐式转换；</li><li>不同的变量类型可以用结构体（struct）组合在一起，以此来声明新的数据类型；</li><li>C 语言可以用 typedef 关键字来定义类型的别名，以此来达到变量类型的抽象；</li><li>C 语言是一个有结构化程序设计、具有变量作用域以及递归功能的过程式语言；</li><li>C 语言传递参数一般是以值传递，也可以传递指针；</li><li>通过指针，C 语言可以容易地对内存进行低级控制，然而这引入了非常大的编程复杂度；</li><li>编译预处理让 C 语言的编译更具有弹性，比如跨平台。</li></ul><p>我这里尝试来回忆一下：</p><ul><li>从数据上看，数据本身都是二进制，类型是对这段二进制的解释，类型本身并不是数据。</li><li>从内存山看，可以分成静态区、堆区、栈区、常量区，分别用来存储存储全局、new、局部、常量字符串等数据</li><li>数据对齐方式要注意大小端的差异，尤其在传输过程中，一般都需要大小端的转换，实现方式就是按中轴进行互换。</li><li>还有一些比较有趣的结构：比如union，还记得老师写的那段代码，用union来包含两个struct，它们的长度相同，但在传输与解析时做不同的使用。</li><li>还有很多宏定义，像是去年看的，内核中使用链表时候那段宏定义就很有意义。</li><li>中断的处理，单片机上的中断口有限，需要对中断手动进行配置，包括端口以及回调函数。中断其实一种异步方式，中断方式比起轮询方式节省很多资源。</li></ul><p>C语言回忆就到这里了，说是过程式的，不如说是指令式的，你像机器发送着一些指令，这其实比汇编语言好多了，起码不需要记住每一个寄存器。另外，以前只听老师说过C语言其实可以写OO，一直无缘得见，后来看vfs时候才明白，原来面向对象是一种思想，并不一定被语言限制，在C中一样可以用这种思想。</p><h1 id="面向对象式编程"><a href="#面向对象式编程" class="headerlink" title="面向对象式编程"></a>面向对象式编程</h1><p>最早接触C++其实是在实验室里，那时候用MFC做桌面端的应用程序，当然那时候我们称桌面为上位机。对C++的认识也比较模糊，因为MFC做了好多封装，也体会不出C++的特点。工作之后，写了5年的C++，目前为止，在所有语言里使用时间也是最长的。</p><p>面向对象的3大特性：封装、继承、多态。<br>对面向对象的评价继续引用：</p><ul><li><p>优点</p><ul><li>能和真实的世界交相辉映，符合人的直觉。</li><li>面向对象和数据库模型设计类型，更多地关注对象间的模型设计。</li><li>强调于“名词”而不是“动词”，更多地关注对象和对象间的接口。</li><li>根据业务的特征形成一个个高内聚的对象，有效地分离了抽象和具体实现，增强了可重用性和可扩展性。</li><li>拥有大量非常优秀的设计原则和设计模式。S.O.L.I.D（单一功能、开闭原则、里氏替换、接口隔离以及依赖反转，是面向对象设计的五个基本原则）、IoC/DIP……</li></ul></li><li><p>缺点</p><ul><li>代码都需要附着在一个类上，从一侧面上说，其鼓励了类型。</li><li>代码需要通过对象来达到抽象的效果，导致了相当厚重的“代码粘合层”。</li><li>因为太多的封装以及对状态的鼓励，导致了大量不透明并在并发下出现很多问题。</li></ul></li></ul><p>缺点上这两点原文中，原文中的举例都是针对Java，像Spring的那些注入，导致了大量的封装，这些封装还屏蔽了细节。</p><p>这里只对自己在使用C++的时候的一些回忆吧，主要针对面向对象的3大特性来展开</p><ul><li>封装，封装其实沿用着C语言模块化编程的思维，讲究低耦合高内聚的方式，只不过面向对象是将数据与操作封装成一个类，这里的数据也就是后边说的状态。</li><li>继承，继承是代码复用的一种方式，起先比较喜欢继承，后来发现继承也是有缺点的，会出现类爆炸的情况。于是就提倡使用组合的方式来复用代码。尤其加之与后边将的多态，使对组合元素的依赖于接口，而不是具体实现，耦合程度进一步降低。</li><li>多态，就是刚才说的，依赖于接口而不是具体实现。其实后来发现那些设计模式，其实就是对继承、组合、多态的一些常见用法，直接点就是套路。</li></ul><p>还有一部分是开发过程的控制</p><ul><li>多线程及线程池的使用，重构预处理服务的时候，将不同的处理策略抽象各自的实现中，然后将整个流程又封装成了各自的过程对象，最后获取线程池中的线程运行过程对象。后来发现这种方式在Java中与runable的方式类似，而且当时各个流程是硬编码的，如果是面AOP的方式，或者装饰器的方式会更好一些。</li><li>由于各个处理步骤的只完成对数据处理的一部分，可能会new出一段数据区来，在不同的步骤之间传递引用，但当时的的情况不同，最后的结果并不是线性依赖的，而是根据各个步骤处理结果的逻辑运算。在实现的过程中将数据放到了一块contex的数据区，并将每个步骤的结果也保存在集中，最后将取结果的逻辑与结果本身解耦出来。</li><li>在多线程中处理全局数据，对锁的要求很高。</li></ul><p>感慨一下，没想到3年过去了，还能顺利记起当时的做法。</p><p>其实这隐含着这种编码方式很大的问题，在分布式系统中，状态如此之多，处理起来会加倍的困难。虽然当时从内存监控上看，并没有出现泄露的情况，但也是战战兢兢，如履薄冰的。</p><p>Java其实在面向对象方面其实比C++做的好一些，从我的基础上看，MVC、IoC、动态代理这些是接触到Java之后才真正了解，而且Java的那本Head First设计模式比C++那本更容易理解。由于Java使用并没有C++使用的深，就此作罢吧。</p><h1 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h1><p>对于泛型编程，除去比用的STL，其实自己写的时候还真的比较少，记忆中，刚开始写Qt界面的时候，3个表格数据不同，表达基本相同，我用泛型做了一个实现。这里做个引用：</p><p>理想情况下，算法应是和数据结构以及类型无关的，各种特殊的数据类型理应做好自己分内的工作。算法只关心一个标准的实现。而对于泛型的抽象，我们需要回答的问题是，如果我们的数据类型符合通用算法，那么对数据类型的最小需求又是什么呢？<br>原文中给出的方式包括3重：</p><ol><li><p>它通过类的方式来解决<br>构造函数与析构函数<br>拷贝构造函数，表示对内存的复制<br>重载操作符</p></li><li><p>通过模板达到类型和算法的妥协。</p></li><li><p>通过虚函数和运行时类型识别。</p></li></ol><p>这里想说一下STL，没有接触STL之前，培训老师出了一题，题目现在已经忘记了，记得最主要的数据结构就是动态数据了，我们自己写链表来实现，人家直接用vector，效率高出许多。如果没用vector、set、map，那C++的路还会坎坷一些。</p><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>函数式编程最早也是从coolshell中看到的，而且缺少实践，需要引用的东西更多一些了。</p><ul><li><p>定义</p><p>定义输入数据和输出数据相关的关系，数学表达式里面其实是在做一种映射（mapping），输入的数据和输出的数据关系是什么样的，是用函数来定义的。</p><p>从通篇来看，函数式编程都是在借鉴函数，y = f(x) ,在这里只定义了一种关系，而且这种关系可以替换，如 z = g(y)，这时候可以将y带入变成z = g(f(x))，由此，函数与变量本身是等价的，自然也就是懒惰的，并且，是可以嵌套的。</p></li><li><p>特点</p><p>stateless: 无状态，就像是电路，本身不能存储电荷一样，有出有入，入多少出多少<br>immutable： 输入数据是不能动的，动了输入数据就有危险，所以要返回新的数据集。这条其实是从stateless中演化而来，对与函数f(x)，进了x就要出y，且x不能变</p></li><li><p>一些技术</p><ul><li>first class function（头等函数），函数像变量一样使用，参考 z = g(f(x))</li><li>recursing(递归)， z = f(f(x))，是对上一条的加深</li><li>pipeline(管道), 原文解释：将函数实例成一个一个的 action，然后将一组 action 放到一个数组或是列表中，再把数据传给这个 action list，数据就像一个 pipeline 一样顺序地被各个函数所操作，最终得到我们想要的结果。 pipleline最早也是shell的管道操作了。在代码方面有点。这些用法其实都是基于stateless的。</li><li>tail recursion optimization(尾递归)</li><li>map &amp; reduce &amp; filter，这个不论在python还是js中都有使用<br>…</li></ul></li><li><p>一些总结</p><ul><li>函数式编程的核心就stateless，仿照y = f(x)，仿照节点不存电荷</li><li>函数可以替换，也就是函数与变量等价，因为这种等价，在多线程调用时候，也就更安全</li><li>函数可以嵌套，也就可以currying、可以recursing、可以pipeline</li></ul></li><li><p>一些问题</p><ul><li><p>关于无状态<br>联想到了http协议，本来设计是一个无状态的协议，最后却不得不加上cookie、session等的加上状态。那函数式变成处理陈老师提到的频繁复制的问题，还会有什么问题。</p><p>另一个是体系架构，都是尽量在做到无状态，但一个请求需要在不同的服务中流转来完成，这种感觉有些像pipeline，需要流转的次序可配置，并且需要记录在每个流程中的一些信息，比如日志聚合，这种方式跟http协议上加cookie是何等的相似。</p><p>需要状态才是函数编程存在的问题，无状态是一种存在，优点也是缺点。</p></li><li><p>函数编程与面向对象编程<br>面向对象基础其实是封装了，封装是将数据与操作封装在一起的思想，这些数据也就是成员变量，就是状态。但完全可以封装一个类，没有成员变量，里边的函数全是函数式的无状态。这种范式即是面向对象，也是函数编程。那其实也就没有继承的必要性了，完全组合就可以，但多态还是需要的，面向接口编程会保存下来。</p></li></ul></li></ul><h1 id="基于原型的编程"><a href="#基于原型的编程" class="headerlink" title="基于原型的编程"></a>基于原型的编程</h1><p>基于原型的编程已经单独总结过了，这里只放个链接：<br><a href="https://sunyanfeng.cn/2019/03/31/js%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B/#more" target="_blank" rel="noopener">js中的原型</a>  </p><p>基于原型的编程，其实就是用组合的方式在完成着继承。继承跟组合的界限在这里有些模糊了。<br>node.js中的异步其实是一种软中断，这一部分可以整体梳理成一个博文了，包括单片机的中断处理、linux上下部的中断处理、以及node.js异步的处理，这里就不多写了。</p><h1 id="编程的本质"><a href="#编程的本质" class="headerlink" title="编程的本质"></a>编程的本质</h1><p>陈老师给出的编程本质也是函数式的：<br>Programs = Algorithms + Data Structures<br>Algorithm = Logic + Control<br>So:<br>Promgrams = Logic + Control + DataStructures<br>其中Logic是业务逻辑，逻辑过程的抽象，加上由术语表示的数据结构的定义<br>Control与业务逻辑无关，你控制它的执行，控制一个程序执行的方式，串行or并行，以及调度不同的执行模块，数据之间的存储关系，这些和业务逻辑无关。</p><p>尤其其中给出的注册验证的代码例子，看的我有些汗颜，重构那个模块时，没有想起来，然后这块代码其实在pg测试里见过，没有联想到可以这样玩。</p><p>这里对logic与control的分离做一点简单的思考：</p><p>在代码级别上，将logic以配置的方式（json、xml）来表达出来，然后将control针对格式来做，而不是针对内容。<br>在服务级别上，跟上边的无状态服务有些类似，每个无状态的服务可以看作是logic，通过编排来control执行的服务。</p><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>本文为了自己记忆方便，做一些记录与思考的东西，所有引用都是从陈皓老师，极客时间《左耳听风》处引来。若有不妥，请联系我，联系方式，详见站内“关于”部分。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇作为笔记形式存在，对左耳听风中的编程范式做笔记，便于以后去查看。&lt;br&gt;原文中主要用到了语言有C、C++、Python、Java、Javascript、Go、Prolog。由于我对Go语言了解不深，委托范式像是一种组合方式的应用，这里就不对这种范式进行记录了，以后有机会，再回来补充;另外Prolog的方式我觉得很有趣，以后想去研究一下再写，这里也不包括在内。&lt;/p&gt;
&lt;p&gt;我需要找到一种合适的记录顺序：原文以一种语言发展的顺序展开，是一种不错的方式; 根据我学习语言的前后顺序，也是一种不错的方式; 再有一种是总分式展开方式。这里选用第二种吧，以我接触这些范式的先后关系来展开。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>第二周ARTS</title>
    <link href="http://yoursite.com/2019/03/31/%E7%AC%AC%E4%BA%8C%E5%91%A8ARTS/"/>
    <id>http://yoursite.com/2019/03/31/第二周ARTS/</id>
    <published>2019-03-31T14:00:37.000Z</published>
    <updated>2019-04-15T02:20:24.908Z</updated>
    
    <content type="html"><![CDATA[<p>第二周打卡<br><a id="more"></a></p><h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><p><a href="https://sunyanfeng.cn/2019/03/31/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98/#more" target="_blank" rel="noopener">最大子数组问题</a></p><h1 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h1><p><a href="https://codeburst.io/interfaces-in-javascript-with-es6-naive-implementation-91b703110a09" target="_blank" rel="noopener">Interfaces in JavaScript with ES6 Symbol. Naive implementation</a></p><p>在javascript中通过Symbol的方式来实现interface</p><p>这种打算通过重写一些代码，有一些东西需要依赖接口来编程，于是就探索了一下在javascript中如何使用接口。这其实与本周share中的原型继承有一定的联系了，于是找到了这篇文章。</p><p>在这篇文章中，通过es6提供的Symbol实现了接口的功能，而且使用了es6的getter与setter，主要依赖就是Symbol的唯一性,试想，如果不用Symbol而是使用string，那样如果一个类不具有这个接口实现中，而偏偏有了一个相同的属性名，这样在判断undefine时就是真，就会出现问题。</p><h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><p><a href="https://sunyanfeng.cn/2019/03/31/Matrix-Determinants/#more" target="_blank" rel="noopener">Matrix Determinants</a></p><h1 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h1><p><a href="https://sunyanfeng.cn/2019/03/31/js%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B/#more" target="_blank" rel="noopener">js中的原型</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二周打卡&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>js中的原型</title>
    <link href="http://yoursite.com/2019/03/31/js%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/03/31/js中的原型/</id>
    <published>2019-03-31T13:08:47.000Z</published>
    <updated>2019-04-02T01:59:42.229Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客主要是想总结一下js中的原型，其中包含《左耳听风》36节之后的一点思考。</p><a id="more"></a><h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><p>在去年刚看JS高程的时候，觉得javascipt这继承真麻烦，并没有去深入思考一下，在看到左耳听风这篇文章后，觉得有了一些新的认识。这里对原型再深入探索一下。</p><p><img src="原型链-1.png" alt="原型链.jpg"><br>从这个图里，可以很明白表达原型链的含义，在每个对象里都有一个<code>__proto__</code>的属性，用来指向其原型。</p><p><img src="原型链-2.png" alt="原型链.jpg"><br>这里是对<code>__proto__</code>与prototype差异的一个说明，Foo每个Function对象都会多一个prototype属性，指向一个对象，其他对象的通过<code>__proto__</code>指向Foo.prototype。</p><p><img src="原型链继承.png" alt="原型链继承"><br>这个是JS高程中原型链继承中的图片，很清楚的看出SubType的prototype对象通过<code>__proto__</code>指向SuperType的prototype来继承其中的方法，instance实例通过<code>__proto__</code>来使用subtype中的方法。</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>这引发了我对两个问题的思考：</p><ol><li><p>为什么要有prototype与<code>__proto__</code></p><p>首先原型链的本质就是通过<code>__proto__</code>来指向其他对象的方式来复用代码，典型的组合方式。那为什么会用prototype呢，我觉得是原因Function两个维度上的使用，其一直接new对象，其二被子类继承使用。因为需要直接new对象，也就需要<code>__proto__</code>；因为需要被其他子Function继承，所以将被继承、被共用的部分独立出来，放到prototype中，本质上是一种模块化思维，将可以被复用的与不能被复用的分离。</p></li><li><p>js为什么以这种方式来实现继承</p><p>js基本属于一切皆对象的语言，函数是对象、类是对象。这样的情况注定没有类型，也就注定只能是组合的方式来完成类。在静态语言中，我们生命一个Student类，然后实例化一个xiaoMing的实例，在这里Student是一个对象，它与xiaoMing本质上是一种东西。xiaoMing通过一个指定的属性依赖Student。</p><p>这其实引发另一个问题，这种组合方式是动态类型语言唯一的方式吗？python中好像并不是这样玩的，这个问题留给以后来思考。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇博客主要是想总结一下js中的原型，其中包含《左耳听风》36节之后的一点思考。&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="编程范式" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Matrix Determinants</title>
    <link href="http://yoursite.com/2019/03/31/Matrix-Determinants/"/>
    <id>http://yoursite.com/2019/03/31/Matrix-Determinants/</id>
    <published>2019-03-31T12:21:42.000Z</published>
    <updated>2019-04-08T02:37:55.934Z</updated>
    
    <content type="html"><![CDATA[<p>本周完成了Gilbert Strang线性代数的中行列式的学习，课程中的Lesson18~Lesson20.</p><p>笔记都是用课程中手记的，这里只做一个简单的记录。</p><a id="more"></a><h1 id="determinants"><a href="#determinants" class="headerlink" title="determinants"></a>determinants</h1><ol><li><p>det I = 1</p></li><li><p>交换2行的位置，符合改变。</p></li><li><p>在每一个行上，都是线性的。</p></li><li><p>A中存在2个相同的行，det A = 0</p></li><li><p>substract c*row(i) from row(j), and the det does not change</p></li><li><p>A: Row of zeros, det A = 0</p></li><li><p>U: 上三角矩阵，d1,d2…dn为主元素， det U = d1 <em> d2 ..</em> dn<br>这个说明可以通过消元法来求解行列式，而且Gilbert老师说，是matlib等求det的主要方法。</p></li><li><p>A: singular, det A = 0</p></li><li><p>det(AB) = detA <em> detB<br>det2A = 2^n </em> det A<br>其实看到这里的时候，Gilbert老师就提到过，这种样子像是求体积，自然而然就意识到det其实就是矩阵的体积，不过带有方向。</p></li><li><p>det A transpose = det A</p></li></ol><h1 id="Big-formula"><a href="#Big-formula" class="headerlink" title="Big formula"></a>Big formula</h1><p><img src="bigformular.png" alt="bigformular"></p><h1 id="cofactor"><a href="#cofactor" class="headerlink" title="cofactor"></a>cofactor</h1><p><img src="cofactor-1.png" alt="cofactor"><br><img src="cofactor-2.png" alt="cofactor"></p><h1 id="原矩阵与逆矩阵"><a href="#原矩阵与逆矩阵" class="headerlink" title="原矩阵与逆矩阵"></a>原矩阵与逆矩阵</h1><h2 id="formular-for-A-1"><a href="#formular-for-A-1" class="headerlink" title="formular for A^(-1)"></a>formular for A^(-1)</h2><p><img src="A-1.png" alt="逆矩阵"></p><h2 id="Cramer’s-Rule"><a href="#Cramer’s-Rule" class="headerlink" title="Cramer’s Rule"></a>Cramer’s Rule</h2><p><img src="cramer_rule_1.png" alt="cramer_rule"><br><img src="cramer_rule_2.png" alt="cramer_rule"><br><img src="cramer_rule_3.png" alt="cramer_rule"></p><p>这个Cramer法则好看不中用</p><h1 id="Volumn"><a href="#Volumn" class="headerlink" title="Volumn"></a>Volumn</h1><p>这个很有趣，是对行列式终极含义</p><p>|det A| is equal to the volumn of matrix</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周完成了Gilbert Strang线性代数的中行列式的学习，课程中的Lesson18~Lesson20.&lt;/p&gt;
&lt;p&gt;笔记都是用课程中手记的，这里只做一个简单的记录。&lt;/p&gt;
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Matrix" scheme="http://yoursite.com/tags/Matrix/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>最大子数组问题</title>
    <link href="http://yoursite.com/2019/03/31/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/03/31/最大子数组问题/</id>
    <published>2019-03-31T09:41:06.000Z</published>
    <updated>2019-04-04T05:58:50.355Z</updated>
    
    <content type="html"><![CDATA[<p>本题是 Leecode的53.Maximum Subarray</p><a id="more"></a><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p><p>Example:</p><p>Input: [-2,1,-3,4,-1,2,1,-5,4],<br>Output: 6<br>Explanation: [4,-1,2,1] has the largest sum = 6.<br>Follow up:</p><p>If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>与上周的主题一样，本周训练的主题还是分治，题目是最大子数组，属于分治里的例题了。</p><p>这个题目思路用暴力来求解，可以设置一个窗口，长度是length(from 1 to length-1)，然后不断的在数组中滑动，比较得到最大的数组,这个的复杂度在o(n^2).</p><p>分治的思路大概是找递归的过程，或者找f(n)与f(n-1)之间关系的过程。子问题的划分其实也与数组的分裂相关，最快的分法就是每次都均分。这个问题就可以这样来解决了，最长子数组：</p><ul><li>完全位于子数组nums[low, middle]</li><li>完全位于子数组nums[middle+1, high]</li><li>子数组跨越中点，这种情况下，需要去求middle~low的最大值以及middle~high的最大值，然后求和即可。</li></ul><p>对于完全位于的，可以继续去递归。</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> constMinInt = <span class="number">-2147483648</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = findMaxSubArray(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (low == high) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[low];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> middle = (low+high)/<span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> leftMax = findMaxSubArray(nums, low, middle);</span><br><span class="line">            <span class="keyword">int</span> rightMax = findMaxSubArray(nums, middle+<span class="number">1</span>, high);</span><br><span class="line">            <span class="keyword">int</span> crossMax = findMaxCrossSubArray(nums, low, high, middle);</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span>  getMax(leftMax, rightMax, crossMax);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxCrossSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> middle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leftMax = constMinInt;</span><br><span class="line">        <span class="keyword">int</span> rightMax = constMinInt;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// left</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=middle; i&gt;=low; --i) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; leftMax) &#123;</span><br><span class="line">                leftMax = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// right</span></span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=middle+<span class="number">1</span>; i&lt;=high; ++i) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; rightMax) &#123;</span><br><span class="line">                rightMax = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> leftMax+rightMax;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span> leftMax, <span class="keyword">int</span> rightMax, <span class="keyword">int</span> crossMax)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (leftMax&gt;=rightMax &amp;&amp; leftMax&gt;=crossMax) &#123;</span><br><span class="line">            <span class="keyword">return</span> leftMax;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (rightMax&gt;=leftMax &amp;&amp; rightMax&gt;=crossMax) &#123;</span><br><span class="line">            <span class="keyword">return</span> rightMax;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> crossMax;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个算法在写的过程中，在getMax时候出现了一点问题，即&gt;=写成了&gt;，造成在获取最大值的时候出现了一点问题，提交后问题解决。</p><p>T(n) = 2T(n/2) + O(n)，根据主定理，复杂度是nlgn.</p><p>还有一个要思考的是对最大子数组的思考。将数组每个元素位置看成横坐标，值看成纵坐标，求和的过程其实是积分的过程，这样，最大子数组，其实是在求这个数组表达的函数的定积分。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本题是 Leecode的53.Maximum Subarray&lt;/p&gt;
    
    </summary>
    
      <category term="练习" scheme="http://yoursite.com/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>第一周ARTS</title>
    <link href="http://yoursite.com/2019/03/24/%E7%AC%AC%E4%B8%80%E5%91%A8ARTS/"/>
    <id>http://yoursite.com/2019/03/24/第一周ARTS/</id>
    <published>2019-03-24T15:22:45.000Z</published>
    <updated>2019-04-15T02:20:24.908Z</updated>
    
    <content type="html"><![CDATA[<p>第一周打卡<br><a id="more"></a></p><h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><p><a href="https://sunyanfeng.cn/2019/03/24/%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/#more" target="_blank" rel="noopener">求两个排序数组的中位数</a></p><h1 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h1><p>Socket.io:优点、缺点、丑陋<br>原文地址：(Socket.io — The Good, the Bad, and the Ugly)[<a href="https://dzone.com/articles/socketio-the-good-the-bad-and-the-ugly]" target="_blank" rel="noopener">https://dzone.com/articles/socketio-the-good-the-bad-and-the-ugly]</a></p><p>本周在做一个消息服务过程中，使用了Socket.io这个模块，并对这个模块进行了简单的分析，这里不再记录，在搜索过程中，发现了这篇由James Roper发表DZone上的文章，觉得比较适合做Review。</p><p>这里抛开它对socket.io不谈，我觉得他说的价值观还不错：</p><ol><li>他强烈的支持反应式系统，这种系统相应，弹性，可扩展，并且是消息驱动的</li><li>他支持高生产率的软件开发的工具、lib以及框架</li><li>他认为好的定义标准以及接口能最大化两个解耦实现之间的兼容性</li></ol><p>这里他说的这几个特点，与陈皓老师在技术领导力以及分布式系统架构的一些观念类似，比如提高效率的事，分布式架构之间解耦的过程等</p><h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><p><a href="https://sunyanfeng.cn/2019/03/24/Matrix-Projection/#more" target="_blank" rel="noopener">Matrix Projection</a></p><h1 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h1><p><a href="https://sunyanfeng.cn/2019/03/21/%E7%94%B1%E4%B8%80%E4%B8%AASelect%E5%BC%95%E8%B5%B7%E7%9A%84%E6%8E%A2%E7%B4%A2/#more" target="_blank" rel="noopener">由一个Select引起的探索</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一周打卡&lt;br&gt;
    
    </summary>
    
      <category term="ARMS" scheme="http://yoursite.com/categories/ARMS/"/>
    
    
  </entry>
  
  <entry>
    <title>Matrix Projection</title>
    <link href="http://yoursite.com/2019/03/24/Matrix-Projection/"/>
    <id>http://yoursite.com/2019/03/24/Matrix-Projection/</id>
    <published>2019-03-24T15:08:56.000Z</published>
    <updated>2019-04-01T01:21:18.523Z</updated>
    
    <content type="html"><![CDATA[<p>本周完成了Gilbert Strang线性代数的正交、投影、正交矩阵的学习，课程中的Lesson14～Lesson17</p><p>笔记都是用课程中手记的，这里只做一个简单的记录。</p><a id="more"></a><h1 id="Orthogonal-正交"><a href="#Orthogonal-正交" class="headerlink" title="Orthogonal 正交"></a>Orthogonal 正交</h1><ol><li>两个向量正交的定义</li><li>子空间正交： row space is orthogonal to null space;<pre><code>column space is orthogonal to null space of A tranpose</code></pre></li><li><p>正交的意义：the best solution Ax=b when there is no solution</p><pre><code>which means seperate the nosize from the infomation.A^T&lt;/sup&gt;AX = A&lt;sup&gt;T&lt;/sup&gt;b</code></pre></li></ol><h1 id="Projection投影"><a href="#Projection投影" class="headerlink" title="Projection投影"></a>Projection投影</h1><ol><li>向量投影</li><li>矩阵投影</li><li>投影矩阵</li><li>最小二乘法</li></ol><p>这一部分已经充分说明了一个基本认知：矩阵就是向量。主要研究的是投影矩阵，因为任何向量与它想乘都会映射到相应的空间中。这里对最小二乘法的矩阵解释也很令人印象深刻。</p><h1 id="Orthonomal-Matrix-正交矩阵"><a href="#Orthonomal-Matrix-正交矩阵" class="headerlink" title="Orthonomal Matrix 正交矩阵"></a>Orthonomal Matrix 正交矩阵</h1><p>正交矩阵就是一个向量空间两两垂直的向量组成的一组基。<br>它的好处是简化了投影运算效率</p><ol><li>正交矩阵的定义与意义</li><li>求解正交矩阵的方法：Gramh-schmit方法，（其实就是不断减p然后归一化的过程）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周完成了Gilbert Strang线性代数的正交、投影、正交矩阵的学习，课程中的Lesson14～Lesson17&lt;/p&gt;
&lt;p&gt;笔记都是用课程中手记的，这里只做一个简单的记录。&lt;/p&gt;
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Matrix" scheme="http://yoursite.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>求两个排序数组的中位数</title>
    <link href="http://yoursite.com/2019/03/24/%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://yoursite.com/2019/03/24/求两个排序数组的中位数/</id>
    <published>2019-03-24T00:06:42.000Z</published>
    <updated>2019-04-01T00:58:16.177Z</updated>
    
    <content type="html"><![CDATA[<p>这道题，我并没有完全解答，但从中锻炼了对分治法的理解。</p><a id="more"></a><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p><p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p><p>You may assume nums1 and nums2 cannot be both empty.</p><p>Example 1:</p><p>nums1 = [1, 3]<br>nums2 = [2]</p><p>The median is 2.0<br>Example 2:</p><p>nums1 = [1, 2]<br>nums2 = [3, 4]</p><p>The median is (2 + 3)/2 = 2.5</p><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = nums1.size() + nums2.size();</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// this should throw an error</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums1.size()!=<span class="number">0</span> &amp;&amp; nums2.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>; c&lt;count;++c)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i] &lt; nums2[j])&#123;</span><br><span class="line">                    nums.push_back(nums1[i]);</span><br><span class="line">                    i++;</span><br><span class="line">                    <span class="keyword">if</span>(i==nums1.size())&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    nums.push_back(nums2[j]);</span><br><span class="line">                    j++;</span><br><span class="line">                    <span class="keyword">if</span>(j==nums2.size())&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(i==nums1.size() &amp;&amp; j&lt;nums2.size())&#123;</span><br><span class="line">                <span class="keyword">while</span>(j!=nums2.size())&#123;</span><br><span class="line">                    nums.push_back(nums2[j++]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(j==nums2.size() &amp;&amp; i&lt;nums1.size())&#123;</span><br><span class="line">                <span class="keyword">while</span>(i!=nums1.size())&#123;</span><br><span class="line">                    nums.push_back(nums1[i++]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums1.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;nums2.size(); ++k)&#123;</span><br><span class="line">                nums.push_back(nums2[k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums2.size() == <span class="number">0</span>)&#123;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;nums1.size(); ++k)&#123;</span><br><span class="line">                nums.push_back(nums1[k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> ret = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = count/<span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(count%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            ret = ((<span class="keyword">double</span>)(nums[m<span class="number">-1</span>]+nums[m]))/<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ret = nums[m];</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上答案是一种m+n的算法，虽然通过了，但并不符合复杂度的要求。</p><p>于是进行了第二次的思考，这里选的题目本身，是分治标签下的，上述算法是归并排序中一步的做法，然后就思考怎样用分治的想法来实现。<br>另一种思路是，分治应该是在什么维度上进行分治，本身应该类似于数学归纳法的方式。在维度上既然是数组，就采用数组元素的方式来分。首先思考的是如果两个表，慢慢增加元素会是什么样的，1-0,1-1,2-1,3-2，2-2，这样发现一种可以递归的方式，即每次拿一个数组的最大值与另一个数组的最大值对比去掉最大的，最小值与最小值对比去掉最小的，这样，如果总和为奇数剩余1个，为最后结果，为偶数剩余2个，其平均值为最后结果。<br>回头意向这个复杂度也不是ln(m+n)，而是(m+n)/2，比上一种算法略有提升。</p><p>那最后就看一下提供的解法吧<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = A.length;</span><br><span class="line">        <span class="keyword">int</span> n = B.length;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) &#123; <span class="comment">// to ensure m&lt;=n</span></span><br><span class="line">            <span class="keyword">int</span>[] temp = A; A = B; B = temp;</span><br><span class="line">            <span class="keyword">int</span> tmp = m; m = n; n = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> iMin = <span class="number">0</span>, iMax = m, halfLen = (m + n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (iMin &lt;= iMax) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = (iMin + iMax) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> j = halfLen - i;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; iMax &amp;&amp; B[j-<span class="number">1</span>] &gt; A[i])&#123;</span><br><span class="line">                iMin = i + <span class="number">1</span>; <span class="comment">// i is too small</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; iMin &amp;&amp; A[i-<span class="number">1</span>] &gt; B[j]) &#123;</span><br><span class="line">                iMax = i - <span class="number">1</span>; <span class="comment">// i is too big</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// i is perfect</span></span><br><span class="line">                <span class="keyword">int</span> maxLeft = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123; maxLeft = B[j-<span class="number">1</span>]; &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123; maxLeft = A[i-<span class="number">1</span>]; &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; maxLeft = Math.max(A[i-<span class="number">1</span>], B[j-<span class="number">1</span>]); &#125;</span><br><span class="line">                <span class="keyword">if</span> ( (m + n) % <span class="number">2</span> == <span class="number">1</span> ) &#123; <span class="keyword">return</span> maxLeft; &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> minRight = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (i == m) &#123; minRight = B[j]; &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j == n) &#123; minRight = A[i]; &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; minRight = Math.min(B[j], A[i]); &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> (maxLeft + minRight) / <span class="number">2.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题，我并没有完全解答，但从中锻炼了对分治法的理解。&lt;/p&gt;
    
    </summary>
    
      <category term="练习" scheme="http://yoursite.com/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>由一个Select引起的探索</title>
    <link href="http://yoursite.com/2019/03/21/%E7%94%B1%E4%B8%80%E4%B8%AASelect%E5%BC%95%E8%B5%B7%E7%9A%84%E6%8E%A2%E7%B4%A2/"/>
    <id>http://yoursite.com/2019/03/21/由一个Select引起的探索/</id>
    <published>2019-03-21T09:48:41.000Z</published>
    <updated>2019-04-01T00:58:16.177Z</updated>
    
    <content type="html"><![CDATA[<p>好久没有写问题处理类的博客了，正好今天解决了一个小问题，而且时间还有些，就写一下吧，作为本周的一share。</p><a id="more"></a><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>背景是这样的，今天帮人写了一个查询语句，用于查询一个1（表A）对多（表B）关系中，表B的一个字段的累加和。由于表A已经连接了多张表，而且我不太原因去动那段代码，就想着用表A的id从表B中去获取，而且她已经写好了一个接口来获取列表，我索性就直接在内存里计算了。代码就不贴了，这段代码效率比较低。<br>    问题出现了，我拿出来的数据莫名变成了字符串，数据相加以后成了字符串相加。”50”+”100” = “50100”.</p><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>出现问题咱就处理吧，首先去看一下表结构:<br><img src="表结构.png" alt="表结构"><br>字段是amount 类型是numeric,是数字没问题。</p><p>然后就怀疑是不是存储的时候是字符串，就去调试了一下，发现并没有问题。</p><p>那现在就是存的时候是数字，数据库里也是数字，而读取出来的是字符串。那问题肯定就是读取的时候出现问题了，读取时候调用的是node.js中’pg’这个模块，那就移步到这里去看一下。</p><p>pg模块中的目录如下：<br><img src="pg目录结构.png" alt="pg目录结构"><br>既然怀疑是读取时候出现了问题，从这个结构中，就直接去看结果的处理部分：result.js。在这其中，发现对每个Field都有一个对应的parser，那问题自然就归结到这个Parser上了。</p><p>这个Parser是从’pg-types’中引用而来，那就从pg-types中去看一下<br>在这里定义了3个Parse，arrayParser、binaryParsers、textParsers，在index.js中，通过<code>setTypeParser</code>来设置相应类型的parese，通过<code>getTypeParser</code>来获取。在这里并没有看出问题，然后看了一下这个库的test，这里看到</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bignum = <span class="string">'31415926535897932384626433832795028841971693993751058.16180339887498948482045868343656381177203091798057628'</span></span><br><span class="line">exports.numeric = &#123;</span><br><span class="line">format: <span class="string">'text'</span>,</span><br><span class="line">id: <span class="number">1700</span>,</span><br><span class="line">tests: [</span><br><span class="line">    [bignum, bignum]</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它其实是将numeric放到text这种format下，解析出来的自然就是text了。</p><p>既然是有意将numeric当成text来处理，那就numeric这种类型就要注意一下，在pgsql的官方文档中对其论述为：</p><p>numeric类型可以存储非常大的数字并且准确地进行计算。 我们特别建议将它用于货币金额和其它要求精确计算的场合。不过， numeric类型上的算术运算比整数类型或者我们下一节描述的浮点数类型要慢很多。</p><p> 一个numeric类型的标度 (scale)是小数部分的位数，精度(precision) 是全部数据位的数目，也就是小数点两边的位数总和。 因此数字 23.5141 的精度为 6 而标度为 4 。你可以认为整数的标度为零。</p><p>这样可以思考numeric本身用来处理很大的浮点数，这种数字转换成text也能理解了</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>由于我们的数字比较小，也就修改了一下表结构，将这numeric变成了real，这样问题就解决了。当然也可以通过ParseFloat来从表层处理一下。</p><h1 id="探索"><a href="#探索" class="headerlink" title="探索"></a>探索</h1><p>下边会探索一下pg的结构。这里时间限制，简单写一下依赖关系：<br>index.js中做聚合，聚合了client、Query、Connection、Pool等模块，<br>Client中依赖Connection,通过调用Connection来完成其业务<br>Connect中，依赖net.Socket来完成对postgresql的链接，以及在链接之上的接口；<br>在Client中还还依赖Query，并有一个queryQueue，来异步处理各个请求。<br>在Query中，依赖一个Result模块，来对返回的数据进行解析，其调用了以上的parse模块。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久没有写问题处理类的博客了，正好今天解决了一个小问题，而且时间还有些，就写一下吧，作为本周的一share。&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="node.js" scheme="http://yoursite.com/tags/node-js/"/>
    
      <category term="pgsql" scheme="http://yoursite.com/tags/pgsql/"/>
    
  </entry>
  
  <entry>
    <title>关于技术领导力的思考</title>
    <link href="http://yoursite.com/2019/03/19/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF%E9%A2%86%E5%AF%BC%E5%8A%9B/"/>
    <id>http://yoursite.com/2019/03/19/关于技术领导力/</id>
    <published>2019-03-19T06:14:00.000Z</published>
    <updated>2019-04-01T00:58:16.177Z</updated>
    
    <content type="html"><![CDATA[<p> 本文从极客时间《左耳听风》触发而来。</p><a id="more"></a><h1 id="何为技术领导力"><a href="#何为技术领导力" class="headerlink" title="何为技术领导力"></a>何为技术领导力</h1><p>陈老师的技术领导力定义：</p><ul><li>尊重技术，追求核心基础技术</li><li>追逐自动化的高效率的工具和技术，同时避免无效率的组织架构和管理</li><li>解放生产力，追逐人效的提高</li><li>开发抽象和高质量的可以重用的技术组件</li><li>坚持高于社会主流的技术标准和要求</li></ul><p>这些语言对我来说有些离散，我需要重新逻辑化一下</p><ul><li>追求核心基础技术</li><li>由核心基础技术派生的高质量、可重用的技术组件</li><li>由技术、技术组件而形成的工具，提高效率与人效</li><li>在这些工具之上，进行合理的组织架构与管理</li></ul><h1 id="拥有技术领导力需要的特质"><a href="#拥有技术领导力需要的特质" class="headerlink" title="拥有技术领导力需要的特质"></a>拥有技术领导力需要的特质</h1><p>陈老师的技术领导力特质</p><ul><li>能够发现问题</li><li>能够提供解决问题的思路和方案，并能比较这些方案的优缺点</li><li>能够作出正确的技术决定</li><li>能够用更优雅，更简单，更容易的方式来解决问题</li><li>能够提高代码或软件的扩展性、可重用性和可维护性</li><li>能够用正确的方式管理团队：正确的人干正确的事，提高团队的人效</li><li>创新能力</li></ul><p>同样，也需要逻辑化一下</p><ul><li>发现问题能力</li><li>寻找最佳解决方案的能力</li><li>优雅、高效实现方案的能力</li><li>发现、培养他人拥有以上能力的能力</li></ul><h1 id="如何才能拥有技术领导力"><a href="#如何才能拥有技术领导力" class="headerlink" title="如何才能拥有技术领导力"></a>如何才能拥有技术领导力</h1><p>陈老师在文章中举出了4点，这里只节选2点即可，其余两点价值观更重一些</p><ul><li><p>吃透基础技术</p><ul><li><p>编程部分</p><p>C语言，推荐《C程序设计语言（第二版）》</p><p>编程范式，面向对象变成，泛型编程，函数式编程</p><p>算法和数据结构</p></li><li><p>系统部分</p><p>计算机系统原理。推荐《深入理解计算机系统》</p><p>操作系统原理和基础。cpu，内存，硬盘，中断。推荐《UNIX环境高级编程》、《UNIX网络编程》《Windows核心编程》，可以让你更能从本质理解各种语言或者技术的底层原理（这一步似乎少了编译原理）。</p><p>网络基础。推荐《TCP/IP详解》</p><p>数据库原理。SQL与NoSQL，用于数据性能调优</p><p>分布式技术架构。包括负载均衡、DNS解析、多子域名、无状态应用层、缓存层、数据库分片、容错和恢复机制、Paxos、MR操作、分布式SQL数据库的一致性等。</p></li></ul><p>ps：这一部分比较硬核，也比较干，对于技术联系并没有叙述，我这里也不去说了。</p></li><li><p>提高学习能力</p><ul><li>学习的信息源，Quora、Stack Overflow,书，API、论文、博客</li><li>与高手交流</li></ul></li></ul><h1 id="我的思考"><a href="#我的思考" class="headerlink" title="我的思考"></a>我的思考</h1><h2 id="关于技术"><a href="#关于技术" class="headerlink" title="关于技术"></a>关于技术</h2><p>技术理念</p><ul><li>技术概念中包含实践性;切忌光学不练</li><li>技术概念中包含着理论性;所有光练不学，也是不对的</li><li>可以想像这个模型，技术底层是理论，技术上层是产品，底层的变动要比上层会慢，但来的更有变革性，产品。产品因人而异，因人而变，变化也就很多啦，但不论怎么变，也受技术的制约。</li><li>技术与艺术创作可以类比，若只固守，或者人云亦云，成就不了伟大，只有那些创新，那些拓展技术边界的创新，才能称得上伟大。（技术想象力）</li></ul><p>技术问题</p><ul><li>每一种技术，都是面向问题的，这个问题是什么？</li><li>对于这个问题，如果让你来实现，如何来做？</li><li>技术是如何解决面向的问题？</li><li><p>对比自己的做法与技术的做法，既可以丰富思维，也可以找到技术的不足</p></li><li><p>技术既然是发展的，那承前启后了哪些技术？（技术发展观）</p></li><li>这些技术面向的问题又有怎样的变化？</li><li>由此也就培养了技术鉴赏能力。（技术鉴赏力）</li></ul><h1 id="关于领导力"><a href="#关于领导力" class="headerlink" title="关于领导力"></a>关于领导力</h1><ul><li>领导力这个概念中包含着团队，所以是关于人的</li><li>领导，指引道路；领导力也就是指引的能力；技术领导力也就是在技术方面指引方向的能力啦</li><li>领导力与管理力有区别，有联系</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 本文从极客时间《左耳听风》触发而来。&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>中序遍历二叉树</title>
    <link href="http://yoursite.com/2019/03/16/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2019/03/16/中序遍历二叉树/</id>
    <published>2019-03-16T14:08:33.000Z</published>
    <updated>2019-04-01T00:58:16.177Z</updated>
    
    <content type="html"><![CDATA[<p> 本文是第一周ARMS挑战的Algorithm部分，也是为了熟悉一下Leetcode，选择了一个中序遍历二叉树。其中递归方式很快就完成、通过，但迭代方式花了一点时间，也终于通过啦，主要对迭代方式进行分析。</p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>Given a binary tree, return the inorder traversal of its nodes’ values.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [1,3,2]</span><br></pre></td></tr></table></figure></p><p>Follow up: Recursive solution is trivial, could you do it iteratively?</p><h1 id="递归方式"><a href="#递归方式" class="headerlink" title="递归方式"></a>递归方式</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vecVal;</span><br><span class="line">        recursiveTraversalNode(root, vecVal);        </span><br><span class="line">        <span class="keyword">return</span> vecVal;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recursiveTraversalNode</span><span class="params">(TreeNode * root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vecVal)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            recursiveTraversalNode(root-&gt;left, vecVal);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vecVal.push_back(root-&gt;val);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            recursiveTraversalNode(root-&gt;right, vecVal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="迭代方式"><a href="#迭代方式" class="headerlink" title="迭代方式"></a>迭代方式</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vecValue;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode *&gt; stackTreeNode;</span><br><span class="line">        </span><br><span class="line">        TreeNode *p = root;</span><br><span class="line">        <span class="keyword">while</span>(!stackTreeNode.empty() || p!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                stackTreeNode.push(p);</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                p = stackTreeNode.top();</span><br><span class="line">                stackTreeNode.pop();</span><br><span class="line">                </span><br><span class="line">                vecValue.push_back(p-&gt;val);</span><br><span class="line">                p = p-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> vecValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在迭代方式中，二叉树的指针一定会先遍历最深的left，然后返回遍历父节点，再遍历右节点，结构体中并没有指向父元素的指针，也就是要缓存一下父元素的指针，递归一下，所有的左侧线路上所有的父节点都需要缓存，而且每次完成指向父节点时，都是取最近的一个指针，那这种缓存的结构很自然就想到了stack。这步完成的比较顺利，只是没写C++了一开始想用vector来当stack用，但vector在获取最后一个节点时，处理的不太优雅，其实stack相对会好点，其实感觉pop直接返回数据，更方便一些。</p><p>出现了2个问题：一是入栈时候并没有入到叶子节点，造成出栈时处理的问题；二是在循环的判断上，对循环的结束只思考成stack的empty()。第二遍写的时候，很自然就解决了第一个问题，接着解决了第二个问题，也就顺利通过啦。</p><p>错误代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode&gt; stackNode;</span><br><span class="line">        TreeNode *p = root;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(p == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                p = stackNode.top();</span><br><span class="line">                stackNode.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;left != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                stackNode.push(p);</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                vecVal.push_back(p-&gt;val);</span><br><span class="line"></span><br><span class="line">                p = stackNode.top();</span><br><span class="line">                stackNode.pop();</span><br><span class="line">                </span><br><span class="line">                vecVal.push_back(p-&gt;val);</span><br><span class="line">                </span><br><span class="line">                p = p-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">while</span>(!stackNode.empty());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h1><p>树的遍历有3种，preorder、inorder、postorder,题目给的是inorder方式，后边需要对其余两种进行练习。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 本文是第一周ARMS挑战的Algorithm部分，也是为了熟悉一下Leetcode，选择了一个中序遍历二叉树。其中递归方式很快就完成、通过，但迭代方式花了一点时间，也终于通过啦，主要对迭代方式进行分析。&lt;/p&gt;
    
    </summary>
    
      <category term="练习" scheme="http://yoursite.com/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>旅途</title>
    <link href="http://yoursite.com/2019/03/16/%E6%97%85%E9%80%94/"/>
    <id>http://yoursite.com/2019/03/16/旅途/</id>
    <published>2019-03-16T02:27:59.000Z</published>
    <updated>2019-04-01T00:58:16.177Z</updated>
    
    <content type="html"><![CDATA[<p>  这周机缘巧合之下，参加了陈皓老师的ARTS的挑战，作为一段路途的起点，应该立个flag来表达一下决心，同时需要对这段旅途做一个规划，并论述一下旅途中潜在的问题。</p><a id="more"></a><h1 id="机缘"><a href="#机缘" class="headerlink" title="机缘"></a>机缘</h1><p>与陈老师的机缘应该从coolshell中的那篇《程序员练级攻略》开始，很多技术书籍的选择也是听从了这篇博文中的建议，这是其一；</p><p>回首毕业到现在，自己在技术的广度方面已经有了很多的积累，由C++，到了Java Web栈，到了Hadoop栈，到了我最爱的数据分析栈与机器学习栈，到近来node微服务架构的学习。但在广度之外，深感自己在技术深度方面的不足，于是想在深度方面下一番功夫，这是其二；</p><p>年初开始极客时间的体验，一个月的vip每日一课，可惜更新不足，很多课程看到1/3也就可以了，后有订阅了一个微服务架构栏目，认可了栏目这种方式。刚看完微服务架构，碰到陈老师的ARTS挑战三期，这是其三。</p><h1 id="由ARTS到ARMS"><a href="#由ARTS到ARMS" class="headerlink" title="由ARTS到ARMS"></a>由ARTS到ARMS</h1><p>ARTS挑战是 Algorithm、Review、Tip、Share，具体要求：<br>（1）每周至少做一个 leetcode 的算法题<br>（2）阅读并点评至少一篇英文技术文章<br>（3）学习至少一个技术技巧<br>（4）分享一篇有观点和思考的技术文章</p><p>ARTS挑战是一个习惯的养成，于我而言，已经有了的自己的学习的习惯或者生态，那就借鉴陈老师的ARTS概念，来夯实自己的学习生态。在这4条挑战中</p><p>Algorithm，虽然自己看过很多算法书、视频，但在训练上确实不够，这也是陈老师所说的没有训练看再多也没用的典型代表，而leetcode是一种方式，并没有规定路线，那我就选择按导论中的顺序挑选题目来进行训练，这样会更全面一些。</p><p>Review，应该是评论的意思，在英文方面，我已经迈过了这道坎，所以并不需要刻意去，以后的google过程中，我会更多使用英语来搜索，至于评论或者叫读后的思考，这个就从陈老师的栏目开始吧，结果刚结束的微服务架构，对提到的内容、技术做一个深入的探索。</p><p>Tip，我觉得指的是技术工具，分析、检测工具的使用，这个于当下，可以做一些变通，那就依据我的习惯，改成Math吧，课程依据原来的计划进行。</p><p>Share，我就用我的博客来做share，内容还是保持现有发布的技术性文章，主要是想将Review到的内容share在这里。数学方面的整理，md写数学公式以及矩阵，较为麻烦，写作成本有点高，可能会写一些的纲领性概念。对于我的哲学思考，就先不对外发布了。纠结了一下要不要开启评论，想想先作罢了,这源于我对信息爆炸时代的看法，让我去寻找，不要推送给我。</p><p>那这样就改成ARMS，跟学生时代用的芯片架构很像，挺美。</p><h1 id="矛盾"><a href="#矛盾" class="headerlink" title="矛盾"></a>矛盾</h1><p>在这里也要写一下现实的冲突与内心的冲突。</p><p>本阶段产品的开发效果来看，业务逻辑需要进一步的梳理与优化，产品如此复杂难以用起来，需要进一步简化;开发架构上，由总监开发的node后端框架已经影响到了后端的效率，并造成了代码可维护性的问题;团队成员水平有限，很多时候顶不上，一片败象之下我却想努力一把，不仅源于我对徐老师（老板）的认可，我不想善良、正直的人输的很惨，也源于我对旅途的看法，<strong>每一段旅途，都是生命最美好的馈赠（the best gift of life）</strong>，每一份工作都是一段旅途，如果不去努力，如何对得起这gift。</p><p>接下来的时间，势必耗费极大的精力，这又与ARTS产生了一些冲突，我并不处于当年陈老师简单完成任务而可以追求技术精深的处境上。好在是一周一个循环，需要我好好安排一下时间。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  这周机缘巧合之下，参加了陈皓老师的ARTS的挑战，作为一段路途的起点，应该立个flag来表达一下决心，同时需要对这段旅途做一个规划，并论述一下旅途中潜在的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="ARMS" scheme="http://yoursite.com/categories/ARMS/"/>
    
    
  </entry>
  
  <entry>
    <title>微服务架构</title>
    <link href="http://yoursite.com/2019/03/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    <id>http://yoursite.com/2019/03/12/微服务架构/</id>
    <published>2019-03-11T16:00:00.000Z</published>
    <updated>2019-03-16T04:27:23.300Z</updated>
    
    <content type="html"><![CDATA[<p>本文整理的极客时间中，杨波讲的微服务架构<br><a id="more"></a><br>本来打算把杨老师的图重新画完，一来做一个复习，二来也避免一些问题，但由于时间有限，就一起跟旅途发出来了，若有不妥，请联系我，联系方式见博客的关于。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><img src="overview.png" alt="概述"><br>整个分层体系如上图所示，底层是基础设施，主要是硬件iaas层。往上是平台服务paas层，包括发布系统，集群资源调度，镜像治理，资源治理等，在这层我们的镜像使用阿里的镜像仓库，集群资源调度使用的k8s。再网上是支撑服务，这一部分是课程的重点，包括服务发现，集中配置，容错限流，日志聚合，监控告警，这一层后变各节进行分述。再上一层是业务服务，在业务服务里，这里也分成了2层，聚合服务与基础服务，聚合服务对不同的接入进行相应，并调用基础服务，对web端、手机端、第三方接入提供不同的聚合服务。再一层是网关，网关就像是aop，对接入进行控制、检查等，对网关也会进行分述。</p><p>提出一个重要的思想：系统架构与组织结构相一致<br><img src="微服务团队组织.png" alt="微服务团队组织"></p><p>提出了中台战略</p><p><img src="阿里大中台战略.png" alt="阿里大中台战略"></p><h1 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h1><p><img src="网关整体.jpg" alt="网关整体"><br><img src="zuul网关1.jpg" alt="zuul网关"><br><img src="zuul网关2.jpg" alt="zuul网关"></p><h1 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h1><p><img src="服务发现.jpg" alt="服务发现"></p><h1 id="通讯-jpg"><a href="#通讯-jpg" class="headerlink" title="通讯.jpg"></a>通讯.jpg</h1><p><img src="通讯.jpg" alt="通讯"></p><h1 id="集中配置"><a href="#集中配置" class="headerlink" title="集中配置"></a>集中配置</h1><p><img src="配置中心1.jpg" alt="配置中心"><br><img src="配置中心2.jpg" alt="配置中心"></p><h1 id="熔断限流"><a href="#熔断限流" class="headerlink" title="熔断限流"></a>熔断限流</h1><p><img src="熔断限流1.jpg" alt="熔断限流1"><br><img src="熔断限流2.jpg" alt="熔断限流"></p><h1 id="日志聚合"><a href="#日志聚合" class="headerlink" title="日志聚合"></a>日志聚合</h1><p><img src="日志聚合1.jpg" alt="日志聚合"><br><img src="日志聚合2.jpg" alt="日志聚合"></p><h1 id="监控告警"><a href="#监控告警" class="headerlink" title="监控告警"></a>监控告警</h1><p><img src="监控告警1.jpg" alt="监控告警1"><br><img src="监控告警2.jpg" alt="监控告警2"></p><h1 id="资源调度"><a href="#资源调度" class="headerlink" title="资源调度"></a>资源调度</h1><p><img src="资源调度.jpg" alt="资源调度"></p><h1 id="镜像中心"><a href="#镜像中心" class="headerlink" title="镜像中心"></a>镜像中心</h1><p><img src="镜像中心.jpg" alt="镜像中心"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文整理的极客时间中，杨波讲的微服务架构&lt;br&gt;
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="架构" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="微服务" scheme="http://yoursite.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
</feed>
